// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file arraysTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "arrays.h"
#include "arraysTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

void registerarraysTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(true),
                GetInnerEnumHelperObject(true));
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(false),
                GetInnerEnumHelperObject(false));

                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(true),
                GetInnerBitMaskHelperObject(true));
                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(false),
                GetInnerBitMaskHelperObject(false));

                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(true),
                GetInnerAliasHelperObject(true));
                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(false),
                GetInnerAliasHelperObject(false));

                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(true),
                GetInnerStructureHelperObject(true));
                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(false),
                GetInnerStructureHelperObject(false));

                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(true),
                GetInnerEmptyStructureHelperObject(true));
                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(false),
                GetInnerEmptyStructureHelperObject(false));

                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(true),
                GetInnerUnionHelperObject(true));
                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(false),
                GetInnerUnionHelperObject(false));

                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(true),
                GetInnerBitsetHelperObject(true));
                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(false),
                GetInnerBitsetHelperObject(false));

                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(true),
                GetInner_alias_bounded_string_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(false),
                GetInner_alias_bounded_string_helperObject(false));

                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(true),
                GetInner_alias_bounded_wstring_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(false),
                GetInner_alias_bounded_wstring_helperObject(false));

                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(true),
                GetInner_alias_array_helperObject(true));
                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(false),
                GetInner_alias_array_helperObject(false));

                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(true),
                GetInner_alias_sequence_helperObject(true));
                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(false),
                GetInner_alias_sequence_helperObject(false));

                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(true),
                GetInner_alias_map_helperObject(true));
                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(false),
                GetInner_alias_map_helperObject(false));

                factory->add_type_object("ArrayShort", GetArrayShortIdentifier(true),
                GetArrayShortObject(true));
                factory->add_type_object("ArrayShort", GetArrayShortIdentifier(false),
                GetArrayShortObject(false));

                factory->add_type_object("ArrayUShort", GetArrayUShortIdentifier(true),
                GetArrayUShortObject(true));
                factory->add_type_object("ArrayUShort", GetArrayUShortIdentifier(false),
                GetArrayUShortObject(false));

                factory->add_type_object("ArrayLong", GetArrayLongIdentifier(true),
                GetArrayLongObject(true));
                factory->add_type_object("ArrayLong", GetArrayLongIdentifier(false),
                GetArrayLongObject(false));

                factory->add_type_object("ArrayULong", GetArrayULongIdentifier(true),
                GetArrayULongObject(true));
                factory->add_type_object("ArrayULong", GetArrayULongIdentifier(false),
                GetArrayULongObject(false));

                factory->add_type_object("ArrayLongLong", GetArrayLongLongIdentifier(true),
                GetArrayLongLongObject(true));
                factory->add_type_object("ArrayLongLong", GetArrayLongLongIdentifier(false),
                GetArrayLongLongObject(false));

                factory->add_type_object("ArrayULongLong", GetArrayULongLongIdentifier(true),
                GetArrayULongLongObject(true));
                factory->add_type_object("ArrayULongLong", GetArrayULongLongIdentifier(false),
                GetArrayULongLongObject(false));

                factory->add_type_object("ArrayFloat", GetArrayFloatIdentifier(true),
                GetArrayFloatObject(true));
                factory->add_type_object("ArrayFloat", GetArrayFloatIdentifier(false),
                GetArrayFloatObject(false));

                factory->add_type_object("ArrayDouble", GetArrayDoubleIdentifier(true),
                GetArrayDoubleObject(true));
                factory->add_type_object("ArrayDouble", GetArrayDoubleIdentifier(false),
                GetArrayDoubleObject(false));

                factory->add_type_object("ArrayLongDouble", GetArrayLongDoubleIdentifier(true),
                GetArrayLongDoubleObject(true));
                factory->add_type_object("ArrayLongDouble", GetArrayLongDoubleIdentifier(false),
                GetArrayLongDoubleObject(false));

                factory->add_type_object("ArrayBoolean", GetArrayBooleanIdentifier(true),
                GetArrayBooleanObject(true));
                factory->add_type_object("ArrayBoolean", GetArrayBooleanIdentifier(false),
                GetArrayBooleanObject(false));

                factory->add_type_object("ArrayOctet", GetArrayOctetIdentifier(true),
                GetArrayOctetObject(true));
                factory->add_type_object("ArrayOctet", GetArrayOctetIdentifier(false),
                GetArrayOctetObject(false));

                factory->add_type_object("ArrayChar", GetArrayCharIdentifier(true),
                GetArrayCharObject(true));
                factory->add_type_object("ArrayChar", GetArrayCharIdentifier(false),
                GetArrayCharObject(false));

                factory->add_type_object("ArrayWChar", GetArrayWCharIdentifier(true),
                GetArrayWCharObject(true));
                factory->add_type_object("ArrayWChar", GetArrayWCharIdentifier(false),
                GetArrayWCharObject(false));

                factory->add_type_object("ArrayString", GetArrayStringIdentifier(true),
                GetArrayStringObject(true));
                factory->add_type_object("ArrayString", GetArrayStringIdentifier(false),
                GetArrayStringObject(false));

                factory->add_type_object("ArrayWString", GetArrayWStringIdentifier(true),
                GetArrayWStringObject(true));
                factory->add_type_object("ArrayWString", GetArrayWStringIdentifier(false),
                GetArrayWStringObject(false));

                factory->add_type_object("ArrayBoundedString", GetArrayBoundedStringIdentifier(true),
                GetArrayBoundedStringObject(true));
                factory->add_type_object("ArrayBoundedString", GetArrayBoundedStringIdentifier(false),
                GetArrayBoundedStringObject(false));

                factory->add_type_object("ArrayBoundedWString", GetArrayBoundedWStringIdentifier(true),
                GetArrayBoundedWStringObject(true));
                factory->add_type_object("ArrayBoundedWString", GetArrayBoundedWStringIdentifier(false),
                GetArrayBoundedWStringObject(false));

                factory->add_type_object("ArrayEnum", GetArrayEnumIdentifier(true),
                GetArrayEnumObject(true));
                factory->add_type_object("ArrayEnum", GetArrayEnumIdentifier(false),
                GetArrayEnumObject(false));

                factory->add_type_object("ArrayBitMask", GetArrayBitMaskIdentifier(true),
                GetArrayBitMaskObject(true));
                factory->add_type_object("ArrayBitMask", GetArrayBitMaskIdentifier(false),
                GetArrayBitMaskObject(false));

                factory->add_type_object("ArrayAlias", GetArrayAliasIdentifier(true),
                GetArrayAliasObject(true));
                factory->add_type_object("ArrayAlias", GetArrayAliasIdentifier(false),
                GetArrayAliasObject(false));

                factory->add_type_object("ArrayShortArray", GetArrayShortArrayIdentifier(true),
                GetArrayShortArrayObject(true));
                factory->add_type_object("ArrayShortArray", GetArrayShortArrayIdentifier(false),
                GetArrayShortArrayObject(false));

                factory->add_type_object("ArraySequence", GetArraySequenceIdentifier(true),
                GetArraySequenceObject(true));
                factory->add_type_object("ArraySequence", GetArraySequenceIdentifier(false),
                GetArraySequenceObject(false));

                factory->add_type_object("ArrayMap", GetArrayMapIdentifier(true),
                GetArrayMapObject(true));
                factory->add_type_object("ArrayMap", GetArrayMapIdentifier(false),
                GetArrayMapObject(false));

                factory->add_type_object("ArrayUnion", GetArrayUnionIdentifier(true),
                GetArrayUnionObject(true));
                factory->add_type_object("ArrayUnion", GetArrayUnionIdentifier(false),
                GetArrayUnionObject(false));

                factory->add_type_object("ArrayStructure", GetArrayStructureIdentifier(true),
                GetArrayStructureObject(true));
                factory->add_type_object("ArrayStructure", GetArrayStructureIdentifier(false),
                GetArrayStructureObject(false));

                factory->add_type_object("ArrayBitset", GetArrayBitsetIdentifier(true),
                GetArrayBitsetObject(true));
                factory->add_type_object("ArrayBitset", GetArrayBitsetIdentifier(false),
                GetArrayBitsetObject(false));

                factory->add_type_object("ArrayMultiDimensionShort", GetArrayMultiDimensionShortIdentifier(true),
                GetArrayMultiDimensionShortObject(true));
                factory->add_type_object("ArrayMultiDimensionShort", GetArrayMultiDimensionShortIdentifier(false),
                GetArrayMultiDimensionShortObject(false));

                factory->add_type_object("ArrayMultiDimensionUShort", GetArrayMultiDimensionUShortIdentifier(true),
                GetArrayMultiDimensionUShortObject(true));
                factory->add_type_object("ArrayMultiDimensionUShort", GetArrayMultiDimensionUShortIdentifier(false),
                GetArrayMultiDimensionUShortObject(false));

                factory->add_type_object("ArrayMultiDimensionLong", GetArrayMultiDimensionLongIdentifier(true),
                GetArrayMultiDimensionLongObject(true));
                factory->add_type_object("ArrayMultiDimensionLong", GetArrayMultiDimensionLongIdentifier(false),
                GetArrayMultiDimensionLongObject(false));

                factory->add_type_object("ArrayMultiDimensionULong", GetArrayMultiDimensionULongIdentifier(true),
                GetArrayMultiDimensionULongObject(true));
                factory->add_type_object("ArrayMultiDimensionULong", GetArrayMultiDimensionULongIdentifier(false),
                GetArrayMultiDimensionULongObject(false));

                factory->add_type_object("ArrayMultiDimensionLongLong", GetArrayMultiDimensionLongLongIdentifier(true),
                GetArrayMultiDimensionLongLongObject(true));
                factory->add_type_object("ArrayMultiDimensionLongLong", GetArrayMultiDimensionLongLongIdentifier(false),
                GetArrayMultiDimensionLongLongObject(false));

                factory->add_type_object("ArrayMultiDimensionULongLong", GetArrayMultiDimensionULongLongIdentifier(true),
                GetArrayMultiDimensionULongLongObject(true));
                factory->add_type_object("ArrayMultiDimensionULongLong", GetArrayMultiDimensionULongLongIdentifier(false),
                GetArrayMultiDimensionULongLongObject(false));

                factory->add_type_object("ArrayMultiDimensionFloat", GetArrayMultiDimensionFloatIdentifier(true),
                GetArrayMultiDimensionFloatObject(true));
                factory->add_type_object("ArrayMultiDimensionFloat", GetArrayMultiDimensionFloatIdentifier(false),
                GetArrayMultiDimensionFloatObject(false));

                factory->add_type_object("ArrayMultiDimensionDouble", GetArrayMultiDimensionDoubleIdentifier(true),
                GetArrayMultiDimensionDoubleObject(true));
                factory->add_type_object("ArrayMultiDimensionDouble", GetArrayMultiDimensionDoubleIdentifier(false),
                GetArrayMultiDimensionDoubleObject(false));

                factory->add_type_object("ArrayMultiDimensionLongDouble", GetArrayMultiDimensionLongDoubleIdentifier(true),
                GetArrayMultiDimensionLongDoubleObject(true));
                factory->add_type_object("ArrayMultiDimensionLongDouble", GetArrayMultiDimensionLongDoubleIdentifier(false),
                GetArrayMultiDimensionLongDoubleObject(false));

                factory->add_type_object("ArrayMultiDimensionBoolean", GetArrayMultiDimensionBooleanIdentifier(true),
                GetArrayMultiDimensionBooleanObject(true));
                factory->add_type_object("ArrayMultiDimensionBoolean", GetArrayMultiDimensionBooleanIdentifier(false),
                GetArrayMultiDimensionBooleanObject(false));

                factory->add_type_object("ArrayMultiDimensionOctet", GetArrayMultiDimensionOctetIdentifier(true),
                GetArrayMultiDimensionOctetObject(true));
                factory->add_type_object("ArrayMultiDimensionOctet", GetArrayMultiDimensionOctetIdentifier(false),
                GetArrayMultiDimensionOctetObject(false));

                factory->add_type_object("ArrayMultiDimensionChar", GetArrayMultiDimensionCharIdentifier(true),
                GetArrayMultiDimensionCharObject(true));
                factory->add_type_object("ArrayMultiDimensionChar", GetArrayMultiDimensionCharIdentifier(false),
                GetArrayMultiDimensionCharObject(false));

                factory->add_type_object("ArrayMultiDimensionWChar", GetArrayMultiDimensionWCharIdentifier(true),
                GetArrayMultiDimensionWCharObject(true));
                factory->add_type_object("ArrayMultiDimensionWChar", GetArrayMultiDimensionWCharIdentifier(false),
                GetArrayMultiDimensionWCharObject(false));

                factory->add_type_object("ArrayMultiDimensionString", GetArrayMultiDimensionStringIdentifier(true),
                GetArrayMultiDimensionStringObject(true));
                factory->add_type_object("ArrayMultiDimensionString", GetArrayMultiDimensionStringIdentifier(false),
                GetArrayMultiDimensionStringObject(false));

                factory->add_type_object("ArrayMultiDimensionWString", GetArrayMultiDimensionWStringIdentifier(true),
                GetArrayMultiDimensionWStringObject(true));
                factory->add_type_object("ArrayMultiDimensionWString", GetArrayMultiDimensionWStringIdentifier(false),
                GetArrayMultiDimensionWStringObject(false));

                factory->add_type_object("ArrayMultiDimensionBoundedString", GetArrayMultiDimensionBoundedStringIdentifier(true),
                GetArrayMultiDimensionBoundedStringObject(true));
                factory->add_type_object("ArrayMultiDimensionBoundedString", GetArrayMultiDimensionBoundedStringIdentifier(false),
                GetArrayMultiDimensionBoundedStringObject(false));

                factory->add_type_object("ArrayMultiDimensionBoundedWString", GetArrayMultiDimensionBoundedWStringIdentifier(true),
                GetArrayMultiDimensionBoundedWStringObject(true));
                factory->add_type_object("ArrayMultiDimensionBoundedWString", GetArrayMultiDimensionBoundedWStringIdentifier(false),
                GetArrayMultiDimensionBoundedWStringObject(false));

                factory->add_type_object("ArrayMultiDimensionEnum", GetArrayMultiDimensionEnumIdentifier(true),
                GetArrayMultiDimensionEnumObject(true));
                factory->add_type_object("ArrayMultiDimensionEnum", GetArrayMultiDimensionEnumIdentifier(false),
                GetArrayMultiDimensionEnumObject(false));

                factory->add_type_object("ArrayMultiDimensionBitMask", GetArrayMultiDimensionBitMaskIdentifier(true),
                GetArrayMultiDimensionBitMaskObject(true));
                factory->add_type_object("ArrayMultiDimensionBitMask", GetArrayMultiDimensionBitMaskIdentifier(false),
                GetArrayMultiDimensionBitMaskObject(false));

                factory->add_type_object("ArrayMultiDimensionAlias", GetArrayMultiDimensionAliasIdentifier(true),
                GetArrayMultiDimensionAliasObject(true));
                factory->add_type_object("ArrayMultiDimensionAlias", GetArrayMultiDimensionAliasIdentifier(false),
                GetArrayMultiDimensionAliasObject(false));

                factory->add_type_object("ArrayMultiDimensionSequence", GetArrayMultiDimensionSequenceIdentifier(true),
                GetArrayMultiDimensionSequenceObject(true));
                factory->add_type_object("ArrayMultiDimensionSequence", GetArrayMultiDimensionSequenceIdentifier(false),
                GetArrayMultiDimensionSequenceObject(false));

                factory->add_type_object("ArrayMultiDimensionMap", GetArrayMultiDimensionMapIdentifier(true),
                GetArrayMultiDimensionMapObject(true));
                factory->add_type_object("ArrayMultiDimensionMap", GetArrayMultiDimensionMapIdentifier(false),
                GetArrayMultiDimensionMapObject(false));

                factory->add_type_object("ArrayMultiDimensionUnion", GetArrayMultiDimensionUnionIdentifier(true),
                GetArrayMultiDimensionUnionObject(true));
                factory->add_type_object("ArrayMultiDimensionUnion", GetArrayMultiDimensionUnionIdentifier(false),
                GetArrayMultiDimensionUnionObject(false));

                factory->add_type_object("ArrayMultiDimensionStructure", GetArrayMultiDimensionStructureIdentifier(true),
                GetArrayMultiDimensionStructureObject(true));
                factory->add_type_object("ArrayMultiDimensionStructure", GetArrayMultiDimensionStructureIdentifier(false),
                GetArrayMultiDimensionStructureObject(false));

                factory->add_type_object("ArrayMultiDimensionBitset", GetArrayMultiDimensionBitsetIdentifier(true),
                GetArrayMultiDimensionBitsetObject(true));
                factory->add_type_object("ArrayMultiDimensionBitset", GetArrayMultiDimensionBitsetIdentifier(false),
                GetArrayMultiDimensionBitsetObject(false));



                factory->add_type_object("ArraySingleDimensionLiteralsShort", GetArraySingleDimensionLiteralsShortIdentifier(true),
                GetArraySingleDimensionLiteralsShortObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsShort", GetArraySingleDimensionLiteralsShortIdentifier(false),
                GetArraySingleDimensionLiteralsShortObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsUnsignedShort", GetArraySingleDimensionLiteralsUnsignedShortIdentifier(true),
                GetArraySingleDimensionLiteralsUnsignedShortObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsUnsignedShort", GetArraySingleDimensionLiteralsUnsignedShortIdentifier(false),
                GetArraySingleDimensionLiteralsUnsignedShortObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsLong", GetArraySingleDimensionLiteralsLongIdentifier(true),
                GetArraySingleDimensionLiteralsLongObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsLong", GetArraySingleDimensionLiteralsLongIdentifier(false),
                GetArraySingleDimensionLiteralsLongObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsUnsignedLong", GetArraySingleDimensionLiteralsUnsignedLongIdentifier(true),
                GetArraySingleDimensionLiteralsUnsignedLongObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsUnsignedLong", GetArraySingleDimensionLiteralsUnsignedLongIdentifier(false),
                GetArraySingleDimensionLiteralsUnsignedLongObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsLongLong", GetArraySingleDimensionLiteralsLongLongIdentifier(true),
                GetArraySingleDimensionLiteralsLongLongObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsLongLong", GetArraySingleDimensionLiteralsLongLongIdentifier(false),
                GetArraySingleDimensionLiteralsLongLongObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsUnsignedLongLong", GetArraySingleDimensionLiteralsUnsignedLongLongIdentifier(true),
                GetArraySingleDimensionLiteralsUnsignedLongLongObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsUnsignedLongLong", GetArraySingleDimensionLiteralsUnsignedLongLongIdentifier(false),
                GetArraySingleDimensionLiteralsUnsignedLongLongObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsFloat", GetArraySingleDimensionLiteralsFloatIdentifier(true),
                GetArraySingleDimensionLiteralsFloatObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsFloat", GetArraySingleDimensionLiteralsFloatIdentifier(false),
                GetArraySingleDimensionLiteralsFloatObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsDouble", GetArraySingleDimensionLiteralsDoubleIdentifier(true),
                GetArraySingleDimensionLiteralsDoubleObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsDouble", GetArraySingleDimensionLiteralsDoubleIdentifier(false),
                GetArraySingleDimensionLiteralsDoubleObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsLongDouble", GetArraySingleDimensionLiteralsLongDoubleIdentifier(true),
                GetArraySingleDimensionLiteralsLongDoubleObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsLongDouble", GetArraySingleDimensionLiteralsLongDoubleIdentifier(false),
                GetArraySingleDimensionLiteralsLongDoubleObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsBoolean", GetArraySingleDimensionLiteralsBooleanIdentifier(true),
                GetArraySingleDimensionLiteralsBooleanObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsBoolean", GetArraySingleDimensionLiteralsBooleanIdentifier(false),
                GetArraySingleDimensionLiteralsBooleanObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsOctet", GetArraySingleDimensionLiteralsOctetIdentifier(true),
                GetArraySingleDimensionLiteralsOctetObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsOctet", GetArraySingleDimensionLiteralsOctetIdentifier(false),
                GetArraySingleDimensionLiteralsOctetObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsChar", GetArraySingleDimensionLiteralsCharIdentifier(true),
                GetArraySingleDimensionLiteralsCharObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsChar", GetArraySingleDimensionLiteralsCharIdentifier(false),
                GetArraySingleDimensionLiteralsCharObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsWChar", GetArraySingleDimensionLiteralsWCharIdentifier(true),
                GetArraySingleDimensionLiteralsWCharObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsWChar", GetArraySingleDimensionLiteralsWCharIdentifier(false),
                GetArraySingleDimensionLiteralsWCharObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsString", GetArraySingleDimensionLiteralsStringIdentifier(true),
                GetArraySingleDimensionLiteralsStringObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsString", GetArraySingleDimensionLiteralsStringIdentifier(false),
                GetArraySingleDimensionLiteralsStringObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsWString", GetArraySingleDimensionLiteralsWStringIdentifier(true),
                GetArraySingleDimensionLiteralsWStringObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsWString", GetArraySingleDimensionLiteralsWStringIdentifier(false),
                GetArraySingleDimensionLiteralsWStringObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsBoundedString", GetArraySingleDimensionLiteralsBoundedStringIdentifier(true),
                GetArraySingleDimensionLiteralsBoundedStringObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsBoundedString", GetArraySingleDimensionLiteralsBoundedStringIdentifier(false),
                GetArraySingleDimensionLiteralsBoundedStringObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsBoundedWString", GetArraySingleDimensionLiteralsBoundedWStringIdentifier(true),
                GetArraySingleDimensionLiteralsBoundedWStringObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsBoundedWString", GetArraySingleDimensionLiteralsBoundedWStringIdentifier(false),
                GetArraySingleDimensionLiteralsBoundedWStringObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsEnum", GetArraySingleDimensionLiteralsEnumIdentifier(true),
                GetArraySingleDimensionLiteralsEnumObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsEnum", GetArraySingleDimensionLiteralsEnumIdentifier(false),
                GetArraySingleDimensionLiteralsEnumObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsBitMask", GetArraySingleDimensionLiteralsBitMaskIdentifier(true),
                GetArraySingleDimensionLiteralsBitMaskObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsBitMask", GetArraySingleDimensionLiteralsBitMaskIdentifier(false),
                GetArraySingleDimensionLiteralsBitMaskObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsAlias", GetArraySingleDimensionLiteralsAliasIdentifier(true),
                GetArraySingleDimensionLiteralsAliasObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsAlias", GetArraySingleDimensionLiteralsAliasIdentifier(false),
                GetArraySingleDimensionLiteralsAliasObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsShortArray", GetArraySingleDimensionLiteralsShortArrayIdentifier(true),
                GetArraySingleDimensionLiteralsShortArrayObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsShortArray", GetArraySingleDimensionLiteralsShortArrayIdentifier(false),
                GetArraySingleDimensionLiteralsShortArrayObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsSequence", GetArraySingleDimensionLiteralsSequenceIdentifier(true),
                GetArraySingleDimensionLiteralsSequenceObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsSequence", GetArraySingleDimensionLiteralsSequenceIdentifier(false),
                GetArraySingleDimensionLiteralsSequenceObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsMap", GetArraySingleDimensionLiteralsMapIdentifier(true),
                GetArraySingleDimensionLiteralsMapObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsMap", GetArraySingleDimensionLiteralsMapIdentifier(false),
                GetArraySingleDimensionLiteralsMapObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsUnion", GetArraySingleDimensionLiteralsUnionIdentifier(true),
                GetArraySingleDimensionLiteralsUnionObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsUnion", GetArraySingleDimensionLiteralsUnionIdentifier(false),
                GetArraySingleDimensionLiteralsUnionObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsStructure", GetArraySingleDimensionLiteralsStructureIdentifier(true),
                GetArraySingleDimensionLiteralsStructureObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsStructure", GetArraySingleDimensionLiteralsStructureIdentifier(false),
                GetArraySingleDimensionLiteralsStructureObject(false));

                factory->add_type_object("ArraySingleDimensionLiteralsBitset", GetArraySingleDimensionLiteralsBitsetIdentifier(true),
                GetArraySingleDimensionLiteralsBitsetObject(true));
                factory->add_type_object("ArraySingleDimensionLiteralsBitset", GetArraySingleDimensionLiteralsBitsetIdentifier(false),
                GetArraySingleDimensionLiteralsBitsetObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsShort", GetArrayMultiDimensionLiteralsShortIdentifier(true),
                GetArrayMultiDimensionLiteralsShortObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsShort", GetArrayMultiDimensionLiteralsShortIdentifier(false),
                GetArrayMultiDimensionLiteralsShortObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsUShort", GetArrayMultiDimensionLiteralsUShortIdentifier(true),
                GetArrayMultiDimensionLiteralsUShortObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsUShort", GetArrayMultiDimensionLiteralsUShortIdentifier(false),
                GetArrayMultiDimensionLiteralsUShortObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsLong", GetArrayMultiDimensionLiteralsLongIdentifier(true),
                GetArrayMultiDimensionLiteralsLongObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsLong", GetArrayMultiDimensionLiteralsLongIdentifier(false),
                GetArrayMultiDimensionLiteralsLongObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsULong", GetArrayMultiDimensionLiteralsULongIdentifier(true),
                GetArrayMultiDimensionLiteralsULongObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsULong", GetArrayMultiDimensionLiteralsULongIdentifier(false),
                GetArrayMultiDimensionLiteralsULongObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsLongLong", GetArrayMultiDimensionLiteralsLongLongIdentifier(true),
                GetArrayMultiDimensionLiteralsLongLongObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsLongLong", GetArrayMultiDimensionLiteralsLongLongIdentifier(false),
                GetArrayMultiDimensionLiteralsLongLongObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsULongLong", GetArrayMultiDimensionLiteralsULongLongIdentifier(true),
                GetArrayMultiDimensionLiteralsULongLongObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsULongLong", GetArrayMultiDimensionLiteralsULongLongIdentifier(false),
                GetArrayMultiDimensionLiteralsULongLongObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsFloat", GetArrayMultiDimensionLiteralsFloatIdentifier(true),
                GetArrayMultiDimensionLiteralsFloatObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsFloat", GetArrayMultiDimensionLiteralsFloatIdentifier(false),
                GetArrayMultiDimensionLiteralsFloatObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsDouble", GetArrayMultiDimensionLiteralsDoubleIdentifier(true),
                GetArrayMultiDimensionLiteralsDoubleObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsDouble", GetArrayMultiDimensionLiteralsDoubleIdentifier(false),
                GetArrayMultiDimensionLiteralsDoubleObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsLongDouble", GetArrayMultiDimensionLiteralsLongDoubleIdentifier(true),
                GetArrayMultiDimensionLiteralsLongDoubleObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsLongDouble", GetArrayMultiDimensionLiteralsLongDoubleIdentifier(false),
                GetArrayMultiDimensionLiteralsLongDoubleObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsBoolean", GetArrayMultiDimensionLiteralsBooleanIdentifier(true),
                GetArrayMultiDimensionLiteralsBooleanObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsBoolean", GetArrayMultiDimensionLiteralsBooleanIdentifier(false),
                GetArrayMultiDimensionLiteralsBooleanObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsOctet", GetArrayMultiDimensionLiteralsOctetIdentifier(true),
                GetArrayMultiDimensionLiteralsOctetObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsOctet", GetArrayMultiDimensionLiteralsOctetIdentifier(false),
                GetArrayMultiDimensionLiteralsOctetObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsChar", GetArrayMultiDimensionLiteralsCharIdentifier(true),
                GetArrayMultiDimensionLiteralsCharObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsChar", GetArrayMultiDimensionLiteralsCharIdentifier(false),
                GetArrayMultiDimensionLiteralsCharObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsWChar", GetArrayMultiDimensionLiteralsWCharIdentifier(true),
                GetArrayMultiDimensionLiteralsWCharObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsWChar", GetArrayMultiDimensionLiteralsWCharIdentifier(false),
                GetArrayMultiDimensionLiteralsWCharObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsString", GetArrayMultiDimensionLiteralsStringIdentifier(true),
                GetArrayMultiDimensionLiteralsStringObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsString", GetArrayMultiDimensionLiteralsStringIdentifier(false),
                GetArrayMultiDimensionLiteralsStringObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsWString", GetArrayMultiDimensionLiteralsWStringIdentifier(true),
                GetArrayMultiDimensionLiteralsWStringObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsWString", GetArrayMultiDimensionLiteralsWStringIdentifier(false),
                GetArrayMultiDimensionLiteralsWStringObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsBoundedString", GetArrayMultiDimensionLiteralsBoundedStringIdentifier(true),
                GetArrayMultiDimensionLiteralsBoundedStringObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsBoundedString", GetArrayMultiDimensionLiteralsBoundedStringIdentifier(false),
                GetArrayMultiDimensionLiteralsBoundedStringObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsBoundedWString", GetArrayMultiDimensionLiteralsBoundedWStringIdentifier(true),
                GetArrayMultiDimensionLiteralsBoundedWStringObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsBoundedWString", GetArrayMultiDimensionLiteralsBoundedWStringIdentifier(false),
                GetArrayMultiDimensionLiteralsBoundedWStringObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsEnum", GetArrayMultiDimensionLiteralsEnumIdentifier(true),
                GetArrayMultiDimensionLiteralsEnumObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsEnum", GetArrayMultiDimensionLiteralsEnumIdentifier(false),
                GetArrayMultiDimensionLiteralsEnumObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsBitMask", GetArrayMultiDimensionLiteralsBitMaskIdentifier(true),
                GetArrayMultiDimensionLiteralsBitMaskObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsBitMask", GetArrayMultiDimensionLiteralsBitMaskIdentifier(false),
                GetArrayMultiDimensionLiteralsBitMaskObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsAlias", GetArrayMultiDimensionLiteralsAliasIdentifier(true),
                GetArrayMultiDimensionLiteralsAliasObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsAlias", GetArrayMultiDimensionLiteralsAliasIdentifier(false),
                GetArrayMultiDimensionLiteralsAliasObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsSequence", GetArrayMultiDimensionLiteralsSequenceIdentifier(true),
                GetArrayMultiDimensionLiteralsSequenceObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsSequence", GetArrayMultiDimensionLiteralsSequenceIdentifier(false),
                GetArrayMultiDimensionLiteralsSequenceObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsMap", GetArrayMultiDimensionLiteralsMapIdentifier(true),
                GetArrayMultiDimensionLiteralsMapObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsMap", GetArrayMultiDimensionLiteralsMapIdentifier(false),
                GetArrayMultiDimensionLiteralsMapObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsUnion", GetArrayMultiDimensionLiteralsUnionIdentifier(true),
                GetArrayMultiDimensionLiteralsUnionObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsUnion", GetArrayMultiDimensionLiteralsUnionIdentifier(false),
                GetArrayMultiDimensionLiteralsUnionObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsStructure", GetArrayMultiDimensionLiteralsStructureIdentifier(true),
                GetArrayMultiDimensionLiteralsStructureObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsStructure", GetArrayMultiDimensionLiteralsStructureIdentifier(false),
                GetArrayMultiDimensionLiteralsStructureObject(false));

                factory->add_type_object("ArrayMultiDimensionLiteralsBitSet", GetArrayMultiDimensionLiteralsBitSetIdentifier(true),
                GetArrayMultiDimensionLiteralsBitSetObject(true));
                factory->add_type_object("ArrayMultiDimensionLiteralsBitSet", GetArrayMultiDimensionLiteralsBitSetIdentifier(false),
                GetArrayMultiDimensionLiteralsBitSetObject(false));

                factory->add_type_object("BoundedSmallArrays", GetBoundedSmallArraysIdentifier(true),
                GetBoundedSmallArraysObject(true));
                factory->add_type_object("BoundedSmallArrays", GetBoundedSmallArraysIdentifier(false),
                GetBoundedSmallArraysObject(false));

                factory->add_type_object("BoundedBigArrays", GetBoundedBigArraysIdentifier(true),
                GetBoundedBigArraysObject(true));
                factory->add_type_object("BoundedBigArrays", GetBoundedBigArraysIdentifier(false),
                GetBoundedBigArraysObject(false));

            });
}

const TypeIdentifier* GetArrayShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayShort", complete);
}

const TypeObject* GetArrayShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayShortObject();
    }
    //else
    return GetMinimalArrayShortObject();
}

const TypeObject* GetMinimalArrayShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_short;
    mst_var_array_short.common().member_id(memberId++);
    mst_var_array_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_short.common().member_flags().IS_KEY(false);
    mst_var_array_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10}, false));


    MD5 var_array_short_hash("var_array_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_short.detail().name_hash()[i] = var_array_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayShort", false);
}

const TypeObject* GetCompleteArrayShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_short;
    cst_var_array_short.common().member_id(memberId++);
    cst_var_array_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_short.common().member_flags().IS_KEY(false);
    cst_var_array_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10}, true));


    cst_var_array_short.detail().name("var_array_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayShort", true);
}

const TypeIdentifier* GetArrayUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayUShort", complete);
}

const TypeObject* GetArrayUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayUShortObject();
    }
    //else
    return GetMinimalArrayUShortObject();
}

const TypeObject* GetMinimalArrayUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_ushort;
    mst_var_array_ushort.common().member_id(memberId++);
    mst_var_array_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_ushort.common().member_flags().IS_KEY(false);
    mst_var_array_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint16_t", {10}, false));


    MD5 var_array_ushort_hash("var_array_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_ushort.detail().name_hash()[i] = var_array_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayUShort", false);
}

const TypeObject* GetCompleteArrayUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_ushort;
    cst_var_array_ushort.common().member_id(memberId++);
    cst_var_array_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_ushort.common().member_flags().IS_KEY(false);
    cst_var_array_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint16_t", {10}, true));


    cst_var_array_ushort.detail().name("var_array_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayUShort", true);
}

const TypeIdentifier* GetArrayLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayLong", complete);
}

const TypeObject* GetArrayLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayLongObject();
    }
    //else
    return GetMinimalArrayLongObject();
}

const TypeObject* GetMinimalArrayLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_long;
    mst_var_array_long.common().member_id(memberId++);
    mst_var_array_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_long.common().member_flags().IS_KEY(false);
    mst_var_array_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int32_t", {10}, false));


    MD5 var_array_long_hash("var_array_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_long.detail().name_hash()[i] = var_array_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayLong", false);
}

const TypeObject* GetCompleteArrayLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_long;
    cst_var_array_long.common().member_id(memberId++);
    cst_var_array_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_long.common().member_flags().IS_KEY(false);
    cst_var_array_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int32_t", {10}, true));


    cst_var_array_long.detail().name("var_array_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayLong", true);
}

const TypeIdentifier* GetArrayULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayULong", complete);
}

const TypeObject* GetArrayULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayULongObject();
    }
    //else
    return GetMinimalArrayULongObject();
}

const TypeObject* GetMinimalArrayULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_ulong;
    mst_var_array_ulong.common().member_id(memberId++);
    mst_var_array_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_ulong.common().member_flags().IS_KEY(false);
    mst_var_array_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint32_t", {10}, false));


    MD5 var_array_ulong_hash("var_array_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_ulong.detail().name_hash()[i] = var_array_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayULong", false);
}

const TypeObject* GetCompleteArrayULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_ulong;
    cst_var_array_ulong.common().member_id(memberId++);
    cst_var_array_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_ulong.common().member_flags().IS_KEY(false);
    cst_var_array_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint32_t", {10}, true));


    cst_var_array_ulong.detail().name("var_array_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayULong", true);
}

const TypeIdentifier* GetArrayLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayLongLong", complete);
}

const TypeObject* GetArrayLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayLongLongObject();
    }
    //else
    return GetMinimalArrayLongLongObject();
}

const TypeObject* GetMinimalArrayLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_longlong;
    mst_var_array_longlong.common().member_id(memberId++);
    mst_var_array_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_longlong.common().member_flags().IS_KEY(false);
    mst_var_array_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int64_t", {10}, false));


    MD5 var_array_longlong_hash("var_array_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_longlong.detail().name_hash()[i] = var_array_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayLongLong", false);
}

const TypeObject* GetCompleteArrayLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_longlong;
    cst_var_array_longlong.common().member_id(memberId++);
    cst_var_array_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_longlong.common().member_flags().IS_KEY(false);
    cst_var_array_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int64_t", {10}, true));


    cst_var_array_longlong.detail().name("var_array_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayLongLong", true);
}

const TypeIdentifier* GetArrayULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayULongLong", complete);
}

const TypeObject* GetArrayULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayULongLongObject();
    }
    //else
    return GetMinimalArrayULongLongObject();
}

const TypeObject* GetMinimalArrayULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_ulonglong;
    mst_var_array_ulonglong.common().member_id(memberId++);
    mst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_array_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint64_t", {10}, false));


    MD5 var_array_ulonglong_hash("var_array_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_ulonglong.detail().name_hash()[i] = var_array_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayULongLong", false);
}

const TypeObject* GetCompleteArrayULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_ulonglong;
    cst_var_array_ulonglong.common().member_id(memberId++);
    cst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_array_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint64_t", {10}, true));


    cst_var_array_ulonglong.detail().name("var_array_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayULongLong", true);
}

const TypeIdentifier* GetArrayFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayFloat", complete);
}

const TypeObject* GetArrayFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayFloatObject();
    }
    //else
    return GetMinimalArrayFloatObject();
}

const TypeObject* GetMinimalArrayFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_float;
    mst_var_array_float.common().member_id(memberId++);
    mst_var_array_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_float.common().member_flags().IS_KEY(false);
    mst_var_array_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("float", {10}, false));


    MD5 var_array_float_hash("var_array_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_float.detail().name_hash()[i] = var_array_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayFloat", false);
}

const TypeObject* GetCompleteArrayFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_float;
    cst_var_array_float.common().member_id(memberId++);
    cst_var_array_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_float.common().member_flags().IS_KEY(false);
    cst_var_array_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("float", {10}, true));


    cst_var_array_float.detail().name("var_array_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayFloat", true);
}

const TypeIdentifier* GetArrayDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayDouble", complete);
}

const TypeObject* GetArrayDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayDoubleObject();
    }
    //else
    return GetMinimalArrayDoubleObject();
}

const TypeObject* GetMinimalArrayDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_double;
    mst_var_array_double.common().member_id(memberId++);
    mst_var_array_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_double.common().member_flags().IS_KEY(false);
    mst_var_array_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("double", {10}, false));


    MD5 var_array_double_hash("var_array_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_double.detail().name_hash()[i] = var_array_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayDouble", false);
}

const TypeObject* GetCompleteArrayDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_double;
    cst_var_array_double.common().member_id(memberId++);
    cst_var_array_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_double.common().member_flags().IS_KEY(false);
    cst_var_array_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("double", {10}, true));


    cst_var_array_double.detail().name("var_array_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayDouble", true);
}

const TypeIdentifier* GetArrayLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayLongDouble", complete);
}

const TypeObject* GetArrayLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayLongDoubleObject();
    }
    //else
    return GetMinimalArrayLongDoubleObject();
}

const TypeObject* GetMinimalArrayLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_longdouble;
    mst_var_array_longdouble.common().member_id(memberId++);
    mst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_longdouble.common().member_flags().IS_KEY(false);
    mst_var_array_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("longdouble", {10}, false));


    MD5 var_array_longdouble_hash("var_array_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_longdouble.detail().name_hash()[i] = var_array_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayLongDouble", false);
}

const TypeObject* GetCompleteArrayLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_longdouble;
    cst_var_array_longdouble.common().member_id(memberId++);
    cst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_longdouble.common().member_flags().IS_KEY(false);
    cst_var_array_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("longdouble", {10}, true));


    cst_var_array_longdouble.detail().name("var_array_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayLongDouble", true);
}

const TypeIdentifier* GetArrayBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayBoolean", complete);
}

const TypeObject* GetArrayBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayBooleanObject();
    }
    //else
    return GetMinimalArrayBooleanObject();
}

const TypeObject* GetMinimalArrayBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_boolean;
    mst_var_array_boolean.common().member_id(memberId++);
    mst_var_array_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_boolean.common().member_flags().IS_KEY(false);
    mst_var_array_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("bool", {10}, false));


    MD5 var_array_boolean_hash("var_array_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_boolean.detail().name_hash()[i] = var_array_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayBoolean", false);
}

const TypeObject* GetCompleteArrayBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_boolean;
    cst_var_array_boolean.common().member_id(memberId++);
    cst_var_array_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_boolean.common().member_flags().IS_KEY(false);
    cst_var_array_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("bool", {10}, true));


    cst_var_array_boolean.detail().name("var_array_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayBoolean", true);
}

const TypeIdentifier* GetArrayOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayOctet", complete);
}

const TypeObject* GetArrayOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayOctetObject();
    }
    //else
    return GetMinimalArrayOctetObject();
}

const TypeObject* GetMinimalArrayOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_octet;
    mst_var_array_octet.common().member_id(memberId++);
    mst_var_array_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_octet.common().member_flags().IS_KEY(false);
    mst_var_array_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {10}, false));


    MD5 var_array_octet_hash("var_array_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_octet.detail().name_hash()[i] = var_array_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayOctet", false);
}

const TypeObject* GetCompleteArrayOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_octet;
    cst_var_array_octet.common().member_id(memberId++);
    cst_var_array_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_octet.common().member_flags().IS_KEY(false);
    cst_var_array_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {10}, true));


    cst_var_array_octet.detail().name("var_array_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayOctet", true);
}

const TypeIdentifier* GetArrayCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayChar", complete);
}

const TypeObject* GetArrayCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayCharObject();
    }
    //else
    return GetMinimalArrayCharObject();
}

const TypeObject* GetMinimalArrayCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_char;
    mst_var_array_char.common().member_id(memberId++);
    mst_var_array_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_char.common().member_flags().IS_KEY(false);
    mst_var_array_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("char", {10}, false));


    MD5 var_array_char_hash("var_array_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_char.detail().name_hash()[i] = var_array_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayChar", false);
}

const TypeObject* GetCompleteArrayCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_char;
    cst_var_array_char.common().member_id(memberId++);
    cst_var_array_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_char.common().member_flags().IS_KEY(false);
    cst_var_array_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("char", {10}, true));


    cst_var_array_char.detail().name("var_array_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayChar", true);
}

const TypeIdentifier* GetArrayWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayWChar", complete);
}

const TypeObject* GetArrayWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayWCharObject();
    }
    //else
    return GetMinimalArrayWCharObject();
}

const TypeObject* GetMinimalArrayWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_wchar;
    mst_var_array_wchar.common().member_id(memberId++);
    mst_var_array_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_wchar.common().member_flags().IS_KEY(false);
    mst_var_array_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("wchar_t", {10}, false));


    MD5 var_array_wchar_hash("var_array_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_wchar.detail().name_hash()[i] = var_array_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayWChar", false);
}

const TypeObject* GetCompleteArrayWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_wchar;
    cst_var_array_wchar.common().member_id(memberId++);
    cst_var_array_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_wchar.common().member_flags().IS_KEY(false);
    cst_var_array_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("wchar_t", {10}, true));


    cst_var_array_wchar.detail().name("var_array_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayWChar", true);
}

const TypeIdentifier* GetArrayStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayString", complete);
}

const TypeObject* GetArrayStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayStringObject();
    }
    //else
    return GetMinimalArrayStringObject();
}

const TypeObject* GetMinimalArrayStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_string;
    mst_var_array_string.common().member_id(memberId++);
    mst_var_array_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_string.common().member_flags().IS_KEY(false);
    mst_var_array_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, false), {10}, false));


    MD5 var_array_string_hash("var_array_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_string.detail().name_hash()[i] = var_array_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayString", false);
}

const TypeObject* GetCompleteArrayStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_string;
    cst_var_array_string.common().member_id(memberId++);
    cst_var_array_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_string.common().member_flags().IS_KEY(false);
    cst_var_array_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, false), {10}, true));


    cst_var_array_string.detail().name("var_array_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayString", true);
}

const TypeIdentifier* GetArrayWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayWString", complete);
}

const TypeObject* GetArrayWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayWStringObject();
    }
    //else
    return GetMinimalArrayWStringObject();
}

const TypeObject* GetMinimalArrayWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_wstring;
    mst_var_array_wstring.common().member_id(memberId++);
    mst_var_array_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_wstring.common().member_flags().IS_KEY(false);
    mst_var_array_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, true), {10}, false));


    MD5 var_array_wstring_hash("var_array_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_wstring.detail().name_hash()[i] = var_array_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayWString", false);
}

const TypeObject* GetCompleteArrayWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_wstring;
    cst_var_array_wstring.common().member_id(memberId++);
    cst_var_array_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_wstring.common().member_flags().IS_KEY(false);
    cst_var_array_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, true), {10}, true));


    cst_var_array_wstring.detail().name("var_array_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayWString", true);
}

const TypeIdentifier* GetArrayBoundedStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayBoundedString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayBoundedStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayBoundedString", complete);
}

const TypeObject* GetArrayBoundedStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBoundedString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayBoundedStringObject();
    }
    //else
    return GetMinimalArrayBoundedStringObject();
}

const TypeObject* GetMinimalArrayBoundedStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBoundedString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bounded_string;
    mst_var_array_bounded_string.common().member_id(memberId++);
    mst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bounded_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bounded_string.common().member_flags().IS_KEY(false);
    mst_var_array_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bounded_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_string_helper", {10}, false));


    MD5 var_array_bounded_string_hash("var_array_bounded_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bounded_string.detail().name_hash()[i] = var_array_bounded_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bounded_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayBoundedString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayBoundedString", false);
}

const TypeObject* GetCompleteArrayBoundedStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBoundedString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bounded_string;
    cst_var_array_bounded_string.common().member_id(memberId++);
    cst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bounded_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bounded_string.common().member_flags().IS_KEY(false);
    cst_var_array_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bounded_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_string_helper", {10}, true));


    cst_var_array_bounded_string.detail().name("var_array_bounded_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bounded_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayBoundedString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayBoundedString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayBoundedString", true);
}

const TypeIdentifier* GetArrayBoundedWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayBoundedWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayBoundedWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayBoundedWString", complete);
}

const TypeObject* GetArrayBoundedWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBoundedWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayBoundedWStringObject();
    }
    //else
    return GetMinimalArrayBoundedWStringObject();
}

const TypeObject* GetMinimalArrayBoundedWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBoundedWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bounded_wstring;
    mst_var_array_bounded_wstring.common().member_id(memberId++);
    mst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bounded_wstring.common().member_flags().IS_KEY(false);
    mst_var_array_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bounded_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_wstring_helper", {10}, false));


    MD5 var_array_bounded_wstring_hash("var_array_bounded_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bounded_wstring.detail().name_hash()[i] = var_array_bounded_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bounded_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayBoundedWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayBoundedWString", false);
}

const TypeObject* GetCompleteArrayBoundedWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBoundedWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bounded_wstring;
    cst_var_array_bounded_wstring.common().member_id(memberId++);
    cst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bounded_wstring.common().member_flags().IS_KEY(false);
    cst_var_array_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bounded_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_wstring_helper", {10}, true));


    cst_var_array_bounded_wstring.detail().name("var_array_bounded_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bounded_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayBoundedWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayBoundedWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayBoundedWString", true);
}

const TypeIdentifier* GetArrayEnumIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayEnum", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayEnumObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayEnum", complete);
}

const TypeObject* GetArrayEnumObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayEnum", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayEnumObject();
    }
    //else
    return GetMinimalArrayEnumObject();
}

const TypeObject* GetMinimalArrayEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayEnum", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_enum;
    mst_var_array_enum.common().member_id(memberId++);
    mst_var_array_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_enum.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_enum.common().member_flags().IS_KEY(false);
    mst_var_array_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_enum.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerEnumHelper", {10}, false));


    MD5 var_array_enum_hash("var_array_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_enum.detail().name_hash()[i] = var_array_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_enum);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayEnum", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayEnum", false);
}

const TypeObject* GetCompleteArrayEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayEnum", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_enum;
    cst_var_array_enum.common().member_id(memberId++);
    cst_var_array_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_enum.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_enum.common().member_flags().IS_KEY(false);
    cst_var_array_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_enum.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerEnumHelper", {10}, true));


    cst_var_array_enum.detail().name("var_array_enum");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_enum);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayEnum");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayEnum", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayEnum", true);
}

const TypeIdentifier* GetArrayBitMaskIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayBitMask", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayBitMaskObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayBitMask", complete);
}

const TypeObject* GetArrayBitMaskObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBitMask", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayBitMaskObject();
    }
    //else
    return GetMinimalArrayBitMaskObject();
}

const TypeObject* GetMinimalArrayBitMaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBitMask", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bitmask;
    mst_var_array_bitmask.common().member_id(memberId++);
    mst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bitmask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bitmask.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bitmask.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bitmask.common().member_flags().IS_KEY(false);
    mst_var_array_bitmask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bitmask.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitMaskHelper", {10}, false));


    MD5 var_array_bitmask_hash("var_array_bitmask");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bitmask.detail().name_hash()[i] = var_array_bitmask_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bitmask);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayBitMask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayBitMask", false);
}

const TypeObject* GetCompleteArrayBitMaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBitMask", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bitmask;
    cst_var_array_bitmask.common().member_id(memberId++);
    cst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bitmask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bitmask.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bitmask.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bitmask.common().member_flags().IS_KEY(false);
    cst_var_array_bitmask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bitmask.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitMaskHelper", {10}, true));


    cst_var_array_bitmask.detail().name("var_array_bitmask");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bitmask);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayBitMask");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayBitMask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayBitMask", true);
}

const TypeIdentifier* GetArrayAliasIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayAlias", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayAliasObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayAlias", complete);
}

const TypeObject* GetArrayAliasObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayAlias", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayAliasObject();
    }
    //else
    return GetMinimalArrayAliasObject();
}

const TypeObject* GetMinimalArrayAliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayAlias", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_alias;
    mst_var_array_alias.common().member_id(memberId++);
    mst_var_array_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_alias.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_alias.common().member_flags().IS_KEY(false);
    mst_var_array_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_alias.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerAliasHelper", {10}, false));


    MD5 var_array_alias_hash("var_array_alias");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_alias.detail().name_hash()[i] = var_array_alias_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_alias);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayAlias", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayAlias", false);
}

const TypeObject* GetCompleteArrayAliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayAlias", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_alias;
    cst_var_array_alias.common().member_id(memberId++);
    cst_var_array_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_alias.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_alias.common().member_flags().IS_KEY(false);
    cst_var_array_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_alias.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerAliasHelper", {10}, true));


    cst_var_array_alias.detail().name("var_array_alias");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_alias);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayAlias");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayAlias", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayAlias", true);
}

const TypeIdentifier* GetArrayShortArrayIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayShortArray", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayShortArrayObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayShortArray", complete);
}

const TypeObject* GetArrayShortArrayObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayShortArray", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayShortArrayObject();
    }
    //else
    return GetMinimalArrayShortArrayObject();
}

const TypeObject* GetMinimalArrayShortArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayShortArray", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_short_array;
    mst_var_array_short_array.common().member_id(memberId++);
    mst_var_array_short_array.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_short_array.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_short_array.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_short_array.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_short_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_short_array.common().member_flags().IS_KEY(false);
    mst_var_array_short_array.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_short_array.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10, 10}, false));


    MD5 var_array_short_array_hash("var_array_short_array");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_short_array.detail().name_hash()[i] = var_array_short_array_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_short_array);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayShortArray", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayShortArray", false);
}

const TypeObject* GetCompleteArrayShortArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayShortArray", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_short_array;
    cst_var_array_short_array.common().member_id(memberId++);
    cst_var_array_short_array.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_short_array.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_short_array.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_short_array.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_short_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_short_array.common().member_flags().IS_KEY(false);
    cst_var_array_short_array.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_short_array.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10, 10}, true));


    cst_var_array_short_array.detail().name("var_array_short_array");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_short_array);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayShortArray");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayShortArray", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayShortArray", true);
}

const TypeIdentifier* GetArraySequenceIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySequence", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySequenceObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySequence", complete);
}

const TypeObject* GetArraySequenceObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySequence", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySequenceObject();
    }
    //else
    return GetMinimalArraySequenceObject();
}

const TypeObject* GetMinimalArraySequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySequence", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_sequence;
    mst_var_array_sequence.common().member_id(memberId++);
    mst_var_array_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_sequence.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_sequence.common().member_flags().IS_KEY(false);
    mst_var_array_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_sequence.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_sequence_type_name("int32_t", 100), {10}, false));


    MD5 var_array_sequence_hash("var_array_sequence");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_sequence.detail().name_hash()[i] = var_array_sequence_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_sequence);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySequence", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySequence", false);
}

const TypeObject* GetCompleteArraySequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySequence", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_sequence;
    cst_var_array_sequence.common().member_id(memberId++);
    cst_var_array_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_sequence.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_sequence.common().member_flags().IS_KEY(false);
    cst_var_array_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_sequence.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_sequence_type_name("int32_t", 100), {10}, true));


    cst_var_array_sequence.detail().name("var_array_sequence");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_sequence);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySequence");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySequence", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySequence", true);
}

const TypeIdentifier* GetArrayMapIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMap", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMapObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMap", complete);
}

const TypeObject* GetArrayMapObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMap", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMapObject();
    }
    //else
    return GetMinimalArrayMapObject();
}

const TypeObject* GetMinimalArrayMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMap", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_map;
    mst_var_array_map.common().member_id(memberId++);
    mst_var_array_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_map.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_map.common().member_flags().IS_KEY(false);
    mst_var_array_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100), {10}, false));


    MD5 var_array_map_hash("var_array_map");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_map.detail().name_hash()[i] = var_array_map_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_map);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMap", false);
}

const TypeObject* GetCompleteArrayMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMap", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_map;
    cst_var_array_map.common().member_id(memberId++);
    cst_var_array_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_map.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_map.common().member_flags().IS_KEY(false);
    cst_var_array_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100), {10}, true));


    cst_var_array_map.detail().name("var_array_map");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_map);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMap");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMap", true);
}

const TypeIdentifier* GetArrayUnionIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayUnion", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayUnionObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayUnion", complete);
}

const TypeObject* GetArrayUnionObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayUnion", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayUnionObject();
    }
    //else
    return GetMinimalArrayUnionObject();
}

const TypeObject* GetMinimalArrayUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayUnion", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_union;
    mst_var_array_union.common().member_id(memberId++);
    mst_var_array_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_union.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_union.common().member_flags().IS_KEY(false);
    mst_var_array_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_union.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerUnionHelper", {10}, false));


    MD5 var_array_union_hash("var_array_union");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_union.detail().name_hash()[i] = var_array_union_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_union);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayUnion", false);
}

const TypeObject* GetCompleteArrayUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayUnion", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_union;
    cst_var_array_union.common().member_id(memberId++);
    cst_var_array_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_union.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_union.common().member_flags().IS_KEY(false);
    cst_var_array_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_union.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerUnionHelper", {10}, true));


    cst_var_array_union.detail().name("var_array_union");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_union);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayUnion");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayUnion", true);
}

const TypeIdentifier* GetArrayStructureIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayStructure", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayStructureObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayStructure", complete);
}

const TypeObject* GetArrayStructureObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayStructure", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayStructureObject();
    }
    //else
    return GetMinimalArrayStructureObject();
}

const TypeObject* GetMinimalArrayStructureObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayStructure", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_structure;
    mst_var_array_structure.common().member_id(memberId++);
    mst_var_array_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_structure.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_structure.common().member_flags().IS_KEY(false);
    mst_var_array_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_structure.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerStructureHelper", {10}, false));


    MD5 var_array_structure_hash("var_array_structure");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_structure.detail().name_hash()[i] = var_array_structure_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_structure);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayStructure", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayStructure", false);
}

const TypeObject* GetCompleteArrayStructureObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayStructure", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_structure;
    cst_var_array_structure.common().member_id(memberId++);
    cst_var_array_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_structure.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_structure.common().member_flags().IS_KEY(false);
    cst_var_array_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_structure.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerStructureHelper", {10}, true));


    cst_var_array_structure.detail().name("var_array_structure");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_structure);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayStructure");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayStructure", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayStructure", true);
}

const TypeIdentifier* GetArrayBitsetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayBitset", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayBitsetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayBitset", complete);
}

const TypeObject* GetArrayBitsetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBitset", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayBitsetObject();
    }
    //else
    return GetMinimalArrayBitsetObject();
}

const TypeObject* GetMinimalArrayBitsetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBitset", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bitset;
    mst_var_array_bitset.common().member_id(memberId++);
    mst_var_array_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bitset.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bitset.common().member_flags().IS_KEY(false);
    mst_var_array_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bitset.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitsetHelper", {10}, false));


    MD5 var_array_bitset_hash("var_array_bitset");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bitset.detail().name_hash()[i] = var_array_bitset_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bitset);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayBitset", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayBitset", false);
}

const TypeObject* GetCompleteArrayBitsetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayBitset", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bitset;
    cst_var_array_bitset.common().member_id(memberId++);
    cst_var_array_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bitset.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bitset.common().member_flags().IS_KEY(false);
    cst_var_array_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bitset.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitsetHelper", {10}, true));


    cst_var_array_bitset.detail().name("var_array_bitset");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bitset);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayBitset");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayBitset", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayBitset", true);
}

const TypeIdentifier* GetArrayMultiDimensionShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionShort", complete);
}

const TypeObject* GetArrayMultiDimensionShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionShortObject();
    }
    //else
    return GetMinimalArrayMultiDimensionShortObject();
}

const TypeObject* GetMinimalArrayMultiDimensionShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_short;
    mst_var_array_short.common().member_id(memberId++);
    mst_var_array_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_short.common().member_flags().IS_KEY(false);
    mst_var_array_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10, 10, 10}, false));


    MD5 var_array_short_hash("var_array_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_short.detail().name_hash()[i] = var_array_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionShort", false);
}

const TypeObject* GetCompleteArrayMultiDimensionShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_short;
    cst_var_array_short.common().member_id(memberId++);
    cst_var_array_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_short.common().member_flags().IS_KEY(false);
    cst_var_array_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10, 10, 10}, true));


    cst_var_array_short.detail().name("var_array_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionShort", true);
}

const TypeIdentifier* GetArrayMultiDimensionUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionUShort", complete);
}

const TypeObject* GetArrayMultiDimensionUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionUShortObject();
    }
    //else
    return GetMinimalArrayMultiDimensionUShortObject();
}

const TypeObject* GetMinimalArrayMultiDimensionUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_ushort;
    mst_var_array_ushort.common().member_id(memberId++);
    mst_var_array_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_ushort.common().member_flags().IS_KEY(false);
    mst_var_array_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint16_t", {10, 10, 10}, false));


    MD5 var_array_ushort_hash("var_array_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_ushort.detail().name_hash()[i] = var_array_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionUShort", false);
}

const TypeObject* GetCompleteArrayMultiDimensionUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_ushort;
    cst_var_array_ushort.common().member_id(memberId++);
    cst_var_array_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_ushort.common().member_flags().IS_KEY(false);
    cst_var_array_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint16_t", {10, 10, 10}, true));


    cst_var_array_ushort.detail().name("var_array_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionUShort", true);
}

const TypeIdentifier* GetArrayMultiDimensionLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLong", complete);
}

const TypeObject* GetArrayMultiDimensionLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLongObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLongObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_long;
    mst_var_array_long.common().member_id(memberId++);
    mst_var_array_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_long.common().member_flags().IS_KEY(false);
    mst_var_array_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int32_t", {10, 10, 10}, false));


    MD5 var_array_long_hash("var_array_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_long.detail().name_hash()[i] = var_array_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLong", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_long;
    cst_var_array_long.common().member_id(memberId++);
    cst_var_array_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_long.common().member_flags().IS_KEY(false);
    cst_var_array_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int32_t", {10, 10, 10}, true));


    cst_var_array_long.detail().name("var_array_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLong", true);
}

const TypeIdentifier* GetArrayMultiDimensionULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionULong", complete);
}

const TypeObject* GetArrayMultiDimensionULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionULongObject();
    }
    //else
    return GetMinimalArrayMultiDimensionULongObject();
}

const TypeObject* GetMinimalArrayMultiDimensionULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_ulong;
    mst_var_array_ulong.common().member_id(memberId++);
    mst_var_array_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_ulong.common().member_flags().IS_KEY(false);
    mst_var_array_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint32_t", {10, 10, 10}, false));


    MD5 var_array_ulong_hash("var_array_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_ulong.detail().name_hash()[i] = var_array_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionULong", false);
}

const TypeObject* GetCompleteArrayMultiDimensionULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_ulong;
    cst_var_array_ulong.common().member_id(memberId++);
    cst_var_array_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_ulong.common().member_flags().IS_KEY(false);
    cst_var_array_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint32_t", {10, 10, 10}, true));


    cst_var_array_ulong.detail().name("var_array_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionULong", true);
}

const TypeIdentifier* GetArrayMultiDimensionLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLongLong", complete);
}

const TypeObject* GetArrayMultiDimensionLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLongLongObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLongLongObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_longlong;
    mst_var_array_longlong.common().member_id(memberId++);
    mst_var_array_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_longlong.common().member_flags().IS_KEY(false);
    mst_var_array_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int64_t", {10, 10, 10}, false));


    MD5 var_array_longlong_hash("var_array_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_longlong.detail().name_hash()[i] = var_array_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLongLong", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_longlong;
    cst_var_array_longlong.common().member_id(memberId++);
    cst_var_array_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_longlong.common().member_flags().IS_KEY(false);
    cst_var_array_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int64_t", {10, 10, 10}, true));


    cst_var_array_longlong.detail().name("var_array_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLongLong", true);
}

const TypeIdentifier* GetArrayMultiDimensionULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionULongLong", complete);
}

const TypeObject* GetArrayMultiDimensionULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionULongLongObject();
    }
    //else
    return GetMinimalArrayMultiDimensionULongLongObject();
}

const TypeObject* GetMinimalArrayMultiDimensionULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_ulonglong;
    mst_var_array_ulonglong.common().member_id(memberId++);
    mst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_array_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint64_t", {10, 10, 10}, false));


    MD5 var_array_ulonglong_hash("var_array_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_ulonglong.detail().name_hash()[i] = var_array_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionULongLong", false);
}

const TypeObject* GetCompleteArrayMultiDimensionULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_ulonglong;
    cst_var_array_ulonglong.common().member_id(memberId++);
    cst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_array_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint64_t", {10, 10, 10}, true));


    cst_var_array_ulonglong.detail().name("var_array_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionULongLong", true);
}

const TypeIdentifier* GetArrayMultiDimensionFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionFloat", complete);
}

const TypeObject* GetArrayMultiDimensionFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionFloatObject();
    }
    //else
    return GetMinimalArrayMultiDimensionFloatObject();
}

const TypeObject* GetMinimalArrayMultiDimensionFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_float;
    mst_var_array_float.common().member_id(memberId++);
    mst_var_array_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_float.common().member_flags().IS_KEY(false);
    mst_var_array_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("float", {10, 10, 10}, false));


    MD5 var_array_float_hash("var_array_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_float.detail().name_hash()[i] = var_array_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionFloat", false);
}

const TypeObject* GetCompleteArrayMultiDimensionFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_float;
    cst_var_array_float.common().member_id(memberId++);
    cst_var_array_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_float.common().member_flags().IS_KEY(false);
    cst_var_array_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("float", {10, 10, 10}, true));


    cst_var_array_float.detail().name("var_array_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionFloat", true);
}

const TypeIdentifier* GetArrayMultiDimensionDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionDouble", complete);
}

const TypeObject* GetArrayMultiDimensionDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionDoubleObject();
    }
    //else
    return GetMinimalArrayMultiDimensionDoubleObject();
}

const TypeObject* GetMinimalArrayMultiDimensionDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_double;
    mst_var_array_double.common().member_id(memberId++);
    mst_var_array_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_double.common().member_flags().IS_KEY(false);
    mst_var_array_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("double", {10, 10, 10}, false));


    MD5 var_array_double_hash("var_array_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_double.detail().name_hash()[i] = var_array_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionDouble", false);
}

const TypeObject* GetCompleteArrayMultiDimensionDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_double;
    cst_var_array_double.common().member_id(memberId++);
    cst_var_array_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_double.common().member_flags().IS_KEY(false);
    cst_var_array_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("double", {10, 10, 10}, true));


    cst_var_array_double.detail().name("var_array_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionDouble", true);
}

const TypeIdentifier* GetArrayMultiDimensionLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLongDouble", complete);
}

const TypeObject* GetArrayMultiDimensionLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLongDoubleObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLongDoubleObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_longdouble;
    mst_var_array_longdouble.common().member_id(memberId++);
    mst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_longdouble.common().member_flags().IS_KEY(false);
    mst_var_array_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("longdouble", {10, 10, 10}, false));


    MD5 var_array_longdouble_hash("var_array_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_longdouble.detail().name_hash()[i] = var_array_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLongDouble", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_longdouble;
    cst_var_array_longdouble.common().member_id(memberId++);
    cst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_longdouble.common().member_flags().IS_KEY(false);
    cst_var_array_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("longdouble", {10, 10, 10}, true));


    cst_var_array_longdouble.detail().name("var_array_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLongDouble", true);
}

const TypeIdentifier* GetArrayMultiDimensionBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionBoolean", complete);
}

const TypeObject* GetArrayMultiDimensionBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionBooleanObject();
    }
    //else
    return GetMinimalArrayMultiDimensionBooleanObject();
}

const TypeObject* GetMinimalArrayMultiDimensionBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_boolean;
    mst_var_array_boolean.common().member_id(memberId++);
    mst_var_array_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_boolean.common().member_flags().IS_KEY(false);
    mst_var_array_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("bool", {10, 10, 10}, false));


    MD5 var_array_boolean_hash("var_array_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_boolean.detail().name_hash()[i] = var_array_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoolean", false);
}

const TypeObject* GetCompleteArrayMultiDimensionBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_boolean;
    cst_var_array_boolean.common().member_id(memberId++);
    cst_var_array_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_boolean.common().member_flags().IS_KEY(false);
    cst_var_array_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("bool", {10, 10, 10}, true));


    cst_var_array_boolean.detail().name("var_array_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoolean", true);
}

const TypeIdentifier* GetArrayMultiDimensionOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionOctet", complete);
}

const TypeObject* GetArrayMultiDimensionOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionOctetObject();
    }
    //else
    return GetMinimalArrayMultiDimensionOctetObject();
}

const TypeObject* GetMinimalArrayMultiDimensionOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_octet;
    mst_var_array_octet.common().member_id(memberId++);
    mst_var_array_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_octet.common().member_flags().IS_KEY(false);
    mst_var_array_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {10, 10, 10}, false));


    MD5 var_array_octet_hash("var_array_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_octet.detail().name_hash()[i] = var_array_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionOctet", false);
}

const TypeObject* GetCompleteArrayMultiDimensionOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_octet;
    cst_var_array_octet.common().member_id(memberId++);
    cst_var_array_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_octet.common().member_flags().IS_KEY(false);
    cst_var_array_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {10, 10, 10}, true));


    cst_var_array_octet.detail().name("var_array_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionOctet", true);
}

const TypeIdentifier* GetArrayMultiDimensionCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionChar", complete);
}

const TypeObject* GetArrayMultiDimensionCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionCharObject();
    }
    //else
    return GetMinimalArrayMultiDimensionCharObject();
}

const TypeObject* GetMinimalArrayMultiDimensionCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_char;
    mst_var_array_char.common().member_id(memberId++);
    mst_var_array_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_char.common().member_flags().IS_KEY(false);
    mst_var_array_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("char", {10, 10, 10}, false));


    MD5 var_array_char_hash("var_array_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_char.detail().name_hash()[i] = var_array_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionChar", false);
}

const TypeObject* GetCompleteArrayMultiDimensionCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_char;
    cst_var_array_char.common().member_id(memberId++);
    cst_var_array_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_char.common().member_flags().IS_KEY(false);
    cst_var_array_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("char", {10, 10, 10}, true));


    cst_var_array_char.detail().name("var_array_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionChar", true);
}

const TypeIdentifier* GetArrayMultiDimensionWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionWChar", complete);
}

const TypeObject* GetArrayMultiDimensionWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionWCharObject();
    }
    //else
    return GetMinimalArrayMultiDimensionWCharObject();
}

const TypeObject* GetMinimalArrayMultiDimensionWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_wchar;
    mst_var_array_wchar.common().member_id(memberId++);
    mst_var_array_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_wchar.common().member_flags().IS_KEY(false);
    mst_var_array_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("wchar_t", {10, 10, 10}, false));


    MD5 var_array_wchar_hash("var_array_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_wchar.detail().name_hash()[i] = var_array_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionWChar", false);
}

const TypeObject* GetCompleteArrayMultiDimensionWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_wchar;
    cst_var_array_wchar.common().member_id(memberId++);
    cst_var_array_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_wchar.common().member_flags().IS_KEY(false);
    cst_var_array_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("wchar_t", {10, 10, 10}, true));


    cst_var_array_wchar.detail().name("var_array_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionWChar", true);
}

const TypeIdentifier* GetArrayMultiDimensionStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionString", complete);
}

const TypeObject* GetArrayMultiDimensionStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionStringObject();
    }
    //else
    return GetMinimalArrayMultiDimensionStringObject();
}

const TypeObject* GetMinimalArrayMultiDimensionStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_string;
    mst_var_array_string.common().member_id(memberId++);
    mst_var_array_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_string.common().member_flags().IS_KEY(false);
    mst_var_array_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, false), {10, 10, 10}, false));


    MD5 var_array_string_hash("var_array_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_string.detail().name_hash()[i] = var_array_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionString", false);
}

const TypeObject* GetCompleteArrayMultiDimensionStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_string;
    cst_var_array_string.common().member_id(memberId++);
    cst_var_array_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_string.common().member_flags().IS_KEY(false);
    cst_var_array_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, false), {10, 10, 10}, true));


    cst_var_array_string.detail().name("var_array_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionString", true);
}

const TypeIdentifier* GetArrayMultiDimensionWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionWString", complete);
}

const TypeObject* GetArrayMultiDimensionWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionWStringObject();
    }
    //else
    return GetMinimalArrayMultiDimensionWStringObject();
}

const TypeObject* GetMinimalArrayMultiDimensionWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_wstring;
    mst_var_array_wstring.common().member_id(memberId++);
    mst_var_array_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_wstring.common().member_flags().IS_KEY(false);
    mst_var_array_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, true), {10, 10, 10}, false));


    MD5 var_array_wstring_hash("var_array_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_wstring.detail().name_hash()[i] = var_array_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionWString", false);
}

const TypeObject* GetCompleteArrayMultiDimensionWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_wstring;
    cst_var_array_wstring.common().member_id(memberId++);
    cst_var_array_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_wstring.common().member_flags().IS_KEY(false);
    cst_var_array_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, true), {10, 10, 10}, true));


    cst_var_array_wstring.detail().name("var_array_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionWString", true);
}

const TypeIdentifier* GetArrayMultiDimensionBoundedStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionBoundedString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionBoundedStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionBoundedString", complete);
}

const TypeObject* GetArrayMultiDimensionBoundedStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoundedString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionBoundedStringObject();
    }
    //else
    return GetMinimalArrayMultiDimensionBoundedStringObject();
}

const TypeObject* GetMinimalArrayMultiDimensionBoundedStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoundedString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bounded_string;
    mst_var_array_bounded_string.common().member_id(memberId++);
    mst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bounded_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bounded_string.common().member_flags().IS_KEY(false);
    mst_var_array_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bounded_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_string_helper", {10, 10, 10}, false));


    MD5 var_array_bounded_string_hash("var_array_bounded_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bounded_string.detail().name_hash()[i] = var_array_bounded_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bounded_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionBoundedString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoundedString", false);
}

const TypeObject* GetCompleteArrayMultiDimensionBoundedStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoundedString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bounded_string;
    cst_var_array_bounded_string.common().member_id(memberId++);
    cst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bounded_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bounded_string.common().member_flags().IS_KEY(false);
    cst_var_array_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bounded_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_string_helper", {10, 10, 10}, true));


    cst_var_array_bounded_string.detail().name("var_array_bounded_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bounded_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionBoundedString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionBoundedString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoundedString", true);
}

const TypeIdentifier* GetArrayMultiDimensionBoundedWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionBoundedWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionBoundedWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionBoundedWString", complete);
}

const TypeObject* GetArrayMultiDimensionBoundedWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoundedWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionBoundedWStringObject();
    }
    //else
    return GetMinimalArrayMultiDimensionBoundedWStringObject();
}

const TypeObject* GetMinimalArrayMultiDimensionBoundedWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoundedWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bounded_wstring;
    mst_var_array_bounded_wstring.common().member_id(memberId++);
    mst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bounded_wstring.common().member_flags().IS_KEY(false);
    mst_var_array_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bounded_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_wstring_helper", {10, 10, 10}, false));


    MD5 var_array_bounded_wstring_hash("var_array_bounded_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bounded_wstring.detail().name_hash()[i] = var_array_bounded_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bounded_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionBoundedWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoundedWString", false);
}

const TypeObject* GetCompleteArrayMultiDimensionBoundedWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoundedWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bounded_wstring;
    cst_var_array_bounded_wstring.common().member_id(memberId++);
    cst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bounded_wstring.common().member_flags().IS_KEY(false);
    cst_var_array_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bounded_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_wstring_helper", {10, 10, 10}, true));


    cst_var_array_bounded_wstring.detail().name("var_array_bounded_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bounded_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionBoundedWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionBoundedWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBoundedWString", true);
}

const TypeIdentifier* GetArrayMultiDimensionEnumIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionEnum", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionEnumObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionEnum", complete);
}

const TypeObject* GetArrayMultiDimensionEnumObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionEnum", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionEnumObject();
    }
    //else
    return GetMinimalArrayMultiDimensionEnumObject();
}

const TypeObject* GetMinimalArrayMultiDimensionEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionEnum", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_enum;
    mst_var_array_enum.common().member_id(memberId++);
    mst_var_array_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_enum.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_enum.common().member_flags().IS_KEY(false);
    mst_var_array_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_enum.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerEnumHelper", {10, 10, 10}, false));


    MD5 var_array_enum_hash("var_array_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_enum.detail().name_hash()[i] = var_array_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_enum);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionEnum", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionEnum", false);
}

const TypeObject* GetCompleteArrayMultiDimensionEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionEnum", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_enum;
    cst_var_array_enum.common().member_id(memberId++);
    cst_var_array_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_enum.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_enum.common().member_flags().IS_KEY(false);
    cst_var_array_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_enum.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerEnumHelper", {10, 10, 10}, true));


    cst_var_array_enum.detail().name("var_array_enum");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_enum);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionEnum");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionEnum", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionEnum", true);
}

const TypeIdentifier* GetArrayMultiDimensionBitMaskIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionBitMask", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionBitMaskObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionBitMask", complete);
}

const TypeObject* GetArrayMultiDimensionBitMaskObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBitMask", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionBitMaskObject();
    }
    //else
    return GetMinimalArrayMultiDimensionBitMaskObject();
}

const TypeObject* GetMinimalArrayMultiDimensionBitMaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBitMask", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bitmask;
    mst_var_array_bitmask.common().member_id(memberId++);
    mst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bitmask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bitmask.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bitmask.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bitmask.common().member_flags().IS_KEY(false);
    mst_var_array_bitmask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bitmask.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitMaskHelper", {10, 10, 10}, false));


    MD5 var_array_bitmask_hash("var_array_bitmask");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bitmask.detail().name_hash()[i] = var_array_bitmask_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bitmask);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionBitMask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBitMask", false);
}

const TypeObject* GetCompleteArrayMultiDimensionBitMaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBitMask", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bitmask;
    cst_var_array_bitmask.common().member_id(memberId++);
    cst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bitmask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bitmask.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bitmask.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bitmask.common().member_flags().IS_KEY(false);
    cst_var_array_bitmask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bitmask.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitMaskHelper", {10, 10, 10}, true));


    cst_var_array_bitmask.detail().name("var_array_bitmask");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bitmask);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionBitMask");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionBitMask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBitMask", true);
}

const TypeIdentifier* GetArrayMultiDimensionAliasIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionAlias", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionAliasObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionAlias", complete);
}

const TypeObject* GetArrayMultiDimensionAliasObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionAlias", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionAliasObject();
    }
    //else
    return GetMinimalArrayMultiDimensionAliasObject();
}

const TypeObject* GetMinimalArrayMultiDimensionAliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionAlias", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_alias;
    mst_var_array_alias.common().member_id(memberId++);
    mst_var_array_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_alias.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_alias.common().member_flags().IS_KEY(false);
    mst_var_array_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_alias.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerAliasHelper", {10, 10, 10}, false));


    MD5 var_array_alias_hash("var_array_alias");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_alias.detail().name_hash()[i] = var_array_alias_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_alias);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionAlias", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionAlias", false);
}

const TypeObject* GetCompleteArrayMultiDimensionAliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionAlias", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_alias;
    cst_var_array_alias.common().member_id(memberId++);
    cst_var_array_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_alias.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_alias.common().member_flags().IS_KEY(false);
    cst_var_array_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_alias.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerAliasHelper", {10, 10, 10}, true));


    cst_var_array_alias.detail().name("var_array_alias");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_alias);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionAlias");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionAlias", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionAlias", true);
}

const TypeIdentifier* GetArrayMultiDimensionSequenceIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionSequence", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionSequenceObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionSequence", complete);
}

const TypeObject* GetArrayMultiDimensionSequenceObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionSequence", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionSequenceObject();
    }
    //else
    return GetMinimalArrayMultiDimensionSequenceObject();
}

const TypeObject* GetMinimalArrayMultiDimensionSequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionSequence", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_sequence;
    mst_var_array_sequence.common().member_id(memberId++);
    mst_var_array_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_sequence.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_sequence.common().member_flags().IS_KEY(false);
    mst_var_array_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_sequence.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_sequence_type_name("int32_t", 100), {10, 10, 10}, false));


    MD5 var_array_sequence_hash("var_array_sequence");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_sequence.detail().name_hash()[i] = var_array_sequence_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_sequence);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionSequence", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionSequence", false);
}

const TypeObject* GetCompleteArrayMultiDimensionSequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionSequence", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_sequence;
    cst_var_array_sequence.common().member_id(memberId++);
    cst_var_array_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_sequence.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_sequence.common().member_flags().IS_KEY(false);
    cst_var_array_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_sequence.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_sequence_type_name("int32_t", 100), {10, 10, 10}, true));


    cst_var_array_sequence.detail().name("var_array_sequence");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_sequence);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionSequence");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionSequence", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionSequence", true);
}

const TypeIdentifier* GetArrayMultiDimensionMapIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionMap", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionMapObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionMap", complete);
}

const TypeObject* GetArrayMultiDimensionMapObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionMap", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionMapObject();
    }
    //else
    return GetMinimalArrayMultiDimensionMapObject();
}

const TypeObject* GetMinimalArrayMultiDimensionMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionMap", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_map;
    mst_var_array_map.common().member_id(memberId++);
    mst_var_array_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_map.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_map.common().member_flags().IS_KEY(false);
    mst_var_array_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100), {10, 10, 10}, false));


    MD5 var_array_map_hash("var_array_map");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_map.detail().name_hash()[i] = var_array_map_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_map);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionMap", false);
}

const TypeObject* GetCompleteArrayMultiDimensionMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionMap", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_map;
    cst_var_array_map.common().member_id(memberId++);
    cst_var_array_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_map.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_map.common().member_flags().IS_KEY(false);
    cst_var_array_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100), {10, 10, 10}, true));


    cst_var_array_map.detail().name("var_array_map");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_map);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionMap");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionMap", true);
}

const TypeIdentifier* GetArrayMultiDimensionUnionIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionUnion", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionUnionObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionUnion", complete);
}

const TypeObject* GetArrayMultiDimensionUnionObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionUnion", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionUnionObject();
    }
    //else
    return GetMinimalArrayMultiDimensionUnionObject();
}

const TypeObject* GetMinimalArrayMultiDimensionUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionUnion", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_union;
    mst_var_array_union.common().member_id(memberId++);
    mst_var_array_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_union.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_union.common().member_flags().IS_KEY(false);
    mst_var_array_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_union.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerUnionHelper", {10, 10, 10}, false));


    MD5 var_array_union_hash("var_array_union");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_union.detail().name_hash()[i] = var_array_union_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_union);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionUnion", false);
}

const TypeObject* GetCompleteArrayMultiDimensionUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionUnion", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_union;
    cst_var_array_union.common().member_id(memberId++);
    cst_var_array_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_union.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_union.common().member_flags().IS_KEY(false);
    cst_var_array_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_union.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerUnionHelper", {10, 10, 10}, true));


    cst_var_array_union.detail().name("var_array_union");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_union);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionUnion");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionUnion", true);
}

const TypeIdentifier* GetArrayMultiDimensionStructureIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionStructure", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionStructureObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionStructure", complete);
}

const TypeObject* GetArrayMultiDimensionStructureObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionStructure", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionStructureObject();
    }
    //else
    return GetMinimalArrayMultiDimensionStructureObject();
}

const TypeObject* GetMinimalArrayMultiDimensionStructureObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionStructure", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_structure;
    mst_var_array_structure.common().member_id(memberId++);
    mst_var_array_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_structure.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_structure.common().member_flags().IS_KEY(false);
    mst_var_array_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_structure.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerStructureHelper", {10, 10, 10}, false));


    MD5 var_array_structure_hash("var_array_structure");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_structure.detail().name_hash()[i] = var_array_structure_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_structure);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionStructure", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionStructure", false);
}

const TypeObject* GetCompleteArrayMultiDimensionStructureObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionStructure", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_structure;
    cst_var_array_structure.common().member_id(memberId++);
    cst_var_array_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_structure.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_structure.common().member_flags().IS_KEY(false);
    cst_var_array_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_structure.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerStructureHelper", {10, 10, 10}, true));


    cst_var_array_structure.detail().name("var_array_structure");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_structure);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionStructure");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionStructure", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionStructure", true);
}

const TypeIdentifier* GetArrayMultiDimensionBitsetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionBitset", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionBitsetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionBitset", complete);
}

const TypeObject* GetArrayMultiDimensionBitsetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBitset", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionBitsetObject();
    }
    //else
    return GetMinimalArrayMultiDimensionBitsetObject();
}

const TypeObject* GetMinimalArrayMultiDimensionBitsetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBitset", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bitset;
    mst_var_array_bitset.common().member_id(memberId++);
    mst_var_array_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bitset.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bitset.common().member_flags().IS_KEY(false);
    mst_var_array_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bitset.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitsetHelper", {10, 10, 10}, false));


    MD5 var_array_bitset_hash("var_array_bitset");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bitset.detail().name_hash()[i] = var_array_bitset_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bitset);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionBitset", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBitset", false);
}

const TypeObject* GetCompleteArrayMultiDimensionBitsetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBitset", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bitset;
    cst_var_array_bitset.common().member_id(memberId++);
    cst_var_array_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bitset.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bitset.common().member_flags().IS_KEY(false);
    cst_var_array_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bitset.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitsetHelper", {10, 10, 10}, true));


    cst_var_array_bitset.detail().name("var_array_bitset");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bitset);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionBitset");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionBitset", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionBitset", true);
}



const TypeIdentifier* GetArraySingleDimensionLiteralsShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsShort", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsShortObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsShortObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_short;
    mst_var_array_short.common().member_id(memberId++);
    mst_var_array_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_short.common().member_flags().IS_KEY(false);
    mst_var_array_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {5}, false));


    MD5 var_array_short_hash("var_array_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_short.detail().name_hash()[i] = var_array_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsShort", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_short;
    cst_var_array_short.common().member_id(memberId++);
    cst_var_array_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_short.common().member_flags().IS_KEY(false);
    cst_var_array_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {5}, true));


    cst_var_array_short.detail().name("var_array_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsShort", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsUnsignedShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsUnsignedShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsUnsignedShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsUnsignedShort", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsUnsignedShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsUnsignedShortObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsUnsignedShortObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsUnsignedShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_ushort;
    mst_var_array_ushort.common().member_id(memberId++);
    mst_var_array_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_ushort.common().member_flags().IS_KEY(false);
    mst_var_array_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint16_t", {10}, false));


    MD5 var_array_ushort_hash("var_array_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_ushort.detail().name_hash()[i] = var_array_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsUnsignedShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedShort", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsUnsignedShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_ushort;
    cst_var_array_ushort.common().member_id(memberId++);
    cst_var_array_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_ushort.common().member_flags().IS_KEY(false);
    cst_var_array_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint16_t", {10}, true));


    cst_var_array_ushort.detail().name("var_array_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsUnsignedShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsUnsignedShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedShort", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsLong", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsLongObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsLongObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_long;
    mst_var_array_long.common().member_id(memberId++);
    mst_var_array_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_long.common().member_flags().IS_KEY(false);
    mst_var_array_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int32_t", {10}, false));


    MD5 var_array_long_hash("var_array_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_long.detail().name_hash()[i] = var_array_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLong", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_long;
    cst_var_array_long.common().member_id(memberId++);
    cst_var_array_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_long.common().member_flags().IS_KEY(false);
    cst_var_array_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int32_t", {10}, true));


    cst_var_array_long.detail().name("var_array_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLong", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsUnsignedLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsUnsignedLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsUnsignedLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsUnsignedLong", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsUnsignedLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsUnsignedLongObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsUnsignedLongObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsUnsignedLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_ulong;
    mst_var_array_ulong.common().member_id(memberId++);
    mst_var_array_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_ulong.common().member_flags().IS_KEY(false);
    mst_var_array_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint32_t", {10}, false));


    MD5 var_array_ulong_hash("var_array_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_ulong.detail().name_hash()[i] = var_array_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsUnsignedLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedLong", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsUnsignedLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_ulong;
    cst_var_array_ulong.common().member_id(memberId++);
    cst_var_array_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_ulong.common().member_flags().IS_KEY(false);
    cst_var_array_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint32_t", {10}, true));


    cst_var_array_ulong.detail().name("var_array_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsUnsignedLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsUnsignedLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedLong", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsLongLong", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsLongLongObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsLongLongObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_longlong;
    mst_var_array_longlong.common().member_id(memberId++);
    mst_var_array_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_longlong.common().member_flags().IS_KEY(false);
    mst_var_array_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int64_t", {10}, false));


    MD5 var_array_longlong_hash("var_array_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_longlong.detail().name_hash()[i] = var_array_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLongLong", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_longlong;
    cst_var_array_longlong.common().member_id(memberId++);
    cst_var_array_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_longlong.common().member_flags().IS_KEY(false);
    cst_var_array_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int64_t", {10}, true));


    cst_var_array_longlong.detail().name("var_array_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLongLong", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsUnsignedLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsUnsignedLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsUnsignedLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsUnsignedLongLong", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsUnsignedLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsUnsignedLongLongObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsUnsignedLongLongObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsUnsignedLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_ulonglong;
    mst_var_array_ulonglong.common().member_id(memberId++);
    mst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_array_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint64_t", {10}, false));


    MD5 var_array_ulonglong_hash("var_array_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_ulonglong.detail().name_hash()[i] = var_array_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsUnsignedLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedLongLong", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsUnsignedLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_ulonglong;
    cst_var_array_ulonglong.common().member_id(memberId++);
    cst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_array_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint64_t", {10}, true));


    cst_var_array_ulonglong.detail().name("var_array_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsUnsignedLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsUnsignedLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnsignedLongLong", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsFloat", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsFloatObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsFloatObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_float;
    mst_var_array_float.common().member_id(memberId++);
    mst_var_array_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_float.common().member_flags().IS_KEY(false);
    mst_var_array_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("float", {5}, false));


    MD5 var_array_float_hash("var_array_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_float.detail().name_hash()[i] = var_array_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsFloat", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_float;
    cst_var_array_float.common().member_id(memberId++);
    cst_var_array_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_float.common().member_flags().IS_KEY(false);
    cst_var_array_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("float", {5}, true));


    cst_var_array_float.detail().name("var_array_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsFloat", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsDouble", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsDoubleObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsDoubleObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_double;
    mst_var_array_double.common().member_id(memberId++);
    mst_var_array_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_double.common().member_flags().IS_KEY(false);
    mst_var_array_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("double", {10}, false));


    MD5 var_array_double_hash("var_array_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_double.detail().name_hash()[i] = var_array_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsDouble", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_double;
    cst_var_array_double.common().member_id(memberId++);
    cst_var_array_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_double.common().member_flags().IS_KEY(false);
    cst_var_array_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("double", {10}, true));


    cst_var_array_double.detail().name("var_array_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsDouble", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsLongDouble", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsLongDoubleObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsLongDoubleObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_longdouble;
    mst_var_array_longdouble.common().member_id(memberId++);
    mst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_longdouble.common().member_flags().IS_KEY(false);
    mst_var_array_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("longdouble", {10}, false));


    MD5 var_array_longdouble_hash("var_array_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_longdouble.detail().name_hash()[i] = var_array_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLongDouble", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_longdouble;
    cst_var_array_longdouble.common().member_id(memberId++);
    cst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_longdouble.common().member_flags().IS_KEY(false);
    cst_var_array_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("longdouble", {10}, true));


    cst_var_array_longdouble.detail().name("var_array_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsLongDouble", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsBoolean", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsBooleanObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsBooleanObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_boolean;
    mst_var_array_boolean.common().member_id(memberId++);
    mst_var_array_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_boolean.common().member_flags().IS_KEY(false);
    mst_var_array_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("bool", {5}, false));


    MD5 var_array_boolean_hash("var_array_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_boolean.detail().name_hash()[i] = var_array_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoolean", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_boolean;
    cst_var_array_boolean.common().member_id(memberId++);
    cst_var_array_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_boolean.common().member_flags().IS_KEY(false);
    cst_var_array_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("bool", {5}, true));


    cst_var_array_boolean.detail().name("var_array_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoolean", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsOctet", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsOctetObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsOctetObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_octet;
    mst_var_array_octet.common().member_id(memberId++);
    mst_var_array_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_octet.common().member_flags().IS_KEY(false);
    mst_var_array_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {10}, false));


    MD5 var_array_octet_hash("var_array_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_octet.detail().name_hash()[i] = var_array_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsOctet", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_octet;
    cst_var_array_octet.common().member_id(memberId++);
    cst_var_array_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_octet.common().member_flags().IS_KEY(false);
    cst_var_array_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {10}, true));


    cst_var_array_octet.detail().name("var_array_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsOctet", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsChar", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsCharObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsCharObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_char;
    mst_var_array_char.common().member_id(memberId++);
    mst_var_array_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_char.common().member_flags().IS_KEY(false);
    mst_var_array_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("char", {5}, false));


    MD5 var_array_char_hash("var_array_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_char.detail().name_hash()[i] = var_array_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsChar", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_char;
    cst_var_array_char.common().member_id(memberId++);
    cst_var_array_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_char.common().member_flags().IS_KEY(false);
    cst_var_array_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("char", {5}, true));


    cst_var_array_char.detail().name("var_array_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsChar", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsWChar", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsWCharObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsWCharObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_wchar;
    mst_var_array_wchar.common().member_id(memberId++);
    mst_var_array_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_wchar.common().member_flags().IS_KEY(false);
    mst_var_array_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("wchar_t", {10}, false));


    MD5 var_array_wchar_hash("var_array_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_wchar.detail().name_hash()[i] = var_array_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsWChar", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_wchar;
    cst_var_array_wchar.common().member_id(memberId++);
    cst_var_array_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_wchar.common().member_flags().IS_KEY(false);
    cst_var_array_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("wchar_t", {10}, true));


    cst_var_array_wchar.detail().name("var_array_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsWChar", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsString", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsStringObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsStringObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_string;
    mst_var_array_string.common().member_id(memberId++);
    mst_var_array_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_string.common().member_flags().IS_KEY(false);
    mst_var_array_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, false), {5}, false));


    MD5 var_array_string_hash("var_array_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_string.detail().name_hash()[i] = var_array_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsString", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_string;
    cst_var_array_string.common().member_id(memberId++);
    cst_var_array_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_string.common().member_flags().IS_KEY(false);
    cst_var_array_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, false), {5}, true));


    cst_var_array_string.detail().name("var_array_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsString", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsWString", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsWStringObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsWStringObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_wstring;
    mst_var_array_wstring.common().member_id(memberId++);
    mst_var_array_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_wstring.common().member_flags().IS_KEY(false);
    mst_var_array_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, true), {10}, false));


    MD5 var_array_wstring_hash("var_array_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_wstring.detail().name_hash()[i] = var_array_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsWString", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_wstring;
    cst_var_array_wstring.common().member_id(memberId++);
    cst_var_array_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_wstring.common().member_flags().IS_KEY(false);
    cst_var_array_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, true), {10}, true));


    cst_var_array_wstring.detail().name("var_array_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsWString", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsBoundedStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsBoundedString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsBoundedStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsBoundedString", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsBoundedStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoundedString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsBoundedStringObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsBoundedStringObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsBoundedStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoundedString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bounded_string;
    mst_var_array_bounded_string.common().member_id(memberId++);
    mst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bounded_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bounded_string.common().member_flags().IS_KEY(false);
    mst_var_array_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bounded_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_string_helper", {5}, false));


    MD5 var_array_bounded_string_hash("var_array_bounded_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bounded_string.detail().name_hash()[i] = var_array_bounded_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bounded_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsBoundedString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoundedString", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsBoundedStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoundedString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bounded_string;
    cst_var_array_bounded_string.common().member_id(memberId++);
    cst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bounded_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bounded_string.common().member_flags().IS_KEY(false);
    cst_var_array_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bounded_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_string_helper", {5}, true));


    cst_var_array_bounded_string.detail().name("var_array_bounded_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bounded_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsBoundedString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsBoundedString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoundedString", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsBoundedWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsBoundedWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsBoundedWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsBoundedWString", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsBoundedWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoundedWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsBoundedWStringObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsBoundedWStringObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsBoundedWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoundedWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bounded_wstring;
    mst_var_array_bounded_wstring.common().member_id(memberId++);
    mst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bounded_wstring.common().member_flags().IS_KEY(false);
    mst_var_array_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bounded_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_wstring_helper", {10}, false));


    MD5 var_array_bounded_wstring_hash("var_array_bounded_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bounded_wstring.detail().name_hash()[i] = var_array_bounded_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bounded_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsBoundedWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoundedWString", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsBoundedWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoundedWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bounded_wstring;
    cst_var_array_bounded_wstring.common().member_id(memberId++);
    cst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bounded_wstring.common().member_flags().IS_KEY(false);
    cst_var_array_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bounded_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_wstring_helper", {10}, true));


    cst_var_array_bounded_wstring.detail().name("var_array_bounded_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bounded_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsBoundedWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsBoundedWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBoundedWString", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsEnumIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsEnum", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsEnumObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsEnum", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsEnumObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsEnum", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsEnumObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsEnumObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsEnum", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_enum;
    mst_var_array_enum.common().member_id(memberId++);
    mst_var_array_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_enum.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_enum.common().member_flags().IS_KEY(false);
    mst_var_array_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_enum.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerEnumHelper", {5}, false));


    MD5 var_array_enum_hash("var_array_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_enum.detail().name_hash()[i] = var_array_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_enum);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsEnum", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsEnum", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsEnum", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_enum;
    cst_var_array_enum.common().member_id(memberId++);
    cst_var_array_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_enum.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_enum.common().member_flags().IS_KEY(false);
    cst_var_array_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_enum.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerEnumHelper", {5}, true));


    cst_var_array_enum.detail().name("var_array_enum");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_enum);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsEnum");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsEnum", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsEnum", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsBitMaskIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsBitMask", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsBitMaskObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsBitMask", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsBitMaskObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBitMask", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsBitMaskObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsBitMaskObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsBitMaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBitMask", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bitmask;
    mst_var_array_bitmask.common().member_id(memberId++);
    mst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bitmask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bitmask.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bitmask.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bitmask.common().member_flags().IS_KEY(false);
    mst_var_array_bitmask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bitmask.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitMaskHelper", {10}, false));


    MD5 var_array_bitmask_hash("var_array_bitmask");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bitmask.detail().name_hash()[i] = var_array_bitmask_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bitmask);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsBitMask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBitMask", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsBitMaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBitMask", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bitmask;
    cst_var_array_bitmask.common().member_id(memberId++);
    cst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bitmask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bitmask.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bitmask.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bitmask.common().member_flags().IS_KEY(false);
    cst_var_array_bitmask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bitmask.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitMaskHelper", {10}, true));


    cst_var_array_bitmask.detail().name("var_array_bitmask");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bitmask);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsBitMask");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsBitMask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBitMask", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsAliasIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsAlias", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsAliasObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsAlias", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsAliasObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsAlias", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsAliasObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsAliasObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsAliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsAlias", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_alias;
    mst_var_array_alias.common().member_id(memberId++);
    mst_var_array_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_alias.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_alias.common().member_flags().IS_KEY(false);
    mst_var_array_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_alias.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerAliasHelper", {10}, false));


    MD5 var_array_alias_hash("var_array_alias");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_alias.detail().name_hash()[i] = var_array_alias_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_alias);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsAlias", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsAlias", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsAliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsAlias", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_alias;
    cst_var_array_alias.common().member_id(memberId++);
    cst_var_array_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_alias.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_alias.common().member_flags().IS_KEY(false);
    cst_var_array_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_alias.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerAliasHelper", {10}, true));


    cst_var_array_alias.detail().name("var_array_alias");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_alias);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsAlias");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsAlias", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsAlias", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsShortArrayIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsShortArray", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsShortArrayObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsShortArray", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsShortArrayObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsShortArray", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsShortArrayObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsShortArrayObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsShortArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsShortArray", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_short_array;
    mst_var_array_short_array.common().member_id(memberId++);
    mst_var_array_short_array.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_short_array.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_short_array.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_short_array.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_short_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_short_array.common().member_flags().IS_KEY(false);
    mst_var_array_short_array.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_short_array.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10, 10}, false));


    MD5 var_array_short_array_hash("var_array_short_array");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_short_array.detail().name_hash()[i] = var_array_short_array_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_short_array);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsShortArray", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsShortArray", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsShortArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsShortArray", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_short_array;
    cst_var_array_short_array.common().member_id(memberId++);
    cst_var_array_short_array.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_short_array.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_short_array.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_short_array.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_short_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_short_array.common().member_flags().IS_KEY(false);
    cst_var_array_short_array.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_short_array.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10, 10}, true));


    cst_var_array_short_array.detail().name("var_array_short_array");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_short_array);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsShortArray");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsShortArray", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsShortArray", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsSequenceIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsSequence", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsSequenceObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsSequence", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsSequenceObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsSequence", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsSequenceObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsSequenceObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsSequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsSequence", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_sequence;
    mst_var_array_sequence.common().member_id(memberId++);
    mst_var_array_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_sequence.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_sequence.common().member_flags().IS_KEY(false);
    mst_var_array_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_sequence.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_sequence_type_name("int32_t", 100), {5}, false));


    MD5 var_array_sequence_hash("var_array_sequence");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_sequence.detail().name_hash()[i] = var_array_sequence_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_sequence);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsSequence", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsSequence", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsSequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsSequence", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_sequence;
    cst_var_array_sequence.common().member_id(memberId++);
    cst_var_array_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_sequence.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_sequence.common().member_flags().IS_KEY(false);
    cst_var_array_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_sequence.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_sequence_type_name("int32_t", 100), {5}, true));


    cst_var_array_sequence.detail().name("var_array_sequence");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_sequence);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsSequence");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsSequence", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsSequence", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsMapIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsMap", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsMapObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsMap", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsMapObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsMap", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsMapObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsMapObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsMap", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_map;
    mst_var_array_map.common().member_id(memberId++);
    mst_var_array_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_map.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_map.common().member_flags().IS_KEY(false);
    mst_var_array_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100), {2}, false));


    MD5 var_array_map_hash("var_array_map");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_map.detail().name_hash()[i] = var_array_map_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_map);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsMap", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsMap", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_map;
    cst_var_array_map.common().member_id(memberId++);
    cst_var_array_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_map.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_map.common().member_flags().IS_KEY(false);
    cst_var_array_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100), {2}, true));


    cst_var_array_map.detail().name("var_array_map");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_map);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsMap");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsMap", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsUnionIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsUnion", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsUnionObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsUnion", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsUnionObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnion", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsUnionObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsUnionObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnion", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_union;
    mst_var_array_union.common().member_id(memberId++);
    mst_var_array_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_union.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_union.common().member_flags().IS_KEY(false);
    mst_var_array_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_union.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerUnionHelper", {10}, false));


    MD5 var_array_union_hash("var_array_union");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_union.detail().name_hash()[i] = var_array_union_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_union);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnion", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnion", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_union;
    cst_var_array_union.common().member_id(memberId++);
    cst_var_array_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_union.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_union.common().member_flags().IS_KEY(false);
    cst_var_array_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_union.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerUnionHelper", {10}, true));


    cst_var_array_union.detail().name("var_array_union");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_union);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsUnion");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsUnion", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsStructureIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsStructure", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsStructureObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsStructure", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsStructureObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsStructure", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsStructureObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsStructureObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsStructureObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsStructure", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_structure;
    mst_var_array_structure.common().member_id(memberId++);
    mst_var_array_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_structure.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_structure.common().member_flags().IS_KEY(false);
    mst_var_array_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_structure.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerStructureHelper", {5}, false));


    MD5 var_array_structure_hash("var_array_structure");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_structure.detail().name_hash()[i] = var_array_structure_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_structure);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsStructure", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsStructure", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsStructureObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsStructure", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_structure;
    cst_var_array_structure.common().member_id(memberId++);
    cst_var_array_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_structure.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_structure.common().member_flags().IS_KEY(false);
    cst_var_array_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_structure.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerStructureHelper", {5}, true));


    cst_var_array_structure.detail().name("var_array_structure");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_structure);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsStructure");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsStructure", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsStructure", true);
}

const TypeIdentifier* GetArraySingleDimensionLiteralsBitsetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsBitset", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraySingleDimensionLiteralsBitsetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArraySingleDimensionLiteralsBitset", complete);
}

const TypeObject* GetArraySingleDimensionLiteralsBitsetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBitset", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraySingleDimensionLiteralsBitsetObject();
    }
    //else
    return GetMinimalArraySingleDimensionLiteralsBitsetObject();
}

const TypeObject* GetMinimalArraySingleDimensionLiteralsBitsetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBitset", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bitset;
    mst_var_array_bitset.common().member_id(memberId++);
    mst_var_array_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bitset.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bitset.common().member_flags().IS_KEY(false);
    mst_var_array_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bitset.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitsetHelper", {10}, false));


    MD5 var_array_bitset_hash("var_array_bitset");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bitset.detail().name_hash()[i] = var_array_bitset_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bitset);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsBitset", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBitset", false);
}

const TypeObject* GetCompleteArraySingleDimensionLiteralsBitsetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBitset", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bitset;
    cst_var_array_bitset.common().member_id(memberId++);
    cst_var_array_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bitset.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bitset.common().member_flags().IS_KEY(false);
    cst_var_array_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bitset.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitsetHelper", {10}, true));


    cst_var_array_bitset.detail().name("var_array_bitset");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bitset);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraySingleDimensionLiteralsBitset");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArraySingleDimensionLiteralsBitset", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArraySingleDimensionLiteralsBitset", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsShort", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsShortObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsShortObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_short;
    mst_var_array_short.common().member_id(memberId++);
    mst_var_array_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_short.common().member_flags().IS_KEY(false);
    mst_var_array_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {5, 10, 2}, false));


    MD5 var_array_short_hash("var_array_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_short.detail().name_hash()[i] = var_array_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsShort", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_short;
    cst_var_array_short.common().member_id(memberId++);
    cst_var_array_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_short.common().member_flags().IS_KEY(false);
    cst_var_array_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {5, 10, 2}, true));


    cst_var_array_short.detail().name("var_array_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsShort", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsUShort", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsUShortObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsUShortObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_ushort;
    mst_var_array_ushort.common().member_id(memberId++);
    mst_var_array_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_ushort.common().member_flags().IS_KEY(false);
    mst_var_array_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint16_t", {5, 10, 5}, false));


    MD5 var_array_ushort_hash("var_array_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_ushort.detail().name_hash()[i] = var_array_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsUShort", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_ushort;
    cst_var_array_ushort.common().member_id(memberId++);
    cst_var_array_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_ushort.common().member_flags().IS_KEY(false);
    cst_var_array_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint16_t", {5, 10, 5}, true));


    cst_var_array_ushort.detail().name("var_array_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsUShort", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsLong", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsLongObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsLongObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_long;
    mst_var_array_long.common().member_id(memberId++);
    mst_var_array_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_long.common().member_flags().IS_KEY(false);
    mst_var_array_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int32_t", {10, 5, 5}, false));


    MD5 var_array_long_hash("var_array_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_long.detail().name_hash()[i] = var_array_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLong", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_long;
    cst_var_array_long.common().member_id(memberId++);
    cst_var_array_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_long.common().member_flags().IS_KEY(false);
    cst_var_array_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int32_t", {10, 5, 5}, true));


    cst_var_array_long.detail().name("var_array_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLong", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsULong", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsULongObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsULongObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_ulong;
    mst_var_array_ulong.common().member_id(memberId++);
    mst_var_array_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_ulong.common().member_flags().IS_KEY(false);
    mst_var_array_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint32_t", {10, 10, 5}, false));


    MD5 var_array_ulong_hash("var_array_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_ulong.detail().name_hash()[i] = var_array_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsULong", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_ulong;
    cst_var_array_ulong.common().member_id(memberId++);
    cst_var_array_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_ulong.common().member_flags().IS_KEY(false);
    cst_var_array_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint32_t", {10, 10, 5}, true));


    cst_var_array_ulong.detail().name("var_array_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsULong", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsLongLong", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsLongLongObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsLongLongObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_longlong;
    mst_var_array_longlong.common().member_id(memberId++);
    mst_var_array_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_longlong.common().member_flags().IS_KEY(false);
    mst_var_array_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int64_t", {5, 10, 5}, false));


    MD5 var_array_longlong_hash("var_array_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_longlong.detail().name_hash()[i] = var_array_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLongLong", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_longlong;
    cst_var_array_longlong.common().member_id(memberId++);
    cst_var_array_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_longlong.common().member_flags().IS_KEY(false);
    cst_var_array_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int64_t", {5, 10, 5}, true));


    cst_var_array_longlong.detail().name("var_array_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLongLong", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsULongLong", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsULongLongObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsULongLongObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_ulonglong;
    mst_var_array_ulonglong.common().member_id(memberId++);
    mst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_array_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint64_t", {10, 10, 10}, false));


    MD5 var_array_ulonglong_hash("var_array_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_ulonglong.detail().name_hash()[i] = var_array_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsULongLong", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_ulonglong;
    cst_var_array_ulonglong.common().member_id(memberId++);
    cst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_array_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint64_t", {10, 10, 10}, true));


    cst_var_array_ulonglong.detail().name("var_array_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsULongLong", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsFloat", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsFloatObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsFloatObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_float;
    mst_var_array_float.common().member_id(memberId++);
    mst_var_array_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_float.common().member_flags().IS_KEY(false);
    mst_var_array_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("float", {10, 5, 10}, false));


    MD5 var_array_float_hash("var_array_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_float.detail().name_hash()[i] = var_array_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsFloat", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_float;
    cst_var_array_float.common().member_id(memberId++);
    cst_var_array_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_float.common().member_flags().IS_KEY(false);
    cst_var_array_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("float", {10, 5, 10}, true));


    cst_var_array_float.detail().name("var_array_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsFloat", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsDouble", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsDoubleObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsDoubleObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_double;
    mst_var_array_double.common().member_id(memberId++);
    mst_var_array_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_double.common().member_flags().IS_KEY(false);
    mst_var_array_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("double", {5, 10, 5}, false));


    MD5 var_array_double_hash("var_array_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_double.detail().name_hash()[i] = var_array_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsDouble", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_double;
    cst_var_array_double.common().member_id(memberId++);
    cst_var_array_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_double.common().member_flags().IS_KEY(false);
    cst_var_array_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("double", {5, 10, 5}, true));


    cst_var_array_double.detail().name("var_array_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsDouble", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsLongDouble", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsLongDoubleObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsLongDoubleObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_longdouble;
    mst_var_array_longdouble.common().member_id(memberId++);
    mst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_longdouble.common().member_flags().IS_KEY(false);
    mst_var_array_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("longdouble", {5, 5, 10}, false));


    MD5 var_array_longdouble_hash("var_array_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_longdouble.detail().name_hash()[i] = var_array_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLongDouble", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_longdouble;
    cst_var_array_longdouble.common().member_id(memberId++);
    cst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_longdouble.common().member_flags().IS_KEY(false);
    cst_var_array_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("longdouble", {5, 5, 10}, true));


    cst_var_array_longdouble.detail().name("var_array_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsLongDouble", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsBoolean", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsBooleanObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsBooleanObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_boolean;
    mst_var_array_boolean.common().member_id(memberId++);
    mst_var_array_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_boolean.common().member_flags().IS_KEY(false);
    mst_var_array_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("bool", {10, 5, 5}, false));


    MD5 var_array_boolean_hash("var_array_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_boolean.detail().name_hash()[i] = var_array_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoolean", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_boolean;
    cst_var_array_boolean.common().member_id(memberId++);
    cst_var_array_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_boolean.common().member_flags().IS_KEY(false);
    cst_var_array_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("bool", {10, 5, 5}, true));


    cst_var_array_boolean.detail().name("var_array_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoolean", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsOctet", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsOctetObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsOctetObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_octet;
    mst_var_array_octet.common().member_id(memberId++);
    mst_var_array_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_octet.common().member_flags().IS_KEY(false);
    mst_var_array_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {5, 10, 5}, false));


    MD5 var_array_octet_hash("var_array_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_octet.detail().name_hash()[i] = var_array_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsOctet", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_octet;
    cst_var_array_octet.common().member_id(memberId++);
    cst_var_array_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_octet.common().member_flags().IS_KEY(false);
    cst_var_array_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {5, 10, 5}, true));


    cst_var_array_octet.detail().name("var_array_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsOctet", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsChar", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsCharObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsCharObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_char;
    mst_var_array_char.common().member_id(memberId++);
    mst_var_array_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_char.common().member_flags().IS_KEY(false);
    mst_var_array_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("char", {10, 5, 10}, false));


    MD5 var_array_char_hash("var_array_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_char.detail().name_hash()[i] = var_array_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsChar", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_char;
    cst_var_array_char.common().member_id(memberId++);
    cst_var_array_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_char.common().member_flags().IS_KEY(false);
    cst_var_array_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("char", {10, 5, 10}, true));


    cst_var_array_char.detail().name("var_array_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsChar", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsWChar", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsWCharObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsWCharObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_wchar;
    mst_var_array_wchar.common().member_id(memberId++);
    mst_var_array_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_wchar.common().member_flags().IS_KEY(false);
    mst_var_array_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("wchar_t", {10, 10, 5}, false));


    MD5 var_array_wchar_hash("var_array_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_wchar.detail().name_hash()[i] = var_array_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsWChar", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_wchar;
    cst_var_array_wchar.common().member_id(memberId++);
    cst_var_array_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_wchar.common().member_flags().IS_KEY(false);
    cst_var_array_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("wchar_t", {10, 10, 5}, true));


    cst_var_array_wchar.detail().name("var_array_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsWChar", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsString", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsStringObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsStringObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_string;
    mst_var_array_string.common().member_id(memberId++);
    mst_var_array_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_string.common().member_flags().IS_KEY(false);
    mst_var_array_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, false), {5, 10, 5}, false));


    MD5 var_array_string_hash("var_array_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_string.detail().name_hash()[i] = var_array_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsString", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_string;
    cst_var_array_string.common().member_id(memberId++);
    cst_var_array_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_string.common().member_flags().IS_KEY(false);
    cst_var_array_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, false), {5, 10, 5}, true));


    cst_var_array_string.detail().name("var_array_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsString", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsWString", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsWStringObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsWStringObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_wstring;
    mst_var_array_wstring.common().member_id(memberId++);
    mst_var_array_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_wstring.common().member_flags().IS_KEY(false);
    mst_var_array_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, true), {10, 10, 10}, false));


    MD5 var_array_wstring_hash("var_array_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_wstring.detail().name_hash()[i] = var_array_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsWString", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_wstring;
    cst_var_array_wstring.common().member_id(memberId++);
    cst_var_array_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_wstring.common().member_flags().IS_KEY(false);
    cst_var_array_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_string_type_name(255, true), {10, 10, 10}, true));


    cst_var_array_wstring.detail().name("var_array_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsWString", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsBoundedStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsBoundedString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsBoundedStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsBoundedString", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsBoundedStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoundedString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsBoundedStringObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsBoundedStringObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsBoundedStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoundedString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bounded_string;
    mst_var_array_bounded_string.common().member_id(memberId++);
    mst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bounded_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bounded_string.common().member_flags().IS_KEY(false);
    mst_var_array_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bounded_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_string_helper", {5, 10, 5}, false));


    MD5 var_array_bounded_string_hash("var_array_bounded_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bounded_string.detail().name_hash()[i] = var_array_bounded_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bounded_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsBoundedString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoundedString", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsBoundedStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoundedString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bounded_string;
    cst_var_array_bounded_string.common().member_id(memberId++);
    cst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bounded_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bounded_string.common().member_flags().IS_KEY(false);
    cst_var_array_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bounded_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_string_helper", {5, 10, 5}, true));


    cst_var_array_bounded_string.detail().name("var_array_bounded_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bounded_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsBoundedString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsBoundedString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoundedString", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsBoundedWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsBoundedWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsBoundedWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsBoundedWString", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsBoundedWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoundedWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsBoundedWStringObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsBoundedWStringObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsBoundedWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoundedWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bounded_wstring;
    mst_var_array_bounded_wstring.common().member_id(memberId++);
    mst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bounded_wstring.common().member_flags().IS_KEY(false);
    mst_var_array_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bounded_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_wstring_helper", {10, 10, 10}, false));


    MD5 var_array_bounded_wstring_hash("var_array_bounded_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bounded_wstring.detail().name_hash()[i] = var_array_bounded_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bounded_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsBoundedWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoundedWString", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsBoundedWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoundedWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bounded_wstring;
    cst_var_array_bounded_wstring.common().member_id(memberId++);
    cst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bounded_wstring.common().member_flags().IS_KEY(false);
    cst_var_array_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bounded_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("Inner_alias_bounded_wstring_helper", {10, 10, 10}, true));


    cst_var_array_bounded_wstring.detail().name("var_array_bounded_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bounded_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsBoundedWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsBoundedWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBoundedWString", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsEnumIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsEnum", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsEnumObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsEnum", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsEnumObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsEnum", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsEnumObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsEnumObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsEnum", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_enum;
    mst_var_array_enum.common().member_id(memberId++);
    mst_var_array_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_enum.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_enum.common().member_flags().IS_KEY(false);
    mst_var_array_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_enum.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerEnumHelper", {10, 5, 10}, false));


    MD5 var_array_enum_hash("var_array_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_enum.detail().name_hash()[i] = var_array_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_enum);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsEnum", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsEnum", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsEnum", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_enum;
    cst_var_array_enum.common().member_id(memberId++);
    cst_var_array_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_enum.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_enum.common().member_flags().IS_KEY(false);
    cst_var_array_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_enum.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerEnumHelper", {10, 5, 10}, true));


    cst_var_array_enum.detail().name("var_array_enum");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_enum);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsEnum");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsEnum", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsEnum", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsBitMaskIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsBitMask", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsBitMaskObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsBitMask", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsBitMaskObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBitMask", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsBitMaskObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsBitMaskObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsBitMaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBitMask", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bitmask;
    mst_var_array_bitmask.common().member_id(memberId++);
    mst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bitmask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bitmask.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bitmask.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bitmask.common().member_flags().IS_KEY(false);
    mst_var_array_bitmask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bitmask.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitMaskHelper", {5, 10, 5}, false));


    MD5 var_array_bitmask_hash("var_array_bitmask");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bitmask.detail().name_hash()[i] = var_array_bitmask_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bitmask);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsBitMask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBitMask", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsBitMaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBitMask", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bitmask;
    cst_var_array_bitmask.common().member_id(memberId++);
    cst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bitmask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bitmask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bitmask.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bitmask.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bitmask.common().member_flags().IS_KEY(false);
    cst_var_array_bitmask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bitmask.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitMaskHelper", {5, 10, 5}, true));


    cst_var_array_bitmask.detail().name("var_array_bitmask");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bitmask);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsBitMask");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsBitMask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBitMask", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsAliasIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsAlias", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsAliasObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsAlias", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsAliasObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsAlias", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsAliasObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsAliasObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsAliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsAlias", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_alias;
    mst_var_array_alias.common().member_id(memberId++);
    mst_var_array_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_alias.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_alias.common().member_flags().IS_KEY(false);
    mst_var_array_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_alias.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerAliasHelper", {10, 10, 10}, false));


    MD5 var_array_alias_hash("var_array_alias");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_alias.detail().name_hash()[i] = var_array_alias_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_alias);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsAlias", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsAlias", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsAliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsAlias", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_alias;
    cst_var_array_alias.common().member_id(memberId++);
    cst_var_array_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_alias.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_alias.common().member_flags().IS_KEY(false);
    cst_var_array_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_alias.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerAliasHelper", {10, 10, 10}, true));


    cst_var_array_alias.detail().name("var_array_alias");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_alias);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsAlias");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsAlias", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsAlias", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsSequenceIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsSequence", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsSequenceObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsSequence", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsSequenceObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsSequence", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsSequenceObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsSequenceObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsSequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsSequence", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_sequence;
    mst_var_array_sequence.common().member_id(memberId++);
    mst_var_array_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_sequence.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_sequence.common().member_flags().IS_KEY(false);
    mst_var_array_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_sequence.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_sequence_type_name("int32_t", 100), {10, 5, 10}, false));


    MD5 var_array_sequence_hash("var_array_sequence");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_sequence.detail().name_hash()[i] = var_array_sequence_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_sequence);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsSequence", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsSequence", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsSequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsSequence", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_sequence;
    cst_var_array_sequence.common().member_id(memberId++);
    cst_var_array_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_sequence.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_sequence.common().member_flags().IS_KEY(false);
    cst_var_array_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_sequence.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_sequence_type_name("int32_t", 100), {10, 5, 10}, true));


    cst_var_array_sequence.detail().name("var_array_sequence");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_sequence);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsSequence");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsSequence", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsSequence", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsMapIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsMap", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsMapObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsMap", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsMapObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsMap", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsMapObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsMapObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsMap", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_map;
    mst_var_array_map.common().member_id(memberId++);
    mst_var_array_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_map.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_map.common().member_flags().IS_KEY(false);
    mst_var_array_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100), {5, 10, 5}, false));


    MD5 var_array_map_hash("var_array_map");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_map.detail().name_hash()[i] = var_array_map_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_map);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsMap", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsMap", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_map;
    cst_var_array_map.common().member_id(memberId++);
    cst_var_array_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_map.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_map.common().member_flags().IS_KEY(false);
    cst_var_array_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier(TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100), {5, 10, 5}, true));


    cst_var_array_map.detail().name("var_array_map");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_map);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsMap");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsMap", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsUnionIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsUnion", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsUnionObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsUnion", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsUnionObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsUnion", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsUnionObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsUnionObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsUnion", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_union;
    mst_var_array_union.common().member_id(memberId++);
    mst_var_array_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_union.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_union.common().member_flags().IS_KEY(false);
    mst_var_array_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_union.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerUnionHelper", {10, 10, 10}, false));


    MD5 var_array_union_hash("var_array_union");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_union.detail().name_hash()[i] = var_array_union_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_union);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsUnion", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsUnion", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_union;
    cst_var_array_union.common().member_id(memberId++);
    cst_var_array_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_union.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_union.common().member_flags().IS_KEY(false);
    cst_var_array_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_union.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerUnionHelper", {10, 10, 10}, true));


    cst_var_array_union.detail().name("var_array_union");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_union);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsUnion");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsUnion", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsStructureIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsStructure", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsStructureObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsStructure", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsStructureObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsStructure", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsStructureObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsStructureObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsStructureObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsStructure", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_structure;
    mst_var_array_structure.common().member_id(memberId++);
    mst_var_array_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_structure.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_structure.common().member_flags().IS_KEY(false);
    mst_var_array_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_structure.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerStructureHelper", {5, 5, 10}, false));


    MD5 var_array_structure_hash("var_array_structure");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_structure.detail().name_hash()[i] = var_array_structure_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_structure);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsStructure", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsStructure", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsStructureObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsStructure", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_structure;
    cst_var_array_structure.common().member_id(memberId++);
    cst_var_array_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_structure.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_structure.common().member_flags().IS_KEY(false);
    cst_var_array_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_structure.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerStructureHelper", {5, 5, 10}, true));


    cst_var_array_structure.detail().name("var_array_structure");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_structure);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsStructure");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsStructure", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsStructure", true);
}

const TypeIdentifier* GetArrayMultiDimensionLiteralsBitSetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsBitSet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayMultiDimensionLiteralsBitSetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ArrayMultiDimensionLiteralsBitSet", complete);
}

const TypeObject* GetArrayMultiDimensionLiteralsBitSetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBitSet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayMultiDimensionLiteralsBitSetObject();
    }
    //else
    return GetMinimalArrayMultiDimensionLiteralsBitSetObject();
}

const TypeObject* GetMinimalArrayMultiDimensionLiteralsBitSetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBitSet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_bitset;
    mst_var_array_bitset.common().member_id(memberId++);
    mst_var_array_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_bitset.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_bitset.common().member_flags().IS_KEY(false);
    mst_var_array_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_bitset.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitsetHelper", {10, 10, 10}, false));


    MD5 var_array_bitset_hash("var_array_bitset");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_bitset.detail().name_hash()[i] = var_array_bitset_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_bitset);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsBitSet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBitSet", false);
}

const TypeObject* GetCompleteArrayMultiDimensionLiteralsBitSetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBitSet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_bitset;
    cst_var_array_bitset.common().member_id(memberId++);
    cst_var_array_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_bitset.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_bitset.common().member_flags().IS_KEY(false);
    cst_var_array_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_bitset.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("InnerBitsetHelper", {10, 10, 10}, true));


    cst_var_array_bitset.detail().name("var_array_bitset");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_bitset);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayMultiDimensionLiteralsBitSet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ArrayMultiDimensionLiteralsBitSet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ArrayMultiDimensionLiteralsBitSet", true);
}

const TypeIdentifier* GetBoundedSmallArraysIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("BoundedSmallArrays", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBoundedSmallArraysObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("BoundedSmallArrays", complete);
}

const TypeObject* GetBoundedSmallArraysObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedSmallArrays", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBoundedSmallArraysObject();
    }
    //else
    return GetMinimalBoundedSmallArraysObject();
}

const TypeObject* GetMinimalBoundedSmallArraysObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedSmallArrays", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_small;
    mst_var_array_small.common().member_id(memberId++);
    mst_var_array_small.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_small.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_small.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_small.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_small.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_small.common().member_flags().IS_KEY(false);
    mst_var_array_small.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_small.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {1}, false));


    MD5 var_array_small_hash("var_array_small");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_small.detail().name_hash()[i] = var_array_small_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_small);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedSmallArrays", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedSmallArrays", false);
}

const TypeObject* GetCompleteBoundedSmallArraysObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedSmallArrays", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_small;
    cst_var_array_small.common().member_id(memberId++);
    cst_var_array_small.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_small.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_small.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_small.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_small.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_small.common().member_flags().IS_KEY(false);
    cst_var_array_small.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_small.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {1}, true));


    cst_var_array_small.detail().name("var_array_small");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_small);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BoundedSmallArrays");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedSmallArrays", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedSmallArrays", true);
}

const TypeIdentifier* GetBoundedBigArraysIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("BoundedBigArrays", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBoundedBigArraysObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("BoundedBigArrays", complete);
}

const TypeObject* GetBoundedBigArraysObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedBigArrays", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBoundedBigArraysObject();
    }
    //else
    return GetMinimalBoundedBigArraysObject();
}

const TypeObject* GetMinimalBoundedBigArraysObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedBigArrays", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_big;
    mst_var_array_big.common().member_id(memberId++);
    mst_var_array_big.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_big.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_big.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_big.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_big.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_big.common().member_flags().IS_KEY(false);
    mst_var_array_big.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_big.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {41925}, false));


    MD5 var_array_big_hash("var_array_big");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_big.detail().name_hash()[i] = var_array_big_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_big);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedBigArrays", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedBigArrays", false);
}

const TypeObject* GetCompleteBoundedBigArraysObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedBigArrays", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_big;
    cst_var_array_big.common().member_id(memberId++);
    cst_var_array_big.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_big.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_big.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_big.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_big.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_big.common().member_flags().IS_KEY(false);
    cst_var_array_big.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_big.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {41925}, true));


    cst_var_array_big.detail().name("var_array_big");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_big);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BoundedBigArrays");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedBigArrays", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedBigArrays", true);
}
