// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file declarations.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "declarations.h"
#include "declarationsTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>




#define ForwardDeclarationsStruct_max_cdr_typesize 16ULL;
#define ModuledForwardDeclarationsStruct_max_cdr_typesize 16ULL;
#define ForwardStruct_max_cdr_typesize 8ULL;



#define ModuledForwardDeclarationsRecursiveStruct_max_cdr_typesize 1776ULL;


#define ForwardDeclarationsRecursiveStruct_max_cdr_typesize 1776ULL;


#define declarations_module_ModuledForwardStruct_max_cdr_typesize 8ULL;



#define ForwardDeclarationsStruct_max_key_cdr_typesize 0ULL;
#define ModuledForwardDeclarationsStruct_max_key_cdr_typesize 0ULL;
#define ForwardStruct_max_key_cdr_typesize 0ULL;



#define ModuledForwardDeclarationsRecursiveStruct_max_key_cdr_typesize 0ULL;


#define ForwardDeclarationsRecursiveStruct_max_key_cdr_typesize 0ULL;


#define declarations_module_ModuledForwardStruct_max_key_cdr_typesize 0ULL;

class ForwardStruct;

class ForwardUnion;





ForwardDeclarationsStruct::ForwardDeclarationsStruct()
{
    // ForwardStruct m_var_ForwardStruct
        m_var_ForwardStruct = new ForwardStruct();
    // ForwardUnion m_var_ForwardUnion
        m_var_ForwardUnion = new ForwardUnion();

    // Just to register all known types
    registerdeclarationsTypes();
}

ForwardDeclarationsStruct::~ForwardDeclarationsStruct()
{
    delete m_var_ForwardStruct;
    delete m_var_ForwardUnion;
}

ForwardDeclarationsStruct::ForwardDeclarationsStruct(
        const ForwardDeclarationsStruct& x)
{
    m_var_ForwardStruct = new ForwardStruct();
    *m_var_ForwardStruct = *x.m_var_ForwardStruct;

    m_var_ForwardUnion = new ForwardUnion();
    *m_var_ForwardUnion = *x.m_var_ForwardUnion;

}

ForwardDeclarationsStruct::ForwardDeclarationsStruct(
        ForwardDeclarationsStruct&& x) noexcept 
{
    m_var_ForwardStruct = x.m_var_ForwardStruct;
    x.m_var_ForwardStruct = nullptr;
    m_var_ForwardUnion = x.m_var_ForwardUnion;
    x.m_var_ForwardUnion = nullptr;
}

ForwardDeclarationsStruct& ForwardDeclarationsStruct::operator =(
        const ForwardDeclarationsStruct& x)
{

    m_var_ForwardStruct = new ForwardStruct();
    *m_var_ForwardStruct = *x.m_var_ForwardStruct;

    m_var_ForwardUnion = new ForwardUnion();
    *m_var_ForwardUnion = *x.m_var_ForwardUnion;


    return *this;
}

ForwardDeclarationsStruct& ForwardDeclarationsStruct::operator =(
        ForwardDeclarationsStruct&& x) noexcept
{

    m_var_ForwardStruct = x.m_var_ForwardStruct;
    x.m_var_ForwardStruct = nullptr;
    m_var_ForwardUnion = x.m_var_ForwardUnion;
    x.m_var_ForwardUnion = nullptr;

    return *this;
}

bool ForwardDeclarationsStruct::operator ==(
        const ForwardDeclarationsStruct& x) const
{

    return (m_var_ForwardStruct == x.m_var_ForwardStruct && m_var_ForwardUnion == x.m_var_ForwardUnion);
}

bool ForwardDeclarationsStruct::operator !=(
        const ForwardDeclarationsStruct& x) const
{
    return !(*this == x);
}

size_t ForwardDeclarationsStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ForwardDeclarationsStruct_max_cdr_typesize;
}

size_t ForwardDeclarationsStruct::getCdrSerializedSize(
        const ForwardDeclarationsStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ForwardStruct::getCdrSerializedSize(data.var_ForwardStruct(), current_alignment);
    current_alignment += ForwardUnion::getCdrSerializedSize(data.var_ForwardUnion(), current_alignment);

    return current_alignment - initial_alignment;
}

void ForwardDeclarationsStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << *m_var_ForwardStruct;scdr << *m_var_ForwardUnion;
}

void ForwardDeclarationsStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> *m_var_ForwardStruct;
    dcdr >> *m_var_ForwardUnion;
}

/*!
 * @brief This function copies the value in member var_ForwardStruct
 * @param _var_ForwardStruct New value to be copied in member var_ForwardStruct
 */
void ForwardDeclarationsStruct::var_ForwardStruct(
        const ForwardStruct& _var_ForwardStruct)
{
    *m_var_ForwardStruct = _var_ForwardStruct;
}

/*!
 * @brief This function moves the value in member var_ForwardStruct
 * @param _var_ForwardStruct New value to be moved in member var_ForwardStruct
 */
void ForwardDeclarationsStruct::var_ForwardStruct(
        ForwardStruct&& _var_ForwardStruct)
{
    *m_var_ForwardStruct = std::move(_var_ForwardStruct);
}

/*!
 * @brief This function returns a constant reference to member var_ForwardStruct
 * @return Constant reference to member var_ForwardStruct
 */
const ForwardStruct& ForwardDeclarationsStruct::var_ForwardStruct() const
{
    return *m_var_ForwardStruct;
}

/*!
 * @brief This function returns a reference to member var_ForwardStruct
 * @return Reference to member var_ForwardStruct
 */
ForwardStruct& ForwardDeclarationsStruct::var_ForwardStruct()
{
    return *m_var_ForwardStruct;
}
/*!
 * @brief This function copies the value in member var_ForwardUnion
 * @param _var_ForwardUnion New value to be copied in member var_ForwardUnion
 */
void ForwardDeclarationsStruct::var_ForwardUnion(
        const ForwardUnion& _var_ForwardUnion)
{
    *m_var_ForwardUnion = _var_ForwardUnion;
}

/*!
 * @brief This function moves the value in member var_ForwardUnion
 * @param _var_ForwardUnion New value to be moved in member var_ForwardUnion
 */
void ForwardDeclarationsStruct::var_ForwardUnion(
        ForwardUnion&& _var_ForwardUnion)
{
    *m_var_ForwardUnion = std::move(_var_ForwardUnion);
}

/*!
 * @brief This function returns a constant reference to member var_ForwardUnion
 * @return Constant reference to member var_ForwardUnion
 */
const ForwardUnion& ForwardDeclarationsStruct::var_ForwardUnion() const
{
    return *m_var_ForwardUnion;
}

/*!
 * @brief This function returns a reference to member var_ForwardUnion
 * @return Reference to member var_ForwardUnion
 */
ForwardUnion& ForwardDeclarationsStruct::var_ForwardUnion()
{
    return *m_var_ForwardUnion;
}


size_t ForwardDeclarationsStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ForwardDeclarationsStruct_max_key_cdr_typesize;
}

bool ForwardDeclarationsStruct::isKeyDefined()
{
    return false;
}

void ForwardDeclarationsStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ForwardDeclarationsRecursiveStruct::ForwardDeclarationsRecursiveStruct()
{
    // RecursiveUnboundedSeqForwardStruct m_var_RecursiveUnboundedSeqForwardStruct

    // RecursiveBoundedSeqForwardStruct m_var_RecursiveBoundedSeqForwardStruct

    // RecursiveUnboundedSeqForwardUnion m_var_RecursiveUnboundedSeqForwardUnion

    // RecursiveBoundedSeqForwardUnion m_var_RecursiveBoundedSeqForwardUnion


    // Just to register all known types
    registerdeclarationsTypes();
}

ForwardDeclarationsRecursiveStruct::~ForwardDeclarationsRecursiveStruct()
{




}

ForwardDeclarationsRecursiveStruct::ForwardDeclarationsRecursiveStruct(
        const ForwardDeclarationsRecursiveStruct& x)
{
    m_var_RecursiveUnboundedSeqForwardStruct = x.m_var_RecursiveUnboundedSeqForwardStruct;
    m_var_RecursiveBoundedSeqForwardStruct = x.m_var_RecursiveBoundedSeqForwardStruct;
    m_var_RecursiveUnboundedSeqForwardUnion = x.m_var_RecursiveUnboundedSeqForwardUnion;
    m_var_RecursiveBoundedSeqForwardUnion = x.m_var_RecursiveBoundedSeqForwardUnion;
}

ForwardDeclarationsRecursiveStruct::ForwardDeclarationsRecursiveStruct(
        ForwardDeclarationsRecursiveStruct&& x) noexcept 
{
    m_var_RecursiveUnboundedSeqForwardStruct = std::move(x.m_var_RecursiveUnboundedSeqForwardStruct);
    m_var_RecursiveBoundedSeqForwardStruct = std::move(x.m_var_RecursiveBoundedSeqForwardStruct);
    m_var_RecursiveUnboundedSeqForwardUnion = std::move(x.m_var_RecursiveUnboundedSeqForwardUnion);
    m_var_RecursiveBoundedSeqForwardUnion = std::move(x.m_var_RecursiveBoundedSeqForwardUnion);
}

ForwardDeclarationsRecursiveStruct& ForwardDeclarationsRecursiveStruct::operator =(
        const ForwardDeclarationsRecursiveStruct& x)
{

    m_var_RecursiveUnboundedSeqForwardStruct = x.m_var_RecursiveUnboundedSeqForwardStruct;
    m_var_RecursiveBoundedSeqForwardStruct = x.m_var_RecursiveBoundedSeqForwardStruct;
    m_var_RecursiveUnboundedSeqForwardUnion = x.m_var_RecursiveUnboundedSeqForwardUnion;
    m_var_RecursiveBoundedSeqForwardUnion = x.m_var_RecursiveBoundedSeqForwardUnion;

    return *this;
}

ForwardDeclarationsRecursiveStruct& ForwardDeclarationsRecursiveStruct::operator =(
        ForwardDeclarationsRecursiveStruct&& x) noexcept
{

    m_var_RecursiveUnboundedSeqForwardStruct = std::move(x.m_var_RecursiveUnboundedSeqForwardStruct);
    m_var_RecursiveBoundedSeqForwardStruct = std::move(x.m_var_RecursiveBoundedSeqForwardStruct);
    m_var_RecursiveUnboundedSeqForwardUnion = std::move(x.m_var_RecursiveUnboundedSeqForwardUnion);
    m_var_RecursiveBoundedSeqForwardUnion = std::move(x.m_var_RecursiveBoundedSeqForwardUnion);

    return *this;
}

bool ForwardDeclarationsRecursiveStruct::operator ==(
        const ForwardDeclarationsRecursiveStruct& x) const
{

    return (m_var_RecursiveUnboundedSeqForwardStruct == x.m_var_RecursiveUnboundedSeqForwardStruct && m_var_RecursiveBoundedSeqForwardStruct == x.m_var_RecursiveBoundedSeqForwardStruct && m_var_RecursiveUnboundedSeqForwardUnion == x.m_var_RecursiveUnboundedSeqForwardUnion && m_var_RecursiveBoundedSeqForwardUnion == x.m_var_RecursiveBoundedSeqForwardUnion);
}

bool ForwardDeclarationsRecursiveStruct::operator !=(
        const ForwardDeclarationsRecursiveStruct& x) const
{
    return !(*this == x);
}

size_t ForwardDeclarationsRecursiveStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ForwardDeclarationsRecursiveStruct_max_cdr_typesize;
}

size_t ForwardDeclarationsRecursiveStruct::getCdrSerializedSize(
        const ForwardDeclarationsRecursiveStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.var_RecursiveUnboundedSeqForwardStruct().size(); ++a)
    {
        current_alignment += ForwardStruct::getCdrSerializedSize(data.var_RecursiveUnboundedSeqForwardStruct().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.var_RecursiveBoundedSeqForwardStruct().size(); ++a)
    {
        current_alignment += ForwardStruct::getCdrSerializedSize(data.var_RecursiveBoundedSeqForwardStruct().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.var_RecursiveUnboundedSeqForwardUnion().size(); ++a)
    {
        current_alignment += ForwardUnion::getCdrSerializedSize(data.var_RecursiveUnboundedSeqForwardUnion().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.var_RecursiveBoundedSeqForwardUnion().size(); ++a)
    {
        current_alignment += ForwardUnion::getCdrSerializedSize(data.var_RecursiveBoundedSeqForwardUnion().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void ForwardDeclarationsRecursiveStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_RecursiveUnboundedSeqForwardStruct;
    scdr << m_var_RecursiveBoundedSeqForwardStruct;
    scdr << m_var_RecursiveUnboundedSeqForwardUnion;
    scdr << m_var_RecursiveBoundedSeqForwardUnion;
}

void ForwardDeclarationsRecursiveStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_RecursiveUnboundedSeqForwardStruct;
    dcdr >> m_var_RecursiveBoundedSeqForwardStruct;
    dcdr >> m_var_RecursiveUnboundedSeqForwardUnion;
    dcdr >> m_var_RecursiveBoundedSeqForwardUnion;
}

/*!
 * @brief This function copies the value in member var_RecursiveUnboundedSeqForwardStruct
 * @param _var_RecursiveUnboundedSeqForwardStruct New value to be copied in member var_RecursiveUnboundedSeqForwardStruct
 */
void ForwardDeclarationsRecursiveStruct::var_RecursiveUnboundedSeqForwardStruct(
        const RecursiveUnboundedSeqForwardStruct& _var_RecursiveUnboundedSeqForwardStruct)
{
    m_var_RecursiveUnboundedSeqForwardStruct = _var_RecursiveUnboundedSeqForwardStruct;
}

/*!
 * @brief This function moves the value in member var_RecursiveUnboundedSeqForwardStruct
 * @param _var_RecursiveUnboundedSeqForwardStruct New value to be moved in member var_RecursiveUnboundedSeqForwardStruct
 */
void ForwardDeclarationsRecursiveStruct::var_RecursiveUnboundedSeqForwardStruct(
        RecursiveUnboundedSeqForwardStruct&& _var_RecursiveUnboundedSeqForwardStruct)
{
    m_var_RecursiveUnboundedSeqForwardStruct = std::move(_var_RecursiveUnboundedSeqForwardStruct);
}

/*!
 * @brief This function returns a constant reference to member var_RecursiveUnboundedSeqForwardStruct
 * @return Constant reference to member var_RecursiveUnboundedSeqForwardStruct
 */
const RecursiveUnboundedSeqForwardStruct& ForwardDeclarationsRecursiveStruct::var_RecursiveUnboundedSeqForwardStruct() const
{
    return m_var_RecursiveUnboundedSeqForwardStruct;
}

/*!
 * @brief This function returns a reference to member var_RecursiveUnboundedSeqForwardStruct
 * @return Reference to member var_RecursiveUnboundedSeqForwardStruct
 */
RecursiveUnboundedSeqForwardStruct& ForwardDeclarationsRecursiveStruct::var_RecursiveUnboundedSeqForwardStruct()
{
    return m_var_RecursiveUnboundedSeqForwardStruct;
}
/*!
 * @brief This function copies the value in member var_RecursiveBoundedSeqForwardStruct
 * @param _var_RecursiveBoundedSeqForwardStruct New value to be copied in member var_RecursiveBoundedSeqForwardStruct
 */
void ForwardDeclarationsRecursiveStruct::var_RecursiveBoundedSeqForwardStruct(
        const RecursiveBoundedSeqForwardStruct& _var_RecursiveBoundedSeqForwardStruct)
{
    m_var_RecursiveBoundedSeqForwardStruct = _var_RecursiveBoundedSeqForwardStruct;
}

/*!
 * @brief This function moves the value in member var_RecursiveBoundedSeqForwardStruct
 * @param _var_RecursiveBoundedSeqForwardStruct New value to be moved in member var_RecursiveBoundedSeqForwardStruct
 */
void ForwardDeclarationsRecursiveStruct::var_RecursiveBoundedSeqForwardStruct(
        RecursiveBoundedSeqForwardStruct&& _var_RecursiveBoundedSeqForwardStruct)
{
    m_var_RecursiveBoundedSeqForwardStruct = std::move(_var_RecursiveBoundedSeqForwardStruct);
}

/*!
 * @brief This function returns a constant reference to member var_RecursiveBoundedSeqForwardStruct
 * @return Constant reference to member var_RecursiveBoundedSeqForwardStruct
 */
const RecursiveBoundedSeqForwardStruct& ForwardDeclarationsRecursiveStruct::var_RecursiveBoundedSeqForwardStruct() const
{
    return m_var_RecursiveBoundedSeqForwardStruct;
}

/*!
 * @brief This function returns a reference to member var_RecursiveBoundedSeqForwardStruct
 * @return Reference to member var_RecursiveBoundedSeqForwardStruct
 */
RecursiveBoundedSeqForwardStruct& ForwardDeclarationsRecursiveStruct::var_RecursiveBoundedSeqForwardStruct()
{
    return m_var_RecursiveBoundedSeqForwardStruct;
}
/*!
 * @brief This function copies the value in member var_RecursiveUnboundedSeqForwardUnion
 * @param _var_RecursiveUnboundedSeqForwardUnion New value to be copied in member var_RecursiveUnboundedSeqForwardUnion
 */
void ForwardDeclarationsRecursiveStruct::var_RecursiveUnboundedSeqForwardUnion(
        const RecursiveUnboundedSeqForwardUnion& _var_RecursiveUnboundedSeqForwardUnion)
{
    m_var_RecursiveUnboundedSeqForwardUnion = _var_RecursiveUnboundedSeqForwardUnion;
}

/*!
 * @brief This function moves the value in member var_RecursiveUnboundedSeqForwardUnion
 * @param _var_RecursiveUnboundedSeqForwardUnion New value to be moved in member var_RecursiveUnboundedSeqForwardUnion
 */
void ForwardDeclarationsRecursiveStruct::var_RecursiveUnboundedSeqForwardUnion(
        RecursiveUnboundedSeqForwardUnion&& _var_RecursiveUnboundedSeqForwardUnion)
{
    m_var_RecursiveUnboundedSeqForwardUnion = std::move(_var_RecursiveUnboundedSeqForwardUnion);
}

/*!
 * @brief This function returns a constant reference to member var_RecursiveUnboundedSeqForwardUnion
 * @return Constant reference to member var_RecursiveUnboundedSeqForwardUnion
 */
const RecursiveUnboundedSeqForwardUnion& ForwardDeclarationsRecursiveStruct::var_RecursiveUnboundedSeqForwardUnion() const
{
    return m_var_RecursiveUnboundedSeqForwardUnion;
}

/*!
 * @brief This function returns a reference to member var_RecursiveUnboundedSeqForwardUnion
 * @return Reference to member var_RecursiveUnboundedSeqForwardUnion
 */
RecursiveUnboundedSeqForwardUnion& ForwardDeclarationsRecursiveStruct::var_RecursiveUnboundedSeqForwardUnion()
{
    return m_var_RecursiveUnboundedSeqForwardUnion;
}
/*!
 * @brief This function copies the value in member var_RecursiveBoundedSeqForwardUnion
 * @param _var_RecursiveBoundedSeqForwardUnion New value to be copied in member var_RecursiveBoundedSeqForwardUnion
 */
void ForwardDeclarationsRecursiveStruct::var_RecursiveBoundedSeqForwardUnion(
        const RecursiveBoundedSeqForwardUnion& _var_RecursiveBoundedSeqForwardUnion)
{
    m_var_RecursiveBoundedSeqForwardUnion = _var_RecursiveBoundedSeqForwardUnion;
}

/*!
 * @brief This function moves the value in member var_RecursiveBoundedSeqForwardUnion
 * @param _var_RecursiveBoundedSeqForwardUnion New value to be moved in member var_RecursiveBoundedSeqForwardUnion
 */
void ForwardDeclarationsRecursiveStruct::var_RecursiveBoundedSeqForwardUnion(
        RecursiveBoundedSeqForwardUnion&& _var_RecursiveBoundedSeqForwardUnion)
{
    m_var_RecursiveBoundedSeqForwardUnion = std::move(_var_RecursiveBoundedSeqForwardUnion);
}

/*!
 * @brief This function returns a constant reference to member var_RecursiveBoundedSeqForwardUnion
 * @return Constant reference to member var_RecursiveBoundedSeqForwardUnion
 */
const RecursiveBoundedSeqForwardUnion& ForwardDeclarationsRecursiveStruct::var_RecursiveBoundedSeqForwardUnion() const
{
    return m_var_RecursiveBoundedSeqForwardUnion;
}

/*!
 * @brief This function returns a reference to member var_RecursiveBoundedSeqForwardUnion
 * @return Reference to member var_RecursiveBoundedSeqForwardUnion
 */
RecursiveBoundedSeqForwardUnion& ForwardDeclarationsRecursiveStruct::var_RecursiveBoundedSeqForwardUnion()
{
    return m_var_RecursiveBoundedSeqForwardUnion;
}


size_t ForwardDeclarationsRecursiveStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ForwardDeclarationsRecursiveStruct_max_key_cdr_typesize;
}

bool ForwardDeclarationsRecursiveStruct::isKeyDefined()
{
    return false;
}

void ForwardDeclarationsRecursiveStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ForwardUnion::ForwardUnion()
{
    m__d = 0;
    // long m_case_zero
    m_case_zero = 0;
    // long m_case_one
    m_case_one = 0;
}

ForwardUnion::~ForwardUnion()
{
}

ForwardUnion::ForwardUnion(
        const ForwardUnion& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_case_zero = x.m_case_zero;
        break;
        case 1:
        m_case_one = x.m_case_one;
        break;
        default:
        break;
    }
}

ForwardUnion::ForwardUnion(
        ForwardUnion&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_case_zero = x.m_case_zero;
        break;
        case 1:
        m_case_one = x.m_case_one;
        break;
        default:
        break;
    }
}

ForwardUnion& ForwardUnion::operator =(
        const ForwardUnion& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_case_zero = x.m_case_zero;
        break;
        case 1:
        m_case_one = x.m_case_one;
        break;
        default:
        break;
    }

    return *this;
}

ForwardUnion& ForwardUnion::operator =(
        ForwardUnion&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_case_zero = x.m_case_zero;
        break;
        case 1:
        m_case_one = x.m_case_one;
        break;
        default:
        break;
    }

    return *this;
}

bool ForwardUnion::operator ==(
        const ForwardUnion& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 0:
            return (m_case_zero == x.m_case_zero);
            break;
        case 1:
            return (m_case_one == x.m_case_one);
            break;
        default:
        break;
    }
    return false;
}

bool ForwardUnion::operator !=(
        const ForwardUnion& x) const
{
    return !(*this == x);
}

void ForwardUnion::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        switch(__d)
        {
            case 0:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t ForwardUnion::_d() const
{
    return m__d;
}

int32_t& ForwardUnion::_d()
{
    return m__d;
}

void ForwardUnion::case_zero(
        int32_t _case_zero)
{
    m_case_zero = _case_zero;
    m__d = 0;
}

int32_t ForwardUnion::case_zero() const
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_case_zero;
}

int32_t& ForwardUnion::case_zero()
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_case_zero;
}
void ForwardUnion::case_one(
        int32_t _case_one)
{
    m_case_one = _case_one;
    m__d = 1;
}

int32_t ForwardUnion::case_one() const
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_case_one;
}

int32_t& ForwardUnion::case_one()
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_case_one;
}

// TODO(Ricardo) Review
size_t ForwardUnion::getCdrSerializedSize(
        const ForwardUnion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 0:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 1:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void ForwardUnion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 0:
        scdr << m_case_zero;
        break;
        case 1:
        scdr << m_case_one;
        break;
        default:
        break;
    }
}

void ForwardUnion::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 0:
        dcdr >> m_case_zero;
        break;
        case 1:
        dcdr >> m_case_one;
        break;
        default:
        break;
    }
}


ForwardStruct::ForwardStruct()
{
    // short m_var_short
    m_var_short = 0;
    // long m_var_long
    m_var_long = 0;

    // Just to register all known types
    registerdeclarationsTypes();
}

ForwardStruct::~ForwardStruct()
{


}

ForwardStruct::ForwardStruct(
        const ForwardStruct& x)
{
    m_var_short = x.m_var_short;
    m_var_long = x.m_var_long;
}

ForwardStruct::ForwardStruct(
        ForwardStruct&& x) noexcept 
{
    m_var_short = x.m_var_short;
    m_var_long = x.m_var_long;
}

ForwardStruct& ForwardStruct::operator =(
        const ForwardStruct& x)
{

    m_var_short = x.m_var_short;
    m_var_long = x.m_var_long;

    return *this;
}

ForwardStruct& ForwardStruct::operator =(
        ForwardStruct&& x) noexcept
{

    m_var_short = x.m_var_short;
    m_var_long = x.m_var_long;

    return *this;
}

bool ForwardStruct::operator ==(
        const ForwardStruct& x) const
{

    return (m_var_short == x.m_var_short && m_var_long == x.m_var_long);
}

bool ForwardStruct::operator !=(
        const ForwardStruct& x) const
{
    return !(*this == x);
}

size_t ForwardStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ForwardStruct_max_cdr_typesize;
}

size_t ForwardStruct::getCdrSerializedSize(
        const ForwardStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void ForwardStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_short;scdr << m_var_long;
}

void ForwardStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_short;
    dcdr >> m_var_long;
}

/*!
 * @brief This function sets a value in member var_short
 * @param _var_short New value for member var_short
 */
void ForwardStruct::var_short(
        int16_t _var_short)
{
    m_var_short = _var_short;
}

/*!
 * @brief This function returns the value of member var_short
 * @return Value of member var_short
 */
int16_t ForwardStruct::var_short() const
{
    return m_var_short;
}

/*!
 * @brief This function returns a reference to member var_short
 * @return Reference to member var_short
 */
int16_t& ForwardStruct::var_short()
{
    return m_var_short;
}

/*!
 * @brief This function sets a value in member var_long
 * @param _var_long New value for member var_long
 */
void ForwardStruct::var_long(
        int32_t _var_long)
{
    m_var_long = _var_long;
}

/*!
 * @brief This function returns the value of member var_long
 * @return Value of member var_long
 */
int32_t ForwardStruct::var_long() const
{
    return m_var_long;
}

/*!
 * @brief This function returns a reference to member var_long
 * @return Reference to member var_long
 */
int32_t& ForwardStruct::var_long()
{
    return m_var_long;
}



size_t ForwardStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ForwardStruct_max_key_cdr_typesize;
}

bool ForwardStruct::isKeyDefined()
{
    return false;
}

void ForwardStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


class ModuledForwardStruct;

class ModuledForwardUnion;






ModuledForwardDeclarationsStruct::ModuledForwardDeclarationsStruct()
{
    // declarations_module::ModuledForwardStruct m_var_ModuledForwardStruct
        m_var_ModuledForwardStruct = new declarations_module::ModuledForwardStruct();
    // declarations_module::ModuledForwardUnion m_var_ModuledForwardUnion
        m_var_ModuledForwardUnion = new declarations_module::ModuledForwardUnion();

    // Just to register all known types
    registerdeclarationsTypes();
}

ModuledForwardDeclarationsStruct::~ModuledForwardDeclarationsStruct()
{
    delete m_var_ModuledForwardStruct;
    delete m_var_ModuledForwardUnion;
}

ModuledForwardDeclarationsStruct::ModuledForwardDeclarationsStruct(
        const ModuledForwardDeclarationsStruct& x)
{
    m_var_ModuledForwardStruct = new declarations_module::ModuledForwardStruct();
    *m_var_ModuledForwardStruct = *x.m_var_ModuledForwardStruct;

    m_var_ModuledForwardUnion = new declarations_module::ModuledForwardUnion();
    *m_var_ModuledForwardUnion = *x.m_var_ModuledForwardUnion;

}

ModuledForwardDeclarationsStruct::ModuledForwardDeclarationsStruct(
        ModuledForwardDeclarationsStruct&& x) noexcept 
{
    m_var_ModuledForwardStruct = x.m_var_ModuledForwardStruct;
    x.m_var_ModuledForwardStruct = nullptr;
    m_var_ModuledForwardUnion = x.m_var_ModuledForwardUnion;
    x.m_var_ModuledForwardUnion = nullptr;
}

ModuledForwardDeclarationsStruct& ModuledForwardDeclarationsStruct::operator =(
        const ModuledForwardDeclarationsStruct& x)
{

    m_var_ModuledForwardStruct = new declarations_module::ModuledForwardStruct();
    *m_var_ModuledForwardStruct = *x.m_var_ModuledForwardStruct;

    m_var_ModuledForwardUnion = new declarations_module::ModuledForwardUnion();
    *m_var_ModuledForwardUnion = *x.m_var_ModuledForwardUnion;


    return *this;
}

ModuledForwardDeclarationsStruct& ModuledForwardDeclarationsStruct::operator =(
        ModuledForwardDeclarationsStruct&& x) noexcept
{

    m_var_ModuledForwardStruct = x.m_var_ModuledForwardStruct;
    x.m_var_ModuledForwardStruct = nullptr;
    m_var_ModuledForwardUnion = x.m_var_ModuledForwardUnion;
    x.m_var_ModuledForwardUnion = nullptr;

    return *this;
}

bool ModuledForwardDeclarationsStruct::operator ==(
        const ModuledForwardDeclarationsStruct& x) const
{

    return (m_var_ModuledForwardStruct == x.m_var_ModuledForwardStruct && m_var_ModuledForwardUnion == x.m_var_ModuledForwardUnion);
}

bool ModuledForwardDeclarationsStruct::operator !=(
        const ModuledForwardDeclarationsStruct& x) const
{
    return !(*this == x);
}

size_t ModuledForwardDeclarationsStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ModuledForwardDeclarationsStruct_max_cdr_typesize;
}

size_t ModuledForwardDeclarationsStruct::getCdrSerializedSize(
        const ModuledForwardDeclarationsStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += declarations_module::ModuledForwardStruct::getCdrSerializedSize(data.var_ModuledForwardStruct(), current_alignment);
    current_alignment += declarations_module::ModuledForwardUnion::getCdrSerializedSize(data.var_ModuledForwardUnion(), current_alignment);

    return current_alignment - initial_alignment;
}

void ModuledForwardDeclarationsStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << *m_var_ModuledForwardStruct;scdr << *m_var_ModuledForwardUnion;
}

void ModuledForwardDeclarationsStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> *m_var_ModuledForwardStruct;
    dcdr >> *m_var_ModuledForwardUnion;
}

/*!
 * @brief This function copies the value in member var_ModuledForwardStruct
 * @param _var_ModuledForwardStruct New value to be copied in member var_ModuledForwardStruct
 */
void ModuledForwardDeclarationsStruct::var_ModuledForwardStruct(
        const declarations_module::ModuledForwardStruct& _var_ModuledForwardStruct)
{
    *m_var_ModuledForwardStruct = _var_ModuledForwardStruct;
}

/*!
 * @brief This function moves the value in member var_ModuledForwardStruct
 * @param _var_ModuledForwardStruct New value to be moved in member var_ModuledForwardStruct
 */
void ModuledForwardDeclarationsStruct::var_ModuledForwardStruct(
        declarations_module::ModuledForwardStruct&& _var_ModuledForwardStruct)
{
    *m_var_ModuledForwardStruct = std::move(_var_ModuledForwardStruct);
}

/*!
 * @brief This function returns a constant reference to member var_ModuledForwardStruct
 * @return Constant reference to member var_ModuledForwardStruct
 */
const declarations_module::ModuledForwardStruct& ModuledForwardDeclarationsStruct::var_ModuledForwardStruct() const
{
    return *m_var_ModuledForwardStruct;
}

/*!
 * @brief This function returns a reference to member var_ModuledForwardStruct
 * @return Reference to member var_ModuledForwardStruct
 */
declarations_module::ModuledForwardStruct& ModuledForwardDeclarationsStruct::var_ModuledForwardStruct()
{
    return *m_var_ModuledForwardStruct;
}
/*!
 * @brief This function copies the value in member var_ModuledForwardUnion
 * @param _var_ModuledForwardUnion New value to be copied in member var_ModuledForwardUnion
 */
void ModuledForwardDeclarationsStruct::var_ModuledForwardUnion(
        const declarations_module::ModuledForwardUnion& _var_ModuledForwardUnion)
{
    *m_var_ModuledForwardUnion = _var_ModuledForwardUnion;
}

/*!
 * @brief This function moves the value in member var_ModuledForwardUnion
 * @param _var_ModuledForwardUnion New value to be moved in member var_ModuledForwardUnion
 */
void ModuledForwardDeclarationsStruct::var_ModuledForwardUnion(
        declarations_module::ModuledForwardUnion&& _var_ModuledForwardUnion)
{
    *m_var_ModuledForwardUnion = std::move(_var_ModuledForwardUnion);
}

/*!
 * @brief This function returns a constant reference to member var_ModuledForwardUnion
 * @return Constant reference to member var_ModuledForwardUnion
 */
const declarations_module::ModuledForwardUnion& ModuledForwardDeclarationsStruct::var_ModuledForwardUnion() const
{
    return *m_var_ModuledForwardUnion;
}

/*!
 * @brief This function returns a reference to member var_ModuledForwardUnion
 * @return Reference to member var_ModuledForwardUnion
 */
declarations_module::ModuledForwardUnion& ModuledForwardDeclarationsStruct::var_ModuledForwardUnion()
{
    return *m_var_ModuledForwardUnion;
}


size_t ModuledForwardDeclarationsStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ModuledForwardDeclarationsStruct_max_key_cdr_typesize;
}

bool ModuledForwardDeclarationsStruct::isKeyDefined()
{
    return false;
}

void ModuledForwardDeclarationsStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ModuledForwardDeclarationsRecursiveStruct::ModuledForwardDeclarationsRecursiveStruct()
{
    // declarations_module::ModuledRecursiveUnboundedSeqForwardStruct m_var_ModuledRecursiveUnboundedSeqForwardStruct

    // declarations_module::ModuledRecursiveBoundedSeqForwardStruct m_var_ModuledRecursiveBoundedSeqForwardStruct

    // declarations_module::ModuledRecursiveUnboundedSeqForwardUnion m_var_ModuledRecursiveUnboundedSeqForwardUnion

    // declarations_module::ModuledRecursiveBoundedSeqForwardUnion m_var_ModuledRecursiveBoundedSeqForwardUnion


    // Just to register all known types
    registerdeclarationsTypes();
}

ModuledForwardDeclarationsRecursiveStruct::~ModuledForwardDeclarationsRecursiveStruct()
{




}

ModuledForwardDeclarationsRecursiveStruct::ModuledForwardDeclarationsRecursiveStruct(
        const ModuledForwardDeclarationsRecursiveStruct& x)
{
    m_var_ModuledRecursiveUnboundedSeqForwardStruct = x.m_var_ModuledRecursiveUnboundedSeqForwardStruct;
    m_var_ModuledRecursiveBoundedSeqForwardStruct = x.m_var_ModuledRecursiveBoundedSeqForwardStruct;
    m_var_ModuledRecursiveUnboundedSeqForwardUnion = x.m_var_ModuledRecursiveUnboundedSeqForwardUnion;
    m_var_ModuledRecursiveBoundedSeqForwardUnion = x.m_var_ModuledRecursiveBoundedSeqForwardUnion;
}

ModuledForwardDeclarationsRecursiveStruct::ModuledForwardDeclarationsRecursiveStruct(
        ModuledForwardDeclarationsRecursiveStruct&& x) noexcept 
{
    m_var_ModuledRecursiveUnboundedSeqForwardStruct = std::move(x.m_var_ModuledRecursiveUnboundedSeqForwardStruct);
    m_var_ModuledRecursiveBoundedSeqForwardStruct = std::move(x.m_var_ModuledRecursiveBoundedSeqForwardStruct);
    m_var_ModuledRecursiveUnboundedSeqForwardUnion = std::move(x.m_var_ModuledRecursiveUnboundedSeqForwardUnion);
    m_var_ModuledRecursiveBoundedSeqForwardUnion = std::move(x.m_var_ModuledRecursiveBoundedSeqForwardUnion);
}

ModuledForwardDeclarationsRecursiveStruct& ModuledForwardDeclarationsRecursiveStruct::operator =(
        const ModuledForwardDeclarationsRecursiveStruct& x)
{

    m_var_ModuledRecursiveUnboundedSeqForwardStruct = x.m_var_ModuledRecursiveUnboundedSeqForwardStruct;
    m_var_ModuledRecursiveBoundedSeqForwardStruct = x.m_var_ModuledRecursiveBoundedSeqForwardStruct;
    m_var_ModuledRecursiveUnboundedSeqForwardUnion = x.m_var_ModuledRecursiveUnboundedSeqForwardUnion;
    m_var_ModuledRecursiveBoundedSeqForwardUnion = x.m_var_ModuledRecursiveBoundedSeqForwardUnion;

    return *this;
}

ModuledForwardDeclarationsRecursiveStruct& ModuledForwardDeclarationsRecursiveStruct::operator =(
        ModuledForwardDeclarationsRecursiveStruct&& x) noexcept
{

    m_var_ModuledRecursiveUnboundedSeqForwardStruct = std::move(x.m_var_ModuledRecursiveUnboundedSeqForwardStruct);
    m_var_ModuledRecursiveBoundedSeqForwardStruct = std::move(x.m_var_ModuledRecursiveBoundedSeqForwardStruct);
    m_var_ModuledRecursiveUnboundedSeqForwardUnion = std::move(x.m_var_ModuledRecursiveUnboundedSeqForwardUnion);
    m_var_ModuledRecursiveBoundedSeqForwardUnion = std::move(x.m_var_ModuledRecursiveBoundedSeqForwardUnion);

    return *this;
}

bool ModuledForwardDeclarationsRecursiveStruct::operator ==(
        const ModuledForwardDeclarationsRecursiveStruct& x) const
{

    return (m_var_ModuledRecursiveUnboundedSeqForwardStruct == x.m_var_ModuledRecursiveUnboundedSeqForwardStruct && m_var_ModuledRecursiveBoundedSeqForwardStruct == x.m_var_ModuledRecursiveBoundedSeqForwardStruct && m_var_ModuledRecursiveUnboundedSeqForwardUnion == x.m_var_ModuledRecursiveUnboundedSeqForwardUnion && m_var_ModuledRecursiveBoundedSeqForwardUnion == x.m_var_ModuledRecursiveBoundedSeqForwardUnion);
}

bool ModuledForwardDeclarationsRecursiveStruct::operator !=(
        const ModuledForwardDeclarationsRecursiveStruct& x) const
{
    return !(*this == x);
}

size_t ModuledForwardDeclarationsRecursiveStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ModuledForwardDeclarationsRecursiveStruct_max_cdr_typesize;
}

size_t ModuledForwardDeclarationsRecursiveStruct::getCdrSerializedSize(
        const ModuledForwardDeclarationsRecursiveStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.var_ModuledRecursiveUnboundedSeqForwardStruct().size(); ++a)
    {
        current_alignment += declarations_module::ModuledForwardStruct::getCdrSerializedSize(data.var_ModuledRecursiveUnboundedSeqForwardStruct().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.var_ModuledRecursiveBoundedSeqForwardStruct().size(); ++a)
    {
        current_alignment += declarations_module::ModuledForwardStruct::getCdrSerializedSize(data.var_ModuledRecursiveBoundedSeqForwardStruct().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.var_ModuledRecursiveUnboundedSeqForwardUnion().size(); ++a)
    {
        current_alignment += declarations_module::ModuledForwardUnion::getCdrSerializedSize(data.var_ModuledRecursiveUnboundedSeqForwardUnion().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.var_ModuledRecursiveBoundedSeqForwardUnion().size(); ++a)
    {
        current_alignment += declarations_module::ModuledForwardUnion::getCdrSerializedSize(data.var_ModuledRecursiveBoundedSeqForwardUnion().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void ModuledForwardDeclarationsRecursiveStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ModuledRecursiveUnboundedSeqForwardStruct;
    scdr << m_var_ModuledRecursiveBoundedSeqForwardStruct;
    scdr << m_var_ModuledRecursiveUnboundedSeqForwardUnion;
    scdr << m_var_ModuledRecursiveBoundedSeqForwardUnion;
}

void ModuledForwardDeclarationsRecursiveStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ModuledRecursiveUnboundedSeqForwardStruct;
    dcdr >> m_var_ModuledRecursiveBoundedSeqForwardStruct;
    dcdr >> m_var_ModuledRecursiveUnboundedSeqForwardUnion;
    dcdr >> m_var_ModuledRecursiveBoundedSeqForwardUnion;
}

/*!
 * @brief This function copies the value in member var_ModuledRecursiveUnboundedSeqForwardStruct
 * @param _var_ModuledRecursiveUnboundedSeqForwardStruct New value to be copied in member var_ModuledRecursiveUnboundedSeqForwardStruct
 */
void ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveUnboundedSeqForwardStruct(
        const declarations_module::ModuledRecursiveUnboundedSeqForwardStruct& _var_ModuledRecursiveUnboundedSeqForwardStruct)
{
    m_var_ModuledRecursiveUnboundedSeqForwardStruct = _var_ModuledRecursiveUnboundedSeqForwardStruct;
}

/*!
 * @brief This function moves the value in member var_ModuledRecursiveUnboundedSeqForwardStruct
 * @param _var_ModuledRecursiveUnboundedSeqForwardStruct New value to be moved in member var_ModuledRecursiveUnboundedSeqForwardStruct
 */
void ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveUnboundedSeqForwardStruct(
        declarations_module::ModuledRecursiveUnboundedSeqForwardStruct&& _var_ModuledRecursiveUnboundedSeqForwardStruct)
{
    m_var_ModuledRecursiveUnboundedSeqForwardStruct = std::move(_var_ModuledRecursiveUnboundedSeqForwardStruct);
}

/*!
 * @brief This function returns a constant reference to member var_ModuledRecursiveUnboundedSeqForwardStruct
 * @return Constant reference to member var_ModuledRecursiveUnboundedSeqForwardStruct
 */
const declarations_module::ModuledRecursiveUnboundedSeqForwardStruct& ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveUnboundedSeqForwardStruct() const
{
    return m_var_ModuledRecursiveUnboundedSeqForwardStruct;
}

/*!
 * @brief This function returns a reference to member var_ModuledRecursiveUnboundedSeqForwardStruct
 * @return Reference to member var_ModuledRecursiveUnboundedSeqForwardStruct
 */
declarations_module::ModuledRecursiveUnboundedSeqForwardStruct& ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveUnboundedSeqForwardStruct()
{
    return m_var_ModuledRecursiveUnboundedSeqForwardStruct;
}
/*!
 * @brief This function copies the value in member var_ModuledRecursiveBoundedSeqForwardStruct
 * @param _var_ModuledRecursiveBoundedSeqForwardStruct New value to be copied in member var_ModuledRecursiveBoundedSeqForwardStruct
 */
void ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveBoundedSeqForwardStruct(
        const declarations_module::ModuledRecursiveBoundedSeqForwardStruct& _var_ModuledRecursiveBoundedSeqForwardStruct)
{
    m_var_ModuledRecursiveBoundedSeqForwardStruct = _var_ModuledRecursiveBoundedSeqForwardStruct;
}

/*!
 * @brief This function moves the value in member var_ModuledRecursiveBoundedSeqForwardStruct
 * @param _var_ModuledRecursiveBoundedSeqForwardStruct New value to be moved in member var_ModuledRecursiveBoundedSeqForwardStruct
 */
void ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveBoundedSeqForwardStruct(
        declarations_module::ModuledRecursiveBoundedSeqForwardStruct&& _var_ModuledRecursiveBoundedSeqForwardStruct)
{
    m_var_ModuledRecursiveBoundedSeqForwardStruct = std::move(_var_ModuledRecursiveBoundedSeqForwardStruct);
}

/*!
 * @brief This function returns a constant reference to member var_ModuledRecursiveBoundedSeqForwardStruct
 * @return Constant reference to member var_ModuledRecursiveBoundedSeqForwardStruct
 */
const declarations_module::ModuledRecursiveBoundedSeqForwardStruct& ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveBoundedSeqForwardStruct() const
{
    return m_var_ModuledRecursiveBoundedSeqForwardStruct;
}

/*!
 * @brief This function returns a reference to member var_ModuledRecursiveBoundedSeqForwardStruct
 * @return Reference to member var_ModuledRecursiveBoundedSeqForwardStruct
 */
declarations_module::ModuledRecursiveBoundedSeqForwardStruct& ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveBoundedSeqForwardStruct()
{
    return m_var_ModuledRecursiveBoundedSeqForwardStruct;
}
/*!
 * @brief This function copies the value in member var_ModuledRecursiveUnboundedSeqForwardUnion
 * @param _var_ModuledRecursiveUnboundedSeqForwardUnion New value to be copied in member var_ModuledRecursiveUnboundedSeqForwardUnion
 */
void ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveUnboundedSeqForwardUnion(
        const declarations_module::ModuledRecursiveUnboundedSeqForwardUnion& _var_ModuledRecursiveUnboundedSeqForwardUnion)
{
    m_var_ModuledRecursiveUnboundedSeqForwardUnion = _var_ModuledRecursiveUnboundedSeqForwardUnion;
}

/*!
 * @brief This function moves the value in member var_ModuledRecursiveUnboundedSeqForwardUnion
 * @param _var_ModuledRecursiveUnboundedSeqForwardUnion New value to be moved in member var_ModuledRecursiveUnboundedSeqForwardUnion
 */
void ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveUnboundedSeqForwardUnion(
        declarations_module::ModuledRecursiveUnboundedSeqForwardUnion&& _var_ModuledRecursiveUnboundedSeqForwardUnion)
{
    m_var_ModuledRecursiveUnboundedSeqForwardUnion = std::move(_var_ModuledRecursiveUnboundedSeqForwardUnion);
}

/*!
 * @brief This function returns a constant reference to member var_ModuledRecursiveUnboundedSeqForwardUnion
 * @return Constant reference to member var_ModuledRecursiveUnboundedSeqForwardUnion
 */
const declarations_module::ModuledRecursiveUnboundedSeqForwardUnion& ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveUnboundedSeqForwardUnion() const
{
    return m_var_ModuledRecursiveUnboundedSeqForwardUnion;
}

/*!
 * @brief This function returns a reference to member var_ModuledRecursiveUnboundedSeqForwardUnion
 * @return Reference to member var_ModuledRecursiveUnboundedSeqForwardUnion
 */
declarations_module::ModuledRecursiveUnboundedSeqForwardUnion& ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveUnboundedSeqForwardUnion()
{
    return m_var_ModuledRecursiveUnboundedSeqForwardUnion;
}
/*!
 * @brief This function copies the value in member var_ModuledRecursiveBoundedSeqForwardUnion
 * @param _var_ModuledRecursiveBoundedSeqForwardUnion New value to be copied in member var_ModuledRecursiveBoundedSeqForwardUnion
 */
void ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveBoundedSeqForwardUnion(
        const declarations_module::ModuledRecursiveBoundedSeqForwardUnion& _var_ModuledRecursiveBoundedSeqForwardUnion)
{
    m_var_ModuledRecursiveBoundedSeqForwardUnion = _var_ModuledRecursiveBoundedSeqForwardUnion;
}

/*!
 * @brief This function moves the value in member var_ModuledRecursiveBoundedSeqForwardUnion
 * @param _var_ModuledRecursiveBoundedSeqForwardUnion New value to be moved in member var_ModuledRecursiveBoundedSeqForwardUnion
 */
void ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveBoundedSeqForwardUnion(
        declarations_module::ModuledRecursiveBoundedSeqForwardUnion&& _var_ModuledRecursiveBoundedSeqForwardUnion)
{
    m_var_ModuledRecursiveBoundedSeqForwardUnion = std::move(_var_ModuledRecursiveBoundedSeqForwardUnion);
}

/*!
 * @brief This function returns a constant reference to member var_ModuledRecursiveBoundedSeqForwardUnion
 * @return Constant reference to member var_ModuledRecursiveBoundedSeqForwardUnion
 */
const declarations_module::ModuledRecursiveBoundedSeqForwardUnion& ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveBoundedSeqForwardUnion() const
{
    return m_var_ModuledRecursiveBoundedSeqForwardUnion;
}

/*!
 * @brief This function returns a reference to member var_ModuledRecursiveBoundedSeqForwardUnion
 * @return Reference to member var_ModuledRecursiveBoundedSeqForwardUnion
 */
declarations_module::ModuledRecursiveBoundedSeqForwardUnion& ModuledForwardDeclarationsRecursiveStruct::var_ModuledRecursiveBoundedSeqForwardUnion()
{
    return m_var_ModuledRecursiveBoundedSeqForwardUnion;
}


size_t ModuledForwardDeclarationsRecursiveStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ModuledForwardDeclarationsRecursiveStruct_max_key_cdr_typesize;
}

bool ModuledForwardDeclarationsRecursiveStruct::isKeyDefined()
{
    return false;
}

void ModuledForwardDeclarationsRecursiveStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


declarations_module::ModuledForwardStruct::ModuledForwardStruct()
{
    // short m_var_short
    m_var_short = 0;
    // long m_var_long
    m_var_long = 0;

    // Just to register all known types
    registerdeclarationsTypes();
}

declarations_module::ModuledForwardStruct::~ModuledForwardStruct()
{


}

declarations_module::ModuledForwardStruct::ModuledForwardStruct(
        const ModuledForwardStruct& x)
{
    m_var_short = x.m_var_short;
    m_var_long = x.m_var_long;
}

declarations_module::ModuledForwardStruct::ModuledForwardStruct(
        ModuledForwardStruct&& x) noexcept 
{
    m_var_short = x.m_var_short;
    m_var_long = x.m_var_long;
}

declarations_module::ModuledForwardStruct& declarations_module::ModuledForwardStruct::operator =(
        const ModuledForwardStruct& x)
{

    m_var_short = x.m_var_short;
    m_var_long = x.m_var_long;

    return *this;
}

declarations_module::ModuledForwardStruct& declarations_module::ModuledForwardStruct::operator =(
        ModuledForwardStruct&& x) noexcept
{

    m_var_short = x.m_var_short;
    m_var_long = x.m_var_long;

    return *this;
}

bool declarations_module::ModuledForwardStruct::operator ==(
        const ModuledForwardStruct& x) const
{

    return (m_var_short == x.m_var_short && m_var_long == x.m_var_long);
}

bool declarations_module::ModuledForwardStruct::operator !=(
        const ModuledForwardStruct& x) const
{
    return !(*this == x);
}

size_t declarations_module::ModuledForwardStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return declarations_module_ModuledForwardStruct_max_cdr_typesize;
}

size_t declarations_module::ModuledForwardStruct::getCdrSerializedSize(
        const declarations_module::ModuledForwardStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void declarations_module::ModuledForwardStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_short;scdr << m_var_long;
}

void declarations_module::ModuledForwardStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_short;
    dcdr >> m_var_long;
}

/*!
 * @brief This function sets a value in member var_short
 * @param _var_short New value for member var_short
 */
void declarations_module::ModuledForwardStruct::var_short(
        int16_t _var_short)
{
    m_var_short = _var_short;
}

/*!
 * @brief This function returns the value of member var_short
 * @return Value of member var_short
 */
int16_t declarations_module::ModuledForwardStruct::var_short() const
{
    return m_var_short;
}

/*!
 * @brief This function returns a reference to member var_short
 * @return Reference to member var_short
 */
int16_t& declarations_module::ModuledForwardStruct::var_short()
{
    return m_var_short;
}

/*!
 * @brief This function sets a value in member var_long
 * @param _var_long New value for member var_long
 */
void declarations_module::ModuledForwardStruct::var_long(
        int32_t _var_long)
{
    m_var_long = _var_long;
}

/*!
 * @brief This function returns the value of member var_long
 * @return Value of member var_long
 */
int32_t declarations_module::ModuledForwardStruct::var_long() const
{
    return m_var_long;
}

/*!
 * @brief This function returns a reference to member var_long
 * @return Reference to member var_long
 */
int32_t& declarations_module::ModuledForwardStruct::var_long()
{
    return m_var_long;
}



size_t declarations_module::ModuledForwardStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return declarations_module_ModuledForwardStruct_max_key_cdr_typesize;
}

bool declarations_module::ModuledForwardStruct::isKeyDefined()
{
    return false;
}

void declarations_module::ModuledForwardStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


declarations_module::ModuledForwardUnion::ModuledForwardUnion()
{
    m__d = 0;
    // long m_case_zero
    m_case_zero = 0;
    // long m_case_one
    m_case_one = 0;
}

declarations_module::ModuledForwardUnion::~ModuledForwardUnion()
{
}

declarations_module::ModuledForwardUnion::ModuledForwardUnion(
        const ModuledForwardUnion& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_case_zero = x.m_case_zero;
        break;
        case 1:
        m_case_one = x.m_case_one;
        break;
        default:
        break;
    }
}

declarations_module::ModuledForwardUnion::ModuledForwardUnion(
        ModuledForwardUnion&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_case_zero = x.m_case_zero;
        break;
        case 1:
        m_case_one = x.m_case_one;
        break;
        default:
        break;
    }
}

declarations_module::ModuledForwardUnion& declarations_module::ModuledForwardUnion::operator =(
        const ModuledForwardUnion& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_case_zero = x.m_case_zero;
        break;
        case 1:
        m_case_one = x.m_case_one;
        break;
        default:
        break;
    }

    return *this;
}

declarations_module::ModuledForwardUnion& declarations_module::ModuledForwardUnion::operator =(
        ModuledForwardUnion&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_case_zero = x.m_case_zero;
        break;
        case 1:
        m_case_one = x.m_case_one;
        break;
        default:
        break;
    }

    return *this;
}

bool declarations_module::ModuledForwardUnion::operator ==(
        const ModuledForwardUnion& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 0:
            return (m_case_zero == x.m_case_zero);
            break;
        case 1:
            return (m_case_one == x.m_case_one);
            break;
        default:
        break;
    }
    return false;
}

bool declarations_module::ModuledForwardUnion::operator !=(
        const ModuledForwardUnion& x) const
{
    return !(*this == x);
}

void declarations_module::ModuledForwardUnion::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        switch(__d)
        {
            case 0:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t declarations_module::ModuledForwardUnion::_d() const
{
    return m__d;
}

int32_t& declarations_module::ModuledForwardUnion::_d()
{
    return m__d;
}

void declarations_module::ModuledForwardUnion::case_zero(
        int32_t _case_zero)
{
    m_case_zero = _case_zero;
    m__d = 0;
}

int32_t declarations_module::ModuledForwardUnion::case_zero() const
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_case_zero;
}

int32_t& declarations_module::ModuledForwardUnion::case_zero()
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_case_zero;
}
void declarations_module::ModuledForwardUnion::case_one(
        int32_t _case_one)
{
    m_case_one = _case_one;
    m__d = 1;
}

int32_t declarations_module::ModuledForwardUnion::case_one() const
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_case_one;
}

int32_t& declarations_module::ModuledForwardUnion::case_one()
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_case_one;
}

// TODO(Ricardo) Review
size_t declarations_module::ModuledForwardUnion::getCdrSerializedSize(
        const declarations_module::ModuledForwardUnion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 0:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 1:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void declarations_module::ModuledForwardUnion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 0:
        scdr << m_case_zero;
        break;
        case 1:
        scdr << m_case_one;
        break;
        default:
        break;
    }
}

void declarations_module::ModuledForwardUnion::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 0:
        dcdr >> m_case_zero;
        break;
        case 1:
        dcdr >> m_case_one;
        break;
        default:
        break;
    }
}


