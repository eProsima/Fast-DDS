// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file declarationsTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "declarations.h"
#include "declarationsTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

void registerdeclarationsTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("ForwardStruct", GetForwardStructIdentifier(true),
                GetForwardStructObject(true));
                factory->add_type_object("ForwardStruct", GetForwardStructIdentifier(false),
                GetForwardStructObject(false));

                factory->add_type_object("ForwardUnion", GetForwardUnionIdentifier(true),
                GetForwardUnionObject(true));
                factory->add_type_object("ForwardUnion", GetForwardUnionIdentifier(false),
                GetForwardUnionObject(false));

                factory->add_type_object("RecursiveUnboundedSeqForwardStruct", GetRecursiveUnboundedSeqForwardStructIdentifier(true),
                GetRecursiveUnboundedSeqForwardStructObject(true));
                factory->add_type_object("RecursiveUnboundedSeqForwardStruct", GetRecursiveUnboundedSeqForwardStructIdentifier(false),
                GetRecursiveUnboundedSeqForwardStructObject(false));

                factory->add_type_object("RecursiveBoundedSeqForwardStruct", GetRecursiveBoundedSeqForwardStructIdentifier(true),
                GetRecursiveBoundedSeqForwardStructObject(true));
                factory->add_type_object("RecursiveBoundedSeqForwardStruct", GetRecursiveBoundedSeqForwardStructIdentifier(false),
                GetRecursiveBoundedSeqForwardStructObject(false));

                factory->add_type_object("RecursiveUnboundedSeqForwardUnion", GetRecursiveUnboundedSeqForwardUnionIdentifier(true),
                GetRecursiveUnboundedSeqForwardUnionObject(true));
                factory->add_type_object("RecursiveUnboundedSeqForwardUnion", GetRecursiveUnboundedSeqForwardUnionIdentifier(false),
                GetRecursiveUnboundedSeqForwardUnionObject(false));

                factory->add_type_object("RecursiveBoundedSeqForwardUnion", GetRecursiveBoundedSeqForwardUnionIdentifier(true),
                GetRecursiveBoundedSeqForwardUnionObject(true));
                factory->add_type_object("RecursiveBoundedSeqForwardUnion", GetRecursiveBoundedSeqForwardUnionIdentifier(false),
                GetRecursiveBoundedSeqForwardUnionObject(false));

                factory->add_type_object("ForwardDeclarationsStruct", GetForwardDeclarationsStructIdentifier(true),
                GetForwardDeclarationsStructObject(true));
                factory->add_type_object("ForwardDeclarationsStruct", GetForwardDeclarationsStructIdentifier(false),
                GetForwardDeclarationsStructObject(false));

                factory->add_type_object("ForwardDeclarationsRecursiveStruct", GetForwardDeclarationsRecursiveStructIdentifier(true),
                GetForwardDeclarationsRecursiveStructObject(true));
                factory->add_type_object("ForwardDeclarationsRecursiveStruct", GetForwardDeclarationsRecursiveStructIdentifier(false),
                GetForwardDeclarationsRecursiveStructObject(false));

                factory->add_type_object("ForwardUnion", GetForwardUnionIdentifier(true),
                GetForwardUnionObject(true));
                factory->add_type_object("ForwardUnion", GetForwardUnionIdentifier(false),
                GetForwardUnionObject(false));

                factory->add_type_object("ForwardStruct", GetForwardStructIdentifier(true),
                GetForwardStructObject(true));
                factory->add_type_object("ForwardStruct", GetForwardStructIdentifier(false),
                GetForwardStructObject(false));

                factory->add_type_object("declarations_module::ModuledForwardStruct", declarations_module::GetModuledForwardStructIdentifier(true),
                        declarations_module::GetModuledForwardStructObject(true));
                factory->add_type_object("declarations_module::ModuledForwardStruct", declarations_module::GetModuledForwardStructIdentifier(false),
                        declarations_module::GetModuledForwardStructObject(false));

                factory->add_type_object("declarations_module::ModuledForwardUnion", declarations_module::GetModuledForwardUnionIdentifier(true),
                        declarations_module::GetModuledForwardUnionObject(true));
                factory->add_type_object("declarations_module::ModuledForwardUnion", declarations_module::GetModuledForwardUnionIdentifier(false),
                        declarations_module::GetModuledForwardUnionObject(false));

                factory->add_type_object("declarations_module::ModuledRecursiveUnboundedSeqForwardStruct", declarations_module::GetModuledRecursiveUnboundedSeqForwardStructIdentifier(true),
                        declarations_module::GetModuledRecursiveUnboundedSeqForwardStructObject(true));
                factory->add_type_object("declarations_module::ModuledRecursiveUnboundedSeqForwardStruct", declarations_module::GetModuledRecursiveUnboundedSeqForwardStructIdentifier(false),
                        declarations_module::GetModuledRecursiveUnboundedSeqForwardStructObject(false));

                factory->add_type_object("declarations_module::ModuledRecursiveBoundedSeqForwardStruct", declarations_module::GetModuledRecursiveBoundedSeqForwardStructIdentifier(true),
                        declarations_module::GetModuledRecursiveBoundedSeqForwardStructObject(true));
                factory->add_type_object("declarations_module::ModuledRecursiveBoundedSeqForwardStruct", declarations_module::GetModuledRecursiveBoundedSeqForwardStructIdentifier(false),
                        declarations_module::GetModuledRecursiveBoundedSeqForwardStructObject(false));

                factory->add_type_object("declarations_module::ModuledRecursiveUnboundedSeqForwardUnion", declarations_module::GetModuledRecursiveUnboundedSeqForwardUnionIdentifier(true),
                        declarations_module::GetModuledRecursiveUnboundedSeqForwardUnionObject(true));
                factory->add_type_object("declarations_module::ModuledRecursiveUnboundedSeqForwardUnion", declarations_module::GetModuledRecursiveUnboundedSeqForwardUnionIdentifier(false),
                        declarations_module::GetModuledRecursiveUnboundedSeqForwardUnionObject(false));

                factory->add_type_object("declarations_module::ModuledRecursiveBoundedSeqForwardUnion", declarations_module::GetModuledRecursiveBoundedSeqForwardUnionIdentifier(true),
                        declarations_module::GetModuledRecursiveBoundedSeqForwardUnionObject(true));
                factory->add_type_object("declarations_module::ModuledRecursiveBoundedSeqForwardUnion", declarations_module::GetModuledRecursiveBoundedSeqForwardUnionIdentifier(false),
                        declarations_module::GetModuledRecursiveBoundedSeqForwardUnionObject(false));


                factory->add_type_object("ModuledForwardDeclarationsStruct", GetModuledForwardDeclarationsStructIdentifier(true),
                GetModuledForwardDeclarationsStructObject(true));
                factory->add_type_object("ModuledForwardDeclarationsStruct", GetModuledForwardDeclarationsStructIdentifier(false),
                GetModuledForwardDeclarationsStructObject(false));

                factory->add_type_object("ModuledForwardDeclarationsRecursiveStruct", GetModuledForwardDeclarationsRecursiveStructIdentifier(true),
                GetModuledForwardDeclarationsRecursiveStructObject(true));
                factory->add_type_object("ModuledForwardDeclarationsRecursiveStruct", GetModuledForwardDeclarationsRecursiveStructIdentifier(false),
                GetModuledForwardDeclarationsRecursiveStructObject(false));

                factory->add_type_object("declarations_module::ModuledForwardStruct", declarations_module::GetModuledForwardStructIdentifier(true),
                        declarations_module::GetModuledForwardStructObject(true));
                factory->add_type_object("declarations_module::ModuledForwardStruct", declarations_module::GetModuledForwardStructIdentifier(false),
                        declarations_module::GetModuledForwardStructObject(false));

                factory->add_type_object("declarations_module::ModuledForwardUnion", declarations_module::GetModuledForwardUnionIdentifier(true),
                        declarations_module::GetModuledForwardUnionObject(true));
                factory->add_type_object("declarations_module::ModuledForwardUnion", declarations_module::GetModuledForwardUnionIdentifier(false),
                        declarations_module::GetModuledForwardUnionObject(false));


            });
}

class ForwardStruct;

class ForwardUnion;

const TypeIdentifier* GetRecursiveUnboundedSeqForwardStructIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("RecursiveUnboundedSeqForwardStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetRecursiveUnboundedSeqForwardStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("RecursiveUnboundedSeqForwardStruct", complete);
}

const TypeObject* GetRecursiveUnboundedSeqForwardStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RecursiveUnboundedSeqForwardStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteRecursiveUnboundedSeqForwardStructObject();
    }
    else
    {
        return GetMinimalRecursiveUnboundedSeqForwardStructObject();
    }
}

const TypeObject* GetMinimalRecursiveUnboundedSeqForwardStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RecursiveUnboundedSeqForwardStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_sequence_type_name("ForwardStruct", 100), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("RecursiveUnboundedSeqForwardStruct", TypeNamesGenerator::get_sequence_type_name("ForwardStruct", 100));

    TypeObjectFactory::get_instance()->add_type_object("RecursiveUnboundedSeqForwardStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("RecursiveUnboundedSeqForwardStruct", false);
}

const TypeObject* GetCompleteRecursiveUnboundedSeqForwardStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RecursiveUnboundedSeqForwardStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("RecursiveUnboundedSeqForwardStruct");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_sequence_type_name("ForwardStruct", 100));


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("RecursiveUnboundedSeqForwardStruct", TypeNamesGenerator::get_sequence_type_name("ForwardStruct", 100));

    TypeObjectFactory::get_instance()->add_type_object("RecursiveUnboundedSeqForwardStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("RecursiveUnboundedSeqForwardStruct", true);
}

const TypeIdentifier* GetRecursiveBoundedSeqForwardStructIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("RecursiveBoundedSeqForwardStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetRecursiveBoundedSeqForwardStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("RecursiveBoundedSeqForwardStruct", complete);
}

const TypeObject* GetRecursiveBoundedSeqForwardStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RecursiveBoundedSeqForwardStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteRecursiveBoundedSeqForwardStructObject();
    }
    else
    {
        return GetMinimalRecursiveBoundedSeqForwardStructObject();
    }
}

const TypeObject* GetMinimalRecursiveBoundedSeqForwardStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RecursiveBoundedSeqForwardStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_sequence_type_name("ForwardStruct", 10), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("RecursiveBoundedSeqForwardStruct", TypeNamesGenerator::get_sequence_type_name("ForwardStruct", 10));

    TypeObjectFactory::get_instance()->add_type_object("RecursiveBoundedSeqForwardStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("RecursiveBoundedSeqForwardStruct", false);
}

const TypeObject* GetCompleteRecursiveBoundedSeqForwardStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RecursiveBoundedSeqForwardStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("RecursiveBoundedSeqForwardStruct");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_sequence_type_name("ForwardStruct", 10));


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("RecursiveBoundedSeqForwardStruct", TypeNamesGenerator::get_sequence_type_name("ForwardStruct", 10));

    TypeObjectFactory::get_instance()->add_type_object("RecursiveBoundedSeqForwardStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("RecursiveBoundedSeqForwardStruct", true);
}

const TypeIdentifier* GetRecursiveUnboundedSeqForwardUnionIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("RecursiveUnboundedSeqForwardUnion", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetRecursiveUnboundedSeqForwardUnionObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("RecursiveUnboundedSeqForwardUnion", complete);
}

const TypeObject* GetRecursiveUnboundedSeqForwardUnionObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RecursiveUnboundedSeqForwardUnion", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteRecursiveUnboundedSeqForwardUnionObject();
    }
    else
    {
        return GetMinimalRecursiveUnboundedSeqForwardUnionObject();
    }
}

const TypeObject* GetMinimalRecursiveUnboundedSeqForwardUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RecursiveUnboundedSeqForwardUnion", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_sequence_type_name("ForwardUnion", 100), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("RecursiveUnboundedSeqForwardUnion", TypeNamesGenerator::get_sequence_type_name("ForwardUnion", 100));

    TypeObjectFactory::get_instance()->add_type_object("RecursiveUnboundedSeqForwardUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("RecursiveUnboundedSeqForwardUnion", false);
}

const TypeObject* GetCompleteRecursiveUnboundedSeqForwardUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RecursiveUnboundedSeqForwardUnion", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("RecursiveUnboundedSeqForwardUnion");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_sequence_type_name("ForwardUnion", 100));


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("RecursiveUnboundedSeqForwardUnion", TypeNamesGenerator::get_sequence_type_name("ForwardUnion", 100));

    TypeObjectFactory::get_instance()->add_type_object("RecursiveUnboundedSeqForwardUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("RecursiveUnboundedSeqForwardUnion", true);
}

const TypeIdentifier* GetRecursiveBoundedSeqForwardUnionIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("RecursiveBoundedSeqForwardUnion", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetRecursiveBoundedSeqForwardUnionObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("RecursiveBoundedSeqForwardUnion", complete);
}

const TypeObject* GetRecursiveBoundedSeqForwardUnionObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RecursiveBoundedSeqForwardUnion", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteRecursiveBoundedSeqForwardUnionObject();
    }
    else
    {
        return GetMinimalRecursiveBoundedSeqForwardUnionObject();
    }
}

const TypeObject* GetMinimalRecursiveBoundedSeqForwardUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RecursiveBoundedSeqForwardUnion", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_sequence_type_name("ForwardUnion", 10), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("RecursiveBoundedSeqForwardUnion", TypeNamesGenerator::get_sequence_type_name("ForwardUnion", 10));

    TypeObjectFactory::get_instance()->add_type_object("RecursiveBoundedSeqForwardUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("RecursiveBoundedSeqForwardUnion", false);
}

const TypeObject* GetCompleteRecursiveBoundedSeqForwardUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RecursiveBoundedSeqForwardUnion", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("RecursiveBoundedSeqForwardUnion");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_sequence_type_name("ForwardUnion", 10));


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("RecursiveBoundedSeqForwardUnion", TypeNamesGenerator::get_sequence_type_name("ForwardUnion", 10));

    TypeObjectFactory::get_instance()->add_type_object("RecursiveBoundedSeqForwardUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("RecursiveBoundedSeqForwardUnion", true);
}

const TypeIdentifier* GetForwardDeclarationsStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ForwardDeclarationsStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetForwardDeclarationsStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ForwardDeclarationsStruct", complete);
}

const TypeObject* GetForwardDeclarationsStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ForwardDeclarationsStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteForwardDeclarationsStructObject();
    }
    //else
    return GetMinimalForwardDeclarationsStructObject();
}

const TypeObject* GetMinimalForwardDeclarationsStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ForwardDeclarationsStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ForwardStruct;
    mst_var_ForwardStruct.common().member_id(memberId++);
    mst_var_ForwardStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ForwardStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ForwardStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ForwardStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_ForwardStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ForwardStruct.common().member_flags().IS_KEY(false);
    mst_var_ForwardStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ForwardStruct.common().member_type_id(*GetForwardStructIdentifier(false));
    MD5 var_ForwardStruct_hash("var_ForwardStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ForwardStruct.detail().name_hash()[i] = var_ForwardStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ForwardStruct);

    MinimalStructMember mst_var_ForwardUnion;
    mst_var_ForwardUnion.common().member_id(memberId++);
    mst_var_ForwardUnion.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ForwardUnion.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ForwardUnion.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ForwardUnion.common().member_flags().IS_OPTIONAL(false);
    mst_var_ForwardUnion.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ForwardUnion.common().member_flags().IS_KEY(false);
    mst_var_ForwardUnion.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ForwardUnion.common().member_type_id(*GetForwardUnionIdentifier(false));
    MD5 var_ForwardUnion_hash("var_ForwardUnion");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ForwardUnion.detail().name_hash()[i] = var_ForwardUnion_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ForwardUnion);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ForwardDeclarationsStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ForwardDeclarationsStruct", false);
}

const TypeObject* GetCompleteForwardDeclarationsStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ForwardDeclarationsStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ForwardStruct;
    cst_var_ForwardStruct.common().member_id(memberId++);
    cst_var_ForwardStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ForwardStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ForwardStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ForwardStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_ForwardStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ForwardStruct.common().member_flags().IS_KEY(false);
    cst_var_ForwardStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ForwardStruct.common().member_type_id(*GetForwardStructIdentifier(true));
    cst_var_ForwardStruct.detail().name("var_ForwardStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ForwardStruct);

    CompleteStructMember cst_var_ForwardUnion;
    cst_var_ForwardUnion.common().member_id(memberId++);
    cst_var_ForwardUnion.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ForwardUnion.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ForwardUnion.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ForwardUnion.common().member_flags().IS_OPTIONAL(false);
    cst_var_ForwardUnion.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ForwardUnion.common().member_flags().IS_KEY(false);
    cst_var_ForwardUnion.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ForwardUnion.common().member_type_id(*GetForwardUnionIdentifier(true));
    cst_var_ForwardUnion.detail().name("var_ForwardUnion");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ForwardUnion);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ForwardDeclarationsStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ForwardDeclarationsStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ForwardDeclarationsStruct", true);
}

const TypeIdentifier* GetForwardDeclarationsRecursiveStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ForwardDeclarationsRecursiveStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetForwardDeclarationsRecursiveStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ForwardDeclarationsRecursiveStruct", complete);
}

const TypeObject* GetForwardDeclarationsRecursiveStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ForwardDeclarationsRecursiveStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteForwardDeclarationsRecursiveStructObject();
    }
    //else
    return GetMinimalForwardDeclarationsRecursiveStructObject();
}

const TypeObject* GetMinimalForwardDeclarationsRecursiveStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ForwardDeclarationsRecursiveStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_RecursiveUnboundedSeqForwardStruct;
    mst_var_RecursiveUnboundedSeqForwardStruct.common().member_id(memberId++);
    mst_var_RecursiveUnboundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_RecursiveUnboundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_RecursiveUnboundedSeqForwardStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_RecursiveUnboundedSeqForwardStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_RecursiveUnboundedSeqForwardStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_RecursiveUnboundedSeqForwardStruct.common().member_flags().IS_KEY(false);
    mst_var_RecursiveUnboundedSeqForwardStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_RecursiveUnboundedSeqForwardStruct.common().member_type_id(*GetRecursiveUnboundedSeqForwardStructIdentifier(false));
    MD5 var_RecursiveUnboundedSeqForwardStruct_hash("var_RecursiveUnboundedSeqForwardStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_RecursiveUnboundedSeqForwardStruct.detail().name_hash()[i] = var_RecursiveUnboundedSeqForwardStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_RecursiveUnboundedSeqForwardStruct);

    MinimalStructMember mst_var_RecursiveBoundedSeqForwardStruct;
    mst_var_RecursiveBoundedSeqForwardStruct.common().member_id(memberId++);
    mst_var_RecursiveBoundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_RecursiveBoundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_RecursiveBoundedSeqForwardStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_RecursiveBoundedSeqForwardStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_RecursiveBoundedSeqForwardStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_RecursiveBoundedSeqForwardStruct.common().member_flags().IS_KEY(false);
    mst_var_RecursiveBoundedSeqForwardStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_RecursiveBoundedSeqForwardStruct.common().member_type_id(*GetRecursiveBoundedSeqForwardStructIdentifier(false));
    MD5 var_RecursiveBoundedSeqForwardStruct_hash("var_RecursiveBoundedSeqForwardStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_RecursiveBoundedSeqForwardStruct.detail().name_hash()[i] = var_RecursiveBoundedSeqForwardStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_RecursiveBoundedSeqForwardStruct);

    MinimalStructMember mst_var_RecursiveUnboundedSeqForwardUnion;
    mst_var_RecursiveUnboundedSeqForwardUnion.common().member_id(memberId++);
    mst_var_RecursiveUnboundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_RecursiveUnboundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_RecursiveUnboundedSeqForwardUnion.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_RecursiveUnboundedSeqForwardUnion.common().member_flags().IS_OPTIONAL(false);
    mst_var_RecursiveUnboundedSeqForwardUnion.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_RecursiveUnboundedSeqForwardUnion.common().member_flags().IS_KEY(false);
    mst_var_RecursiveUnboundedSeqForwardUnion.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_RecursiveUnboundedSeqForwardUnion.common().member_type_id(*GetRecursiveUnboundedSeqForwardUnionIdentifier(false));
    MD5 var_RecursiveUnboundedSeqForwardUnion_hash("var_RecursiveUnboundedSeqForwardUnion");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_RecursiveUnboundedSeqForwardUnion.detail().name_hash()[i] = var_RecursiveUnboundedSeqForwardUnion_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_RecursiveUnboundedSeqForwardUnion);

    MinimalStructMember mst_var_RecursiveBoundedSeqForwardUnion;
    mst_var_RecursiveBoundedSeqForwardUnion.common().member_id(memberId++);
    mst_var_RecursiveBoundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_RecursiveBoundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_RecursiveBoundedSeqForwardUnion.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_RecursiveBoundedSeqForwardUnion.common().member_flags().IS_OPTIONAL(false);
    mst_var_RecursiveBoundedSeqForwardUnion.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_RecursiveBoundedSeqForwardUnion.common().member_flags().IS_KEY(false);
    mst_var_RecursiveBoundedSeqForwardUnion.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_RecursiveBoundedSeqForwardUnion.common().member_type_id(*GetRecursiveBoundedSeqForwardUnionIdentifier(false));
    MD5 var_RecursiveBoundedSeqForwardUnion_hash("var_RecursiveBoundedSeqForwardUnion");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_RecursiveBoundedSeqForwardUnion.detail().name_hash()[i] = var_RecursiveBoundedSeqForwardUnion_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_RecursiveBoundedSeqForwardUnion);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ForwardDeclarationsRecursiveStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ForwardDeclarationsRecursiveStruct", false);
}

const TypeObject* GetCompleteForwardDeclarationsRecursiveStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ForwardDeclarationsRecursiveStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_RecursiveUnboundedSeqForwardStruct;
    cst_var_RecursiveUnboundedSeqForwardStruct.common().member_id(memberId++);
    cst_var_RecursiveUnboundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_RecursiveUnboundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_RecursiveUnboundedSeqForwardStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_RecursiveUnboundedSeqForwardStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_RecursiveUnboundedSeqForwardStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_RecursiveUnboundedSeqForwardStruct.common().member_flags().IS_KEY(false);
    cst_var_RecursiveUnboundedSeqForwardStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_RecursiveUnboundedSeqForwardStruct.common().member_type_id(*GetRecursiveUnboundedSeqForwardStructIdentifier(true));
    cst_var_RecursiveUnboundedSeqForwardStruct.detail().name("var_RecursiveUnboundedSeqForwardStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_RecursiveUnboundedSeqForwardStruct);

    CompleteStructMember cst_var_RecursiveBoundedSeqForwardStruct;
    cst_var_RecursiveBoundedSeqForwardStruct.common().member_id(memberId++);
    cst_var_RecursiveBoundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_RecursiveBoundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_RecursiveBoundedSeqForwardStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_RecursiveBoundedSeqForwardStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_RecursiveBoundedSeqForwardStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_RecursiveBoundedSeqForwardStruct.common().member_flags().IS_KEY(false);
    cst_var_RecursiveBoundedSeqForwardStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_RecursiveBoundedSeqForwardStruct.common().member_type_id(*GetRecursiveBoundedSeqForwardStructIdentifier(true));
    cst_var_RecursiveBoundedSeqForwardStruct.detail().name("var_RecursiveBoundedSeqForwardStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_RecursiveBoundedSeqForwardStruct);

    CompleteStructMember cst_var_RecursiveUnboundedSeqForwardUnion;
    cst_var_RecursiveUnboundedSeqForwardUnion.common().member_id(memberId++);
    cst_var_RecursiveUnboundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_RecursiveUnboundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_RecursiveUnboundedSeqForwardUnion.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_RecursiveUnboundedSeqForwardUnion.common().member_flags().IS_OPTIONAL(false);
    cst_var_RecursiveUnboundedSeqForwardUnion.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_RecursiveUnboundedSeqForwardUnion.common().member_flags().IS_KEY(false);
    cst_var_RecursiveUnboundedSeqForwardUnion.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_RecursiveUnboundedSeqForwardUnion.common().member_type_id(*GetRecursiveUnboundedSeqForwardUnionIdentifier(true));
    cst_var_RecursiveUnboundedSeqForwardUnion.detail().name("var_RecursiveUnboundedSeqForwardUnion");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_RecursiveUnboundedSeqForwardUnion);

    CompleteStructMember cst_var_RecursiveBoundedSeqForwardUnion;
    cst_var_RecursiveBoundedSeqForwardUnion.common().member_id(memberId++);
    cst_var_RecursiveBoundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_RecursiveBoundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_RecursiveBoundedSeqForwardUnion.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_RecursiveBoundedSeqForwardUnion.common().member_flags().IS_OPTIONAL(false);
    cst_var_RecursiveBoundedSeqForwardUnion.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_RecursiveBoundedSeqForwardUnion.common().member_flags().IS_KEY(false);
    cst_var_RecursiveBoundedSeqForwardUnion.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_RecursiveBoundedSeqForwardUnion.common().member_type_id(*GetRecursiveBoundedSeqForwardUnionIdentifier(true));
    cst_var_RecursiveBoundedSeqForwardUnion.detail().name("var_RecursiveBoundedSeqForwardUnion");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_RecursiveBoundedSeqForwardUnion);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ForwardDeclarationsRecursiveStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ForwardDeclarationsRecursiveStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ForwardDeclarationsRecursiveStruct", true);
}

const TypeIdentifier* GetForwardUnionIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ForwardUnion", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetForwardUnionObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("ForwardUnion", complete);
}

const TypeObject* GetForwardUnionObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ForwardUnion", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteForwardUnionObject();
    }
    // else
    return GetMinimalForwardUnionObject();
}

const TypeObject* GetMinimalForwardUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ForwardUnion", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_case_zero;
    mst_case_zero.common().member_id(memberId++);
    mst_case_zero.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_case_zero.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_case_zero.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_case_zero.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_case_zero.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_case_zero.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_case_zero.common().member_flags().IS_DEFAULT(false);
    mst_case_zero.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_case_zero.common().label_seq().emplace_back(0);
    MD5 case_zero_hash("case_zero");
    for(int i = 0; i < 4; ++i)
    {
        mst_case_zero.detail().name_hash()[i] = case_zero_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_case_zero);

    MinimalUnionMember mst_case_one;
    mst_case_one.common().member_id(memberId++);
    mst_case_one.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_case_one.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_case_one.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_case_one.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_case_one.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_case_one.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_case_one.common().member_flags().IS_DEFAULT(false);
    mst_case_one.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_case_one.common().label_seq().emplace_back(1);
    MD5 case_one_hash("case_one");
    for(int i = 0; i < 4; ++i)
    {
        mst_case_one.detail().name_hash()[i] = case_one_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_case_one);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ForwardUnion", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("ForwardUnion", false);
}

const TypeObject* GetCompleteForwardUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ForwardUnion", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_case_zero;
    cst_case_zero.common().member_id(memberId++);
    cst_case_zero.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_case_zero.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_case_zero.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_case_zero.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_case_zero.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_case_zero.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_case_zero.common().member_flags().IS_DEFAULT(false);
    cst_case_zero.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_case_zero.common().label_seq().emplace_back(0);

    cst_case_zero.detail().name("case_zero");

    type_object->complete().union_type().member_seq().emplace_back(cst_case_zero);

    CompleteUnionMember cst_case_one;
    cst_case_one.common().member_id(memberId++);
    cst_case_one.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_case_one.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_case_one.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_case_one.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_case_one.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_case_one.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_case_one.common().member_flags().IS_DEFAULT(false);
    cst_case_one.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_case_one.common().label_seq().emplace_back(1);

    cst_case_one.detail().name("case_one");

    type_object->complete().union_type().member_seq().emplace_back(cst_case_one);


    // Header
    type_object->complete().union_type().header().detail().type_name("ForwardUnion");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ForwardUnion", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("ForwardUnion", true);
}

const TypeIdentifier* GetForwardStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ForwardStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetForwardStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ForwardStruct", complete);
}

const TypeObject* GetForwardStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ForwardStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteForwardStructObject();
    }
    //else
    return GetMinimalForwardStructObject();
}

const TypeObject* GetMinimalForwardStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ForwardStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_short;
    mst_var_short.common().member_id(memberId++);
    mst_var_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_short.common().member_flags().IS_KEY(false);
    mst_var_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    MD5 var_short_hash("var_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_short.detail().name_hash()[i] = var_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_short);

    MinimalStructMember mst_var_long;
    mst_var_long.common().member_id(memberId++);
    mst_var_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_long.common().member_flags().IS_KEY(false);
    mst_var_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MD5 var_long_hash("var_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_long.detail().name_hash()[i] = var_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ForwardStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ForwardStruct", false);
}

const TypeObject* GetCompleteForwardStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ForwardStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_short;
    cst_var_short.common().member_id(memberId++);
    cst_var_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_short.common().member_flags().IS_KEY(false);
    cst_var_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    cst_var_short.detail().name("var_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_short);

    CompleteStructMember cst_var_long;
    cst_var_long.common().member_id(memberId++);
    cst_var_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_long.common().member_flags().IS_KEY(false);
    cst_var_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    cst_var_long.detail().name("var_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ForwardStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ForwardStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ForwardStruct", true);
}

namespace declarations_module {
    class ModuledForwardStruct;

    class ModuledForwardUnion;

    const TypeIdentifier* GetModuledRecursiveUnboundedSeqForwardStructIdentifier(bool complete)
    {
        const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ModuledRecursiveUnboundedSeqForwardStruct", complete);
        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
        {
            return c_identifier;
        }

        GetModuledRecursiveUnboundedSeqForwardStructObject(complete); // Generated inside
        return TypeObjectFactory::get_instance()->get_type_identifier("ModuledRecursiveUnboundedSeqForwardStruct", complete);
    }

    const TypeObject* GetModuledRecursiveUnboundedSeqForwardStructObject(bool complete)
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveUnboundedSeqForwardStruct", complete);
        if (c_type_object != nullptr)
        {
            return c_type_object;
        }
        else if (complete)
        {
            return GetCompleteModuledRecursiveUnboundedSeqForwardStructObject();
        }
        else
        {
            return GetMinimalModuledRecursiveUnboundedSeqForwardStructObject();
        }
    }

    const TypeObject* GetMinimalModuledRecursiveUnboundedSeqForwardStructObject()
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveUnboundedSeqForwardStruct", false);
        if (c_type_object != nullptr)
        {
            return c_type_object;
        }

        TypeObject *type_object = new TypeObject();
        type_object->_d(EK_MINIMAL);
        type_object->minimal()._d(TK_ALIAS);

        // No flags apply
        //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
        //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
        //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
        //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
        //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

        // type_object->minimal().alias_type().header()... Is empty

        // No flags apply
        //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
        //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

        // Must be defined already, if don't, may be an recursive alias
        const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardStruct", 100), false);


        if (relatedType != nullptr)
        {
            type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
        }
        else
        {
            // Cannot determine base type
            delete type_object;
            return nullptr;
        }

        TypeIdentifier identifier;
        identifier._d(EK_MINIMAL);

        SerializedPayload_t payload(static_cast<uint32_t>(
            MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
        eprosima::fastcdr::Cdr ser(
            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload.encapsulation = CDR_LE;

        type_object->serialize(ser);
        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        MD5 objectHash;
        objectHash.update((char*)payload.data, payload.length);
        objectHash.finalize();
        for(int i = 0; i < 14; ++i)
        {
            identifier.equivalence_hash()[i] = objectHash.digest[i];
        }

        // Don't add our TypeIdentifier but our alias
        TypeObjectFactory::get_instance()->add_alias("ModuledRecursiveUnboundedSeqForwardStruct", TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardStruct", 100));

        TypeObjectFactory::get_instance()->add_type_object("ModuledRecursiveUnboundedSeqForwardStruct", &identifier, type_object);
        delete type_object;
        return TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveUnboundedSeqForwardStruct", false);
    }

    const TypeObject* GetCompleteModuledRecursiveUnboundedSeqForwardStructObject()
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveUnboundedSeqForwardStruct", true);
        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
        {
            return c_type_object;
        }

        TypeObject *type_object = new TypeObject();
        type_object->_d(EK_COMPLETE);
        type_object->complete()._d(TK_ALIAS);

        // No flags apply
        //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
        //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
        //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
        //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
        //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
        //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
        type_object->complete().alias_type().header().detail().type_name("ModuledRecursiveUnboundedSeqForwardStruct");

        // No flags apply
        //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
        //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

        //type_object->complete().alias_type().body().common().ann_builtin()
        //type_object->complete().alias_type().body().common().ann_custom()

        // Must be defined already, if don't, may be an recursive alias
        const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardStruct", 100));


        if (relatedType != nullptr)
        {
            type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
        }
        else
        {
            // Cannot determine base type
            delete type_object;
            return nullptr;
        }

        TypeIdentifier identifier;
        identifier._d(EK_COMPLETE);

        SerializedPayload_t payload(static_cast<uint32_t>(
            CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
        eprosima::fastcdr::Cdr ser(
            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload.encapsulation = CDR_LE;

        type_object->serialize(ser);
        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        MD5 objectHash;
        objectHash.update((char*)payload.data, payload.length);
        objectHash.finalize();
        for(int i = 0; i < 14; ++i)
        {
            identifier.equivalence_hash()[i] = objectHash.digest[i];
        }

        // Don't add our TypeIdentifier but our alias
        TypeObjectFactory::get_instance()->add_alias("ModuledRecursiveUnboundedSeqForwardStruct", TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardStruct", 100));

        TypeObjectFactory::get_instance()->add_type_object("ModuledRecursiveUnboundedSeqForwardStruct", &identifier, type_object);
        delete type_object;
        return TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveUnboundedSeqForwardStruct", true);
    }

    const TypeIdentifier* GetModuledRecursiveBoundedSeqForwardStructIdentifier(bool complete)
    {
        const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ModuledRecursiveBoundedSeqForwardStruct", complete);
        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
        {
            return c_identifier;
        }

        GetModuledRecursiveBoundedSeqForwardStructObject(complete); // Generated inside
        return TypeObjectFactory::get_instance()->get_type_identifier("ModuledRecursiveBoundedSeqForwardStruct", complete);
    }

    const TypeObject* GetModuledRecursiveBoundedSeqForwardStructObject(bool complete)
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveBoundedSeqForwardStruct", complete);
        if (c_type_object != nullptr)
        {
            return c_type_object;
        }
        else if (complete)
        {
            return GetCompleteModuledRecursiveBoundedSeqForwardStructObject();
        }
        else
        {
            return GetMinimalModuledRecursiveBoundedSeqForwardStructObject();
        }
    }

    const TypeObject* GetMinimalModuledRecursiveBoundedSeqForwardStructObject()
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveBoundedSeqForwardStruct", false);
        if (c_type_object != nullptr)
        {
            return c_type_object;
        }

        TypeObject *type_object = new TypeObject();
        type_object->_d(EK_MINIMAL);
        type_object->minimal()._d(TK_ALIAS);

        // No flags apply
        //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
        //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
        //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
        //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
        //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

        // type_object->minimal().alias_type().header()... Is empty

        // No flags apply
        //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
        //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

        // Must be defined already, if don't, may be an recursive alias
        const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardStruct", 10), false);


        if (relatedType != nullptr)
        {
            type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
        }
        else
        {
            // Cannot determine base type
            delete type_object;
            return nullptr;
        }

        TypeIdentifier identifier;
        identifier._d(EK_MINIMAL);

        SerializedPayload_t payload(static_cast<uint32_t>(
            MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
        eprosima::fastcdr::Cdr ser(
            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload.encapsulation = CDR_LE;

        type_object->serialize(ser);
        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        MD5 objectHash;
        objectHash.update((char*)payload.data, payload.length);
        objectHash.finalize();
        for(int i = 0; i < 14; ++i)
        {
            identifier.equivalence_hash()[i] = objectHash.digest[i];
        }

        // Don't add our TypeIdentifier but our alias
        TypeObjectFactory::get_instance()->add_alias("ModuledRecursiveBoundedSeqForwardStruct", TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardStruct", 10));

        TypeObjectFactory::get_instance()->add_type_object("ModuledRecursiveBoundedSeqForwardStruct", &identifier, type_object);
        delete type_object;
        return TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveBoundedSeqForwardStruct", false);
    }

    const TypeObject* GetCompleteModuledRecursiveBoundedSeqForwardStructObject()
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveBoundedSeqForwardStruct", true);
        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
        {
            return c_type_object;
        }

        TypeObject *type_object = new TypeObject();
        type_object->_d(EK_COMPLETE);
        type_object->complete()._d(TK_ALIAS);

        // No flags apply
        //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
        //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
        //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
        //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
        //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
        //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
        type_object->complete().alias_type().header().detail().type_name("ModuledRecursiveBoundedSeqForwardStruct");

        // No flags apply
        //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
        //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

        //type_object->complete().alias_type().body().common().ann_builtin()
        //type_object->complete().alias_type().body().common().ann_custom()

        // Must be defined already, if don't, may be an recursive alias
        const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardStruct", 10));


        if (relatedType != nullptr)
        {
            type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
        }
        else
        {
            // Cannot determine base type
            delete type_object;
            return nullptr;
        }

        TypeIdentifier identifier;
        identifier._d(EK_COMPLETE);

        SerializedPayload_t payload(static_cast<uint32_t>(
            CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
        eprosima::fastcdr::Cdr ser(
            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload.encapsulation = CDR_LE;

        type_object->serialize(ser);
        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        MD5 objectHash;
        objectHash.update((char*)payload.data, payload.length);
        objectHash.finalize();
        for(int i = 0; i < 14; ++i)
        {
            identifier.equivalence_hash()[i] = objectHash.digest[i];
        }

        // Don't add our TypeIdentifier but our alias
        TypeObjectFactory::get_instance()->add_alias("ModuledRecursiveBoundedSeqForwardStruct", TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardStruct", 10));

        TypeObjectFactory::get_instance()->add_type_object("ModuledRecursiveBoundedSeqForwardStruct", &identifier, type_object);
        delete type_object;
        return TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveBoundedSeqForwardStruct", true);
    }

    const TypeIdentifier* GetModuledRecursiveUnboundedSeqForwardUnionIdentifier(bool complete)
    {
        const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ModuledRecursiveUnboundedSeqForwardUnion", complete);
        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
        {
            return c_identifier;
        }

        GetModuledRecursiveUnboundedSeqForwardUnionObject(complete); // Generated inside
        return TypeObjectFactory::get_instance()->get_type_identifier("ModuledRecursiveUnboundedSeqForwardUnion", complete);
    }

    const TypeObject* GetModuledRecursiveUnboundedSeqForwardUnionObject(bool complete)
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveUnboundedSeqForwardUnion", complete);
        if (c_type_object != nullptr)
        {
            return c_type_object;
        }
        else if (complete)
        {
            return GetCompleteModuledRecursiveUnboundedSeqForwardUnionObject();
        }
        else
        {
            return GetMinimalModuledRecursiveUnboundedSeqForwardUnionObject();
        }
    }

    const TypeObject* GetMinimalModuledRecursiveUnboundedSeqForwardUnionObject()
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveUnboundedSeqForwardUnion", false);
        if (c_type_object != nullptr)
        {
            return c_type_object;
        }

        TypeObject *type_object = new TypeObject();
        type_object->_d(EK_MINIMAL);
        type_object->minimal()._d(TK_ALIAS);

        // No flags apply
        //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
        //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
        //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
        //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
        //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

        // type_object->minimal().alias_type().header()... Is empty

        // No flags apply
        //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
        //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

        // Must be defined already, if don't, may be an recursive alias
        const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardUnion", 100), false);


        if (relatedType != nullptr)
        {
            type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
        }
        else
        {
            // Cannot determine base type
            delete type_object;
            return nullptr;
        }

        TypeIdentifier identifier;
        identifier._d(EK_MINIMAL);

        SerializedPayload_t payload(static_cast<uint32_t>(
            MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
        eprosima::fastcdr::Cdr ser(
            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload.encapsulation = CDR_LE;

        type_object->serialize(ser);
        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        MD5 objectHash;
        objectHash.update((char*)payload.data, payload.length);
        objectHash.finalize();
        for(int i = 0; i < 14; ++i)
        {
            identifier.equivalence_hash()[i] = objectHash.digest[i];
        }

        // Don't add our TypeIdentifier but our alias
        TypeObjectFactory::get_instance()->add_alias("ModuledRecursiveUnboundedSeqForwardUnion", TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardUnion", 100));

        TypeObjectFactory::get_instance()->add_type_object("ModuledRecursiveUnboundedSeqForwardUnion", &identifier, type_object);
        delete type_object;
        return TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveUnboundedSeqForwardUnion", false);
    }

    const TypeObject* GetCompleteModuledRecursiveUnboundedSeqForwardUnionObject()
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveUnboundedSeqForwardUnion", true);
        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
        {
            return c_type_object;
        }

        TypeObject *type_object = new TypeObject();
        type_object->_d(EK_COMPLETE);
        type_object->complete()._d(TK_ALIAS);

        // No flags apply
        //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
        //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
        //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
        //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
        //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
        //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
        type_object->complete().alias_type().header().detail().type_name("ModuledRecursiveUnboundedSeqForwardUnion");

        // No flags apply
        //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
        //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

        //type_object->complete().alias_type().body().common().ann_builtin()
        //type_object->complete().alias_type().body().common().ann_custom()

        // Must be defined already, if don't, may be an recursive alias
        const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardUnion", 100));


        if (relatedType != nullptr)
        {
            type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
        }
        else
        {
            // Cannot determine base type
            delete type_object;
            return nullptr;
        }

        TypeIdentifier identifier;
        identifier._d(EK_COMPLETE);

        SerializedPayload_t payload(static_cast<uint32_t>(
            CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
        eprosima::fastcdr::Cdr ser(
            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload.encapsulation = CDR_LE;

        type_object->serialize(ser);
        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        MD5 objectHash;
        objectHash.update((char*)payload.data, payload.length);
        objectHash.finalize();
        for(int i = 0; i < 14; ++i)
        {
            identifier.equivalence_hash()[i] = objectHash.digest[i];
        }

        // Don't add our TypeIdentifier but our alias
        TypeObjectFactory::get_instance()->add_alias("ModuledRecursiveUnboundedSeqForwardUnion", TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardUnion", 100));

        TypeObjectFactory::get_instance()->add_type_object("ModuledRecursiveUnboundedSeqForwardUnion", &identifier, type_object);
        delete type_object;
        return TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveUnboundedSeqForwardUnion", true);
    }

    const TypeIdentifier* GetModuledRecursiveBoundedSeqForwardUnionIdentifier(bool complete)
    {
        const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ModuledRecursiveBoundedSeqForwardUnion", complete);
        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
        {
            return c_identifier;
        }

        GetModuledRecursiveBoundedSeqForwardUnionObject(complete); // Generated inside
        return TypeObjectFactory::get_instance()->get_type_identifier("ModuledRecursiveBoundedSeqForwardUnion", complete);
    }

    const TypeObject* GetModuledRecursiveBoundedSeqForwardUnionObject(bool complete)
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveBoundedSeqForwardUnion", complete);
        if (c_type_object != nullptr)
        {
            return c_type_object;
        }
        else if (complete)
        {
            return GetCompleteModuledRecursiveBoundedSeqForwardUnionObject();
        }
        else
        {
            return GetMinimalModuledRecursiveBoundedSeqForwardUnionObject();
        }
    }

    const TypeObject* GetMinimalModuledRecursiveBoundedSeqForwardUnionObject()
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveBoundedSeqForwardUnion", false);
        if (c_type_object != nullptr)
        {
            return c_type_object;
        }

        TypeObject *type_object = new TypeObject();
        type_object->_d(EK_MINIMAL);
        type_object->minimal()._d(TK_ALIAS);

        // No flags apply
        //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
        //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
        //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
        //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
        //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

        // type_object->minimal().alias_type().header()... Is empty

        // No flags apply
        //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
        //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
        //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

        // Must be defined already, if don't, may be an recursive alias
        const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardUnion", 10), false);


        if (relatedType != nullptr)
        {
            type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
        }
        else
        {
            // Cannot determine base type
            delete type_object;
            return nullptr;
        }

        TypeIdentifier identifier;
        identifier._d(EK_MINIMAL);

        SerializedPayload_t payload(static_cast<uint32_t>(
            MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
        eprosima::fastcdr::Cdr ser(
            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload.encapsulation = CDR_LE;

        type_object->serialize(ser);
        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        MD5 objectHash;
        objectHash.update((char*)payload.data, payload.length);
        objectHash.finalize();
        for(int i = 0; i < 14; ++i)
        {
            identifier.equivalence_hash()[i] = objectHash.digest[i];
        }

        // Don't add our TypeIdentifier but our alias
        TypeObjectFactory::get_instance()->add_alias("ModuledRecursiveBoundedSeqForwardUnion", TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardUnion", 10));

        TypeObjectFactory::get_instance()->add_type_object("ModuledRecursiveBoundedSeqForwardUnion", &identifier, type_object);
        delete type_object;
        return TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveBoundedSeqForwardUnion", false);
    }

    const TypeObject* GetCompleteModuledRecursiveBoundedSeqForwardUnionObject()
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveBoundedSeqForwardUnion", true);
        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
        {
            return c_type_object;
        }

        TypeObject *type_object = new TypeObject();
        type_object->_d(EK_COMPLETE);
        type_object->complete()._d(TK_ALIAS);

        // No flags apply
        //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
        //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
        //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
        //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
        //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
        //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
        type_object->complete().alias_type().header().detail().type_name("ModuledRecursiveBoundedSeqForwardUnion");

        // No flags apply
        //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
        //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
        //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

        //type_object->complete().alias_type().body().common().ann_builtin()
        //type_object->complete().alias_type().body().common().ann_custom()

        // Must be defined already, if don't, may be an recursive alias
        const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardUnion", 10));


        if (relatedType != nullptr)
        {
            type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
        }
        else
        {
            // Cannot determine base type
            delete type_object;
            return nullptr;
        }

        TypeIdentifier identifier;
        identifier._d(EK_COMPLETE);

        SerializedPayload_t payload(static_cast<uint32_t>(
            CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
        eprosima::fastcdr::Cdr ser(
            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload.encapsulation = CDR_LE;

        type_object->serialize(ser);
        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        MD5 objectHash;
        objectHash.update((char*)payload.data, payload.length);
        objectHash.finalize();
        for(int i = 0; i < 14; ++i)
        {
            identifier.equivalence_hash()[i] = objectHash.digest[i];
        }

        // Don't add our TypeIdentifier but our alias
        TypeObjectFactory::get_instance()->add_alias("ModuledRecursiveBoundedSeqForwardUnion", TypeNamesGenerator::get_sequence_type_name("declarations_module::ModuledForwardUnion", 10));

        TypeObjectFactory::get_instance()->add_type_object("ModuledRecursiveBoundedSeqForwardUnion", &identifier, type_object);
        delete type_object;
        return TypeObjectFactory::get_instance()->get_type_object("ModuledRecursiveBoundedSeqForwardUnion", true);
    }

} // namespace declarations_module
const TypeIdentifier* GetModuledForwardDeclarationsStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ModuledForwardDeclarationsStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetModuledForwardDeclarationsStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ModuledForwardDeclarationsStruct", complete);
}

const TypeObject* GetModuledForwardDeclarationsStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledForwardDeclarationsStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteModuledForwardDeclarationsStructObject();
    }
    //else
    return GetMinimalModuledForwardDeclarationsStructObject();
}

const TypeObject* GetMinimalModuledForwardDeclarationsStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledForwardDeclarationsStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ModuledForwardStruct;
    mst_var_ModuledForwardStruct.common().member_id(memberId++);
    mst_var_ModuledForwardStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ModuledForwardStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ModuledForwardStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ModuledForwardStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_ModuledForwardStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ModuledForwardStruct.common().member_flags().IS_KEY(false);
    mst_var_ModuledForwardStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ModuledForwardStruct.common().member_type_id(*declarations_module::GetModuledForwardStructIdentifier(false));
    MD5 var_ModuledForwardStruct_hash("var_ModuledForwardStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ModuledForwardStruct.detail().name_hash()[i] = var_ModuledForwardStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ModuledForwardStruct);

    MinimalStructMember mst_var_ModuledForwardUnion;
    mst_var_ModuledForwardUnion.common().member_id(memberId++);
    mst_var_ModuledForwardUnion.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ModuledForwardUnion.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ModuledForwardUnion.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ModuledForwardUnion.common().member_flags().IS_OPTIONAL(false);
    mst_var_ModuledForwardUnion.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ModuledForwardUnion.common().member_flags().IS_KEY(false);
    mst_var_ModuledForwardUnion.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ModuledForwardUnion.common().member_type_id(*declarations_module::GetModuledForwardUnionIdentifier(false));
    MD5 var_ModuledForwardUnion_hash("var_ModuledForwardUnion");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ModuledForwardUnion.detail().name_hash()[i] = var_ModuledForwardUnion_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ModuledForwardUnion);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ModuledForwardDeclarationsStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ModuledForwardDeclarationsStruct", false);
}

const TypeObject* GetCompleteModuledForwardDeclarationsStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledForwardDeclarationsStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ModuledForwardStruct;
    cst_var_ModuledForwardStruct.common().member_id(memberId++);
    cst_var_ModuledForwardStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ModuledForwardStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ModuledForwardStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ModuledForwardStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_ModuledForwardStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ModuledForwardStruct.common().member_flags().IS_KEY(false);
    cst_var_ModuledForwardStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ModuledForwardStruct.common().member_type_id(*declarations_module::GetModuledForwardStructIdentifier(true));
    cst_var_ModuledForwardStruct.detail().name("var_ModuledForwardStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ModuledForwardStruct);

    CompleteStructMember cst_var_ModuledForwardUnion;
    cst_var_ModuledForwardUnion.common().member_id(memberId++);
    cst_var_ModuledForwardUnion.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ModuledForwardUnion.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ModuledForwardUnion.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ModuledForwardUnion.common().member_flags().IS_OPTIONAL(false);
    cst_var_ModuledForwardUnion.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ModuledForwardUnion.common().member_flags().IS_KEY(false);
    cst_var_ModuledForwardUnion.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ModuledForwardUnion.common().member_type_id(*declarations_module::GetModuledForwardUnionIdentifier(true));
    cst_var_ModuledForwardUnion.detail().name("var_ModuledForwardUnion");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ModuledForwardUnion);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ModuledForwardDeclarationsStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ModuledForwardDeclarationsStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ModuledForwardDeclarationsStruct", true);
}

const TypeIdentifier* GetModuledForwardDeclarationsRecursiveStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ModuledForwardDeclarationsRecursiveStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetModuledForwardDeclarationsRecursiveStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ModuledForwardDeclarationsRecursiveStruct", complete);
}

const TypeObject* GetModuledForwardDeclarationsRecursiveStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledForwardDeclarationsRecursiveStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteModuledForwardDeclarationsRecursiveStructObject();
    }
    //else
    return GetMinimalModuledForwardDeclarationsRecursiveStructObject();
}

const TypeObject* GetMinimalModuledForwardDeclarationsRecursiveStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledForwardDeclarationsRecursiveStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ModuledRecursiveUnboundedSeqForwardStruct;
    mst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_id(memberId++);
    mst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_flags().IS_KEY(false);
    mst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_type_id(*declarations_module::GetModuledRecursiveUnboundedSeqForwardStructIdentifier(false));
    MD5 var_ModuledRecursiveUnboundedSeqForwardStruct_hash("var_ModuledRecursiveUnboundedSeqForwardStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ModuledRecursiveUnboundedSeqForwardStruct.detail().name_hash()[i] = var_ModuledRecursiveUnboundedSeqForwardStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ModuledRecursiveUnboundedSeqForwardStruct);

    MinimalStructMember mst_var_ModuledRecursiveBoundedSeqForwardStruct;
    mst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_id(memberId++);
    mst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_flags().IS_KEY(false);
    mst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_type_id(*declarations_module::GetModuledRecursiveBoundedSeqForwardStructIdentifier(false));
    MD5 var_ModuledRecursiveBoundedSeqForwardStruct_hash("var_ModuledRecursiveBoundedSeqForwardStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ModuledRecursiveBoundedSeqForwardStruct.detail().name_hash()[i] = var_ModuledRecursiveBoundedSeqForwardStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ModuledRecursiveBoundedSeqForwardStruct);

    MinimalStructMember mst_var_ModuledRecursiveUnboundedSeqForwardUnion;
    mst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_id(memberId++);
    mst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_flags().IS_OPTIONAL(false);
    mst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_flags().IS_KEY(false);
    mst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_type_id(*declarations_module::GetModuledRecursiveUnboundedSeqForwardUnionIdentifier(false));
    MD5 var_ModuledRecursiveUnboundedSeqForwardUnion_hash("var_ModuledRecursiveUnboundedSeqForwardUnion");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ModuledRecursiveUnboundedSeqForwardUnion.detail().name_hash()[i] = var_ModuledRecursiveUnboundedSeqForwardUnion_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ModuledRecursiveUnboundedSeqForwardUnion);

    MinimalStructMember mst_var_ModuledRecursiveBoundedSeqForwardUnion;
    mst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_id(memberId++);
    mst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_flags().IS_OPTIONAL(false);
    mst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_flags().IS_KEY(false);
    mst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_type_id(*declarations_module::GetModuledRecursiveBoundedSeqForwardUnionIdentifier(false));
    MD5 var_ModuledRecursiveBoundedSeqForwardUnion_hash("var_ModuledRecursiveBoundedSeqForwardUnion");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ModuledRecursiveBoundedSeqForwardUnion.detail().name_hash()[i] = var_ModuledRecursiveBoundedSeqForwardUnion_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ModuledRecursiveBoundedSeqForwardUnion);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ModuledForwardDeclarationsRecursiveStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ModuledForwardDeclarationsRecursiveStruct", false);
}

const TypeObject* GetCompleteModuledForwardDeclarationsRecursiveStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledForwardDeclarationsRecursiveStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ModuledRecursiveUnboundedSeqForwardStruct;
    cst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_id(memberId++);
    cst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_flags().IS_KEY(false);
    cst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ModuledRecursiveUnboundedSeqForwardStruct.common().member_type_id(*declarations_module::GetModuledRecursiveUnboundedSeqForwardStructIdentifier(true));
    cst_var_ModuledRecursiveUnboundedSeqForwardStruct.detail().name("var_ModuledRecursiveUnboundedSeqForwardStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ModuledRecursiveUnboundedSeqForwardStruct);

    CompleteStructMember cst_var_ModuledRecursiveBoundedSeqForwardStruct;
    cst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_id(memberId++);
    cst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_flags().IS_KEY(false);
    cst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ModuledRecursiveBoundedSeqForwardStruct.common().member_type_id(*declarations_module::GetModuledRecursiveBoundedSeqForwardStructIdentifier(true));
    cst_var_ModuledRecursiveBoundedSeqForwardStruct.detail().name("var_ModuledRecursiveBoundedSeqForwardStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ModuledRecursiveBoundedSeqForwardStruct);

    CompleteStructMember cst_var_ModuledRecursiveUnboundedSeqForwardUnion;
    cst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_id(memberId++);
    cst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_flags().IS_OPTIONAL(false);
    cst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_flags().IS_KEY(false);
    cst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ModuledRecursiveUnboundedSeqForwardUnion.common().member_type_id(*declarations_module::GetModuledRecursiveUnboundedSeqForwardUnionIdentifier(true));
    cst_var_ModuledRecursiveUnboundedSeqForwardUnion.detail().name("var_ModuledRecursiveUnboundedSeqForwardUnion");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ModuledRecursiveUnboundedSeqForwardUnion);

    CompleteStructMember cst_var_ModuledRecursiveBoundedSeqForwardUnion;
    cst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_id(memberId++);
    cst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_flags().IS_OPTIONAL(false);
    cst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_flags().IS_KEY(false);
    cst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ModuledRecursiveBoundedSeqForwardUnion.common().member_type_id(*declarations_module::GetModuledRecursiveBoundedSeqForwardUnionIdentifier(true));
    cst_var_ModuledRecursiveBoundedSeqForwardUnion.detail().name("var_ModuledRecursiveBoundedSeqForwardUnion");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ModuledRecursiveBoundedSeqForwardUnion);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ModuledForwardDeclarationsRecursiveStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ModuledForwardDeclarationsRecursiveStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ModuledForwardDeclarationsRecursiveStruct", true);
}

namespace declarations_module {
    const TypeIdentifier* GetModuledForwardStructIdentifier(bool complete)
    {
        const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ModuledForwardStruct", complete);
        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
        {
            return c_identifier;
        }

        GetModuledForwardStructObject(complete); // Generated inside
        return TypeObjectFactory::get_instance()->get_type_identifier("ModuledForwardStruct", complete);
    }

    const TypeObject* GetModuledForwardStructObject(bool complete)
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledForwardStruct", complete);
        if (c_type_object != nullptr)
        {
            return c_type_object;
        }
        else if (complete)
        {
            return GetCompleteModuledForwardStructObject();
        }
        //else
        return GetMinimalModuledForwardStructObject();
    }

    const TypeObject* GetMinimalModuledForwardStructObject()
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledForwardStruct", false);
        if (c_type_object != nullptr)
        {
            return c_type_object;
        }

        TypeObject *type_object = new TypeObject();
        type_object->_d(EK_MINIMAL);
        type_object->minimal()._d(TK_STRUCTURE);

        type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
        type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
        type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
        type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
        type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

        MemberId memberId = 0;
        MinimalStructMember mst_var_short;
        mst_var_short.common().member_id(memberId++);
        mst_var_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
        mst_var_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
        mst_var_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
        mst_var_short.common().member_flags().IS_OPTIONAL(false);
        mst_var_short.common().member_flags().IS_MUST_UNDERSTAND(false);
        mst_var_short.common().member_flags().IS_KEY(false);
        mst_var_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
        mst_var_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

        MD5 var_short_hash("var_short");
        for(int i = 0; i < 4; ++i)
        {
            mst_var_short.detail().name_hash()[i] = var_short_hash.digest[i];
        }
        type_object->minimal().struct_type().member_seq().emplace_back(mst_var_short);

        MinimalStructMember mst_var_long;
        mst_var_long.common().member_id(memberId++);
        mst_var_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
        mst_var_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
        mst_var_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
        mst_var_long.common().member_flags().IS_OPTIONAL(false);
        mst_var_long.common().member_flags().IS_MUST_UNDERSTAND(false);
        mst_var_long.common().member_flags().IS_KEY(false);
        mst_var_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
        mst_var_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

        MD5 var_long_hash("var_long");
        for(int i = 0; i < 4; ++i)
        {
            mst_var_long.detail().name_hash()[i] = var_long_hash.digest[i];
        }
        type_object->minimal().struct_type().member_seq().emplace_back(mst_var_long);


        // Header
        // TODO Inheritance
        //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
        //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

        TypeIdentifier identifier;
        identifier._d(EK_MINIMAL);

        SerializedPayload_t payload(static_cast<uint32_t>(
            MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
        eprosima::fastcdr::Cdr ser(
            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload.encapsulation = CDR_LE;

        type_object->serialize(ser);
        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        MD5 objectHash;
        objectHash.update((char*)payload.data, payload.length);
        objectHash.finalize();
        for(int i = 0; i < 14; ++i)
        {
            identifier.equivalence_hash()[i] = objectHash.digest[i];
        }

        TypeObjectFactory::get_instance()->add_type_object("ModuledForwardStruct", &identifier, type_object);
        delete type_object;
        return TypeObjectFactory::get_instance()->get_type_object("ModuledForwardStruct", false);
    }

    const TypeObject* GetCompleteModuledForwardStructObject()
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledForwardStruct", true);
        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
        {
            return c_type_object;
        }

        TypeObject *type_object = new TypeObject();
        type_object->_d(EK_COMPLETE);
        type_object->complete()._d(TK_STRUCTURE);

        type_object->complete().struct_type().struct_flags().IS_FINAL(false);
        type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
        type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
        type_object->complete().struct_type().struct_flags().IS_NESTED(false);
        type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

        MemberId memberId = 0;
        CompleteStructMember cst_var_short;
        cst_var_short.common().member_id(memberId++);
        cst_var_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
        cst_var_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
        cst_var_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
        cst_var_short.common().member_flags().IS_OPTIONAL(false);
        cst_var_short.common().member_flags().IS_MUST_UNDERSTAND(false);
        cst_var_short.common().member_flags().IS_KEY(false);
        cst_var_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
        cst_var_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

        cst_var_short.detail().name("var_short");

        type_object->complete().struct_type().member_seq().emplace_back(cst_var_short);

        CompleteStructMember cst_var_long;
        cst_var_long.common().member_id(memberId++);
        cst_var_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
        cst_var_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
        cst_var_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
        cst_var_long.common().member_flags().IS_OPTIONAL(false);
        cst_var_long.common().member_flags().IS_MUST_UNDERSTAND(false);
        cst_var_long.common().member_flags().IS_KEY(false);
        cst_var_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
        cst_var_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

        cst_var_long.detail().name("var_long");

        type_object->complete().struct_type().member_seq().emplace_back(cst_var_long);


        // Header
        type_object->complete().struct_type().header().detail().type_name("ModuledForwardStruct");
        // TODO inheritance


        TypeIdentifier identifier;
        identifier._d(EK_COMPLETE);

        SerializedPayload_t payload(static_cast<uint32_t>(
            CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
        eprosima::fastcdr::Cdr ser(
            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload.encapsulation = CDR_LE;

        type_object->serialize(ser);
        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        MD5 objectHash;
        objectHash.update((char*)payload.data, payload.length);
        objectHash.finalize();
        for(int i = 0; i < 14; ++i)
        {
            identifier.equivalence_hash()[i] = objectHash.digest[i];
        }

        TypeObjectFactory::get_instance()->add_type_object("ModuledForwardStruct", &identifier, type_object);
        delete type_object;
        return TypeObjectFactory::get_instance()->get_type_object("ModuledForwardStruct", true);
    }

    const TypeIdentifier* GetModuledForwardUnionIdentifier(bool complete)
    {
        const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ModuledForwardUnion", complete);
        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
        {
            return c_identifier;
        }

        GetModuledForwardUnionObject(complete);
        return TypeObjectFactory::get_instance()->get_type_identifier("ModuledForwardUnion", complete);
    }

    const TypeObject* GetModuledForwardUnionObject(bool complete)
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledForwardUnion", complete);
        if (c_type_object != nullptr)
        {
            return c_type_object;
        }
        else if (complete)
        {
            return GetCompleteModuledForwardUnionObject();
        }
        // else
        return GetMinimalModuledForwardUnionObject();
    }

    const TypeObject* GetMinimalModuledForwardUnionObject()
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledForwardUnion", false);
        if (c_type_object != nullptr)
        {
            return c_type_object;
        }

        TypeObject *type_object = new TypeObject();
        type_object->_d(EK_MINIMAL);
        type_object->minimal()._d(TK_UNION);

        type_object->minimal().union_type().union_flags().IS_FINAL(false);
        type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
        type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
        type_object->minimal().union_type().union_flags().IS_NESTED(false);
        type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

        type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
        type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
        type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
        type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
        type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
        type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
        type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

        type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

        MemberId memberId = 0;
        MinimalUnionMember mst_case_zero;
        mst_case_zero.common().member_id(memberId++);
        mst_case_zero.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
        mst_case_zero.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
        mst_case_zero.common().member_flags().IS_EXTERNAL(false); // Unsupported
        mst_case_zero.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
        mst_case_zero.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
        mst_case_zero.common().member_flags().IS_KEY(false); // Doesn't apply
        mst_case_zero.common().member_flags().IS_DEFAULT(false);
        mst_case_zero.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

        mst_case_zero.common().label_seq().emplace_back(0);
        MD5 case_zero_hash("case_zero");
        for(int i = 0; i < 4; ++i)
        {
            mst_case_zero.detail().name_hash()[i] = case_zero_hash.digest[i];
        }
        type_object->minimal().union_type().member_seq().emplace_back(mst_case_zero);

        MinimalUnionMember mst_case_one;
        mst_case_one.common().member_id(memberId++);
        mst_case_one.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
        mst_case_one.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
        mst_case_one.common().member_flags().IS_EXTERNAL(false); // Unsupported
        mst_case_one.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
        mst_case_one.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
        mst_case_one.common().member_flags().IS_KEY(false); // Doesn't apply
        mst_case_one.common().member_flags().IS_DEFAULT(false);
        mst_case_one.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

        mst_case_one.common().label_seq().emplace_back(1);
        MD5 case_one_hash("case_one");
        for(int i = 0; i < 4; ++i)
        {
            mst_case_one.detail().name_hash()[i] = case_one_hash.digest[i];
        }
        type_object->minimal().union_type().member_seq().emplace_back(mst_case_one);


        // Header
        //type_object->minimal().union_type().header().detail()... // Empty

        TypeIdentifier* identifier = new TypeIdentifier();
        identifier->_d(EK_MINIMAL);

        SerializedPayload_t payload(static_cast<uint32_t>(
            MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
        eprosima::fastcdr::Cdr ser(
            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload.encapsulation = CDR_LE;

        type_object->serialize(ser);
        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        MD5 objectHash;
        objectHash.update((char*)payload.data, payload.length);
        objectHash.finalize();
        for(int i = 0; i < 14; ++i)
        {
            identifier->equivalence_hash()[i] = objectHash.digest[i];
        }

        TypeObjectFactory::get_instance()->add_type_object("ModuledForwardUnion", identifier, type_object);
        delete type_object;
        delete identifier;
        return TypeObjectFactory::get_instance()->get_type_object("ModuledForwardUnion", false);
    }

    const TypeObject* GetCompleteModuledForwardUnionObject()
    {
        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ModuledForwardUnion", true);
        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
        {
            return c_type_object;
        }

        TypeObject *type_object = new TypeObject();
        type_object->_d(EK_COMPLETE);
        type_object->complete()._d(TK_UNION);

        type_object->complete().union_type().union_flags().IS_FINAL(false);
        type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
        type_object->complete().union_type().union_flags().IS_MUTABLE(false);
        type_object->complete().union_type().union_flags().IS_NESTED(false);
        type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

        type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
        type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
        type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
        type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
        type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
        type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
        type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

        type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


        MemberId memberId = 0;
        CompleteUnionMember cst_case_zero;
        cst_case_zero.common().member_id(memberId++);
        cst_case_zero.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
        cst_case_zero.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
        cst_case_zero.common().member_flags().IS_EXTERNAL(false); // Unsupported
        cst_case_zero.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
        cst_case_zero.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
        cst_case_zero.common().member_flags().IS_KEY(false); // Doesn't apply
        cst_case_zero.common().member_flags().IS_DEFAULT(false);
        cst_case_zero.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
        cst_case_zero.common().label_seq().emplace_back(0);

        cst_case_zero.detail().name("case_zero");

        type_object->complete().union_type().member_seq().emplace_back(cst_case_zero);

        CompleteUnionMember cst_case_one;
        cst_case_one.common().member_id(memberId++);
        cst_case_one.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
        cst_case_one.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
        cst_case_one.common().member_flags().IS_EXTERNAL(false); // Unsupported
        cst_case_one.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
        cst_case_one.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
        cst_case_one.common().member_flags().IS_KEY(false); // Doesn't apply
        cst_case_one.common().member_flags().IS_DEFAULT(false);
        cst_case_one.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
        cst_case_one.common().label_seq().emplace_back(1);

        cst_case_one.detail().name("case_one");

        type_object->complete().union_type().member_seq().emplace_back(cst_case_one);


        // Header
        type_object->complete().union_type().header().detail().type_name("ModuledForwardUnion");


        TypeIdentifier* identifier = new TypeIdentifier();
        identifier->_d(EK_COMPLETE);

        SerializedPayload_t payload(static_cast<uint32_t>(
            CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
        eprosima::fastcdr::Cdr ser(
            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload.encapsulation = CDR_LE;

        type_object->serialize(ser);
        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        MD5 objectHash;
        objectHash.update((char*)payload.data, payload.length);
        objectHash.finalize();
        for(int i = 0; i < 14; ++i)
        {
            identifier->equivalence_hash()[i] = objectHash.digest[i];
        }

        TypeObjectFactory::get_instance()->add_type_object("ModuledForwardUnion", identifier, type_object);
        delete type_object;
        delete identifier;
        return TypeObjectFactory::get_instance()->get_type_object("ModuledForwardUnion", true);
    }

} // namespace declarations_module