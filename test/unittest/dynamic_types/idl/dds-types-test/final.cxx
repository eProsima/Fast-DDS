// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file final.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "final.h"
#include "finalTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define FinalLongStruct_max_cdr_typesize 4ULL;
#define FinalLongDoubleStruct_max_cdr_typesize 16ULL;
#define FinalInheritanceStruct_max_cdr_typesize 264ULL;
#define FinalEmptyInheritanceStruct_max_cdr_typesize 260ULL;
#define FinalULongLongStruct_max_cdr_typesize 8ULL;
#define FinalCharStruct_max_cdr_typesize 1ULL;
#define FinalUShortStruct_max_cdr_typesize 2ULL;
#define FinalOctetStruct_max_cdr_typesize 1ULL;
#define FinalFloatStruct_max_cdr_typesize 4ULL;
#define FinalLongLongStruct_max_cdr_typesize 8ULL;
#define FinalDoubleStruct_max_cdr_typesize 8ULL;
#define InheritanceEmptyStruct_max_cdr_typesize 2ULL;
#define FinalBooleanStruct_max_cdr_typesize 1ULL;
#define FinalWCharStruct_max_cdr_typesize 4ULL;
#define FinalShortStruct_max_cdr_typesize 2ULL;
#define FinalULongStruct_max_cdr_typesize 4ULL;
#define FinalEmptyStruct_max_cdr_typesize 0ULL;
#define FinalLongStruct_max_key_cdr_typesize 0ULL;
#define FinalLongDoubleStruct_max_key_cdr_typesize 0ULL;
#define FinalInheritanceStruct_max_key_cdr_typesize 0ULL;
#define FinalEmptyInheritanceStruct_max_key_cdr_typesize 0ULL;
#define FinalULongLongStruct_max_key_cdr_typesize 0ULL;
#define FinalCharStruct_max_key_cdr_typesize 0ULL;
#define FinalUShortStruct_max_key_cdr_typesize 0ULL;
#define FinalOctetStruct_max_key_cdr_typesize 0ULL;
#define FinalFloatStruct_max_key_cdr_typesize 0ULL;
#define FinalLongLongStruct_max_key_cdr_typesize 0ULL;
#define FinalDoubleStruct_max_key_cdr_typesize 0ULL;
#define InheritanceEmptyStruct_max_key_cdr_typesize 0ULL;
#define FinalBooleanStruct_max_key_cdr_typesize 0ULL;
#define FinalWCharStruct_max_key_cdr_typesize 0ULL;
#define FinalShortStruct_max_key_cdr_typesize 0ULL;
#define FinalULongStruct_max_key_cdr_typesize 0ULL;
#define FinalEmptyStruct_max_key_cdr_typesize 0ULL;

FinalShortStruct::FinalShortStruct()
{
    // short m_var_short
    m_var_short = 0;

    // Just to register all known types
    registerfinalTypes();
}

FinalShortStruct::~FinalShortStruct()
{
}

FinalShortStruct::FinalShortStruct(
        const FinalShortStruct& x)
{
    m_var_short = x.m_var_short;
}

FinalShortStruct::FinalShortStruct(
        FinalShortStruct&& x) noexcept 
{
    m_var_short = x.m_var_short;
}

FinalShortStruct& FinalShortStruct::operator =(
        const FinalShortStruct& x)
{

    m_var_short = x.m_var_short;

    return *this;
}

FinalShortStruct& FinalShortStruct::operator =(
        FinalShortStruct&& x) noexcept
{

    m_var_short = x.m_var_short;

    return *this;
}

bool FinalShortStruct::operator ==(
        const FinalShortStruct& x) const
{

    return (m_var_short == x.m_var_short);
}

bool FinalShortStruct::operator !=(
        const FinalShortStruct& x) const
{
    return !(*this == x);
}

size_t FinalShortStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalShortStruct_max_cdr_typesize;
}

size_t FinalShortStruct::getCdrSerializedSize(
        const FinalShortStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void FinalShortStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_short;
}

void FinalShortStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_short;
}

/*!
 * @brief This function sets a value in member var_short
 * @param _var_short New value for member var_short
 */
void FinalShortStruct::var_short(
        int16_t _var_short)
{
    m_var_short = _var_short;
}

/*!
 * @brief This function returns the value of member var_short
 * @return Value of member var_short
 */
int16_t FinalShortStruct::var_short() const
{
    return m_var_short;
}

/*!
 * @brief This function returns a reference to member var_short
 * @return Reference to member var_short
 */
int16_t& FinalShortStruct::var_short()
{
    return m_var_short;
}



size_t FinalShortStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalShortStruct_max_key_cdr_typesize;
}

bool FinalShortStruct::isKeyDefined()
{
    return false;
}

void FinalShortStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FinalUShortStruct::FinalUShortStruct()
{
    // unsigned short m_var_ushort
    m_var_ushort = 0;

    // Just to register all known types
    registerfinalTypes();
}

FinalUShortStruct::~FinalUShortStruct()
{
}

FinalUShortStruct::FinalUShortStruct(
        const FinalUShortStruct& x)
{
    m_var_ushort = x.m_var_ushort;
}

FinalUShortStruct::FinalUShortStruct(
        FinalUShortStruct&& x) noexcept 
{
    m_var_ushort = x.m_var_ushort;
}

FinalUShortStruct& FinalUShortStruct::operator =(
        const FinalUShortStruct& x)
{

    m_var_ushort = x.m_var_ushort;

    return *this;
}

FinalUShortStruct& FinalUShortStruct::operator =(
        FinalUShortStruct&& x) noexcept
{

    m_var_ushort = x.m_var_ushort;

    return *this;
}

bool FinalUShortStruct::operator ==(
        const FinalUShortStruct& x) const
{

    return (m_var_ushort == x.m_var_ushort);
}

bool FinalUShortStruct::operator !=(
        const FinalUShortStruct& x) const
{
    return !(*this == x);
}

size_t FinalUShortStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalUShortStruct_max_cdr_typesize;
}

size_t FinalUShortStruct::getCdrSerializedSize(
        const FinalUShortStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void FinalUShortStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ushort;
}

void FinalUShortStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ushort;
}

/*!
 * @brief This function sets a value in member var_ushort
 * @param _var_ushort New value for member var_ushort
 */
void FinalUShortStruct::var_ushort(
        uint16_t _var_ushort)
{
    m_var_ushort = _var_ushort;
}

/*!
 * @brief This function returns the value of member var_ushort
 * @return Value of member var_ushort
 */
uint16_t FinalUShortStruct::var_ushort() const
{
    return m_var_ushort;
}

/*!
 * @brief This function returns a reference to member var_ushort
 * @return Reference to member var_ushort
 */
uint16_t& FinalUShortStruct::var_ushort()
{
    return m_var_ushort;
}



size_t FinalUShortStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalUShortStruct_max_key_cdr_typesize;
}

bool FinalUShortStruct::isKeyDefined()
{
    return false;
}

void FinalUShortStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FinalLongStruct::FinalLongStruct()
{
    // long m_var_long
    m_var_long = 0;

    // Just to register all known types
    registerfinalTypes();
}

FinalLongStruct::~FinalLongStruct()
{
}

FinalLongStruct::FinalLongStruct(
        const FinalLongStruct& x)
{
    m_var_long = x.m_var_long;
}

FinalLongStruct::FinalLongStruct(
        FinalLongStruct&& x) noexcept 
{
    m_var_long = x.m_var_long;
}

FinalLongStruct& FinalLongStruct::operator =(
        const FinalLongStruct& x)
{

    m_var_long = x.m_var_long;

    return *this;
}

FinalLongStruct& FinalLongStruct::operator =(
        FinalLongStruct&& x) noexcept
{

    m_var_long = x.m_var_long;

    return *this;
}

bool FinalLongStruct::operator ==(
        const FinalLongStruct& x) const
{

    return (m_var_long == x.m_var_long);
}

bool FinalLongStruct::operator !=(
        const FinalLongStruct& x) const
{
    return !(*this == x);
}

size_t FinalLongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalLongStruct_max_cdr_typesize;
}

size_t FinalLongStruct::getCdrSerializedSize(
        const FinalLongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void FinalLongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_long;
}

void FinalLongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_long;
}

/*!
 * @brief This function sets a value in member var_long
 * @param _var_long New value for member var_long
 */
void FinalLongStruct::var_long(
        int32_t _var_long)
{
    m_var_long = _var_long;
}

/*!
 * @brief This function returns the value of member var_long
 * @return Value of member var_long
 */
int32_t FinalLongStruct::var_long() const
{
    return m_var_long;
}

/*!
 * @brief This function returns a reference to member var_long
 * @return Reference to member var_long
 */
int32_t& FinalLongStruct::var_long()
{
    return m_var_long;
}



size_t FinalLongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalLongStruct_max_key_cdr_typesize;
}

bool FinalLongStruct::isKeyDefined()
{
    return false;
}

void FinalLongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FinalULongStruct::FinalULongStruct()
{
    // unsigned long m_var_ulong
    m_var_ulong = 0;

    // Just to register all known types
    registerfinalTypes();
}

FinalULongStruct::~FinalULongStruct()
{
}

FinalULongStruct::FinalULongStruct(
        const FinalULongStruct& x)
{
    m_var_ulong = x.m_var_ulong;
}

FinalULongStruct::FinalULongStruct(
        FinalULongStruct&& x) noexcept 
{
    m_var_ulong = x.m_var_ulong;
}

FinalULongStruct& FinalULongStruct::operator =(
        const FinalULongStruct& x)
{

    m_var_ulong = x.m_var_ulong;

    return *this;
}

FinalULongStruct& FinalULongStruct::operator =(
        FinalULongStruct&& x) noexcept
{

    m_var_ulong = x.m_var_ulong;

    return *this;
}

bool FinalULongStruct::operator ==(
        const FinalULongStruct& x) const
{

    return (m_var_ulong == x.m_var_ulong);
}

bool FinalULongStruct::operator !=(
        const FinalULongStruct& x) const
{
    return !(*this == x);
}

size_t FinalULongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalULongStruct_max_cdr_typesize;
}

size_t FinalULongStruct::getCdrSerializedSize(
        const FinalULongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void FinalULongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ulong;
}

void FinalULongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ulong;
}

/*!
 * @brief This function sets a value in member var_ulong
 * @param _var_ulong New value for member var_ulong
 */
void FinalULongStruct::var_ulong(
        uint32_t _var_ulong)
{
    m_var_ulong = _var_ulong;
}

/*!
 * @brief This function returns the value of member var_ulong
 * @return Value of member var_ulong
 */
uint32_t FinalULongStruct::var_ulong() const
{
    return m_var_ulong;
}

/*!
 * @brief This function returns a reference to member var_ulong
 * @return Reference to member var_ulong
 */
uint32_t& FinalULongStruct::var_ulong()
{
    return m_var_ulong;
}



size_t FinalULongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalULongStruct_max_key_cdr_typesize;
}

bool FinalULongStruct::isKeyDefined()
{
    return false;
}

void FinalULongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FinalLongLongStruct::FinalLongLongStruct()
{
    // long long m_var_longlong
    m_var_longlong = 0;

    // Just to register all known types
    registerfinalTypes();
}

FinalLongLongStruct::~FinalLongLongStruct()
{
}

FinalLongLongStruct::FinalLongLongStruct(
        const FinalLongLongStruct& x)
{
    m_var_longlong = x.m_var_longlong;
}

FinalLongLongStruct::FinalLongLongStruct(
        FinalLongLongStruct&& x) noexcept 
{
    m_var_longlong = x.m_var_longlong;
}

FinalLongLongStruct& FinalLongLongStruct::operator =(
        const FinalLongLongStruct& x)
{

    m_var_longlong = x.m_var_longlong;

    return *this;
}

FinalLongLongStruct& FinalLongLongStruct::operator =(
        FinalLongLongStruct&& x) noexcept
{

    m_var_longlong = x.m_var_longlong;

    return *this;
}

bool FinalLongLongStruct::operator ==(
        const FinalLongLongStruct& x) const
{

    return (m_var_longlong == x.m_var_longlong);
}

bool FinalLongLongStruct::operator !=(
        const FinalLongLongStruct& x) const
{
    return !(*this == x);
}

size_t FinalLongLongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalLongLongStruct_max_cdr_typesize;
}

size_t FinalLongLongStruct::getCdrSerializedSize(
        const FinalLongLongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void FinalLongLongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_longlong;
}

void FinalLongLongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_longlong;
}

/*!
 * @brief This function sets a value in member var_longlong
 * @param _var_longlong New value for member var_longlong
 */
void FinalLongLongStruct::var_longlong(
        int64_t _var_longlong)
{
    m_var_longlong = _var_longlong;
}

/*!
 * @brief This function returns the value of member var_longlong
 * @return Value of member var_longlong
 */
int64_t FinalLongLongStruct::var_longlong() const
{
    return m_var_longlong;
}

/*!
 * @brief This function returns a reference to member var_longlong
 * @return Reference to member var_longlong
 */
int64_t& FinalLongLongStruct::var_longlong()
{
    return m_var_longlong;
}



size_t FinalLongLongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalLongLongStruct_max_key_cdr_typesize;
}

bool FinalLongLongStruct::isKeyDefined()
{
    return false;
}

void FinalLongLongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FinalULongLongStruct::FinalULongLongStruct()
{
    // unsigned long long m_var_ulonglong
    m_var_ulonglong = 0;

    // Just to register all known types
    registerfinalTypes();
}

FinalULongLongStruct::~FinalULongLongStruct()
{
}

FinalULongLongStruct::FinalULongLongStruct(
        const FinalULongLongStruct& x)
{
    m_var_ulonglong = x.m_var_ulonglong;
}

FinalULongLongStruct::FinalULongLongStruct(
        FinalULongLongStruct&& x) noexcept 
{
    m_var_ulonglong = x.m_var_ulonglong;
}

FinalULongLongStruct& FinalULongLongStruct::operator =(
        const FinalULongLongStruct& x)
{

    m_var_ulonglong = x.m_var_ulonglong;

    return *this;
}

FinalULongLongStruct& FinalULongLongStruct::operator =(
        FinalULongLongStruct&& x) noexcept
{

    m_var_ulonglong = x.m_var_ulonglong;

    return *this;
}

bool FinalULongLongStruct::operator ==(
        const FinalULongLongStruct& x) const
{

    return (m_var_ulonglong == x.m_var_ulonglong);
}

bool FinalULongLongStruct::operator !=(
        const FinalULongLongStruct& x) const
{
    return !(*this == x);
}

size_t FinalULongLongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalULongLongStruct_max_cdr_typesize;
}

size_t FinalULongLongStruct::getCdrSerializedSize(
        const FinalULongLongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void FinalULongLongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ulonglong;
}

void FinalULongLongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ulonglong;
}

/*!
 * @brief This function sets a value in member var_ulonglong
 * @param _var_ulonglong New value for member var_ulonglong
 */
void FinalULongLongStruct::var_ulonglong(
        uint64_t _var_ulonglong)
{
    m_var_ulonglong = _var_ulonglong;
}

/*!
 * @brief This function returns the value of member var_ulonglong
 * @return Value of member var_ulonglong
 */
uint64_t FinalULongLongStruct::var_ulonglong() const
{
    return m_var_ulonglong;
}

/*!
 * @brief This function returns a reference to member var_ulonglong
 * @return Reference to member var_ulonglong
 */
uint64_t& FinalULongLongStruct::var_ulonglong()
{
    return m_var_ulonglong;
}



size_t FinalULongLongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalULongLongStruct_max_key_cdr_typesize;
}

bool FinalULongLongStruct::isKeyDefined()
{
    return false;
}

void FinalULongLongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FinalFloatStruct::FinalFloatStruct()
{
    // float m_var_float
    m_var_float = 0.0;

    // Just to register all known types
    registerfinalTypes();
}

FinalFloatStruct::~FinalFloatStruct()
{
}

FinalFloatStruct::FinalFloatStruct(
        const FinalFloatStruct& x)
{
    m_var_float = x.m_var_float;
}

FinalFloatStruct::FinalFloatStruct(
        FinalFloatStruct&& x) noexcept 
{
    m_var_float = x.m_var_float;
}

FinalFloatStruct& FinalFloatStruct::operator =(
        const FinalFloatStruct& x)
{

    m_var_float = x.m_var_float;

    return *this;
}

FinalFloatStruct& FinalFloatStruct::operator =(
        FinalFloatStruct&& x) noexcept
{

    m_var_float = x.m_var_float;

    return *this;
}

bool FinalFloatStruct::operator ==(
        const FinalFloatStruct& x) const
{

    return (m_var_float == x.m_var_float);
}

bool FinalFloatStruct::operator !=(
        const FinalFloatStruct& x) const
{
    return !(*this == x);
}

size_t FinalFloatStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalFloatStruct_max_cdr_typesize;
}

size_t FinalFloatStruct::getCdrSerializedSize(
        const FinalFloatStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void FinalFloatStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_float;
}

void FinalFloatStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_float;
}

/*!
 * @brief This function sets a value in member var_float
 * @param _var_float New value for member var_float
 */
void FinalFloatStruct::var_float(
        float _var_float)
{
    m_var_float = _var_float;
}

/*!
 * @brief This function returns the value of member var_float
 * @return Value of member var_float
 */
float FinalFloatStruct::var_float() const
{
    return m_var_float;
}

/*!
 * @brief This function returns a reference to member var_float
 * @return Reference to member var_float
 */
float& FinalFloatStruct::var_float()
{
    return m_var_float;
}



size_t FinalFloatStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalFloatStruct_max_key_cdr_typesize;
}

bool FinalFloatStruct::isKeyDefined()
{
    return false;
}

void FinalFloatStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FinalDoubleStruct::FinalDoubleStruct()
{
    // double m_var_double
    m_var_double = 0.0;

    // Just to register all known types
    registerfinalTypes();
}

FinalDoubleStruct::~FinalDoubleStruct()
{
}

FinalDoubleStruct::FinalDoubleStruct(
        const FinalDoubleStruct& x)
{
    m_var_double = x.m_var_double;
}

FinalDoubleStruct::FinalDoubleStruct(
        FinalDoubleStruct&& x) noexcept 
{
    m_var_double = x.m_var_double;
}

FinalDoubleStruct& FinalDoubleStruct::operator =(
        const FinalDoubleStruct& x)
{

    m_var_double = x.m_var_double;

    return *this;
}

FinalDoubleStruct& FinalDoubleStruct::operator =(
        FinalDoubleStruct&& x) noexcept
{

    m_var_double = x.m_var_double;

    return *this;
}

bool FinalDoubleStruct::operator ==(
        const FinalDoubleStruct& x) const
{

    return (m_var_double == x.m_var_double);
}

bool FinalDoubleStruct::operator !=(
        const FinalDoubleStruct& x) const
{
    return !(*this == x);
}

size_t FinalDoubleStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalDoubleStruct_max_cdr_typesize;
}

size_t FinalDoubleStruct::getCdrSerializedSize(
        const FinalDoubleStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void FinalDoubleStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_double;
}

void FinalDoubleStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_double;
}

/*!
 * @brief This function sets a value in member var_double
 * @param _var_double New value for member var_double
 */
void FinalDoubleStruct::var_double(
        double _var_double)
{
    m_var_double = _var_double;
}

/*!
 * @brief This function returns the value of member var_double
 * @return Value of member var_double
 */
double FinalDoubleStruct::var_double() const
{
    return m_var_double;
}

/*!
 * @brief This function returns a reference to member var_double
 * @return Reference to member var_double
 */
double& FinalDoubleStruct::var_double()
{
    return m_var_double;
}



size_t FinalDoubleStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalDoubleStruct_max_key_cdr_typesize;
}

bool FinalDoubleStruct::isKeyDefined()
{
    return false;
}

void FinalDoubleStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FinalLongDoubleStruct::FinalLongDoubleStruct()
{
    // long double m_var_longdouble
    m_var_longdouble = 0.0;

    // Just to register all known types
    registerfinalTypes();
}

FinalLongDoubleStruct::~FinalLongDoubleStruct()
{
}

FinalLongDoubleStruct::FinalLongDoubleStruct(
        const FinalLongDoubleStruct& x)
{
    m_var_longdouble = x.m_var_longdouble;
}

FinalLongDoubleStruct::FinalLongDoubleStruct(
        FinalLongDoubleStruct&& x) noexcept 
{
    m_var_longdouble = x.m_var_longdouble;
}

FinalLongDoubleStruct& FinalLongDoubleStruct::operator =(
        const FinalLongDoubleStruct& x)
{

    m_var_longdouble = x.m_var_longdouble;

    return *this;
}

FinalLongDoubleStruct& FinalLongDoubleStruct::operator =(
        FinalLongDoubleStruct&& x) noexcept
{

    m_var_longdouble = x.m_var_longdouble;

    return *this;
}

bool FinalLongDoubleStruct::operator ==(
        const FinalLongDoubleStruct& x) const
{

    return (m_var_longdouble == x.m_var_longdouble);
}

bool FinalLongDoubleStruct::operator !=(
        const FinalLongDoubleStruct& x) const
{
    return !(*this == x);
}

size_t FinalLongDoubleStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalLongDoubleStruct_max_cdr_typesize;
}

size_t FinalLongDoubleStruct::getCdrSerializedSize(
        const FinalLongDoubleStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 16 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8); // 128 bits, but aligned as 64


    return current_alignment - initial_alignment;
}

void FinalLongDoubleStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_longdouble;
}

void FinalLongDoubleStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_longdouble;
}

/*!
 * @brief This function sets a value in member var_longdouble
 * @param _var_longdouble New value for member var_longdouble
 */
void FinalLongDoubleStruct::var_longdouble(
        long double _var_longdouble)
{
    m_var_longdouble = _var_longdouble;
}

/*!
 * @brief This function returns the value of member var_longdouble
 * @return Value of member var_longdouble
 */
long double FinalLongDoubleStruct::var_longdouble() const
{
    return m_var_longdouble;
}

/*!
 * @brief This function returns a reference to member var_longdouble
 * @return Reference to member var_longdouble
 */
long double& FinalLongDoubleStruct::var_longdouble()
{
    return m_var_longdouble;
}



size_t FinalLongDoubleStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalLongDoubleStruct_max_key_cdr_typesize;
}

bool FinalLongDoubleStruct::isKeyDefined()
{
    return false;
}

void FinalLongDoubleStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FinalBooleanStruct::FinalBooleanStruct()
{
    // boolean m_var_boolean
    m_var_boolean = false;

    // Just to register all known types
    registerfinalTypes();
}

FinalBooleanStruct::~FinalBooleanStruct()
{
}

FinalBooleanStruct::FinalBooleanStruct(
        const FinalBooleanStruct& x)
{
    m_var_boolean = x.m_var_boolean;
}

FinalBooleanStruct::FinalBooleanStruct(
        FinalBooleanStruct&& x) noexcept 
{
    m_var_boolean = x.m_var_boolean;
}

FinalBooleanStruct& FinalBooleanStruct::operator =(
        const FinalBooleanStruct& x)
{

    m_var_boolean = x.m_var_boolean;

    return *this;
}

FinalBooleanStruct& FinalBooleanStruct::operator =(
        FinalBooleanStruct&& x) noexcept
{

    m_var_boolean = x.m_var_boolean;

    return *this;
}

bool FinalBooleanStruct::operator ==(
        const FinalBooleanStruct& x) const
{

    return (m_var_boolean == x.m_var_boolean);
}

bool FinalBooleanStruct::operator !=(
        const FinalBooleanStruct& x) const
{
    return !(*this == x);
}

size_t FinalBooleanStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalBooleanStruct_max_cdr_typesize;
}

size_t FinalBooleanStruct::getCdrSerializedSize(
        const FinalBooleanStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void FinalBooleanStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_boolean;
}

void FinalBooleanStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_boolean;
}

/*!
 * @brief This function sets a value in member var_boolean
 * @param _var_boolean New value for member var_boolean
 */
void FinalBooleanStruct::var_boolean(
        bool _var_boolean)
{
    m_var_boolean = _var_boolean;
}

/*!
 * @brief This function returns the value of member var_boolean
 * @return Value of member var_boolean
 */
bool FinalBooleanStruct::var_boolean() const
{
    return m_var_boolean;
}

/*!
 * @brief This function returns a reference to member var_boolean
 * @return Reference to member var_boolean
 */
bool& FinalBooleanStruct::var_boolean()
{
    return m_var_boolean;
}



size_t FinalBooleanStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalBooleanStruct_max_key_cdr_typesize;
}

bool FinalBooleanStruct::isKeyDefined()
{
    return false;
}

void FinalBooleanStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FinalOctetStruct::FinalOctetStruct()
{
    // octet m_var_octet
    m_var_octet = 0;

    // Just to register all known types
    registerfinalTypes();
}

FinalOctetStruct::~FinalOctetStruct()
{
}

FinalOctetStruct::FinalOctetStruct(
        const FinalOctetStruct& x)
{
    m_var_octet = x.m_var_octet;
}

FinalOctetStruct::FinalOctetStruct(
        FinalOctetStruct&& x) noexcept 
{
    m_var_octet = x.m_var_octet;
}

FinalOctetStruct& FinalOctetStruct::operator =(
        const FinalOctetStruct& x)
{

    m_var_octet = x.m_var_octet;

    return *this;
}

FinalOctetStruct& FinalOctetStruct::operator =(
        FinalOctetStruct&& x) noexcept
{

    m_var_octet = x.m_var_octet;

    return *this;
}

bool FinalOctetStruct::operator ==(
        const FinalOctetStruct& x) const
{

    return (m_var_octet == x.m_var_octet);
}

bool FinalOctetStruct::operator !=(
        const FinalOctetStruct& x) const
{
    return !(*this == x);
}

size_t FinalOctetStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalOctetStruct_max_cdr_typesize;
}

size_t FinalOctetStruct::getCdrSerializedSize(
        const FinalOctetStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void FinalOctetStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_octet;
}

void FinalOctetStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_octet;
}

/*!
 * @brief This function sets a value in member var_octet
 * @param _var_octet New value for member var_octet
 */
void FinalOctetStruct::var_octet(
        uint8_t _var_octet)
{
    m_var_octet = _var_octet;
}

/*!
 * @brief This function returns the value of member var_octet
 * @return Value of member var_octet
 */
uint8_t FinalOctetStruct::var_octet() const
{
    return m_var_octet;
}

/*!
 * @brief This function returns a reference to member var_octet
 * @return Reference to member var_octet
 */
uint8_t& FinalOctetStruct::var_octet()
{
    return m_var_octet;
}



size_t FinalOctetStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalOctetStruct_max_key_cdr_typesize;
}

bool FinalOctetStruct::isKeyDefined()
{
    return false;
}

void FinalOctetStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FinalCharStruct::FinalCharStruct()
{
    // char m_var_char8
    m_var_char8 = 0;

    // Just to register all known types
    registerfinalTypes();
}

FinalCharStruct::~FinalCharStruct()
{
}

FinalCharStruct::FinalCharStruct(
        const FinalCharStruct& x)
{
    m_var_char8 = x.m_var_char8;
}

FinalCharStruct::FinalCharStruct(
        FinalCharStruct&& x) noexcept 
{
    m_var_char8 = x.m_var_char8;
}

FinalCharStruct& FinalCharStruct::operator =(
        const FinalCharStruct& x)
{

    m_var_char8 = x.m_var_char8;

    return *this;
}

FinalCharStruct& FinalCharStruct::operator =(
        FinalCharStruct&& x) noexcept
{

    m_var_char8 = x.m_var_char8;

    return *this;
}

bool FinalCharStruct::operator ==(
        const FinalCharStruct& x) const
{

    return (m_var_char8 == x.m_var_char8);
}

bool FinalCharStruct::operator !=(
        const FinalCharStruct& x) const
{
    return !(*this == x);
}

size_t FinalCharStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalCharStruct_max_cdr_typesize;
}

size_t FinalCharStruct::getCdrSerializedSize(
        const FinalCharStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void FinalCharStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_char8;
}

void FinalCharStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_char8;
}

/*!
 * @brief This function sets a value in member var_char8
 * @param _var_char8 New value for member var_char8
 */
void FinalCharStruct::var_char8(
        char _var_char8)
{
    m_var_char8 = _var_char8;
}

/*!
 * @brief This function returns the value of member var_char8
 * @return Value of member var_char8
 */
char FinalCharStruct::var_char8() const
{
    return m_var_char8;
}

/*!
 * @brief This function returns a reference to member var_char8
 * @return Reference to member var_char8
 */
char& FinalCharStruct::var_char8()
{
    return m_var_char8;
}



size_t FinalCharStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalCharStruct_max_key_cdr_typesize;
}

bool FinalCharStruct::isKeyDefined()
{
    return false;
}

void FinalCharStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FinalWCharStruct::FinalWCharStruct()
{
    // wchar m_var_char16
    m_var_char16 = 0;

    // Just to register all known types
    registerfinalTypes();
}

FinalWCharStruct::~FinalWCharStruct()
{
}

FinalWCharStruct::FinalWCharStruct(
        const FinalWCharStruct& x)
{
    m_var_char16 = x.m_var_char16;
}

FinalWCharStruct::FinalWCharStruct(
        FinalWCharStruct&& x) noexcept 
{
    m_var_char16 = x.m_var_char16;
}

FinalWCharStruct& FinalWCharStruct::operator =(
        const FinalWCharStruct& x)
{

    m_var_char16 = x.m_var_char16;

    return *this;
}

FinalWCharStruct& FinalWCharStruct::operator =(
        FinalWCharStruct&& x) noexcept
{

    m_var_char16 = x.m_var_char16;

    return *this;
}

bool FinalWCharStruct::operator ==(
        const FinalWCharStruct& x) const
{

    return (m_var_char16 == x.m_var_char16);
}

bool FinalWCharStruct::operator !=(
        const FinalWCharStruct& x) const
{
    return !(*this == x);
}

size_t FinalWCharStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalWCharStruct_max_cdr_typesize;
}

size_t FinalWCharStruct::getCdrSerializedSize(
        const FinalWCharStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void FinalWCharStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_char16;
}

void FinalWCharStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_char16;
}

/*!
 * @brief This function sets a value in member var_char16
 * @param _var_char16 New value for member var_char16
 */
void FinalWCharStruct::var_char16(
        wchar_t _var_char16)
{
    m_var_char16 = _var_char16;
}

/*!
 * @brief This function returns the value of member var_char16
 * @return Value of member var_char16
 */
wchar_t FinalWCharStruct::var_char16() const
{
    return m_var_char16;
}

/*!
 * @brief This function returns a reference to member var_char16
 * @return Reference to member var_char16
 */
wchar_t& FinalWCharStruct::var_char16()
{
    return m_var_char16;
}



size_t FinalWCharStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalWCharStruct_max_key_cdr_typesize;
}

bool FinalWCharStruct::isKeyDefined()
{
    return false;
}

void FinalWCharStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FinalEmptyStruct::FinalEmptyStruct()
{

    // Just to register all known types
    registerfinalTypes();
}

FinalEmptyStruct::~FinalEmptyStruct()
{
}

FinalEmptyStruct::FinalEmptyStruct(
        const FinalEmptyStruct& x)
{
}

FinalEmptyStruct::FinalEmptyStruct(
        FinalEmptyStruct&& x) noexcept 
{
}

FinalEmptyStruct& FinalEmptyStruct::operator =(
        const FinalEmptyStruct& x)
{


    return *this;
}

FinalEmptyStruct& FinalEmptyStruct::operator =(
        FinalEmptyStruct&& x) noexcept
{


    return *this;
}

bool FinalEmptyStruct::operator ==(
        const FinalEmptyStruct& x) const
{

    return true;
}

bool FinalEmptyStruct::operator !=(
        const FinalEmptyStruct& x) const
{
    return !(*this == x);
}

size_t FinalEmptyStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalEmptyStruct_max_cdr_typesize;
}

size_t FinalEmptyStruct::getCdrSerializedSize(
        const FinalEmptyStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    return current_alignment - initial_alignment;
}

void FinalEmptyStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

}

void FinalEmptyStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

}



size_t FinalEmptyStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalEmptyStruct_max_key_cdr_typesize;
}

bool FinalEmptyStruct::isKeyDefined()
{
    return false;
}

void FinalEmptyStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FinalEmptyInheritanceStruct::FinalEmptyInheritanceStruct()    : FinalEmptyStruct() 
{
    // string m_var_str
    m_var_str = "";


    // Just to register all known types
    registerfinalTypes();
}

FinalEmptyInheritanceStruct::~FinalEmptyInheritanceStruct()
{
}

FinalEmptyInheritanceStruct::FinalEmptyInheritanceStruct(
        const FinalEmptyInheritanceStruct& x)    : FinalEmptyStruct(x) 
{
    m_var_str = x.m_var_str;
}

FinalEmptyInheritanceStruct::FinalEmptyInheritanceStruct(
        FinalEmptyInheritanceStruct&& x) noexcept     : FinalEmptyStruct(std::move(x)) 
{
    m_var_str = std::move(x.m_var_str);
}

FinalEmptyInheritanceStruct& FinalEmptyInheritanceStruct::operator =(
        const FinalEmptyInheritanceStruct& x)
{
    FinalEmptyStruct::operator =(x); 

    m_var_str = x.m_var_str;

    return *this;
}

FinalEmptyInheritanceStruct& FinalEmptyInheritanceStruct::operator =(
        FinalEmptyInheritanceStruct&& x) noexcept
{
    FinalEmptyStruct::operator =(std::move(x)); 

    m_var_str = std::move(x.m_var_str);

    return *this;
}

bool FinalEmptyInheritanceStruct::operator ==(
        const FinalEmptyInheritanceStruct& x) const
{
     if (FinalEmptyStruct::operator !=(x)) return false; 

    return (m_var_str == x.m_var_str);
}

bool FinalEmptyInheritanceStruct::operator !=(
        const FinalEmptyInheritanceStruct& x) const
{
    return !(*this == x);
}

size_t FinalEmptyInheritanceStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalEmptyInheritanceStruct_max_cdr_typesize;
}

size_t FinalEmptyInheritanceStruct::getCdrSerializedSize(
        const FinalEmptyInheritanceStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += FinalEmptyStruct::getCdrSerializedSize(data, current_alignment); 

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_str().size() + 1;

    return current_alignment - initial_alignment;
}

void FinalEmptyInheritanceStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    FinalEmptyStruct::serialize(scdr); 

    scdr << m_var_str.c_str();
}

void FinalEmptyInheritanceStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    FinalEmptyStruct::deserialize(dcdr); 

    dcdr >> m_var_str;}

/*!
 * @brief This function copies the value in member var_str
 * @param _var_str New value to be copied in member var_str
 */
void FinalEmptyInheritanceStruct::var_str(
        const std::string& _var_str)
{
    m_var_str = _var_str;
}

/*!
 * @brief This function moves the value in member var_str
 * @param _var_str New value to be moved in member var_str
 */
void FinalEmptyInheritanceStruct::var_str(
        std::string&& _var_str)
{
    m_var_str = std::move(_var_str);
}

/*!
 * @brief This function returns a constant reference to member var_str
 * @return Constant reference to member var_str
 */
const std::string& FinalEmptyInheritanceStruct::var_str() const
{
    return m_var_str;
}

/*!
 * @brief This function returns a reference to member var_str
 * @return Reference to member var_str
 */
std::string& FinalEmptyInheritanceStruct::var_str()
{
    return m_var_str;
}


size_t FinalEmptyInheritanceStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalEmptyInheritanceStruct_max_key_cdr_typesize;
}

bool FinalEmptyInheritanceStruct::isKeyDefined()
{
    if (FinalEmptyStruct::isKeyDefined())
        return true;
     return false;
}

void FinalEmptyInheritanceStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
 FinalEmptyStruct::serializeKey(scdr);  
}


FinalInheritanceStruct::FinalInheritanceStruct()    : FinalShortStruct() 
{
    // string m_var_str
    m_var_str = "";


    // Just to register all known types
    registerfinalTypes();
}

FinalInheritanceStruct::~FinalInheritanceStruct()
{
}

FinalInheritanceStruct::FinalInheritanceStruct(
        const FinalInheritanceStruct& x)    : FinalShortStruct(x) 
{
    m_var_str = x.m_var_str;
}

FinalInheritanceStruct::FinalInheritanceStruct(
        FinalInheritanceStruct&& x) noexcept     : FinalShortStruct(std::move(x)) 
{
    m_var_str = std::move(x.m_var_str);
}

FinalInheritanceStruct& FinalInheritanceStruct::operator =(
        const FinalInheritanceStruct& x)
{
    FinalShortStruct::operator =(x); 

    m_var_str = x.m_var_str;

    return *this;
}

FinalInheritanceStruct& FinalInheritanceStruct::operator =(
        FinalInheritanceStruct&& x) noexcept
{
    FinalShortStruct::operator =(std::move(x)); 

    m_var_str = std::move(x.m_var_str);

    return *this;
}

bool FinalInheritanceStruct::operator ==(
        const FinalInheritanceStruct& x) const
{
     if (FinalShortStruct::operator !=(x)) return false; 

    return (m_var_str == x.m_var_str);
}

bool FinalInheritanceStruct::operator !=(
        const FinalInheritanceStruct& x) const
{
    return !(*this == x);
}

size_t FinalInheritanceStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalInheritanceStruct_max_cdr_typesize;
}

size_t FinalInheritanceStruct::getCdrSerializedSize(
        const FinalInheritanceStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += FinalShortStruct::getCdrSerializedSize(data, current_alignment); 

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_str().size() + 1;

    return current_alignment - initial_alignment;
}

void FinalInheritanceStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    FinalShortStruct::serialize(scdr); 

    scdr << m_var_str.c_str();
}

void FinalInheritanceStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    FinalShortStruct::deserialize(dcdr); 

    dcdr >> m_var_str;}

/*!
 * @brief This function copies the value in member var_str
 * @param _var_str New value to be copied in member var_str
 */
void FinalInheritanceStruct::var_str(
        const std::string& _var_str)
{
    m_var_str = _var_str;
}

/*!
 * @brief This function moves the value in member var_str
 * @param _var_str New value to be moved in member var_str
 */
void FinalInheritanceStruct::var_str(
        std::string&& _var_str)
{
    m_var_str = std::move(_var_str);
}

/*!
 * @brief This function returns a constant reference to member var_str
 * @return Constant reference to member var_str
 */
const std::string& FinalInheritanceStruct::var_str() const
{
    return m_var_str;
}

/*!
 * @brief This function returns a reference to member var_str
 * @return Reference to member var_str
 */
std::string& FinalInheritanceStruct::var_str()
{
    return m_var_str;
}


size_t FinalInheritanceStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FinalInheritanceStruct_max_key_cdr_typesize;
}

bool FinalInheritanceStruct::isKeyDefined()
{
    if (FinalShortStruct::isKeyDefined())
        return true;
     return false;
}

void FinalInheritanceStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
 FinalShortStruct::serializeKey(scdr);  
}


InheritanceEmptyStruct::InheritanceEmptyStruct()    : FinalShortStruct() 
{

    // Just to register all known types
    registerfinalTypes();
}

InheritanceEmptyStruct::~InheritanceEmptyStruct()
{
}

InheritanceEmptyStruct::InheritanceEmptyStruct(
        const InheritanceEmptyStruct& x)    : FinalShortStruct(x) 
{
}

InheritanceEmptyStruct::InheritanceEmptyStruct(
        InheritanceEmptyStruct&& x) noexcept     : FinalShortStruct(std::move(x)) 
{
}

InheritanceEmptyStruct& InheritanceEmptyStruct::operator =(
        const InheritanceEmptyStruct& x)
{
    FinalShortStruct::operator =(x); 


    return *this;
}

InheritanceEmptyStruct& InheritanceEmptyStruct::operator =(
        InheritanceEmptyStruct&& x) noexcept
{
    FinalShortStruct::operator =(std::move(x)); 


    return *this;
}

bool InheritanceEmptyStruct::operator ==(
        const InheritanceEmptyStruct& x) const
{
     if (FinalShortStruct::operator !=(x)) return false; 

    return true;
}

bool InheritanceEmptyStruct::operator !=(
        const InheritanceEmptyStruct& x) const
{
    return !(*this == x);
}

size_t InheritanceEmptyStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return InheritanceEmptyStruct_max_cdr_typesize;
}

size_t InheritanceEmptyStruct::getCdrSerializedSize(
        const InheritanceEmptyStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += FinalShortStruct::getCdrSerializedSize(data, current_alignment); 


    return current_alignment - initial_alignment;
}

void InheritanceEmptyStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    FinalShortStruct::serialize(scdr); 

}

void InheritanceEmptyStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    FinalShortStruct::deserialize(dcdr); 

}



size_t InheritanceEmptyStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return InheritanceEmptyStruct_max_key_cdr_typesize;
}

bool InheritanceEmptyStruct::isKeyDefined()
{
    if (FinalShortStruct::isKeyDefined())
        return true;
     return false;
}

void InheritanceEmptyStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
 FinalShortStruct::serializeKey(scdr);  
}

