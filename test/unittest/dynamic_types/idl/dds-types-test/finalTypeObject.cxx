// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file finalTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "final.h"
#include "finalTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

void registerfinalTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("FinalShortStruct", GetFinalShortStructIdentifier(true),
                GetFinalShortStructObject(true));
                factory->add_type_object("FinalShortStruct", GetFinalShortStructIdentifier(false),
                GetFinalShortStructObject(false));

                factory->add_type_object("FinalUShortStruct", GetFinalUShortStructIdentifier(true),
                GetFinalUShortStructObject(true));
                factory->add_type_object("FinalUShortStruct", GetFinalUShortStructIdentifier(false),
                GetFinalUShortStructObject(false));

                factory->add_type_object("FinalLongStruct", GetFinalLongStructIdentifier(true),
                GetFinalLongStructObject(true));
                factory->add_type_object("FinalLongStruct", GetFinalLongStructIdentifier(false),
                GetFinalLongStructObject(false));

                factory->add_type_object("FinalULongStruct", GetFinalULongStructIdentifier(true),
                GetFinalULongStructObject(true));
                factory->add_type_object("FinalULongStruct", GetFinalULongStructIdentifier(false),
                GetFinalULongStructObject(false));

                factory->add_type_object("FinalLongLongStruct", GetFinalLongLongStructIdentifier(true),
                GetFinalLongLongStructObject(true));
                factory->add_type_object("FinalLongLongStruct", GetFinalLongLongStructIdentifier(false),
                GetFinalLongLongStructObject(false));

                factory->add_type_object("FinalULongLongStruct", GetFinalULongLongStructIdentifier(true),
                GetFinalULongLongStructObject(true));
                factory->add_type_object("FinalULongLongStruct", GetFinalULongLongStructIdentifier(false),
                GetFinalULongLongStructObject(false));

                factory->add_type_object("FinalFloatStruct", GetFinalFloatStructIdentifier(true),
                GetFinalFloatStructObject(true));
                factory->add_type_object("FinalFloatStruct", GetFinalFloatStructIdentifier(false),
                GetFinalFloatStructObject(false));

                factory->add_type_object("FinalDoubleStruct", GetFinalDoubleStructIdentifier(true),
                GetFinalDoubleStructObject(true));
                factory->add_type_object("FinalDoubleStruct", GetFinalDoubleStructIdentifier(false),
                GetFinalDoubleStructObject(false));

                factory->add_type_object("FinalLongDoubleStruct", GetFinalLongDoubleStructIdentifier(true),
                GetFinalLongDoubleStructObject(true));
                factory->add_type_object("FinalLongDoubleStruct", GetFinalLongDoubleStructIdentifier(false),
                GetFinalLongDoubleStructObject(false));

                factory->add_type_object("FinalBooleanStruct", GetFinalBooleanStructIdentifier(true),
                GetFinalBooleanStructObject(true));
                factory->add_type_object("FinalBooleanStruct", GetFinalBooleanStructIdentifier(false),
                GetFinalBooleanStructObject(false));

                factory->add_type_object("FinalOctetStruct", GetFinalOctetStructIdentifier(true),
                GetFinalOctetStructObject(true));
                factory->add_type_object("FinalOctetStruct", GetFinalOctetStructIdentifier(false),
                GetFinalOctetStructObject(false));

                factory->add_type_object("FinalCharStruct", GetFinalCharStructIdentifier(true),
                GetFinalCharStructObject(true));
                factory->add_type_object("FinalCharStruct", GetFinalCharStructIdentifier(false),
                GetFinalCharStructObject(false));

                factory->add_type_object("FinalWCharStruct", GetFinalWCharStructIdentifier(true),
                GetFinalWCharStructObject(true));
                factory->add_type_object("FinalWCharStruct", GetFinalWCharStructIdentifier(false),
                GetFinalWCharStructObject(false));

                factory->add_type_object("FinalEmptyStruct", GetFinalEmptyStructIdentifier(true),
                GetFinalEmptyStructObject(true));
                factory->add_type_object("FinalEmptyStruct", GetFinalEmptyStructIdentifier(false),
                GetFinalEmptyStructObject(false));

                factory->add_type_object("FinalEmptyInheritanceStruct", GetFinalEmptyInheritanceStructIdentifier(true),
                GetFinalEmptyInheritanceStructObject(true));
                factory->add_type_object("FinalEmptyInheritanceStruct", GetFinalEmptyInheritanceStructIdentifier(false),
                GetFinalEmptyInheritanceStructObject(false));

                factory->add_type_object("FinalInheritanceStruct", GetFinalInheritanceStructIdentifier(true),
                GetFinalInheritanceStructObject(true));
                factory->add_type_object("FinalInheritanceStruct", GetFinalInheritanceStructIdentifier(false),
                GetFinalInheritanceStructObject(false));

                factory->add_type_object("InheritanceEmptyStruct", GetInheritanceEmptyStructIdentifier(true),
                GetInheritanceEmptyStructObject(true));
                factory->add_type_object("InheritanceEmptyStruct", GetInheritanceEmptyStructIdentifier(false),
                GetInheritanceEmptyStructObject(false));

            });
}

const TypeIdentifier* GetFinalShortStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalShortStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalShortStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalShortStruct", complete);
}

const TypeObject* GetFinalShortStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalShortStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalShortStructObject();
    }
    //else
    return GetMinimalFinalShortStructObject();
}

const TypeObject* GetMinimalFinalShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalShortStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_short;
    mst_var_short.common().member_id(memberId++);
    mst_var_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_short.common().member_flags().IS_KEY(false);
    mst_var_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    MD5 var_short_hash("var_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_short.detail().name_hash()[i] = var_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalShortStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalShortStruct", false);
}

const TypeObject* GetCompleteFinalShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalShortStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_short;
    cst_var_short.common().member_id(memberId++);
    cst_var_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_short.common().member_flags().IS_KEY(false);
    cst_var_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    cst_var_short.detail().name("var_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalShortStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalShortStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalShortStruct", true);
}

const TypeIdentifier* GetFinalUShortStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalUShortStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalUShortStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalUShortStruct", complete);
}

const TypeObject* GetFinalUShortStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalUShortStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalUShortStructObject();
    }
    //else
    return GetMinimalFinalUShortStructObject();
}

const TypeObject* GetMinimalFinalUShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalUShortStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ushort;
    mst_var_ushort.common().member_id(memberId++);
    mst_var_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ushort.common().member_flags().IS_KEY(false);
    mst_var_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 var_ushort_hash("var_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ushort.detail().name_hash()[i] = var_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalUShortStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalUShortStruct", false);
}

const TypeObject* GetCompleteFinalUShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalUShortStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ushort;
    cst_var_ushort.common().member_id(memberId++);
    cst_var_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ushort.common().member_flags().IS_KEY(false);
    cst_var_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_var_ushort.detail().name("var_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalUShortStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalUShortStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalUShortStruct", true);
}

const TypeIdentifier* GetFinalLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalLongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalLongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalLongStruct", complete);
}

const TypeObject* GetFinalLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalLongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalLongStructObject();
    }
    //else
    return GetMinimalFinalLongStructObject();
}

const TypeObject* GetMinimalFinalLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalLongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_long;
    mst_var_long.common().member_id(memberId++);
    mst_var_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_long.common().member_flags().IS_KEY(false);
    mst_var_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MD5 var_long_hash("var_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_long.detail().name_hash()[i] = var_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalLongStruct", false);
}

const TypeObject* GetCompleteFinalLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalLongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_long;
    cst_var_long.common().member_id(memberId++);
    cst_var_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_long.common().member_flags().IS_KEY(false);
    cst_var_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    cst_var_long.detail().name("var_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalLongStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalLongStruct", true);
}

const TypeIdentifier* GetFinalULongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalULongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalULongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalULongStruct", complete);
}

const TypeObject* GetFinalULongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalULongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalULongStructObject();
    }
    //else
    return GetMinimalFinalULongStructObject();
}

const TypeObject* GetMinimalFinalULongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalULongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ulong;
    mst_var_ulong.common().member_id(memberId++);
    mst_var_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ulong.common().member_flags().IS_KEY(false);
    mst_var_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 var_ulong_hash("var_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ulong.detail().name_hash()[i] = var_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalULongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalULongStruct", false);
}

const TypeObject* GetCompleteFinalULongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalULongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ulong;
    cst_var_ulong.common().member_id(memberId++);
    cst_var_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ulong.common().member_flags().IS_KEY(false);
    cst_var_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_var_ulong.detail().name("var_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalULongStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalULongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalULongStruct", true);
}

const TypeIdentifier* GetFinalLongLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalLongLongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalLongLongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalLongLongStruct", complete);
}

const TypeObject* GetFinalLongLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalLongLongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalLongLongStructObject();
    }
    //else
    return GetMinimalFinalLongLongStructObject();
}

const TypeObject* GetMinimalFinalLongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalLongLongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_longlong;
    mst_var_longlong.common().member_id(memberId++);
    mst_var_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_longlong.common().member_flags().IS_KEY(false);
    mst_var_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    MD5 var_longlong_hash("var_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_longlong.detail().name_hash()[i] = var_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalLongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalLongLongStruct", false);
}

const TypeObject* GetCompleteFinalLongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalLongLongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_longlong;
    cst_var_longlong.common().member_id(memberId++);
    cst_var_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_longlong.common().member_flags().IS_KEY(false);
    cst_var_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    cst_var_longlong.detail().name("var_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalLongLongStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalLongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalLongLongStruct", true);
}

const TypeIdentifier* GetFinalULongLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalULongLongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalULongLongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalULongLongStruct", complete);
}

const TypeObject* GetFinalULongLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalULongLongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalULongLongStructObject();
    }
    //else
    return GetMinimalFinalULongLongStructObject();
}

const TypeObject* GetMinimalFinalULongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalULongLongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ulonglong;
    mst_var_ulonglong.common().member_id(memberId++);
    mst_var_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    MD5 var_ulonglong_hash("var_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ulonglong.detail().name_hash()[i] = var_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalULongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalULongLongStruct", false);
}

const TypeObject* GetCompleteFinalULongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalULongLongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ulonglong;
    cst_var_ulonglong.common().member_id(memberId++);
    cst_var_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    cst_var_ulonglong.detail().name("var_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalULongLongStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalULongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalULongLongStruct", true);
}

const TypeIdentifier* GetFinalFloatStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalFloatStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalFloatStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalFloatStruct", complete);
}

const TypeObject* GetFinalFloatStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalFloatStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalFloatStructObject();
    }
    //else
    return GetMinimalFinalFloatStructObject();
}

const TypeObject* GetMinimalFinalFloatStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalFloatStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_float;
    mst_var_float.common().member_id(memberId++);
    mst_var_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_float.common().member_flags().IS_KEY(false);
    mst_var_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 var_float_hash("var_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_float.detail().name_hash()[i] = var_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalFloatStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalFloatStruct", false);
}

const TypeObject* GetCompleteFinalFloatStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalFloatStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_float;
    cst_var_float.common().member_id(memberId++);
    cst_var_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_float.common().member_flags().IS_KEY(false);
    cst_var_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_var_float.detail().name("var_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalFloatStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalFloatStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalFloatStruct", true);
}

const TypeIdentifier* GetFinalDoubleStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalDoubleStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalDoubleStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalDoubleStruct", complete);
}

const TypeObject* GetFinalDoubleStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalDoubleStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalDoubleStructObject();
    }
    //else
    return GetMinimalFinalDoubleStructObject();
}

const TypeObject* GetMinimalFinalDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalDoubleStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_double;
    mst_var_double.common().member_id(memberId++);
    mst_var_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_double.common().member_flags().IS_KEY(false);
    mst_var_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    MD5 var_double_hash("var_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_double.detail().name_hash()[i] = var_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalDoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalDoubleStruct", false);
}

const TypeObject* GetCompleteFinalDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalDoubleStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_double;
    cst_var_double.common().member_id(memberId++);
    cst_var_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_double.common().member_flags().IS_KEY(false);
    cst_var_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    cst_var_double.detail().name("var_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalDoubleStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalDoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalDoubleStruct", true);
}

const TypeIdentifier* GetFinalLongDoubleStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalLongDoubleStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalLongDoubleStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalLongDoubleStruct", complete);
}

const TypeObject* GetFinalLongDoubleStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalLongDoubleStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalLongDoubleStructObject();
    }
    //else
    return GetMinimalFinalLongDoubleStructObject();
}

const TypeObject* GetMinimalFinalLongDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalLongDoubleStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_longdouble;
    mst_var_longdouble.common().member_id(memberId++);
    mst_var_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_longdouble.common().member_flags().IS_KEY(false);
    mst_var_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    MD5 var_longdouble_hash("var_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_longdouble.detail().name_hash()[i] = var_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalLongDoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalLongDoubleStruct", false);
}

const TypeObject* GetCompleteFinalLongDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalLongDoubleStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_longdouble;
    cst_var_longdouble.common().member_id(memberId++);
    cst_var_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_longdouble.common().member_flags().IS_KEY(false);
    cst_var_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    cst_var_longdouble.detail().name("var_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalLongDoubleStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalLongDoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalLongDoubleStruct", true);
}

const TypeIdentifier* GetFinalBooleanStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalBooleanStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalBooleanStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalBooleanStruct", complete);
}

const TypeObject* GetFinalBooleanStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalBooleanStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalBooleanStructObject();
    }
    //else
    return GetMinimalFinalBooleanStructObject();
}

const TypeObject* GetMinimalFinalBooleanStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalBooleanStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_boolean;
    mst_var_boolean.common().member_id(memberId++);
    mst_var_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_boolean.common().member_flags().IS_KEY(false);
    mst_var_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    MD5 var_boolean_hash("var_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_boolean.detail().name_hash()[i] = var_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalBooleanStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalBooleanStruct", false);
}

const TypeObject* GetCompleteFinalBooleanStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalBooleanStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_boolean;
    cst_var_boolean.common().member_id(memberId++);
    cst_var_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_boolean.common().member_flags().IS_KEY(false);
    cst_var_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    cst_var_boolean.detail().name("var_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalBooleanStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalBooleanStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalBooleanStruct", true);
}

const TypeIdentifier* GetFinalOctetStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalOctetStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalOctetStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalOctetStruct", complete);
}

const TypeObject* GetFinalOctetStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalOctetStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalOctetStructObject();
    }
    //else
    return GetMinimalFinalOctetStructObject();
}

const TypeObject* GetMinimalFinalOctetStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalOctetStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_octet;
    mst_var_octet.common().member_id(memberId++);
    mst_var_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_octet.common().member_flags().IS_KEY(false);
    mst_var_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 var_octet_hash("var_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_octet.detail().name_hash()[i] = var_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalOctetStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalOctetStruct", false);
}

const TypeObject* GetCompleteFinalOctetStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalOctetStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_octet;
    cst_var_octet.common().member_id(memberId++);
    cst_var_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_octet.common().member_flags().IS_KEY(false);
    cst_var_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_var_octet.detail().name("var_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalOctetStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalOctetStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalOctetStruct", true);
}

const TypeIdentifier* GetFinalCharStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalCharStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalCharStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalCharStruct", complete);
}

const TypeObject* GetFinalCharStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalCharStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalCharStructObject();
    }
    //else
    return GetMinimalFinalCharStructObject();
}

const TypeObject* GetMinimalFinalCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalCharStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_char8;
    mst_var_char8.common().member_id(memberId++);
    mst_var_char8.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_char8.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_char8.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_char8.common().member_flags().IS_OPTIONAL(false);
    mst_var_char8.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_char8.common().member_flags().IS_KEY(false);
    mst_var_char8.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_char8.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    MD5 var_char8_hash("var_char8");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_char8.detail().name_hash()[i] = var_char8_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_char8);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalCharStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalCharStruct", false);
}

const TypeObject* GetCompleteFinalCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalCharStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_char8;
    cst_var_char8.common().member_id(memberId++);
    cst_var_char8.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_char8.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_char8.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_char8.common().member_flags().IS_OPTIONAL(false);
    cst_var_char8.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_char8.common().member_flags().IS_KEY(false);
    cst_var_char8.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_char8.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    cst_var_char8.detail().name("var_char8");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_char8);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalCharStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalCharStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalCharStruct", true);
}

const TypeIdentifier* GetFinalWCharStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalWCharStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalWCharStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalWCharStruct", complete);
}

const TypeObject* GetFinalWCharStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalWCharStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalWCharStructObject();
    }
    //else
    return GetMinimalFinalWCharStructObject();
}

const TypeObject* GetMinimalFinalWCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalWCharStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_char16;
    mst_var_char16.common().member_id(memberId++);
    mst_var_char16.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_char16.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_char16.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_char16.common().member_flags().IS_OPTIONAL(false);
    mst_var_char16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_char16.common().member_flags().IS_KEY(false);
    mst_var_char16.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_char16.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    MD5 var_char16_hash("var_char16");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_char16.detail().name_hash()[i] = var_char16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_char16);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalWCharStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalWCharStruct", false);
}

const TypeObject* GetCompleteFinalWCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalWCharStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_char16;
    cst_var_char16.common().member_id(memberId++);
    cst_var_char16.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_char16.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_char16.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_char16.common().member_flags().IS_OPTIONAL(false);
    cst_var_char16.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_char16.common().member_flags().IS_KEY(false);
    cst_var_char16.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_char16.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    cst_var_char16.detail().name("var_char16");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_char16);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalWCharStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalWCharStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalWCharStruct", true);
}

const TypeIdentifier* GetFinalEmptyStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalEmptyStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalEmptyStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalEmptyStruct", complete);
}

const TypeObject* GetFinalEmptyStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalEmptyStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalEmptyStructObject();
    }
    //else
    return GetMinimalFinalEmptyStructObject();
}

const TypeObject* GetMinimalFinalEmptyStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalEmptyStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;

    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalEmptyStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalEmptyStruct", false);
}

const TypeObject* GetCompleteFinalEmptyStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalEmptyStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;

    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalEmptyStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalEmptyStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalEmptyStruct", true);
}

const TypeIdentifier* GetFinalEmptyInheritanceStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalEmptyInheritanceStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalEmptyInheritanceStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalEmptyInheritanceStruct", complete);
}

const TypeObject* GetFinalEmptyInheritanceStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalEmptyInheritanceStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalEmptyInheritanceStructObject();
    }
    //else
    return GetMinimalFinalEmptyInheritanceStructObject();
}

const TypeObject* GetMinimalFinalEmptyInheritanceStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalEmptyInheritanceStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_str;
    mst_var_str.common().member_id(memberId++);
    mst_var_str.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_str.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_str.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_str.common().member_flags().IS_OPTIONAL(false);
    mst_var_str.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_str.common().member_flags().IS_KEY(false);
    mst_var_str.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_str.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    MD5 var_str_hash("var_str");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_str.detail().name_hash()[i] = var_str_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_str);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    type_object->minimal().struct_type().header().base_type(*GetFinalEmptyStructIdentifier(false));

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalEmptyInheritanceStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalEmptyInheritanceStruct", false);
}

const TypeObject* GetCompleteFinalEmptyInheritanceStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalEmptyInheritanceStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_str;
    cst_var_str.common().member_id(memberId++);
    cst_var_str.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_str.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_str.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_str.common().member_flags().IS_OPTIONAL(false);
    cst_var_str.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_str.common().member_flags().IS_KEY(false);
    cst_var_str.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_str.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    cst_var_str.detail().name("var_str");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_str);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalEmptyInheritanceStruct");
    // TODO inheritance
    type_object->complete().struct_type().header().base_type(*GetFinalEmptyStructIdentifier(true));

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalEmptyInheritanceStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalEmptyInheritanceStruct", true);
}

const TypeIdentifier* GetFinalInheritanceStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FinalInheritanceStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFinalInheritanceStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FinalInheritanceStruct", complete);
}

const TypeObject* GetFinalInheritanceStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalInheritanceStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFinalInheritanceStructObject();
    }
    //else
    return GetMinimalFinalInheritanceStructObject();
}

const TypeObject* GetMinimalFinalInheritanceStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalInheritanceStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_str;
    mst_var_str.common().member_id(memberId++);
    mst_var_str.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_str.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_str.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_str.common().member_flags().IS_OPTIONAL(false);
    mst_var_str.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_str.common().member_flags().IS_KEY(false);
    mst_var_str.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_str.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    MD5 var_str_hash("var_str");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_str.detail().name_hash()[i] = var_str_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_str);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    type_object->minimal().struct_type().header().base_type(*GetFinalShortStructIdentifier(false));

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalInheritanceStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalInheritanceStruct", false);
}

const TypeObject* GetCompleteFinalInheritanceStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FinalInheritanceStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_str;
    cst_var_str.common().member_id(memberId++);
    cst_var_str.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_str.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_str.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_str.common().member_flags().IS_OPTIONAL(false);
    cst_var_str.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_str.common().member_flags().IS_KEY(false);
    cst_var_str.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_str.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    cst_var_str.detail().name("var_str");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_str);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FinalInheritanceStruct");
    // TODO inheritance
    type_object->complete().struct_type().header().base_type(*GetFinalShortStructIdentifier(true));

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FinalInheritanceStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FinalInheritanceStruct", true);
}

const TypeIdentifier* GetInheritanceEmptyStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("InheritanceEmptyStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInheritanceEmptyStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("InheritanceEmptyStruct", complete);
}

const TypeObject* GetInheritanceEmptyStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InheritanceEmptyStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInheritanceEmptyStructObject();
    }
    //else
    return GetMinimalInheritanceEmptyStructObject();
}

const TypeObject* GetMinimalInheritanceEmptyStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InheritanceEmptyStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(true);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;

    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    type_object->minimal().struct_type().header().base_type(*GetFinalShortStructIdentifier(false));

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InheritanceEmptyStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InheritanceEmptyStruct", false);
}

const TypeObject* GetCompleteInheritanceEmptyStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InheritanceEmptyStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(true);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;

    // Header
    type_object->complete().struct_type().header().detail().type_name("InheritanceEmptyStruct");
    // TODO inheritance
    type_object->complete().struct_type().header().base_type(*GetFinalShortStructIdentifier(true));

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetfinalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("final"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InheritanceEmptyStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InheritanceEmptyStruct", true);
}
