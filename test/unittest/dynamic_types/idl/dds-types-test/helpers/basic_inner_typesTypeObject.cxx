// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file basic_inner_typesTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "basic_inner_types.h"
#include "basic_inner_typesTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

void registerbasic_inner_typesTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(true),
                GetInnerEnumHelperObject(true));
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(false),
                GetInnerEnumHelperObject(false));

                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(true),
                GetInnerBitMaskHelperObject(true));
                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(false),
                GetInnerBitMaskHelperObject(false));

                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(true),
                GetInnerAliasHelperObject(true));
                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(false),
                GetInnerAliasHelperObject(false));

                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(true),
                GetInnerStructureHelperObject(true));
                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(false),
                GetInnerStructureHelperObject(false));

                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(true),
                GetInnerEmptyStructureHelperObject(true));
                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(false),
                GetInnerEmptyStructureHelperObject(false));

                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(true),
                GetInnerUnionHelperObject(true));
                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(false),
                GetInnerUnionHelperObject(false));

                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(true),
                GetInnerBitsetHelperObject(true));
                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(false),
                GetInnerBitsetHelperObject(false));

                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(true),
                GetInner_alias_bounded_string_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(false),
                GetInner_alias_bounded_string_helperObject(false));

                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(true),
                GetInner_alias_bounded_wstring_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(false),
                GetInner_alias_bounded_wstring_helperObject(false));

                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(true),
                GetInner_alias_array_helperObject(true));
                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(false),
                GetInner_alias_array_helperObject(false));

                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(true),
                GetInner_alias_sequence_helperObject(true));
                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(false),
                GetInner_alias_sequence_helperObject(false));

                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(true),
                GetInner_alias_map_helperObject(true));
                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(false),
                GetInner_alias_map_helperObject(false));

            });
}

const TypeIdentifier* GetInnerEnumHelperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("InnerEnumHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInnerEnumHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("InnerEnumHelper", complete);
}

const TypeObject* GetInnerEnumHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerEnumHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInnerEnumHelperObject();
    }
    // else
    return GetMinimalInnerEnumHelperObject();
}

const TypeObject* GetMinimalInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerEnumHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_ENUM_VALUE_1;
    mel_ENUM_VALUE_1.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_ENUM_VALUE_1.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_ENUM_VALUE_1.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_ENUM_VALUE_1.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_ENUM_VALUE_1.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_ENUM_VALUE_1.common().flags().IS_KEY(false); // Doesn't apply
    mel_ENUM_VALUE_1.common().flags().IS_DEFAULT(false);
    mel_ENUM_VALUE_1.common().value(value++);
    MD5 ENUM_VALUE_1_hash("ENUM_VALUE_1");
    for(int i = 0; i < 4; ++i)
    {
        mel_ENUM_VALUE_1.detail().name_hash()[i] = ENUM_VALUE_1_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_ENUM_VALUE_1);

    MinimalEnumeratedLiteral mel_ENUM_VALUE_2;
    mel_ENUM_VALUE_2.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_ENUM_VALUE_2.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_ENUM_VALUE_2.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_ENUM_VALUE_2.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_ENUM_VALUE_2.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_ENUM_VALUE_2.common().flags().IS_KEY(false); // Doesn't apply
    mel_ENUM_VALUE_2.common().flags().IS_DEFAULT(false);
    mel_ENUM_VALUE_2.common().value(value++);
    MD5 ENUM_VALUE_2_hash("ENUM_VALUE_2");
    for(int i = 0; i < 4; ++i)
    {
        mel_ENUM_VALUE_2.detail().name_hash()[i] = ENUM_VALUE_2_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_ENUM_VALUE_2);

    MinimalEnumeratedLiteral mel_ENUM_VALUE_3;
    mel_ENUM_VALUE_3.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_ENUM_VALUE_3.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_ENUM_VALUE_3.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_ENUM_VALUE_3.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_ENUM_VALUE_3.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_ENUM_VALUE_3.common().flags().IS_KEY(false); // Doesn't apply
    mel_ENUM_VALUE_3.common().flags().IS_DEFAULT(false);
    mel_ENUM_VALUE_3.common().value(value++);
    MD5 ENUM_VALUE_3_hash("ENUM_VALUE_3");
    for(int i = 0; i < 4; ++i)
    {
        mel_ENUM_VALUE_3.detail().name_hash()[i] = ENUM_VALUE_3_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_ENUM_VALUE_3);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalEnumeratedType::getCdrSerializedSize(type_object->minimal().enumerated_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerEnumHelper", false);
}

const TypeObject* GetCompleteInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerEnumHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    type_object->complete().enumerated_type().header().detail().type_name("InnerEnumHelper");


    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_ENUM_VALUE_1;
    cel_ENUM_VALUE_1.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_ENUM_VALUE_1.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_ENUM_VALUE_1.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_ENUM_VALUE_1.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_ENUM_VALUE_1.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_ENUM_VALUE_1.common().flags().IS_KEY(false); // Doesn't apply
    cel_ENUM_VALUE_1.common().flags().IS_DEFAULT(false);
    cel_ENUM_VALUE_1.common().value(value++);
    cel_ENUM_VALUE_1.detail().name("ENUM_VALUE_1");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_ENUM_VALUE_1);

    CompleteEnumeratedLiteral cel_ENUM_VALUE_2;
    cel_ENUM_VALUE_2.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_ENUM_VALUE_2.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_ENUM_VALUE_2.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_ENUM_VALUE_2.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_ENUM_VALUE_2.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_ENUM_VALUE_2.common().flags().IS_KEY(false); // Doesn't apply
    cel_ENUM_VALUE_2.common().flags().IS_DEFAULT(false);
    cel_ENUM_VALUE_2.common().value(value++);
    cel_ENUM_VALUE_2.detail().name("ENUM_VALUE_2");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_ENUM_VALUE_2);

    CompleteEnumeratedLiteral cel_ENUM_VALUE_3;
    cel_ENUM_VALUE_3.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_ENUM_VALUE_3.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_ENUM_VALUE_3.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_ENUM_VALUE_3.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_ENUM_VALUE_3.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_ENUM_VALUE_3.common().flags().IS_KEY(false); // Doesn't apply
    cel_ENUM_VALUE_3.common().flags().IS_DEFAULT(false);
    cel_ENUM_VALUE_3.common().value(value++);
    cel_ENUM_VALUE_3.detail().name("ENUM_VALUE_3");

    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_ENUM_VALUE_3);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteEnumeratedType::getCdrSerializedSize(type_object->complete().enumerated_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerEnumHelper", true);
}

const TypeIdentifier* GetInnerBitMaskHelperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("InnerBitMaskHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInnerBitMaskHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("InnerBitMaskHelper", complete);
}

const TypeObject* GetInnerBitMaskHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerBitMaskHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInnerBitMaskHelperObject();
    }
    // else
    return GetMinimalInnerBitMaskHelperObject();
}

const TypeObject* GetMinimalInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerBitMaskHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_BITMASK);

    type_object->minimal().bitmask_type().header().common().bit_bound(32);

    MinimalBitflag mbf_flag0;
    mbf_flag0.common().flags().TRY_CONSTRUCT1(false);
    mbf_flag0.common().flags().TRY_CONSTRUCT2(false);
    mbf_flag0.common().flags().IS_EXTERNAL(false);
    mbf_flag0.common().flags().IS_OPTIONAL(false);
    mbf_flag0.common().flags().IS_MUST_UNDERSTAND(false);
    mbf_flag0.common().flags().IS_KEY(false);
    mbf_flag0.common().flags().IS_DEFAULT(false);
    mbf_flag0.common().position(0);
    MD5 flag0_hash("flag0");
    for(int i = 0; i < 4; ++i)
    {
        mbf_flag0.detail().name_hash()[i] = flag0_hash.digest[i];
    }
    type_object->minimal().bitmask_type().flag_seq().emplace_back(mbf_flag0);

    MinimalBitflag mbf_flag1;
    mbf_flag1.common().flags().TRY_CONSTRUCT1(false);
    mbf_flag1.common().flags().TRY_CONSTRUCT2(false);
    mbf_flag1.common().flags().IS_EXTERNAL(false);
    mbf_flag1.common().flags().IS_OPTIONAL(false);
    mbf_flag1.common().flags().IS_MUST_UNDERSTAND(false);
    mbf_flag1.common().flags().IS_KEY(false);
    mbf_flag1.common().flags().IS_DEFAULT(false);
    mbf_flag1.common().position(1);
    MD5 flag1_hash("flag1");
    for(int i = 0; i < 4; ++i)
    {
        mbf_flag1.detail().name_hash()[i] = flag1_hash.digest[i];
    }
    type_object->minimal().bitmask_type().flag_seq().emplace_back(mbf_flag1);

    MinimalBitflag mbf_flag4;
    mbf_flag4.common().flags().TRY_CONSTRUCT1(false);
    mbf_flag4.common().flags().TRY_CONSTRUCT2(false);
    mbf_flag4.common().flags().IS_EXTERNAL(false);
    mbf_flag4.common().flags().IS_OPTIONAL(false);
    mbf_flag4.common().flags().IS_MUST_UNDERSTAND(false);
    mbf_flag4.common().flags().IS_KEY(false);
    mbf_flag4.common().flags().IS_DEFAULT(false);
    mbf_flag4.common().position(4);
    MD5 flag4_hash("flag4");
    for(int i = 0; i < 4; ++i)
    {
        mbf_flag4.detail().name_hash()[i] = flag4_hash.digest[i];
    }
    type_object->minimal().bitmask_type().flag_seq().emplace_back(mbf_flag4);

    MinimalBitflag mbf_flag6;
    mbf_flag6.common().flags().TRY_CONSTRUCT1(false);
    mbf_flag6.common().flags().TRY_CONSTRUCT2(false);
    mbf_flag6.common().flags().IS_EXTERNAL(false);
    mbf_flag6.common().flags().IS_OPTIONAL(false);
    mbf_flag6.common().flags().IS_MUST_UNDERSTAND(false);
    mbf_flag6.common().flags().IS_KEY(false);
    mbf_flag6.common().flags().IS_DEFAULT(false);
    mbf_flag6.common().position(6);
    MD5 flag6_hash("flag6");
    for(int i = 0; i < 4; ++i)
    {
        mbf_flag6.detail().name_hash()[i] = flag6_hash.digest[i];
    }
    type_object->minimal().bitmask_type().flag_seq().emplace_back(mbf_flag6);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalBitmaskType::getCdrSerializedSize(type_object->minimal().bitmask_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerBitMaskHelper", false);
}

const TypeObject* GetCompleteInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerBitMaskHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_BITMASK);

    // No flags apply
    //type_object->complete().bitmask_type().bitmask_flags().IS_FINAL(false);
    //type_object->complete().bitmask_type().bitmask_flags().IS_APPENDABLE(false);
    //type_object->complete().bitmask_type().bitmask_flags().IS_MUTABLE(false);
    //type_object->complete().bitmask_type().bitmask_flags().IS_NESTED(false);
    //type_object->complete().bitmask_type().bitmask_flags().IS_AUTOID_HASH(false);

    type_object->complete().bitmask_type().header().common().bit_bound(32);


    type_object->complete().bitmask_type().header().detail().type_name("InnerBitMaskHelper");

    CompleteBitflag cbf_flag0;
    cbf_flag0.common().flags().TRY_CONSTRUCT1(false);
    cbf_flag0.common().flags().TRY_CONSTRUCT2(false);
    cbf_flag0.common().flags().IS_EXTERNAL(false);
    cbf_flag0.common().flags().IS_OPTIONAL(false);
    cbf_flag0.common().flags().IS_MUST_UNDERSTAND(false);
    cbf_flag0.common().flags().IS_KEY(false);
    cbf_flag0.common().flags().IS_DEFAULT(false);
    cbf_flag0.common().position(0);
    cbf_flag0.detail().name("flag0");

    // Position annotation always present
    {
        AppliedAnnotation ann;
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("position"));
        AppliedAnnotationParameter annParam;
        MD5 message_hash("value");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        }
        AnnotationParameterValue paramValue;
        paramValue._d(TK_UINT16);
        paramValue.uint_16_value(0);
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);

        cbf_flag0.detail().ann_custom().push_back(ann);
    }

    {
        if (std::strcmp("position", "position") != 0)
        {
            AppliedAnnotation ann;
            //ann.annotation_typeid(GetpositionIdentifier(true));
            ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("position"));
                    {
                        AppliedAnnotationParameter annParam;
                        MD5 message_hash("value");
                        for(int i = 0; i < 4; ++i)
                        {
                            annParam.paramname_hash()[i] = message_hash.digest[i];
                        }
                        AnnotationParameterValue paramValue;
                        paramValue._d(TK_UINT16);
                        paramValue.from_string("0");
                        annParam.value(paramValue);
                        ann.param_seq().push_back(annParam);
                    }
                    
            cbf_flag0.detail().ann_custom().push_back(ann);
        }
    }

    type_object->complete().bitmask_type().flag_seq().emplace_back(cbf_flag0);

    CompleteBitflag cbf_flag1;
    cbf_flag1.common().flags().TRY_CONSTRUCT1(false);
    cbf_flag1.common().flags().TRY_CONSTRUCT2(false);
    cbf_flag1.common().flags().IS_EXTERNAL(false);
    cbf_flag1.common().flags().IS_OPTIONAL(false);
    cbf_flag1.common().flags().IS_MUST_UNDERSTAND(false);
    cbf_flag1.common().flags().IS_KEY(false);
    cbf_flag1.common().flags().IS_DEFAULT(false);
    cbf_flag1.common().position(1);
    cbf_flag1.detail().name("flag1");

    // Position annotation always present
    {
        AppliedAnnotation ann;
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("position"));
        AppliedAnnotationParameter annParam;
        MD5 message_hash("value");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        }
        AnnotationParameterValue paramValue;
        paramValue._d(TK_UINT16);
        paramValue.uint_16_value(1);
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);

        cbf_flag1.detail().ann_custom().push_back(ann);
    }

    {
        if (std::strcmp("position", "position") != 0)
        {
            AppliedAnnotation ann;
            //ann.annotation_typeid(GetpositionIdentifier(true));
            ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("position"));
                    {
                        AppliedAnnotationParameter annParam;
                        MD5 message_hash("value");
                        for(int i = 0; i < 4; ++i)
                        {
                            annParam.paramname_hash()[i] = message_hash.digest[i];
                        }
                        AnnotationParameterValue paramValue;
                        paramValue._d(TK_UINT16);
                        paramValue.from_string("1");
                        annParam.value(paramValue);
                        ann.param_seq().push_back(annParam);
                    }
                    
            cbf_flag1.detail().ann_custom().push_back(ann);
        }
    }

    type_object->complete().bitmask_type().flag_seq().emplace_back(cbf_flag1);

    CompleteBitflag cbf_flag4;
    cbf_flag4.common().flags().TRY_CONSTRUCT1(false);
    cbf_flag4.common().flags().TRY_CONSTRUCT2(false);
    cbf_flag4.common().flags().IS_EXTERNAL(false);
    cbf_flag4.common().flags().IS_OPTIONAL(false);
    cbf_flag4.common().flags().IS_MUST_UNDERSTAND(false);
    cbf_flag4.common().flags().IS_KEY(false);
    cbf_flag4.common().flags().IS_DEFAULT(false);
    cbf_flag4.common().position(4);
    cbf_flag4.detail().name("flag4");

    // Position annotation always present
    {
        AppliedAnnotation ann;
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("position"));
        AppliedAnnotationParameter annParam;
        MD5 message_hash("value");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        }
        AnnotationParameterValue paramValue;
        paramValue._d(TK_UINT16);
        paramValue.uint_16_value(4);
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);

        cbf_flag4.detail().ann_custom().push_back(ann);
    }

    {
        if (std::strcmp("position", "position") != 0)
        {
            AppliedAnnotation ann;
            //ann.annotation_typeid(GetpositionIdentifier(true));
            ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("position"));
                    {
                        AppliedAnnotationParameter annParam;
                        MD5 message_hash("value");
                        for(int i = 0; i < 4; ++i)
                        {
                            annParam.paramname_hash()[i] = message_hash.digest[i];
                        }
                        AnnotationParameterValue paramValue;
                        paramValue._d(TK_UINT16);
                        paramValue.from_string("4");
                        annParam.value(paramValue);
                        ann.param_seq().push_back(annParam);
                    }
                    
            cbf_flag4.detail().ann_custom().push_back(ann);
        }
    }

    type_object->complete().bitmask_type().flag_seq().emplace_back(cbf_flag4);

    CompleteBitflag cbf_flag6;
    cbf_flag6.common().flags().TRY_CONSTRUCT1(false);
    cbf_flag6.common().flags().TRY_CONSTRUCT2(false);
    cbf_flag6.common().flags().IS_EXTERNAL(false);
    cbf_flag6.common().flags().IS_OPTIONAL(false);
    cbf_flag6.common().flags().IS_MUST_UNDERSTAND(false);
    cbf_flag6.common().flags().IS_KEY(false);
    cbf_flag6.common().flags().IS_DEFAULT(false);
    cbf_flag6.common().position(6);
    cbf_flag6.detail().name("flag6");

    // Position annotation always present
    {
        AppliedAnnotation ann;
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("position"));
        AppliedAnnotationParameter annParam;
        MD5 message_hash("value");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        }
        AnnotationParameterValue paramValue;
        paramValue._d(TK_UINT16);
        paramValue.uint_16_value(6);
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);

        cbf_flag6.detail().ann_custom().push_back(ann);
    }

    {
        if (std::strcmp("position", "position") != 0)
        {
            AppliedAnnotation ann;
            //ann.annotation_typeid(GetpositionIdentifier(true));
            ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("position"));
                    {
                        AppliedAnnotationParameter annParam;
                        MD5 message_hash("value");
                        for(int i = 0; i < 4; ++i)
                        {
                            annParam.paramname_hash()[i] = message_hash.digest[i];
                        }
                        AnnotationParameterValue paramValue;
                        paramValue._d(TK_UINT16);
                        paramValue.from_string("6");
                        annParam.value(paramValue);
                        ann.param_seq().push_back(annParam);
                    }
                    
            cbf_flag6.detail().ann_custom().push_back(ann);
        }
    }

    type_object->complete().bitmask_type().flag_seq().emplace_back(cbf_flag6);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteBitmaskType::getCdrSerializedSize(type_object->complete().bitmask_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerBitMaskHelper", true);
}

const TypeIdentifier* GetInnerAliasHelperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("InnerAliasHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInnerAliasHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("InnerAliasHelper", complete);
}

const TypeObject* GetInnerAliasHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerAliasHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInnerAliasHelperObject();
    }
    else
    {
        return GetMinimalInnerAliasHelperObject();
    }
}

const TypeObject* GetMinimalInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerAliasHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("InnerAliasHelper", "int32_t");

    TypeObjectFactory::get_instance()->add_type_object("InnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerAliasHelper", false);
}

const TypeObject* GetCompleteInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerAliasHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("InnerAliasHelper");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("int32_t");


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("InnerAliasHelper", "int32_t");

    TypeObjectFactory::get_instance()->add_type_object("InnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerAliasHelper", true);
}

const TypeIdentifier* GetInnerStructureHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("InnerStructureHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInnerStructureHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("InnerStructureHelper", complete);
}

const TypeObject* GetInnerStructureHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerStructureHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInnerStructureHelperObject();
    }
    //else
    return GetMinimalInnerStructureHelperObject();
}

const TypeObject* GetMinimalInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerStructureHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_field1;
    mst_field1.common().member_id(memberId++);
    mst_field1.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_field1.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_field1.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_field1.common().member_flags().IS_OPTIONAL(false);
    mst_field1.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_field1.common().member_flags().IS_KEY(false);
    mst_field1.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_field1.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MD5 field1_hash("field1");
    for(int i = 0; i < 4; ++i)
    {
        mst_field1.detail().name_hash()[i] = field1_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_field1);

    MinimalStructMember mst_field2;
    mst_field2.common().member_id(memberId++);
    mst_field2.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_field2.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_field2.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_field2.common().member_flags().IS_OPTIONAL(false);
    mst_field2.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_field2.common().member_flags().IS_KEY(false);
    mst_field2.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_field2.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 field2_hash("field2");
    for(int i = 0; i < 4; ++i)
    {
        mst_field2.detail().name_hash()[i] = field2_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_field2);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerStructureHelper", false);
}

const TypeObject* GetCompleteInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerStructureHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_field1;
    cst_field1.common().member_id(memberId++);
    cst_field1.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_field1.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_field1.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_field1.common().member_flags().IS_OPTIONAL(false);
    cst_field1.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_field1.common().member_flags().IS_KEY(false);
    cst_field1.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_field1.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    cst_field1.detail().name("field1");

    type_object->complete().struct_type().member_seq().emplace_back(cst_field1);

    CompleteStructMember cst_field2;
    cst_field2.common().member_id(memberId++);
    cst_field2.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_field2.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_field2.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_field2.common().member_flags().IS_OPTIONAL(false);
    cst_field2.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_field2.common().member_flags().IS_KEY(false);
    cst_field2.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_field2.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_field2.detail().name("field2");

    type_object->complete().struct_type().member_seq().emplace_back(cst_field2);


    // Header
    type_object->complete().struct_type().header().detail().type_name("InnerStructureHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerStructureHelper", true);
}

const TypeIdentifier* GetInnerEmptyStructureHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("InnerEmptyStructureHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInnerEmptyStructureHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("InnerEmptyStructureHelper", complete);
}

const TypeObject* GetInnerEmptyStructureHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerEmptyStructureHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInnerEmptyStructureHelperObject();
    }
    //else
    return GetMinimalInnerEmptyStructureHelperObject();
}

const TypeObject* GetMinimalInnerEmptyStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerEmptyStructureHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;

    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InnerEmptyStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerEmptyStructureHelper", false);
}

const TypeObject* GetCompleteInnerEmptyStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerEmptyStructureHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;

    // Header
    type_object->complete().struct_type().header().detail().type_name("InnerEmptyStructureHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InnerEmptyStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerEmptyStructureHelper", true);
}

const TypeIdentifier* GetInnerUnionHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("InnerUnionHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInnerUnionHelperObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("InnerUnionHelper", complete);
}

const TypeObject* GetInnerUnionHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerUnionHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInnerUnionHelperObject();
    }
    // else
    return GetMinimalInnerUnionHelperObject();
}

const TypeObject* GetMinimalInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerUnionHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_longValue;
    mst_longValue.common().member_id(memberId++);
    mst_longValue.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_longValue.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_longValue.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_longValue.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_longValue.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_longValue.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_longValue.common().member_flags().IS_DEFAULT(false);
    mst_longValue.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_longValue.common().label_seq().emplace_back(0);
    MD5 longValue_hash("longValue");
    for(int i = 0; i < 4; ++i)
    {
        mst_longValue.detail().name_hash()[i] = longValue_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_longValue);

    MinimalUnionMember mst_floatValue;
    mst_floatValue.common().member_id(memberId++);
    mst_floatValue.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_floatValue.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_floatValue.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_floatValue.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_floatValue.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_floatValue.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_floatValue.common().member_flags().IS_DEFAULT(false);
    mst_floatValue.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    mst_floatValue.common().label_seq().emplace_back(1);
    MD5 floatValue_hash("floatValue");
    for(int i = 0; i < 4; ++i)
    {
        mst_floatValue.detail().name_hash()[i] = floatValue_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_floatValue);

    MinimalUnionMember mst_shortValue;
    mst_shortValue.common().member_id(memberId++);
    mst_shortValue.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_shortValue.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_shortValue.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_shortValue.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_shortValue.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_shortValue.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_shortValue.common().member_flags().IS_DEFAULT(false);
    mst_shortValue.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    MD5 shortValue_hash("shortValue");
    for(int i = 0; i < 4; ++i)
    {
        mst_shortValue.detail().name_hash()[i] = shortValue_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_shortValue);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InnerUnionHelper", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("InnerUnionHelper", false);
}

const TypeObject* GetCompleteInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerUnionHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_longValue;
    cst_longValue.common().member_id(memberId++);
    cst_longValue.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_longValue.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_longValue.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_longValue.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_longValue.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_longValue.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_longValue.common().member_flags().IS_DEFAULT(false);
    cst_longValue.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_longValue.common().label_seq().emplace_back(0);

    cst_longValue.detail().name("longValue");

    type_object->complete().union_type().member_seq().emplace_back(cst_longValue);

    CompleteUnionMember cst_floatValue;
    cst_floatValue.common().member_id(memberId++);
    cst_floatValue.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_floatValue.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_floatValue.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_floatValue.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_floatValue.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_floatValue.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_floatValue.common().member_flags().IS_DEFAULT(false);
    cst_floatValue.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));
    cst_floatValue.common().label_seq().emplace_back(1);

    cst_floatValue.detail().name("floatValue");

    type_object->complete().union_type().member_seq().emplace_back(cst_floatValue);

    CompleteUnionMember cst_shortValue;
    cst_shortValue.common().member_id(memberId++);
    cst_shortValue.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_shortValue.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_shortValue.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_shortValue.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_shortValue.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_shortValue.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_shortValue.common().member_flags().IS_DEFAULT(false);
    cst_shortValue.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    cst_shortValue.detail().name("shortValue");

    type_object->complete().union_type().member_seq().emplace_back(cst_shortValue);


    // Header
    type_object->complete().union_type().header().detail().type_name("InnerUnionHelper");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InnerUnionHelper", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("InnerUnionHelper", true);
}

const TypeIdentifier* GetInnerBitsetHelperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("InnerBitsetHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInnerBitsetHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("InnerBitsetHelper", complete);
}

const TypeObject* GetInnerBitsetHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerBitsetHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInnerBitsetHelperObject();
    }
    // else
    return GetMinimalInnerBitsetHelperObject();
}

const TypeObject* GetMinimalInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerBitsetHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_BITSET);

    MinimalBitfield mbf_a;
    mbf_a.common().flags().TRY_CONSTRUCT1(false);
    mbf_a.common().flags().TRY_CONSTRUCT2(false);
    mbf_a.common().flags().IS_EXTERNAL(false);
    mbf_a.common().flags().IS_OPTIONAL(false);
    mbf_a.common().flags().IS_MUST_UNDERSTAND(false);
    mbf_a.common().flags().IS_KEY(false);
    mbf_a.common().flags().IS_DEFAULT(false);
    mbf_a.common().position(0);
    mbf_a.common().bitcount(3);
    mbf_a.common().holder_type(TK_CHAR8);
    MD5 a_hash("a");
    for(int i = 0; i < 4; ++i)
    {
        mbf_a.name_hash()[i] = a_hash.digest[i];
    }
    type_object->minimal().bitset_type().field_seq().emplace_back(mbf_a);
    MinimalBitfield mbf_b;
    mbf_b.common().flags().TRY_CONSTRUCT1(false);
    mbf_b.common().flags().TRY_CONSTRUCT2(false);
    mbf_b.common().flags().IS_EXTERNAL(false);
    mbf_b.common().flags().IS_OPTIONAL(false);
    mbf_b.common().flags().IS_MUST_UNDERSTAND(false);
    mbf_b.common().flags().IS_KEY(false);
    mbf_b.common().flags().IS_DEFAULT(false);
    mbf_b.common().position(3);
    mbf_b.common().bitcount(1);
    mbf_b.common().holder_type(TK_BOOLEAN);
    MD5 b_hash("b");
    for(int i = 0; i < 4; ++i)
    {
        mbf_b.name_hash()[i] = b_hash.digest[i];
    }
    type_object->minimal().bitset_type().field_seq().emplace_back(mbf_b);

    MinimalBitfield mbf_c;
    mbf_c.common().flags().TRY_CONSTRUCT1(false);
    mbf_c.common().flags().TRY_CONSTRUCT2(false);
    mbf_c.common().flags().IS_EXTERNAL(false);
    mbf_c.common().flags().IS_OPTIONAL(false);
    mbf_c.common().flags().IS_MUST_UNDERSTAND(false);
    mbf_c.common().flags().IS_KEY(false);
    mbf_c.common().flags().IS_DEFAULT(false);
    mbf_c.common().position(8);
    mbf_c.common().bitcount(10);
    mbf_c.common().holder_type(TK_UINT16);
    MD5 c_hash("c");
    for(int i = 0; i < 4; ++i)
    {
        mbf_c.name_hash()[i] = c_hash.digest[i];
    }
    type_object->minimal().bitset_type().field_seq().emplace_back(mbf_c);
    MinimalBitfield mbf_d;
    mbf_d.common().flags().TRY_CONSTRUCT1(false);
    mbf_d.common().flags().TRY_CONSTRUCT2(false);
    mbf_d.common().flags().IS_EXTERNAL(false);
    mbf_d.common().flags().IS_OPTIONAL(false);
    mbf_d.common().flags().IS_MUST_UNDERSTAND(false);
    mbf_d.common().flags().IS_KEY(false);
    mbf_d.common().flags().IS_DEFAULT(false);
    mbf_d.common().position(18);
    mbf_d.common().bitcount(12);
    mbf_d.common().holder_type(TK_INT16);
    MD5 d_hash("d");
    for(int i = 0; i < 4; ++i)
    {
        mbf_d.name_hash()[i] = d_hash.digest[i];
    }
    type_object->minimal().bitset_type().field_seq().emplace_back(mbf_d);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalBitsetType::getCdrSerializedSize(type_object->minimal().bitset_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerBitsetHelper", false);
}

const TypeObject* GetCompleteInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerBitsetHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_BITSET);

    // No flags apply
    //type_object->complete().bitset_type().bitset_flags().IS_FINAL(false);
    //type_object->complete().bitset_type().bitset_flags().IS_APPENDABLE(false);
    //type_object->complete().bitset_type().bitset_flags().IS_MUTABLE(false);
    //type_object->complete().bitset_type().bitset_flags().IS_NESTED(false);
    //type_object->complete().bitset_type().bitset_flags().IS_AUTOID_HASH(false);


    type_object->complete().bitset_type().header().detail().type_name("InnerBitsetHelper");

    CompleteBitfield cbf_a;
    cbf_a.common().flags().TRY_CONSTRUCT1(false);
    cbf_a.common().flags().TRY_CONSTRUCT2(false);
    cbf_a.common().flags().IS_EXTERNAL(false);
    cbf_a.common().flags().IS_OPTIONAL(false);
    cbf_a.common().flags().IS_MUST_UNDERSTAND(false);
    cbf_a.common().flags().IS_KEY(false);
    cbf_a.common().flags().IS_DEFAULT(false);
    cbf_a.common().position(0);
    cbf_a.common().bitcount(3);
    cbf_a.common().holder_type(TK_CHAR8);
    cbf_a.detail().name("a");

    // Position annotation always present
    {
        // Position
        AppliedAnnotation ann;
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("position"));
        AppliedAnnotationParameter annParam;
        MD5 message_hash("value");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        }
        AnnotationParameterValue paramValue;
        paramValue._d(TK_UINT16);
        paramValue.uint_16_value(0);
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);

        cbf_a.detail().ann_custom().push_back(ann);
    }

    // Use bit_bound as bitcount.
    {
        // Position
        AppliedAnnotation ann;
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("bit_bound"));
        AppliedAnnotationParameter annParam;
        MD5 message_hash("value");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        }
        AnnotationParameterValue paramValue;
        paramValue._d(TK_UINT16);
        paramValue.uint_16_value(3);
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);

        cbf_a.detail().ann_custom().push_back(ann);
    }

    type_object->complete().bitset_type().field_seq().emplace_back(cbf_a);
    CompleteBitfield cbf_b;
    cbf_b.common().flags().TRY_CONSTRUCT1(false);
    cbf_b.common().flags().TRY_CONSTRUCT2(false);
    cbf_b.common().flags().IS_EXTERNAL(false);
    cbf_b.common().flags().IS_OPTIONAL(false);
    cbf_b.common().flags().IS_MUST_UNDERSTAND(false);
    cbf_b.common().flags().IS_KEY(false);
    cbf_b.common().flags().IS_DEFAULT(false);
    cbf_b.common().position(3);
    cbf_b.common().bitcount(1);
    cbf_b.common().holder_type(TK_BOOLEAN);
    cbf_b.detail().name("b");

    // Position annotation always present
    {
        // Position
        AppliedAnnotation ann;
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("position"));
        AppliedAnnotationParameter annParam;
        MD5 message_hash("value");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        }
        AnnotationParameterValue paramValue;
        paramValue._d(TK_UINT16);
        paramValue.uint_16_value(3);
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);

        cbf_b.detail().ann_custom().push_back(ann);
    }

    // Use bit_bound as bitcount.
    {
        // Position
        AppliedAnnotation ann;
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("bit_bound"));
        AppliedAnnotationParameter annParam;
        MD5 message_hash("value");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        }
        AnnotationParameterValue paramValue;
        paramValue._d(TK_UINT16);
        paramValue.uint_16_value(1);
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);

        cbf_b.detail().ann_custom().push_back(ann);
    }

    type_object->complete().bitset_type().field_seq().emplace_back(cbf_b);

    CompleteBitfield cbf_c;
    cbf_c.common().flags().TRY_CONSTRUCT1(false);
    cbf_c.common().flags().TRY_CONSTRUCT2(false);
    cbf_c.common().flags().IS_EXTERNAL(false);
    cbf_c.common().flags().IS_OPTIONAL(false);
    cbf_c.common().flags().IS_MUST_UNDERSTAND(false);
    cbf_c.common().flags().IS_KEY(false);
    cbf_c.common().flags().IS_DEFAULT(false);
    cbf_c.common().position(8);
    cbf_c.common().bitcount(10);
    cbf_c.common().holder_type(TK_UINT16);
    cbf_c.detail().name("c");

    // Position annotation always present
    {
        // Position
        AppliedAnnotation ann;
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("position"));
        AppliedAnnotationParameter annParam;
        MD5 message_hash("value");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        }
        AnnotationParameterValue paramValue;
        paramValue._d(TK_UINT16);
        paramValue.uint_16_value(8);
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);

        cbf_c.detail().ann_custom().push_back(ann);
    }

    // Use bit_bound as bitcount.
    {
        // Position
        AppliedAnnotation ann;
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("bit_bound"));
        AppliedAnnotationParameter annParam;
        MD5 message_hash("value");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        }
        AnnotationParameterValue paramValue;
        paramValue._d(TK_UINT16);
        paramValue.uint_16_value(10);
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);

        cbf_c.detail().ann_custom().push_back(ann);
    }

    type_object->complete().bitset_type().field_seq().emplace_back(cbf_c);
    CompleteBitfield cbf_d;
    cbf_d.common().flags().TRY_CONSTRUCT1(false);
    cbf_d.common().flags().TRY_CONSTRUCT2(false);
    cbf_d.common().flags().IS_EXTERNAL(false);
    cbf_d.common().flags().IS_OPTIONAL(false);
    cbf_d.common().flags().IS_MUST_UNDERSTAND(false);
    cbf_d.common().flags().IS_KEY(false);
    cbf_d.common().flags().IS_DEFAULT(false);
    cbf_d.common().position(18);
    cbf_d.common().bitcount(12);
    cbf_d.common().holder_type(TK_INT16);
    cbf_d.detail().name("d");

    // Position annotation always present
    {
        // Position
        AppliedAnnotation ann;
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("position"));
        AppliedAnnotationParameter annParam;
        MD5 message_hash("value");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        }
        AnnotationParameterValue paramValue;
        paramValue._d(TK_UINT16);
        paramValue.uint_16_value(18);
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);

        cbf_d.detail().ann_custom().push_back(ann);
    }

    // Use bit_bound as bitcount.
    {
        // Position
        AppliedAnnotation ann;
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("bit_bound"));
        AppliedAnnotationParameter annParam;
        MD5 message_hash("value");
        for(int i = 0; i < 4; ++i)
        {
            annParam.paramname_hash()[i] = message_hash.digest[i];
        }
        AnnotationParameterValue paramValue;
        paramValue._d(TK_UINT16);
        paramValue.uint_16_value(12);
        annParam.value(paramValue);
        ann.param_seq().push_back(annParam);

        cbf_d.detail().ann_custom().push_back(ann);
    }

    type_object->complete().bitset_type().field_seq().emplace_back(cbf_d);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteBitsetType::getCdrSerializedSize(type_object->complete().bitset_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerBitsetHelper", true);
}

const TypeIdentifier* GetInner_alias_bounded_string_helperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_bounded_string_helper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInner_alias_bounded_string_helperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_bounded_string_helper", complete);
}

const TypeObject* GetInner_alias_bounded_string_helperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_string_helper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInner_alias_bounded_string_helperObject();
    }
    else
    {
        return GetMinimalInner_alias_bounded_string_helperObject();
    }
}

const TypeObject* GetMinimalInner_alias_bounded_string_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_string_helper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_string_type_name(10, false), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_bounded_string_helper", TypeNamesGenerator::get_string_type_name(10, false));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_bounded_string_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_string_helper", false);
}

const TypeObject* GetCompleteInner_alias_bounded_string_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_string_helper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("Inner_alias_bounded_string_helper");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_string_type_name(10, false));


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_bounded_string_helper", TypeNamesGenerator::get_string_type_name(10, false));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_bounded_string_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_string_helper", true);
}

const TypeIdentifier* GetInner_alias_bounded_wstring_helperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_bounded_wstring_helper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInner_alias_bounded_wstring_helperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_bounded_wstring_helper", complete);
}

const TypeObject* GetInner_alias_bounded_wstring_helperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_wstring_helper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInner_alias_bounded_wstring_helperObject();
    }
    else
    {
        return GetMinimalInner_alias_bounded_wstring_helperObject();
    }
}

const TypeObject* GetMinimalInner_alias_bounded_wstring_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_wstring_helper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_string_type_name(10, true), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_bounded_wstring_helper", TypeNamesGenerator::get_string_type_name(10, true));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_bounded_wstring_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_wstring_helper", false);
}

const TypeObject* GetCompleteInner_alias_bounded_wstring_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_wstring_helper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("Inner_alias_bounded_wstring_helper");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_string_type_name(10, true));


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_bounded_wstring_helper", TypeNamesGenerator::get_string_type_name(10, true));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_bounded_wstring_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_wstring_helper", true);
}

const TypeIdentifier* GetInner_alias_array_helperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_array_helper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInner_alias_array_helperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_array_helper", complete);
}

const TypeObject* GetInner_alias_array_helperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_array_helper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInner_alias_array_helperObject();
    }
    else
    {
        return GetMinimalInner_alias_array_helperObject();
    }
}

const TypeObject* GetMinimalInner_alias_array_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_array_helper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_array_type_name("int16_t", {2}), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_array_helper", TypeNamesGenerator::get_array_type_name("int16_t", {2}));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_array_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_array_helper", false);
}

const TypeObject* GetCompleteInner_alias_array_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_array_helper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("Inner_alias_array_helper");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_array_type_name("int16_t", {2}));


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_array_helper", TypeNamesGenerator::get_array_type_name("int16_t", {2}));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_array_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_array_helper", true);
}

const TypeIdentifier* GetInner_alias_sequence_helperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_sequence_helper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInner_alias_sequence_helperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_sequence_helper", complete);
}

const TypeObject* GetInner_alias_sequence_helperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_sequence_helper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInner_alias_sequence_helperObject();
    }
    else
    {
        return GetMinimalInner_alias_sequence_helperObject();
    }
}

const TypeObject* GetMinimalInner_alias_sequence_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_sequence_helper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_sequence_type_name("int16_t", 100), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_sequence_helper", TypeNamesGenerator::get_sequence_type_name("int16_t", 100));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_sequence_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_sequence_helper", false);
}

const TypeObject* GetCompleteInner_alias_sequence_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_sequence_helper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("Inner_alias_sequence_helper");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_sequence_type_name("int16_t", 100));


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_sequence_helper", TypeNamesGenerator::get_sequence_type_name("int16_t", 100));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_sequence_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_sequence_helper", true);
}

const TypeIdentifier* GetInner_alias_map_helperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_map_helper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInner_alias_map_helperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_map_helper", complete);
}

const TypeObject* GetInner_alias_map_helperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_map_helper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInner_alias_map_helperObject();
    }
    else
    {
        return GetMinimalInner_alias_map_helperObject();
    }
}

const TypeObject* GetMinimalInner_alias_map_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_map_helper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_map_helper", TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_map_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_map_helper", false);
}

const TypeObject* GetCompleteInner_alias_map_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_map_helper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("Inner_alias_map_helper");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100));


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_map_helper", TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_map_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_map_helper", true);
}
