// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file mapsTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "maps.h"
#include "mapsTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

void registermapsTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(true),
                GetInnerEnumHelperObject(true));
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(false),
                GetInnerEnumHelperObject(false));

                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(true),
                GetInnerBitMaskHelperObject(true));
                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(false),
                GetInnerBitMaskHelperObject(false));

                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(true),
                GetInnerAliasHelperObject(true));
                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(false),
                GetInnerAliasHelperObject(false));

                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(true),
                GetInnerStructureHelperObject(true));
                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(false),
                GetInnerStructureHelperObject(false));

                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(true),
                GetInnerEmptyStructureHelperObject(true));
                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(false),
                GetInnerEmptyStructureHelperObject(false));

                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(true),
                GetInnerUnionHelperObject(true));
                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(false),
                GetInnerUnionHelperObject(false));

                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(true),
                GetInnerBitsetHelperObject(true));
                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(false),
                GetInnerBitsetHelperObject(false));

                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(true),
                GetInner_alias_bounded_string_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(false),
                GetInner_alias_bounded_string_helperObject(false));

                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(true),
                GetInner_alias_bounded_wstring_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(false),
                GetInner_alias_bounded_wstring_helperObject(false));

                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(true),
                GetInner_alias_array_helperObject(true));
                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(false),
                GetInner_alias_array_helperObject(false));

                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(true),
                GetInner_alias_sequence_helperObject(true));
                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(false),
                GetInner_alias_sequence_helperObject(false));

                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(true),
                GetInner_alias_map_helperObject(true));
                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(false),
                GetInner_alias_map_helperObject(false));

                factory->add_type_object("MapShortShort", GetMapShortShortIdentifier(true),
                GetMapShortShortObject(true));
                factory->add_type_object("MapShortShort", GetMapShortShortIdentifier(false),
                GetMapShortShortObject(false));

                factory->add_type_object("MapShortUShort", GetMapShortUShortIdentifier(true),
                GetMapShortUShortObject(true));
                factory->add_type_object("MapShortUShort", GetMapShortUShortIdentifier(false),
                GetMapShortUShortObject(false));

                factory->add_type_object("MapShortLong", GetMapShortLongIdentifier(true),
                GetMapShortLongObject(true));
                factory->add_type_object("MapShortLong", GetMapShortLongIdentifier(false),
                GetMapShortLongObject(false));

                factory->add_type_object("MapShortULong", GetMapShortULongIdentifier(true),
                GetMapShortULongObject(true));
                factory->add_type_object("MapShortULong", GetMapShortULongIdentifier(false),
                GetMapShortULongObject(false));

                factory->add_type_object("MapShortLongLong", GetMapShortLongLongIdentifier(true),
                GetMapShortLongLongObject(true));
                factory->add_type_object("MapShortLongLong", GetMapShortLongLongIdentifier(false),
                GetMapShortLongLongObject(false));

                factory->add_type_object("MapShortULongLong", GetMapShortULongLongIdentifier(true),
                GetMapShortULongLongObject(true));
                factory->add_type_object("MapShortULongLong", GetMapShortULongLongIdentifier(false),
                GetMapShortULongLongObject(false));

                factory->add_type_object("MapShortFloat", GetMapShortFloatIdentifier(true),
                GetMapShortFloatObject(true));
                factory->add_type_object("MapShortFloat", GetMapShortFloatIdentifier(false),
                GetMapShortFloatObject(false));

                factory->add_type_object("MapShortDouble", GetMapShortDoubleIdentifier(true),
                GetMapShortDoubleObject(true));
                factory->add_type_object("MapShortDouble", GetMapShortDoubleIdentifier(false),
                GetMapShortDoubleObject(false));

                factory->add_type_object("MapShortLongDouble", GetMapShortLongDoubleIdentifier(true),
                GetMapShortLongDoubleObject(true));
                factory->add_type_object("MapShortLongDouble", GetMapShortLongDoubleIdentifier(false),
                GetMapShortLongDoubleObject(false));

                factory->add_type_object("MapShortBoolean", GetMapShortBooleanIdentifier(true),
                GetMapShortBooleanObject(true));
                factory->add_type_object("MapShortBoolean", GetMapShortBooleanIdentifier(false),
                GetMapShortBooleanObject(false));

                factory->add_type_object("MapShortOctet", GetMapShortOctetIdentifier(true),
                GetMapShortOctetObject(true));
                factory->add_type_object("MapShortOctet", GetMapShortOctetIdentifier(false),
                GetMapShortOctetObject(false));

                factory->add_type_object("MapShortChar", GetMapShortCharIdentifier(true),
                GetMapShortCharObject(true));
                factory->add_type_object("MapShortChar", GetMapShortCharIdentifier(false),
                GetMapShortCharObject(false));

                factory->add_type_object("MapShortWChar", GetMapShortWCharIdentifier(true),
                GetMapShortWCharObject(true));
                factory->add_type_object("MapShortWChar", GetMapShortWCharIdentifier(false),
                GetMapShortWCharObject(false));

                factory->add_type_object("MapShortString", GetMapShortStringIdentifier(true),
                GetMapShortStringObject(true));
                factory->add_type_object("MapShortString", GetMapShortStringIdentifier(false),
                GetMapShortStringObject(false));

                factory->add_type_object("MapShortWString", GetMapShortWStringIdentifier(true),
                GetMapShortWStringObject(true));
                factory->add_type_object("MapShortWString", GetMapShortWStringIdentifier(false),
                GetMapShortWStringObject(false));

                factory->add_type_object("MapShortInnerAliasBoundedStringHelper", GetMapShortInnerAliasBoundedStringHelperIdentifier(true),
                GetMapShortInnerAliasBoundedStringHelperObject(true));
                factory->add_type_object("MapShortInnerAliasBoundedStringHelper", GetMapShortInnerAliasBoundedStringHelperIdentifier(false),
                GetMapShortInnerAliasBoundedStringHelperObject(false));

                factory->add_type_object("MapShortInnerAliasBoundedWStringHelper", GetMapShortInnerAliasBoundedWStringHelperIdentifier(true),
                GetMapShortInnerAliasBoundedWStringHelperObject(true));
                factory->add_type_object("MapShortInnerAliasBoundedWStringHelper", GetMapShortInnerAliasBoundedWStringHelperIdentifier(false),
                GetMapShortInnerAliasBoundedWStringHelperObject(false));

                factory->add_type_object("MapShortInnerEnumHelper", GetMapShortInnerEnumHelperIdentifier(true),
                GetMapShortInnerEnumHelperObject(true));
                factory->add_type_object("MapShortInnerEnumHelper", GetMapShortInnerEnumHelperIdentifier(false),
                GetMapShortInnerEnumHelperObject(false));

                factory->add_type_object("MapShortInnerBitMaskHelper", GetMapShortInnerBitMaskHelperIdentifier(true),
                GetMapShortInnerBitMaskHelperObject(true));
                factory->add_type_object("MapShortInnerBitMaskHelper", GetMapShortInnerBitMaskHelperIdentifier(false),
                GetMapShortInnerBitMaskHelperObject(false));

                factory->add_type_object("MapShortInnerAliasHelper", GetMapShortInnerAliasHelperIdentifier(true),
                GetMapShortInnerAliasHelperObject(true));
                factory->add_type_object("MapShortInnerAliasHelper", GetMapShortInnerAliasHelperIdentifier(false),
                GetMapShortInnerAliasHelperObject(false));

                factory->add_type_object("MapShortInnerAliasArrayHelper", GetMapShortInnerAliasArrayHelperIdentifier(true),
                GetMapShortInnerAliasArrayHelperObject(true));
                factory->add_type_object("MapShortInnerAliasArrayHelper", GetMapShortInnerAliasArrayHelperIdentifier(false),
                GetMapShortInnerAliasArrayHelperObject(false));

                factory->add_type_object("MapShortInnerAliasSequenceHelper", GetMapShortInnerAliasSequenceHelperIdentifier(true),
                GetMapShortInnerAliasSequenceHelperObject(true));
                factory->add_type_object("MapShortInnerAliasSequenceHelper", GetMapShortInnerAliasSequenceHelperIdentifier(false),
                GetMapShortInnerAliasSequenceHelperObject(false));

                factory->add_type_object("MapShortInnerAliasMapHelper", GetMapShortInnerAliasMapHelperIdentifier(true),
                GetMapShortInnerAliasMapHelperObject(true));
                factory->add_type_object("MapShortInnerAliasMapHelper", GetMapShortInnerAliasMapHelperIdentifier(false),
                GetMapShortInnerAliasMapHelperObject(false));

                factory->add_type_object("MapShortInnerUnionHelper", GetMapShortInnerUnionHelperIdentifier(true),
                GetMapShortInnerUnionHelperObject(true));
                factory->add_type_object("MapShortInnerUnionHelper", GetMapShortInnerUnionHelperIdentifier(false),
                GetMapShortInnerUnionHelperObject(false));

                factory->add_type_object("MapShortInnerStructureHelper", GetMapShortInnerStructureHelperIdentifier(true),
                GetMapShortInnerStructureHelperObject(true));
                factory->add_type_object("MapShortInnerStructureHelper", GetMapShortInnerStructureHelperIdentifier(false),
                GetMapShortInnerStructureHelperObject(false));

                factory->add_type_object("MapShortInnerBitsetHelper", GetMapShortInnerBitsetHelperIdentifier(true),
                GetMapShortInnerBitsetHelperObject(true));
                factory->add_type_object("MapShortInnerBitsetHelper", GetMapShortInnerBitsetHelperIdentifier(false),
                GetMapShortInnerBitsetHelperObject(false));

                factory->add_type_object("MapUShortShort", GetMapUShortShortIdentifier(true),
                GetMapUShortShortObject(true));
                factory->add_type_object("MapUShortShort", GetMapUShortShortIdentifier(false),
                GetMapUShortShortObject(false));

                factory->add_type_object("MapUShortUShort", GetMapUShortUShortIdentifier(true),
                GetMapUShortUShortObject(true));
                factory->add_type_object("MapUShortUShort", GetMapUShortUShortIdentifier(false),
                GetMapUShortUShortObject(false));

                factory->add_type_object("MapUShortLong", GetMapUShortLongIdentifier(true),
                GetMapUShortLongObject(true));
                factory->add_type_object("MapUShortLong", GetMapUShortLongIdentifier(false),
                GetMapUShortLongObject(false));

                factory->add_type_object("MapUShortULong", GetMapUShortULongIdentifier(true),
                GetMapUShortULongObject(true));
                factory->add_type_object("MapUShortULong", GetMapUShortULongIdentifier(false),
                GetMapUShortULongObject(false));

                factory->add_type_object("MapUShortLongLong", GetMapUShortLongLongIdentifier(true),
                GetMapUShortLongLongObject(true));
                factory->add_type_object("MapUShortLongLong", GetMapUShortLongLongIdentifier(false),
                GetMapUShortLongLongObject(false));

                factory->add_type_object("MapUShortULongLong", GetMapUShortULongLongIdentifier(true),
                GetMapUShortULongLongObject(true));
                factory->add_type_object("MapUShortULongLong", GetMapUShortULongLongIdentifier(false),
                GetMapUShortULongLongObject(false));

                factory->add_type_object("MapUShortFloat", GetMapUShortFloatIdentifier(true),
                GetMapUShortFloatObject(true));
                factory->add_type_object("MapUShortFloat", GetMapUShortFloatIdentifier(false),
                GetMapUShortFloatObject(false));

                factory->add_type_object("MapUShortDouble", GetMapUShortDoubleIdentifier(true),
                GetMapUShortDoubleObject(true));
                factory->add_type_object("MapUShortDouble", GetMapUShortDoubleIdentifier(false),
                GetMapUShortDoubleObject(false));

                factory->add_type_object("MapUShortLongDouble", GetMapUShortLongDoubleIdentifier(true),
                GetMapUShortLongDoubleObject(true));
                factory->add_type_object("MapUShortLongDouble", GetMapUShortLongDoubleIdentifier(false),
                GetMapUShortLongDoubleObject(false));

                factory->add_type_object("MapUShortBoolean", GetMapUShortBooleanIdentifier(true),
                GetMapUShortBooleanObject(true));
                factory->add_type_object("MapUShortBoolean", GetMapUShortBooleanIdentifier(false),
                GetMapUShortBooleanObject(false));

                factory->add_type_object("MapUShortOctet", GetMapUShortOctetIdentifier(true),
                GetMapUShortOctetObject(true));
                factory->add_type_object("MapUShortOctet", GetMapUShortOctetIdentifier(false),
                GetMapUShortOctetObject(false));

                factory->add_type_object("MapUShortChar", GetMapUShortCharIdentifier(true),
                GetMapUShortCharObject(true));
                factory->add_type_object("MapUShortChar", GetMapUShortCharIdentifier(false),
                GetMapUShortCharObject(false));

                factory->add_type_object("MapUShortWChar", GetMapUShortWCharIdentifier(true),
                GetMapUShortWCharObject(true));
                factory->add_type_object("MapUShortWChar", GetMapUShortWCharIdentifier(false),
                GetMapUShortWCharObject(false));

                factory->add_type_object("MapUShortString", GetMapUShortStringIdentifier(true),
                GetMapUShortStringObject(true));
                factory->add_type_object("MapUShortString", GetMapUShortStringIdentifier(false),
                GetMapUShortStringObject(false));

                factory->add_type_object("MapUShortWString", GetMapUShortWStringIdentifier(true),
                GetMapUShortWStringObject(true));
                factory->add_type_object("MapUShortWString", GetMapUShortWStringIdentifier(false),
                GetMapUShortWStringObject(false));

                factory->add_type_object("MapUShortInnerAliasBoundedStringHelper", GetMapUShortInnerAliasBoundedStringHelperIdentifier(true),
                GetMapUShortInnerAliasBoundedStringHelperObject(true));
                factory->add_type_object("MapUShortInnerAliasBoundedStringHelper", GetMapUShortInnerAliasBoundedStringHelperIdentifier(false),
                GetMapUShortInnerAliasBoundedStringHelperObject(false));

                factory->add_type_object("MapUShortInnerAliasBoundedWStringHelper", GetMapUShortInnerAliasBoundedWStringHelperIdentifier(true),
                GetMapUShortInnerAliasBoundedWStringHelperObject(true));
                factory->add_type_object("MapUShortInnerAliasBoundedWStringHelper", GetMapUShortInnerAliasBoundedWStringHelperIdentifier(false),
                GetMapUShortInnerAliasBoundedWStringHelperObject(false));

                factory->add_type_object("MapUShortInnerEnumHelper", GetMapUShortInnerEnumHelperIdentifier(true),
                GetMapUShortInnerEnumHelperObject(true));
                factory->add_type_object("MapUShortInnerEnumHelper", GetMapUShortInnerEnumHelperIdentifier(false),
                GetMapUShortInnerEnumHelperObject(false));

                factory->add_type_object("MapUShortInnerBitMaskHelper", GetMapUShortInnerBitMaskHelperIdentifier(true),
                GetMapUShortInnerBitMaskHelperObject(true));
                factory->add_type_object("MapUShortInnerBitMaskHelper", GetMapUShortInnerBitMaskHelperIdentifier(false),
                GetMapUShortInnerBitMaskHelperObject(false));

                factory->add_type_object("MapUShortInnerAliasHelper", GetMapUShortInnerAliasHelperIdentifier(true),
                GetMapUShortInnerAliasHelperObject(true));
                factory->add_type_object("MapUShortInnerAliasHelper", GetMapUShortInnerAliasHelperIdentifier(false),
                GetMapUShortInnerAliasHelperObject(false));

                factory->add_type_object("MapUShortInnerAliasArrayHelper", GetMapUShortInnerAliasArrayHelperIdentifier(true),
                GetMapUShortInnerAliasArrayHelperObject(true));
                factory->add_type_object("MapUShortInnerAliasArrayHelper", GetMapUShortInnerAliasArrayHelperIdentifier(false),
                GetMapUShortInnerAliasArrayHelperObject(false));

                factory->add_type_object("MapUShortInnerAliasSequenceHelper", GetMapUShortInnerAliasSequenceHelperIdentifier(true),
                GetMapUShortInnerAliasSequenceHelperObject(true));
                factory->add_type_object("MapUShortInnerAliasSequenceHelper", GetMapUShortInnerAliasSequenceHelperIdentifier(false),
                GetMapUShortInnerAliasSequenceHelperObject(false));

                factory->add_type_object("MapUShortInnerAliasMapHelper", GetMapUShortInnerAliasMapHelperIdentifier(true),
                GetMapUShortInnerAliasMapHelperObject(true));
                factory->add_type_object("MapUShortInnerAliasMapHelper", GetMapUShortInnerAliasMapHelperIdentifier(false),
                GetMapUShortInnerAliasMapHelperObject(false));

                factory->add_type_object("MapUShortInnerUnionHelper", GetMapUShortInnerUnionHelperIdentifier(true),
                GetMapUShortInnerUnionHelperObject(true));
                factory->add_type_object("MapUShortInnerUnionHelper", GetMapUShortInnerUnionHelperIdentifier(false),
                GetMapUShortInnerUnionHelperObject(false));

                factory->add_type_object("MapUShortInnerStructureHelper", GetMapUShortInnerStructureHelperIdentifier(true),
                GetMapUShortInnerStructureHelperObject(true));
                factory->add_type_object("MapUShortInnerStructureHelper", GetMapUShortInnerStructureHelperIdentifier(false),
                GetMapUShortInnerStructureHelperObject(false));

                factory->add_type_object("MapUShortInnerBitsetHelper", GetMapUShortInnerBitsetHelperIdentifier(true),
                GetMapUShortInnerBitsetHelperObject(true));
                factory->add_type_object("MapUShortInnerBitsetHelper", GetMapUShortInnerBitsetHelperIdentifier(false),
                GetMapUShortInnerBitsetHelperObject(false));

                factory->add_type_object("MapLongShort", GetMapLongShortIdentifier(true),
                GetMapLongShortObject(true));
                factory->add_type_object("MapLongShort", GetMapLongShortIdentifier(false),
                GetMapLongShortObject(false));

                factory->add_type_object("MapLongUShort", GetMapLongUShortIdentifier(true),
                GetMapLongUShortObject(true));
                factory->add_type_object("MapLongUShort", GetMapLongUShortIdentifier(false),
                GetMapLongUShortObject(false));

                factory->add_type_object("MapLongLong", GetMapLongLongIdentifier(true),
                GetMapLongLongObject(true));
                factory->add_type_object("MapLongLong", GetMapLongLongIdentifier(false),
                GetMapLongLongObject(false));

                factory->add_type_object("MapLongULong", GetMapLongULongIdentifier(true),
                GetMapLongULongObject(true));
                factory->add_type_object("MapLongULong", GetMapLongULongIdentifier(false),
                GetMapLongULongObject(false));

                factory->add_type_object("MapLongKeyLongLongValue", GetMapLongKeyLongLongValueIdentifier(true),
                GetMapLongKeyLongLongValueObject(true));
                factory->add_type_object("MapLongKeyLongLongValue", GetMapLongKeyLongLongValueIdentifier(false),
                GetMapLongKeyLongLongValueObject(false));

                factory->add_type_object("MapLongULongLong", GetMapLongULongLongIdentifier(true),
                GetMapLongULongLongObject(true));
                factory->add_type_object("MapLongULongLong", GetMapLongULongLongIdentifier(false),
                GetMapLongULongLongObject(false));

                factory->add_type_object("MapLongFloat", GetMapLongFloatIdentifier(true),
                GetMapLongFloatObject(true));
                factory->add_type_object("MapLongFloat", GetMapLongFloatIdentifier(false),
                GetMapLongFloatObject(false));

                factory->add_type_object("MapLongDouble", GetMapLongDoubleIdentifier(true),
                GetMapLongDoubleObject(true));
                factory->add_type_object("MapLongDouble", GetMapLongDoubleIdentifier(false),
                GetMapLongDoubleObject(false));

                factory->add_type_object("MapLongKeyLongDoubleValue", GetMapLongKeyLongDoubleValueIdentifier(true),
                GetMapLongKeyLongDoubleValueObject(true));
                factory->add_type_object("MapLongKeyLongDoubleValue", GetMapLongKeyLongDoubleValueIdentifier(false),
                GetMapLongKeyLongDoubleValueObject(false));

                factory->add_type_object("MapLongBoolean", GetMapLongBooleanIdentifier(true),
                GetMapLongBooleanObject(true));
                factory->add_type_object("MapLongBoolean", GetMapLongBooleanIdentifier(false),
                GetMapLongBooleanObject(false));

                factory->add_type_object("MapLongOctet", GetMapLongOctetIdentifier(true),
                GetMapLongOctetObject(true));
                factory->add_type_object("MapLongOctet", GetMapLongOctetIdentifier(false),
                GetMapLongOctetObject(false));

                factory->add_type_object("MapLongChar", GetMapLongCharIdentifier(true),
                GetMapLongCharObject(true));
                factory->add_type_object("MapLongChar", GetMapLongCharIdentifier(false),
                GetMapLongCharObject(false));

                factory->add_type_object("MapLongWChar", GetMapLongWCharIdentifier(true),
                GetMapLongWCharObject(true));
                factory->add_type_object("MapLongWChar", GetMapLongWCharIdentifier(false),
                GetMapLongWCharObject(false));

                factory->add_type_object("MapLongString", GetMapLongStringIdentifier(true),
                GetMapLongStringObject(true));
                factory->add_type_object("MapLongString", GetMapLongStringIdentifier(false),
                GetMapLongStringObject(false));

                factory->add_type_object("MapLongWString", GetMapLongWStringIdentifier(true),
                GetMapLongWStringObject(true));
                factory->add_type_object("MapLongWString", GetMapLongWStringIdentifier(false),
                GetMapLongWStringObject(false));

                factory->add_type_object("MapLongInnerAliasBoundedStringHelper", GetMapLongInnerAliasBoundedStringHelperIdentifier(true),
                GetMapLongInnerAliasBoundedStringHelperObject(true));
                factory->add_type_object("MapLongInnerAliasBoundedStringHelper", GetMapLongInnerAliasBoundedStringHelperIdentifier(false),
                GetMapLongInnerAliasBoundedStringHelperObject(false));

                factory->add_type_object("MapLongInnerAliasBoundedWStringHelper", GetMapLongInnerAliasBoundedWStringHelperIdentifier(true),
                GetMapLongInnerAliasBoundedWStringHelperObject(true));
                factory->add_type_object("MapLongInnerAliasBoundedWStringHelper", GetMapLongInnerAliasBoundedWStringHelperIdentifier(false),
                GetMapLongInnerAliasBoundedWStringHelperObject(false));

                factory->add_type_object("MapLongInnerEnumHelper", GetMapLongInnerEnumHelperIdentifier(true),
                GetMapLongInnerEnumHelperObject(true));
                factory->add_type_object("MapLongInnerEnumHelper", GetMapLongInnerEnumHelperIdentifier(false),
                GetMapLongInnerEnumHelperObject(false));

                factory->add_type_object("MapLongInnerBitMaskHelper", GetMapLongInnerBitMaskHelperIdentifier(true),
                GetMapLongInnerBitMaskHelperObject(true));
                factory->add_type_object("MapLongInnerBitMaskHelper", GetMapLongInnerBitMaskHelperIdentifier(false),
                GetMapLongInnerBitMaskHelperObject(false));

                factory->add_type_object("MapLongInnerAliasHelper", GetMapLongInnerAliasHelperIdentifier(true),
                GetMapLongInnerAliasHelperObject(true));
                factory->add_type_object("MapLongInnerAliasHelper", GetMapLongInnerAliasHelperIdentifier(false),
                GetMapLongInnerAliasHelperObject(false));

                factory->add_type_object("MapLongInnerAliasArrayHelper", GetMapLongInnerAliasArrayHelperIdentifier(true),
                GetMapLongInnerAliasArrayHelperObject(true));
                factory->add_type_object("MapLongInnerAliasArrayHelper", GetMapLongInnerAliasArrayHelperIdentifier(false),
                GetMapLongInnerAliasArrayHelperObject(false));

                factory->add_type_object("MapLongInnerAliasSequenceHelper", GetMapLongInnerAliasSequenceHelperIdentifier(true),
                GetMapLongInnerAliasSequenceHelperObject(true));
                factory->add_type_object("MapLongInnerAliasSequenceHelper", GetMapLongInnerAliasSequenceHelperIdentifier(false),
                GetMapLongInnerAliasSequenceHelperObject(false));

                factory->add_type_object("MapLongInnerAliasMapHelper", GetMapLongInnerAliasMapHelperIdentifier(true),
                GetMapLongInnerAliasMapHelperObject(true));
                factory->add_type_object("MapLongInnerAliasMapHelper", GetMapLongInnerAliasMapHelperIdentifier(false),
                GetMapLongInnerAliasMapHelperObject(false));

                factory->add_type_object("MapLongInnerUnionHelper", GetMapLongInnerUnionHelperIdentifier(true),
                GetMapLongInnerUnionHelperObject(true));
                factory->add_type_object("MapLongInnerUnionHelper", GetMapLongInnerUnionHelperIdentifier(false),
                GetMapLongInnerUnionHelperObject(false));

                factory->add_type_object("MapLongInnerStructureHelper", GetMapLongInnerStructureHelperIdentifier(true),
                GetMapLongInnerStructureHelperObject(true));
                factory->add_type_object("MapLongInnerStructureHelper", GetMapLongInnerStructureHelperIdentifier(false),
                GetMapLongInnerStructureHelperObject(false));

                factory->add_type_object("MapLongInnerBitsetHelper", GetMapLongInnerBitsetHelperIdentifier(true),
                GetMapLongInnerBitsetHelperObject(true));
                factory->add_type_object("MapLongInnerBitsetHelper", GetMapLongInnerBitsetHelperIdentifier(false),
                GetMapLongInnerBitsetHelperObject(false));

                factory->add_type_object("MapULongShort", GetMapULongShortIdentifier(true),
                GetMapULongShortObject(true));
                factory->add_type_object("MapULongShort", GetMapULongShortIdentifier(false),
                GetMapULongShortObject(false));

                factory->add_type_object("MapULongUShort", GetMapULongUShortIdentifier(true),
                GetMapULongUShortObject(true));
                factory->add_type_object("MapULongUShort", GetMapULongUShortIdentifier(false),
                GetMapULongUShortObject(false));

                factory->add_type_object("MapULongLong", GetMapULongLongIdentifier(true),
                GetMapULongLongObject(true));
                factory->add_type_object("MapULongLong", GetMapULongLongIdentifier(false),
                GetMapULongLongObject(false));

                factory->add_type_object("MapULongULong", GetMapULongULongIdentifier(true),
                GetMapULongULongObject(true));
                factory->add_type_object("MapULongULong", GetMapULongULongIdentifier(false),
                GetMapULongULongObject(false));

                factory->add_type_object("MapKeyULongValueLongLong", GetMapKeyULongValueLongLongIdentifier(true),
                GetMapKeyULongValueLongLongObject(true));
                factory->add_type_object("MapKeyULongValueLongLong", GetMapKeyULongValueLongLongIdentifier(false),
                GetMapKeyULongValueLongLongObject(false));

                factory->add_type_object("MapULongULongLong", GetMapULongULongLongIdentifier(true),
                GetMapULongULongLongObject(true));
                factory->add_type_object("MapULongULongLong", GetMapULongULongLongIdentifier(false),
                GetMapULongULongLongObject(false));

                factory->add_type_object("MapULongFloat", GetMapULongFloatIdentifier(true),
                GetMapULongFloatObject(true));
                factory->add_type_object("MapULongFloat", GetMapULongFloatIdentifier(false),
                GetMapULongFloatObject(false));

                factory->add_type_object("MapULongDouble", GetMapULongDoubleIdentifier(true),
                GetMapULongDoubleObject(true));
                factory->add_type_object("MapULongDouble", GetMapULongDoubleIdentifier(false),
                GetMapULongDoubleObject(false));

                factory->add_type_object("MapKeyULongValueLongDouble", GetMapKeyULongValueLongDoubleIdentifier(true),
                GetMapKeyULongValueLongDoubleObject(true));
                factory->add_type_object("MapKeyULongValueLongDouble", GetMapKeyULongValueLongDoubleIdentifier(false),
                GetMapKeyULongValueLongDoubleObject(false));

                factory->add_type_object("MapULongBoolean", GetMapULongBooleanIdentifier(true),
                GetMapULongBooleanObject(true));
                factory->add_type_object("MapULongBoolean", GetMapULongBooleanIdentifier(false),
                GetMapULongBooleanObject(false));

                factory->add_type_object("MapULongOctet", GetMapULongOctetIdentifier(true),
                GetMapULongOctetObject(true));
                factory->add_type_object("MapULongOctet", GetMapULongOctetIdentifier(false),
                GetMapULongOctetObject(false));

                factory->add_type_object("MapULongChar", GetMapULongCharIdentifier(true),
                GetMapULongCharObject(true));
                factory->add_type_object("MapULongChar", GetMapULongCharIdentifier(false),
                GetMapULongCharObject(false));

                factory->add_type_object("MapULongWChar", GetMapULongWCharIdentifier(true),
                GetMapULongWCharObject(true));
                factory->add_type_object("MapULongWChar", GetMapULongWCharIdentifier(false),
                GetMapULongWCharObject(false));

                factory->add_type_object("MapULongString", GetMapULongStringIdentifier(true),
                GetMapULongStringObject(true));
                factory->add_type_object("MapULongString", GetMapULongStringIdentifier(false),
                GetMapULongStringObject(false));

                factory->add_type_object("MapULongWString", GetMapULongWStringIdentifier(true),
                GetMapULongWStringObject(true));
                factory->add_type_object("MapULongWString", GetMapULongWStringIdentifier(false),
                GetMapULongWStringObject(false));

                factory->add_type_object("MapULongInnerAliasBoundedStringHelper", GetMapULongInnerAliasBoundedStringHelperIdentifier(true),
                GetMapULongInnerAliasBoundedStringHelperObject(true));
                factory->add_type_object("MapULongInnerAliasBoundedStringHelper", GetMapULongInnerAliasBoundedStringHelperIdentifier(false),
                GetMapULongInnerAliasBoundedStringHelperObject(false));

                factory->add_type_object("MapULongInnerAliasBoundedWStringHelper", GetMapULongInnerAliasBoundedWStringHelperIdentifier(true),
                GetMapULongInnerAliasBoundedWStringHelperObject(true));
                factory->add_type_object("MapULongInnerAliasBoundedWStringHelper", GetMapULongInnerAliasBoundedWStringHelperIdentifier(false),
                GetMapULongInnerAliasBoundedWStringHelperObject(false));

                factory->add_type_object("MapULongInnerEnumHelper", GetMapULongInnerEnumHelperIdentifier(true),
                GetMapULongInnerEnumHelperObject(true));
                factory->add_type_object("MapULongInnerEnumHelper", GetMapULongInnerEnumHelperIdentifier(false),
                GetMapULongInnerEnumHelperObject(false));

                factory->add_type_object("MapULongInnerBitMaskHelper", GetMapULongInnerBitMaskHelperIdentifier(true),
                GetMapULongInnerBitMaskHelperObject(true));
                factory->add_type_object("MapULongInnerBitMaskHelper", GetMapULongInnerBitMaskHelperIdentifier(false),
                GetMapULongInnerBitMaskHelperObject(false));

                factory->add_type_object("MapULongInnerAliasHelper", GetMapULongInnerAliasHelperIdentifier(true),
                GetMapULongInnerAliasHelperObject(true));
                factory->add_type_object("MapULongInnerAliasHelper", GetMapULongInnerAliasHelperIdentifier(false),
                GetMapULongInnerAliasHelperObject(false));

                factory->add_type_object("MapULongInnerAliasArrayHelper", GetMapULongInnerAliasArrayHelperIdentifier(true),
                GetMapULongInnerAliasArrayHelperObject(true));
                factory->add_type_object("MapULongInnerAliasArrayHelper", GetMapULongInnerAliasArrayHelperIdentifier(false),
                GetMapULongInnerAliasArrayHelperObject(false));

                factory->add_type_object("MapULongInnerAliasSequenceHelper", GetMapULongInnerAliasSequenceHelperIdentifier(true),
                GetMapULongInnerAliasSequenceHelperObject(true));
                factory->add_type_object("MapULongInnerAliasSequenceHelper", GetMapULongInnerAliasSequenceHelperIdentifier(false),
                GetMapULongInnerAliasSequenceHelperObject(false));

                factory->add_type_object("MapULongInnerAliasMapHelper", GetMapULongInnerAliasMapHelperIdentifier(true),
                GetMapULongInnerAliasMapHelperObject(true));
                factory->add_type_object("MapULongInnerAliasMapHelper", GetMapULongInnerAliasMapHelperIdentifier(false),
                GetMapULongInnerAliasMapHelperObject(false));

                factory->add_type_object("MapULongInnerUnionHelper", GetMapULongInnerUnionHelperIdentifier(true),
                GetMapULongInnerUnionHelperObject(true));
                factory->add_type_object("MapULongInnerUnionHelper", GetMapULongInnerUnionHelperIdentifier(false),
                GetMapULongInnerUnionHelperObject(false));

                factory->add_type_object("MapULongInnerStructureHelper", GetMapULongInnerStructureHelperIdentifier(true),
                GetMapULongInnerStructureHelperObject(true));
                factory->add_type_object("MapULongInnerStructureHelper", GetMapULongInnerStructureHelperIdentifier(false),
                GetMapULongInnerStructureHelperObject(false));

                factory->add_type_object("MapULongInnerBitsetHelper", GetMapULongInnerBitsetHelperIdentifier(true),
                GetMapULongInnerBitsetHelperObject(true));
                factory->add_type_object("MapULongInnerBitsetHelper", GetMapULongInnerBitsetHelperIdentifier(false),
                GetMapULongInnerBitsetHelperObject(false));

                factory->add_type_object("MapLongLongShort", GetMapLongLongShortIdentifier(true),
                GetMapLongLongShortObject(true));
                factory->add_type_object("MapLongLongShort", GetMapLongLongShortIdentifier(false),
                GetMapLongLongShortObject(false));

                factory->add_type_object("MapLongLongUShort", GetMapLongLongUShortIdentifier(true),
                GetMapLongLongUShortObject(true));
                factory->add_type_object("MapLongLongUShort", GetMapLongLongUShortIdentifier(false),
                GetMapLongLongUShortObject(false));

                factory->add_type_object("MapLongLongKeyLongValue", GetMapLongLongKeyLongValueIdentifier(true),
                GetMapLongLongKeyLongValueObject(true));
                factory->add_type_object("MapLongLongKeyLongValue", GetMapLongLongKeyLongValueIdentifier(false),
                GetMapLongLongKeyLongValueObject(false));

                factory->add_type_object("MapLongLongULong", GetMapLongLongULongIdentifier(true),
                GetMapLongLongULongObject(true));
                factory->add_type_object("MapLongLongULong", GetMapLongLongULongIdentifier(false),
                GetMapLongLongULongObject(false));

                factory->add_type_object("MapLongLongLongLong", GetMapLongLongLongLongIdentifier(true),
                GetMapLongLongLongLongObject(true));
                factory->add_type_object("MapLongLongLongLong", GetMapLongLongLongLongIdentifier(false),
                GetMapLongLongLongLongObject(false));

                factory->add_type_object("MapLongLongULongLong", GetMapLongLongULongLongIdentifier(true),
                GetMapLongLongULongLongObject(true));
                factory->add_type_object("MapLongLongULongLong", GetMapLongLongULongLongIdentifier(false),
                GetMapLongLongULongLongObject(false));

                factory->add_type_object("MapLongLongFloat", GetMapLongLongFloatIdentifier(true),
                GetMapLongLongFloatObject(true));
                factory->add_type_object("MapLongLongFloat", GetMapLongLongFloatIdentifier(false),
                GetMapLongLongFloatObject(false));

                factory->add_type_object("MapLongLongKeyDoubleValue", GetMapLongLongKeyDoubleValueIdentifier(true),
                GetMapLongLongKeyDoubleValueObject(true));
                factory->add_type_object("MapLongLongKeyDoubleValue", GetMapLongLongKeyDoubleValueIdentifier(false),
                GetMapLongLongKeyDoubleValueObject(false));

                factory->add_type_object("MapLongLongLongDouble", GetMapLongLongLongDoubleIdentifier(true),
                GetMapLongLongLongDoubleObject(true));
                factory->add_type_object("MapLongLongLongDouble", GetMapLongLongLongDoubleIdentifier(false),
                GetMapLongLongLongDoubleObject(false));

                factory->add_type_object("MapLongLongBoolean", GetMapLongLongBooleanIdentifier(true),
                GetMapLongLongBooleanObject(true));
                factory->add_type_object("MapLongLongBoolean", GetMapLongLongBooleanIdentifier(false),
                GetMapLongLongBooleanObject(false));

                factory->add_type_object("MapLongLongOctet", GetMapLongLongOctetIdentifier(true),
                GetMapLongLongOctetObject(true));
                factory->add_type_object("MapLongLongOctet", GetMapLongLongOctetIdentifier(false),
                GetMapLongLongOctetObject(false));

                factory->add_type_object("MapLongLongChar", GetMapLongLongCharIdentifier(true),
                GetMapLongLongCharObject(true));
                factory->add_type_object("MapLongLongChar", GetMapLongLongCharIdentifier(false),
                GetMapLongLongCharObject(false));

                factory->add_type_object("MapLongLongWChar", GetMapLongLongWCharIdentifier(true),
                GetMapLongLongWCharObject(true));
                factory->add_type_object("MapLongLongWChar", GetMapLongLongWCharIdentifier(false),
                GetMapLongLongWCharObject(false));

                factory->add_type_object("MapLongLongString", GetMapLongLongStringIdentifier(true),
                GetMapLongLongStringObject(true));
                factory->add_type_object("MapLongLongString", GetMapLongLongStringIdentifier(false),
                GetMapLongLongStringObject(false));

                factory->add_type_object("MapLongLongWString", GetMapLongLongWStringIdentifier(true),
                GetMapLongLongWStringObject(true));
                factory->add_type_object("MapLongLongWString", GetMapLongLongWStringIdentifier(false),
                GetMapLongLongWStringObject(false));

                factory->add_type_object("MapLongLongInnerAliasBoundedStringHelper", GetMapLongLongInnerAliasBoundedStringHelperIdentifier(true),
                GetMapLongLongInnerAliasBoundedStringHelperObject(true));
                factory->add_type_object("MapLongLongInnerAliasBoundedStringHelper", GetMapLongLongInnerAliasBoundedStringHelperIdentifier(false),
                GetMapLongLongInnerAliasBoundedStringHelperObject(false));

                factory->add_type_object("MapLongLongInnerAliasBoundedWStringHelper", GetMapLongLongInnerAliasBoundedWStringHelperIdentifier(true),
                GetMapLongLongInnerAliasBoundedWStringHelperObject(true));
                factory->add_type_object("MapLongLongInnerAliasBoundedWStringHelper", GetMapLongLongInnerAliasBoundedWStringHelperIdentifier(false),
                GetMapLongLongInnerAliasBoundedWStringHelperObject(false));

                factory->add_type_object("MapLongLongInnerEnumHelper", GetMapLongLongInnerEnumHelperIdentifier(true),
                GetMapLongLongInnerEnumHelperObject(true));
                factory->add_type_object("MapLongLongInnerEnumHelper", GetMapLongLongInnerEnumHelperIdentifier(false),
                GetMapLongLongInnerEnumHelperObject(false));

                factory->add_type_object("MapLongLongInnerBitMaskHelper", GetMapLongLongInnerBitMaskHelperIdentifier(true),
                GetMapLongLongInnerBitMaskHelperObject(true));
                factory->add_type_object("MapLongLongInnerBitMaskHelper", GetMapLongLongInnerBitMaskHelperIdentifier(false),
                GetMapLongLongInnerBitMaskHelperObject(false));

                factory->add_type_object("MapLongLongInnerAliasHelper", GetMapLongLongInnerAliasHelperIdentifier(true),
                GetMapLongLongInnerAliasHelperObject(true));
                factory->add_type_object("MapLongLongInnerAliasHelper", GetMapLongLongInnerAliasHelperIdentifier(false),
                GetMapLongLongInnerAliasHelperObject(false));

                factory->add_type_object("MapLongLongInnerAliasArrayHelper", GetMapLongLongInnerAliasArrayHelperIdentifier(true),
                GetMapLongLongInnerAliasArrayHelperObject(true));
                factory->add_type_object("MapLongLongInnerAliasArrayHelper", GetMapLongLongInnerAliasArrayHelperIdentifier(false),
                GetMapLongLongInnerAliasArrayHelperObject(false));

                factory->add_type_object("MapLongLongInnerAliasSequenceHelper", GetMapLongLongInnerAliasSequenceHelperIdentifier(true),
                GetMapLongLongInnerAliasSequenceHelperObject(true));
                factory->add_type_object("MapLongLongInnerAliasSequenceHelper", GetMapLongLongInnerAliasSequenceHelperIdentifier(false),
                GetMapLongLongInnerAliasSequenceHelperObject(false));

                factory->add_type_object("MapLongLongInnerAliasMapHelper", GetMapLongLongInnerAliasMapHelperIdentifier(true),
                GetMapLongLongInnerAliasMapHelperObject(true));
                factory->add_type_object("MapLongLongInnerAliasMapHelper", GetMapLongLongInnerAliasMapHelperIdentifier(false),
                GetMapLongLongInnerAliasMapHelperObject(false));

                factory->add_type_object("MapLongLongInnerUnionHelper", GetMapLongLongInnerUnionHelperIdentifier(true),
                GetMapLongLongInnerUnionHelperObject(true));
                factory->add_type_object("MapLongLongInnerUnionHelper", GetMapLongLongInnerUnionHelperIdentifier(false),
                GetMapLongLongInnerUnionHelperObject(false));

                factory->add_type_object("MapLongLongInnerStructureHelper", GetMapLongLongInnerStructureHelperIdentifier(true),
                GetMapLongLongInnerStructureHelperObject(true));
                factory->add_type_object("MapLongLongInnerStructureHelper", GetMapLongLongInnerStructureHelperIdentifier(false),
                GetMapLongLongInnerStructureHelperObject(false));

                factory->add_type_object("MapLongLongInnerBitsetHelper", GetMapLongLongInnerBitsetHelperIdentifier(true),
                GetMapLongLongInnerBitsetHelperObject(true));
                factory->add_type_object("MapLongLongInnerBitsetHelper", GetMapLongLongInnerBitsetHelperIdentifier(false),
                GetMapLongLongInnerBitsetHelperObject(false));

                factory->add_type_object("MapULongLongShort", GetMapULongLongShortIdentifier(true),
                GetMapULongLongShortObject(true));
                factory->add_type_object("MapULongLongShort", GetMapULongLongShortIdentifier(false),
                GetMapULongLongShortObject(false));

                factory->add_type_object("MapULongLongUShort", GetMapULongLongUShortIdentifier(true),
                GetMapULongLongUShortObject(true));
                factory->add_type_object("MapULongLongUShort", GetMapULongLongUShortIdentifier(false),
                GetMapULongLongUShortObject(false));

                factory->add_type_object("MapULongLongLong", GetMapULongLongLongIdentifier(true),
                GetMapULongLongLongObject(true));
                factory->add_type_object("MapULongLongLong", GetMapULongLongLongIdentifier(false),
                GetMapULongLongLongObject(false));

                factory->add_type_object("MapULongLongULong", GetMapULongLongULongIdentifier(true),
                GetMapULongLongULongObject(true));
                factory->add_type_object("MapULongLongULong", GetMapULongLongULongIdentifier(false),
                GetMapULongLongULongObject(false));

                factory->add_type_object("MapULongLongLongLong", GetMapULongLongLongLongIdentifier(true),
                GetMapULongLongLongLongObject(true));
                factory->add_type_object("MapULongLongLongLong", GetMapULongLongLongLongIdentifier(false),
                GetMapULongLongLongLongObject(false));

                factory->add_type_object("MapULongLongULongLong", GetMapULongLongULongLongIdentifier(true),
                GetMapULongLongULongLongObject(true));
                factory->add_type_object("MapULongLongULongLong", GetMapULongLongULongLongIdentifier(false),
                GetMapULongLongULongLongObject(false));

                factory->add_type_object("MapULongLongFloat", GetMapULongLongFloatIdentifier(true),
                GetMapULongLongFloatObject(true));
                factory->add_type_object("MapULongLongFloat", GetMapULongLongFloatIdentifier(false),
                GetMapULongLongFloatObject(false));

                factory->add_type_object("MapKeyULongLongValueDouble", GetMapKeyULongLongValueDoubleIdentifier(true),
                GetMapKeyULongLongValueDoubleObject(true));
                factory->add_type_object("MapKeyULongLongValueDouble", GetMapKeyULongLongValueDoubleIdentifier(false),
                GetMapKeyULongLongValueDoubleObject(false));

                factory->add_type_object("MapULongLongLongDouble", GetMapULongLongLongDoubleIdentifier(true),
                GetMapULongLongLongDoubleObject(true));
                factory->add_type_object("MapULongLongLongDouble", GetMapULongLongLongDoubleIdentifier(false),
                GetMapULongLongLongDoubleObject(false));

                factory->add_type_object("MapULongLongBoolean", GetMapULongLongBooleanIdentifier(true),
                GetMapULongLongBooleanObject(true));
                factory->add_type_object("MapULongLongBoolean", GetMapULongLongBooleanIdentifier(false),
                GetMapULongLongBooleanObject(false));

                factory->add_type_object("MapULongLongOctet", GetMapULongLongOctetIdentifier(true),
                GetMapULongLongOctetObject(true));
                factory->add_type_object("MapULongLongOctet", GetMapULongLongOctetIdentifier(false),
                GetMapULongLongOctetObject(false));

                factory->add_type_object("MapULongLongChar", GetMapULongLongCharIdentifier(true),
                GetMapULongLongCharObject(true));
                factory->add_type_object("MapULongLongChar", GetMapULongLongCharIdentifier(false),
                GetMapULongLongCharObject(false));

                factory->add_type_object("MapULongLongWChar", GetMapULongLongWCharIdentifier(true),
                GetMapULongLongWCharObject(true));
                factory->add_type_object("MapULongLongWChar", GetMapULongLongWCharIdentifier(false),
                GetMapULongLongWCharObject(false));

                factory->add_type_object("MapULongLongString", GetMapULongLongStringIdentifier(true),
                GetMapULongLongStringObject(true));
                factory->add_type_object("MapULongLongString", GetMapULongLongStringIdentifier(false),
                GetMapULongLongStringObject(false));

                factory->add_type_object("MapULongLongWString", GetMapULongLongWStringIdentifier(true),
                GetMapULongLongWStringObject(true));
                factory->add_type_object("MapULongLongWString", GetMapULongLongWStringIdentifier(false),
                GetMapULongLongWStringObject(false));

                factory->add_type_object("MapULongLongInnerAliasBoundedStringHelper", GetMapULongLongInnerAliasBoundedStringHelperIdentifier(true),
                GetMapULongLongInnerAliasBoundedStringHelperObject(true));
                factory->add_type_object("MapULongLongInnerAliasBoundedStringHelper", GetMapULongLongInnerAliasBoundedStringHelperIdentifier(false),
                GetMapULongLongInnerAliasBoundedStringHelperObject(false));

                factory->add_type_object("MapULongLongInnerAliasBoundedWStringHelper", GetMapULongLongInnerAliasBoundedWStringHelperIdentifier(true),
                GetMapULongLongInnerAliasBoundedWStringHelperObject(true));
                factory->add_type_object("MapULongLongInnerAliasBoundedWStringHelper", GetMapULongLongInnerAliasBoundedWStringHelperIdentifier(false),
                GetMapULongLongInnerAliasBoundedWStringHelperObject(false));

                factory->add_type_object("MapULongLongInnerEnumHelper", GetMapULongLongInnerEnumHelperIdentifier(true),
                GetMapULongLongInnerEnumHelperObject(true));
                factory->add_type_object("MapULongLongInnerEnumHelper", GetMapULongLongInnerEnumHelperIdentifier(false),
                GetMapULongLongInnerEnumHelperObject(false));

                factory->add_type_object("MapULongLongInnerBitMaskHelper", GetMapULongLongInnerBitMaskHelperIdentifier(true),
                GetMapULongLongInnerBitMaskHelperObject(true));
                factory->add_type_object("MapULongLongInnerBitMaskHelper", GetMapULongLongInnerBitMaskHelperIdentifier(false),
                GetMapULongLongInnerBitMaskHelperObject(false));

                factory->add_type_object("MapULongLongInnerAliasHelper", GetMapULongLongInnerAliasHelperIdentifier(true),
                GetMapULongLongInnerAliasHelperObject(true));
                factory->add_type_object("MapULongLongInnerAliasHelper", GetMapULongLongInnerAliasHelperIdentifier(false),
                GetMapULongLongInnerAliasHelperObject(false));

                factory->add_type_object("MapULongLongInnerAliasArrayHelper", GetMapULongLongInnerAliasArrayHelperIdentifier(true),
                GetMapULongLongInnerAliasArrayHelperObject(true));
                factory->add_type_object("MapULongLongInnerAliasArrayHelper", GetMapULongLongInnerAliasArrayHelperIdentifier(false),
                GetMapULongLongInnerAliasArrayHelperObject(false));

                factory->add_type_object("MapULongLongInnerAliasSequenceHelper", GetMapULongLongInnerAliasSequenceHelperIdentifier(true),
                GetMapULongLongInnerAliasSequenceHelperObject(true));
                factory->add_type_object("MapULongLongInnerAliasSequenceHelper", GetMapULongLongInnerAliasSequenceHelperIdentifier(false),
                GetMapULongLongInnerAliasSequenceHelperObject(false));

                factory->add_type_object("MapULongLongInnerAliasMapHelper", GetMapULongLongInnerAliasMapHelperIdentifier(true),
                GetMapULongLongInnerAliasMapHelperObject(true));
                factory->add_type_object("MapULongLongInnerAliasMapHelper", GetMapULongLongInnerAliasMapHelperIdentifier(false),
                GetMapULongLongInnerAliasMapHelperObject(false));

                factory->add_type_object("MapULongLongInnerUnionHelper", GetMapULongLongInnerUnionHelperIdentifier(true),
                GetMapULongLongInnerUnionHelperObject(true));
                factory->add_type_object("MapULongLongInnerUnionHelper", GetMapULongLongInnerUnionHelperIdentifier(false),
                GetMapULongLongInnerUnionHelperObject(false));

                factory->add_type_object("MapULongLongInnerStructureHelper", GetMapULongLongInnerStructureHelperIdentifier(true),
                GetMapULongLongInnerStructureHelperObject(true));
                factory->add_type_object("MapULongLongInnerStructureHelper", GetMapULongLongInnerStructureHelperIdentifier(false),
                GetMapULongLongInnerStructureHelperObject(false));

                factory->add_type_object("MapULongLongInnerBitsetHelper", GetMapULongLongInnerBitsetHelperIdentifier(true),
                GetMapULongLongInnerBitsetHelperObject(true));
                factory->add_type_object("MapULongLongInnerBitsetHelper", GetMapULongLongInnerBitsetHelperIdentifier(false),
                GetMapULongLongInnerBitsetHelperObject(false));

                factory->add_type_object("MapStringShort", GetMapStringShortIdentifier(true),
                GetMapStringShortObject(true));
                factory->add_type_object("MapStringShort", GetMapStringShortIdentifier(false),
                GetMapStringShortObject(false));

                factory->add_type_object("MapStringUShort", GetMapStringUShortIdentifier(true),
                GetMapStringUShortObject(true));
                factory->add_type_object("MapStringUShort", GetMapStringUShortIdentifier(false),
                GetMapStringUShortObject(false));

                factory->add_type_object("MapStringLong", GetMapStringLongIdentifier(true),
                GetMapStringLongObject(true));
                factory->add_type_object("MapStringLong", GetMapStringLongIdentifier(false),
                GetMapStringLongObject(false));

                factory->add_type_object("MapStringULong", GetMapStringULongIdentifier(true),
                GetMapStringULongObject(true));
                factory->add_type_object("MapStringULong", GetMapStringULongIdentifier(false),
                GetMapStringULongObject(false));

                factory->add_type_object("MapStringLongLong", GetMapStringLongLongIdentifier(true),
                GetMapStringLongLongObject(true));
                factory->add_type_object("MapStringLongLong", GetMapStringLongLongIdentifier(false),
                GetMapStringLongLongObject(false));

                factory->add_type_object("MapStringULongLong", GetMapStringULongLongIdentifier(true),
                GetMapStringULongLongObject(true));
                factory->add_type_object("MapStringULongLong", GetMapStringULongLongIdentifier(false),
                GetMapStringULongLongObject(false));

                factory->add_type_object("MapStringFloat", GetMapStringFloatIdentifier(true),
                GetMapStringFloatObject(true));
                factory->add_type_object("MapStringFloat", GetMapStringFloatIdentifier(false),
                GetMapStringFloatObject(false));

                factory->add_type_object("MapStringDouble", GetMapStringDoubleIdentifier(true),
                GetMapStringDoubleObject(true));
                factory->add_type_object("MapStringDouble", GetMapStringDoubleIdentifier(false),
                GetMapStringDoubleObject(false));

                factory->add_type_object("MapStringLongDouble", GetMapStringLongDoubleIdentifier(true),
                GetMapStringLongDoubleObject(true));
                factory->add_type_object("MapStringLongDouble", GetMapStringLongDoubleIdentifier(false),
                GetMapStringLongDoubleObject(false));

                factory->add_type_object("MapStringBoolean", GetMapStringBooleanIdentifier(true),
                GetMapStringBooleanObject(true));
                factory->add_type_object("MapStringBoolean", GetMapStringBooleanIdentifier(false),
                GetMapStringBooleanObject(false));

                factory->add_type_object("MapStringOctet", GetMapStringOctetIdentifier(true),
                GetMapStringOctetObject(true));
                factory->add_type_object("MapStringOctet", GetMapStringOctetIdentifier(false),
                GetMapStringOctetObject(false));

                factory->add_type_object("MapStringChar", GetMapStringCharIdentifier(true),
                GetMapStringCharObject(true));
                factory->add_type_object("MapStringChar", GetMapStringCharIdentifier(false),
                GetMapStringCharObject(false));

                factory->add_type_object("MapStringWChar", GetMapStringWCharIdentifier(true),
                GetMapStringWCharObject(true));
                factory->add_type_object("MapStringWChar", GetMapStringWCharIdentifier(false),
                GetMapStringWCharObject(false));

                factory->add_type_object("MapStringString", GetMapStringStringIdentifier(true),
                GetMapStringStringObject(true));
                factory->add_type_object("MapStringString", GetMapStringStringIdentifier(false),
                GetMapStringStringObject(false));

                factory->add_type_object("MapStringWString", GetMapStringWStringIdentifier(true),
                GetMapStringWStringObject(true));
                factory->add_type_object("MapStringWString", GetMapStringWStringIdentifier(false),
                GetMapStringWStringObject(false));

                factory->add_type_object("MapStringInnerAliasBoundedStringHelper", GetMapStringInnerAliasBoundedStringHelperIdentifier(true),
                GetMapStringInnerAliasBoundedStringHelperObject(true));
                factory->add_type_object("MapStringInnerAliasBoundedStringHelper", GetMapStringInnerAliasBoundedStringHelperIdentifier(false),
                GetMapStringInnerAliasBoundedStringHelperObject(false));

                factory->add_type_object("MapStringInnerAliasBoundedWStringHelper", GetMapStringInnerAliasBoundedWStringHelperIdentifier(true),
                GetMapStringInnerAliasBoundedWStringHelperObject(true));
                factory->add_type_object("MapStringInnerAliasBoundedWStringHelper", GetMapStringInnerAliasBoundedWStringHelperIdentifier(false),
                GetMapStringInnerAliasBoundedWStringHelperObject(false));

                factory->add_type_object("MapStringInnerEnumHelper", GetMapStringInnerEnumHelperIdentifier(true),
                GetMapStringInnerEnumHelperObject(true));
                factory->add_type_object("MapStringInnerEnumHelper", GetMapStringInnerEnumHelperIdentifier(false),
                GetMapStringInnerEnumHelperObject(false));

                factory->add_type_object("MapStringInnerBitMaskHelper", GetMapStringInnerBitMaskHelperIdentifier(true),
                GetMapStringInnerBitMaskHelperObject(true));
                factory->add_type_object("MapStringInnerBitMaskHelper", GetMapStringInnerBitMaskHelperIdentifier(false),
                GetMapStringInnerBitMaskHelperObject(false));

                factory->add_type_object("MapStringInnerAliasHelper", GetMapStringInnerAliasHelperIdentifier(true),
                GetMapStringInnerAliasHelperObject(true));
                factory->add_type_object("MapStringInnerAliasHelper", GetMapStringInnerAliasHelperIdentifier(false),
                GetMapStringInnerAliasHelperObject(false));

                factory->add_type_object("MapStringInnerAliasArrayHelper", GetMapStringInnerAliasArrayHelperIdentifier(true),
                GetMapStringInnerAliasArrayHelperObject(true));
                factory->add_type_object("MapStringInnerAliasArrayHelper", GetMapStringInnerAliasArrayHelperIdentifier(false),
                GetMapStringInnerAliasArrayHelperObject(false));

                factory->add_type_object("MapStringInnerAliasSequenceHelper", GetMapStringInnerAliasSequenceHelperIdentifier(true),
                GetMapStringInnerAliasSequenceHelperObject(true));
                factory->add_type_object("MapStringInnerAliasSequenceHelper", GetMapStringInnerAliasSequenceHelperIdentifier(false),
                GetMapStringInnerAliasSequenceHelperObject(false));

                factory->add_type_object("MapStringInnerAliasMapHelper", GetMapStringInnerAliasMapHelperIdentifier(true),
                GetMapStringInnerAliasMapHelperObject(true));
                factory->add_type_object("MapStringInnerAliasMapHelper", GetMapStringInnerAliasMapHelperIdentifier(false),
                GetMapStringInnerAliasMapHelperObject(false));

                factory->add_type_object("MapStringInnerUnionHelper", GetMapStringInnerUnionHelperIdentifier(true),
                GetMapStringInnerUnionHelperObject(true));
                factory->add_type_object("MapStringInnerUnionHelper", GetMapStringInnerUnionHelperIdentifier(false),
                GetMapStringInnerUnionHelperObject(false));

                factory->add_type_object("MapStringInnerStructureHelper", GetMapStringInnerStructureHelperIdentifier(true),
                GetMapStringInnerStructureHelperObject(true));
                factory->add_type_object("MapStringInnerStructureHelper", GetMapStringInnerStructureHelperIdentifier(false),
                GetMapStringInnerStructureHelperObject(false));

                factory->add_type_object("MapStringInnerBitsetHelper", GetMapStringInnerBitsetHelperIdentifier(true),
                GetMapStringInnerBitsetHelperObject(true));
                factory->add_type_object("MapStringInnerBitsetHelper", GetMapStringInnerBitsetHelperIdentifier(false),
                GetMapStringInnerBitsetHelperObject(false));

                factory->add_type_object("MapWStringShort", GetMapWStringShortIdentifier(true),
                GetMapWStringShortObject(true));
                factory->add_type_object("MapWStringShort", GetMapWStringShortIdentifier(false),
                GetMapWStringShortObject(false));

                factory->add_type_object("MapWStringUShort", GetMapWStringUShortIdentifier(true),
                GetMapWStringUShortObject(true));
                factory->add_type_object("MapWStringUShort", GetMapWStringUShortIdentifier(false),
                GetMapWStringUShortObject(false));

                factory->add_type_object("MapWStringLong", GetMapWStringLongIdentifier(true),
                GetMapWStringLongObject(true));
                factory->add_type_object("MapWStringLong", GetMapWStringLongIdentifier(false),
                GetMapWStringLongObject(false));

                factory->add_type_object("MapWStringULong", GetMapWStringULongIdentifier(true),
                GetMapWStringULongObject(true));
                factory->add_type_object("MapWStringULong", GetMapWStringULongIdentifier(false),
                GetMapWStringULongObject(false));

                factory->add_type_object("MapWStringLongLong", GetMapWStringLongLongIdentifier(true),
                GetMapWStringLongLongObject(true));
                factory->add_type_object("MapWStringLongLong", GetMapWStringLongLongIdentifier(false),
                GetMapWStringLongLongObject(false));

                factory->add_type_object("MapWStringULongLong", GetMapWStringULongLongIdentifier(true),
                GetMapWStringULongLongObject(true));
                factory->add_type_object("MapWStringULongLong", GetMapWStringULongLongIdentifier(false),
                GetMapWStringULongLongObject(false));

                factory->add_type_object("MapWStringFloat", GetMapWStringFloatIdentifier(true),
                GetMapWStringFloatObject(true));
                factory->add_type_object("MapWStringFloat", GetMapWStringFloatIdentifier(false),
                GetMapWStringFloatObject(false));

                factory->add_type_object("MapWStringDouble", GetMapWStringDoubleIdentifier(true),
                GetMapWStringDoubleObject(true));
                factory->add_type_object("MapWStringDouble", GetMapWStringDoubleIdentifier(false),
                GetMapWStringDoubleObject(false));

                factory->add_type_object("MapWStringLongDouble", GetMapWStringLongDoubleIdentifier(true),
                GetMapWStringLongDoubleObject(true));
                factory->add_type_object("MapWStringLongDouble", GetMapWStringLongDoubleIdentifier(false),
                GetMapWStringLongDoubleObject(false));

                factory->add_type_object("MapWStringBoolean", GetMapWStringBooleanIdentifier(true),
                GetMapWStringBooleanObject(true));
                factory->add_type_object("MapWStringBoolean", GetMapWStringBooleanIdentifier(false),
                GetMapWStringBooleanObject(false));

                factory->add_type_object("MapWStringOctet", GetMapWStringOctetIdentifier(true),
                GetMapWStringOctetObject(true));
                factory->add_type_object("MapWStringOctet", GetMapWStringOctetIdentifier(false),
                GetMapWStringOctetObject(false));

                factory->add_type_object("MapWStringChar", GetMapWStringCharIdentifier(true),
                GetMapWStringCharObject(true));
                factory->add_type_object("MapWStringChar", GetMapWStringCharIdentifier(false),
                GetMapWStringCharObject(false));

                factory->add_type_object("MapWStringWChar", GetMapWStringWCharIdentifier(true),
                GetMapWStringWCharObject(true));
                factory->add_type_object("MapWStringWChar", GetMapWStringWCharIdentifier(false),
                GetMapWStringWCharObject(false));

                factory->add_type_object("MapWStringString", GetMapWStringStringIdentifier(true),
                GetMapWStringStringObject(true));
                factory->add_type_object("MapWStringString", GetMapWStringStringIdentifier(false),
                GetMapWStringStringObject(false));

                factory->add_type_object("MapWStringWString", GetMapWStringWStringIdentifier(true),
                GetMapWStringWStringObject(true));
                factory->add_type_object("MapWStringWString", GetMapWStringWStringIdentifier(false),
                GetMapWStringWStringObject(false));

                factory->add_type_object("MapWStringInnerAliasBoundedStringHelper", GetMapWStringInnerAliasBoundedStringHelperIdentifier(true),
                GetMapWStringInnerAliasBoundedStringHelperObject(true));
                factory->add_type_object("MapWStringInnerAliasBoundedStringHelper", GetMapWStringInnerAliasBoundedStringHelperIdentifier(false),
                GetMapWStringInnerAliasBoundedStringHelperObject(false));

                factory->add_type_object("MapWStringInnerAliasBoundedWStringHelper", GetMapWStringInnerAliasBoundedWStringHelperIdentifier(true),
                GetMapWStringInnerAliasBoundedWStringHelperObject(true));
                factory->add_type_object("MapWStringInnerAliasBoundedWStringHelper", GetMapWStringInnerAliasBoundedWStringHelperIdentifier(false),
                GetMapWStringInnerAliasBoundedWStringHelperObject(false));

                factory->add_type_object("MapWStringInnerEnumHelper", GetMapWStringInnerEnumHelperIdentifier(true),
                GetMapWStringInnerEnumHelperObject(true));
                factory->add_type_object("MapWStringInnerEnumHelper", GetMapWStringInnerEnumHelperIdentifier(false),
                GetMapWStringInnerEnumHelperObject(false));

                factory->add_type_object("MapWStringInnerBitMaskHelper", GetMapWStringInnerBitMaskHelperIdentifier(true),
                GetMapWStringInnerBitMaskHelperObject(true));
                factory->add_type_object("MapWStringInnerBitMaskHelper", GetMapWStringInnerBitMaskHelperIdentifier(false),
                GetMapWStringInnerBitMaskHelperObject(false));

                factory->add_type_object("MapWStringInnerAliasHelper", GetMapWStringInnerAliasHelperIdentifier(true),
                GetMapWStringInnerAliasHelperObject(true));
                factory->add_type_object("MapWStringInnerAliasHelper", GetMapWStringInnerAliasHelperIdentifier(false),
                GetMapWStringInnerAliasHelperObject(false));

                factory->add_type_object("MapWStringInnerAliasArrayHelper", GetMapWStringInnerAliasArrayHelperIdentifier(true),
                GetMapWStringInnerAliasArrayHelperObject(true));
                factory->add_type_object("MapWStringInnerAliasArrayHelper", GetMapWStringInnerAliasArrayHelperIdentifier(false),
                GetMapWStringInnerAliasArrayHelperObject(false));

                factory->add_type_object("MapWStringInnerAliasSequenceHelper", GetMapWStringInnerAliasSequenceHelperIdentifier(true),
                GetMapWStringInnerAliasSequenceHelperObject(true));
                factory->add_type_object("MapWStringInnerAliasSequenceHelper", GetMapWStringInnerAliasSequenceHelperIdentifier(false),
                GetMapWStringInnerAliasSequenceHelperObject(false));

                factory->add_type_object("MapWStringInnerAliasMapHelper", GetMapWStringInnerAliasMapHelperIdentifier(true),
                GetMapWStringInnerAliasMapHelperObject(true));
                factory->add_type_object("MapWStringInnerAliasMapHelper", GetMapWStringInnerAliasMapHelperIdentifier(false),
                GetMapWStringInnerAliasMapHelperObject(false));

                factory->add_type_object("MapWStringInnerUnionHelper", GetMapWStringInnerUnionHelperIdentifier(true),
                GetMapWStringInnerUnionHelperObject(true));
                factory->add_type_object("MapWStringInnerUnionHelper", GetMapWStringInnerUnionHelperIdentifier(false),
                GetMapWStringInnerUnionHelperObject(false));

                factory->add_type_object("MapWStringInnerStructureHelper", GetMapWStringInnerStructureHelperIdentifier(true),
                GetMapWStringInnerStructureHelperObject(true));
                factory->add_type_object("MapWStringInnerStructureHelper", GetMapWStringInnerStructureHelperIdentifier(false),
                GetMapWStringInnerStructureHelperObject(false));

                factory->add_type_object("MapWStringInnerBitsetHelper", GetMapWStringInnerBitsetHelperIdentifier(true),
                GetMapWStringInnerBitsetHelperObject(true));
                factory->add_type_object("MapWStringInnerBitsetHelper", GetMapWStringInnerBitsetHelperIdentifier(false),
                GetMapWStringInnerBitsetHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperShort", GetMapInnerAliasBoundedStringHelperShortIdentifier(true),
                GetMapInnerAliasBoundedStringHelperShortObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperShort", GetMapInnerAliasBoundedStringHelperShortIdentifier(false),
                GetMapInnerAliasBoundedStringHelperShortObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperUShort", GetMapInnerAliasBoundedStringHelperUShortIdentifier(true),
                GetMapInnerAliasBoundedStringHelperUShortObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperUShort", GetMapInnerAliasBoundedStringHelperUShortIdentifier(false),
                GetMapInnerAliasBoundedStringHelperUShortObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperLong", GetMapInnerAliasBoundedStringHelperLongIdentifier(true),
                GetMapInnerAliasBoundedStringHelperLongObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperLong", GetMapInnerAliasBoundedStringHelperLongIdentifier(false),
                GetMapInnerAliasBoundedStringHelperLongObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperULong", GetMapInnerAliasBoundedStringHelperULongIdentifier(true),
                GetMapInnerAliasBoundedStringHelperULongObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperULong", GetMapInnerAliasBoundedStringHelperULongIdentifier(false),
                GetMapInnerAliasBoundedStringHelperULongObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperLongLong", GetMapInnerAliasBoundedStringHelperLongLongIdentifier(true),
                GetMapInnerAliasBoundedStringHelperLongLongObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperLongLong", GetMapInnerAliasBoundedStringHelperLongLongIdentifier(false),
                GetMapInnerAliasBoundedStringHelperLongLongObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperULongLong", GetMapInnerAliasBoundedStringHelperULongLongIdentifier(true),
                GetMapInnerAliasBoundedStringHelperULongLongObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperULongLong", GetMapInnerAliasBoundedStringHelperULongLongIdentifier(false),
                GetMapInnerAliasBoundedStringHelperULongLongObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperFloat", GetMapInnerAliasBoundedStringHelperFloatIdentifier(true),
                GetMapInnerAliasBoundedStringHelperFloatObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperFloat", GetMapInnerAliasBoundedStringHelperFloatIdentifier(false),
                GetMapInnerAliasBoundedStringHelperFloatObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperDouble", GetMapInnerAliasBoundedStringHelperDoubleIdentifier(true),
                GetMapInnerAliasBoundedStringHelperDoubleObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperDouble", GetMapInnerAliasBoundedStringHelperDoubleIdentifier(false),
                GetMapInnerAliasBoundedStringHelperDoubleObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperLongDouble", GetMapInnerAliasBoundedStringHelperLongDoubleIdentifier(true),
                GetMapInnerAliasBoundedStringHelperLongDoubleObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperLongDouble", GetMapInnerAliasBoundedStringHelperLongDoubleIdentifier(false),
                GetMapInnerAliasBoundedStringHelperLongDoubleObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperBoolean", GetMapInnerAliasBoundedStringHelperBooleanIdentifier(true),
                GetMapInnerAliasBoundedStringHelperBooleanObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperBoolean", GetMapInnerAliasBoundedStringHelperBooleanIdentifier(false),
                GetMapInnerAliasBoundedStringHelperBooleanObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperOctet", GetMapInnerAliasBoundedStringHelperOctetIdentifier(true),
                GetMapInnerAliasBoundedStringHelperOctetObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperOctet", GetMapInnerAliasBoundedStringHelperOctetIdentifier(false),
                GetMapInnerAliasBoundedStringHelperOctetObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperChar", GetMapInnerAliasBoundedStringHelperCharIdentifier(true),
                GetMapInnerAliasBoundedStringHelperCharObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperChar", GetMapInnerAliasBoundedStringHelperCharIdentifier(false),
                GetMapInnerAliasBoundedStringHelperCharObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperWChar", GetMapInnerAliasBoundedStringHelperWCharIdentifier(true),
                GetMapInnerAliasBoundedStringHelperWCharObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperWChar", GetMapInnerAliasBoundedStringHelperWCharIdentifier(false),
                GetMapInnerAliasBoundedStringHelperWCharObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperString", GetMapInnerAliasBoundedStringHelperStringIdentifier(true),
                GetMapInnerAliasBoundedStringHelperStringObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperString", GetMapInnerAliasBoundedStringHelperStringIdentifier(false),
                GetMapInnerAliasBoundedStringHelperStringObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperWString", GetMapInnerAliasBoundedStringHelperWStringIdentifier(true),
                GetMapInnerAliasBoundedStringHelperWStringObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperWString", GetMapInnerAliasBoundedStringHelperWStringIdentifier(false),
                GetMapInnerAliasBoundedStringHelperWStringObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper", GetMapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelperIdentifier(true),
                GetMapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper", GetMapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelperIdentifier(false),
                GetMapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper", GetMapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelperIdentifier(true),
                GetMapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper", GetMapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelperIdentifier(false),
                GetMapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerEnumHelper", GetMapInnerAliasBoundedStringHelperInnerEnumHelperIdentifier(true),
                GetMapInnerAliasBoundedStringHelperInnerEnumHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerEnumHelper", GetMapInnerAliasBoundedStringHelperInnerEnumHelperIdentifier(false),
                GetMapInnerAliasBoundedStringHelperInnerEnumHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerBitMaskHelper", GetMapInnerAliasBoundedStringHelperInnerBitMaskHelperIdentifier(true),
                GetMapInnerAliasBoundedStringHelperInnerBitMaskHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerBitMaskHelper", GetMapInnerAliasBoundedStringHelperInnerBitMaskHelperIdentifier(false),
                GetMapInnerAliasBoundedStringHelperInnerBitMaskHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasHelper", GetMapInnerAliasBoundedStringHelperInnerAliasHelperIdentifier(true),
                GetMapInnerAliasBoundedStringHelperInnerAliasHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasHelper", GetMapInnerAliasBoundedStringHelperInnerAliasHelperIdentifier(false),
                GetMapInnerAliasBoundedStringHelperInnerAliasHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasArrayHelper", GetMapInnerAliasBoundedStringHelperInnerAliasArrayHelperIdentifier(true),
                GetMapInnerAliasBoundedStringHelperInnerAliasArrayHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasArrayHelper", GetMapInnerAliasBoundedStringHelperInnerAliasArrayHelperIdentifier(false),
                GetMapInnerAliasBoundedStringHelperInnerAliasArrayHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper", GetMapInnerAliasBoundedStringHelperInnerAliasSequenceHelperIdentifier(true),
                GetMapInnerAliasBoundedStringHelperInnerAliasSequenceHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper", GetMapInnerAliasBoundedStringHelperInnerAliasSequenceHelperIdentifier(false),
                GetMapInnerAliasBoundedStringHelperInnerAliasSequenceHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasMapHelper", GetMapInnerAliasBoundedStringHelperInnerAliasMapHelperIdentifier(true),
                GetMapInnerAliasBoundedStringHelperInnerAliasMapHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasMapHelper", GetMapInnerAliasBoundedStringHelperInnerAliasMapHelperIdentifier(false),
                GetMapInnerAliasBoundedStringHelperInnerAliasMapHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerUnionHelper", GetMapInnerAliasBoundedStringHelperInnerUnionHelperIdentifier(true),
                GetMapInnerAliasBoundedStringHelperInnerUnionHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerUnionHelper", GetMapInnerAliasBoundedStringHelperInnerUnionHelperIdentifier(false),
                GetMapInnerAliasBoundedStringHelperInnerUnionHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerStructureHelper", GetMapInnerAliasBoundedStringHelperInnerStructureHelperIdentifier(true),
                GetMapInnerAliasBoundedStringHelperInnerStructureHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerStructureHelper", GetMapInnerAliasBoundedStringHelperInnerStructureHelperIdentifier(false),
                GetMapInnerAliasBoundedStringHelperInnerStructureHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerBitsetHelper", GetMapInnerAliasBoundedStringHelperInnerBitsetHelperIdentifier(true),
                GetMapInnerAliasBoundedStringHelperInnerBitsetHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedStringHelperInnerBitsetHelper", GetMapInnerAliasBoundedStringHelperInnerBitsetHelperIdentifier(false),
                GetMapInnerAliasBoundedStringHelperInnerBitsetHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperShort", GetMapInnerAliasBoundedWStringHelperShortIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperShortObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperShort", GetMapInnerAliasBoundedWStringHelperShortIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperShortObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperUShort", GetMapInnerAliasBoundedWStringHelperUShortIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperUShortObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperUShort", GetMapInnerAliasBoundedWStringHelperUShortIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperUShortObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperLong", GetMapInnerAliasBoundedWStringHelperLongIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperLongObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperLong", GetMapInnerAliasBoundedWStringHelperLongIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperLongObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperULong", GetMapInnerAliasBoundedWStringHelperULongIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperULongObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperULong", GetMapInnerAliasBoundedWStringHelperULongIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperULongObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperLongLong", GetMapInnerAliasBoundedWStringHelperLongLongIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperLongLongObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperLongLong", GetMapInnerAliasBoundedWStringHelperLongLongIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperLongLongObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperULongLong", GetMapInnerAliasBoundedWStringHelperULongLongIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperULongLongObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperULongLong", GetMapInnerAliasBoundedWStringHelperULongLongIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperULongLongObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperFloat", GetMapInnerAliasBoundedWStringHelperFloatIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperFloatObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperFloat", GetMapInnerAliasBoundedWStringHelperFloatIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperFloatObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperDouble", GetMapInnerAliasBoundedWStringHelperDoubleIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperDoubleObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperDouble", GetMapInnerAliasBoundedWStringHelperDoubleIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperDoubleObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperLongDouble", GetMapInnerAliasBoundedWStringHelperLongDoubleIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperLongDoubleObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperLongDouble", GetMapInnerAliasBoundedWStringHelperLongDoubleIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperLongDoubleObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperBoolean", GetMapInnerAliasBoundedWStringHelperBooleanIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperBooleanObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperBoolean", GetMapInnerAliasBoundedWStringHelperBooleanIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperBooleanObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperOctet", GetMapInnerAliasBoundedWStringHelperOctetIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperOctetObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperOctet", GetMapInnerAliasBoundedWStringHelperOctetIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperOctetObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperChar", GetMapInnerAliasBoundedWStringHelperCharIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperCharObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperChar", GetMapInnerAliasBoundedWStringHelperCharIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperCharObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperWChar", GetMapInnerAliasBoundedWStringHelperWCharIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperWCharObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperWChar", GetMapInnerAliasBoundedWStringHelperWCharIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperWCharObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperString", GetMapInnerAliasBoundedWStringHelperStringIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperStringObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperString", GetMapInnerAliasBoundedWStringHelperStringIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperStringObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperWString", GetMapInnerAliasBoundedWStringHelperWStringIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperWStringObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperWString", GetMapInnerAliasBoundedWStringHelperWStringIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperWStringObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper", GetMapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelperIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper", GetMapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelperIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper", GetMapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelperIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper", GetMapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelperIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerEnumHelper", GetMapInnerAliasBoundedWStringHelperInnerEnumHelperIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperInnerEnumHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerEnumHelper", GetMapInnerAliasBoundedWStringHelperInnerEnumHelperIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperInnerEnumHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerBitMaskHelper", GetMapInnerAliasBoundedWStringHelperInnerBitMaskHelperIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperInnerBitMaskHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerBitMaskHelper", GetMapInnerAliasBoundedWStringHelperInnerBitMaskHelperIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperInnerBitMaskHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasHelper", GetMapInnerAliasBoundedWStringHelperInnerAliasHelperIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperInnerAliasHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasHelper", GetMapInnerAliasBoundedWStringHelperInnerAliasHelperIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperInnerAliasHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper", GetMapInnerAliasBoundedWStringHelperInnerAliasArrayHelperIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperInnerAliasArrayHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper", GetMapInnerAliasBoundedWStringHelperInnerAliasArrayHelperIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperInnerAliasArrayHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper", GetMapInnerAliasBoundedWStringHelperInnerAliasSequenceHelperIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperInnerAliasSequenceHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper", GetMapInnerAliasBoundedWStringHelperInnerAliasSequenceHelperIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperInnerAliasSequenceHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasMapHelper", GetMapInnerAliasBoundedWStringHelperInnerAliasMapHelperIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperInnerAliasMapHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasMapHelper", GetMapInnerAliasBoundedWStringHelperInnerAliasMapHelperIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperInnerAliasMapHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerUnionHelper", GetMapInnerAliasBoundedWStringHelperInnerUnionHelperIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperInnerUnionHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerUnionHelper", GetMapInnerAliasBoundedWStringHelperInnerUnionHelperIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperInnerUnionHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerStructureHelper", GetMapInnerAliasBoundedWStringHelperInnerStructureHelperIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperInnerStructureHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerStructureHelper", GetMapInnerAliasBoundedWStringHelperInnerStructureHelperIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperInnerStructureHelperObject(false));

                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerBitsetHelper", GetMapInnerAliasBoundedWStringHelperInnerBitsetHelperIdentifier(true),
                GetMapInnerAliasBoundedWStringHelperInnerBitsetHelperObject(true));
                factory->add_type_object("MapInnerAliasBoundedWStringHelperInnerBitsetHelper", GetMapInnerAliasBoundedWStringHelperInnerBitsetHelperIdentifier(false),
                GetMapInnerAliasBoundedWStringHelperInnerBitsetHelperObject(false));

                factory->add_type_object("BoundedSmallMap", GetBoundedSmallMapIdentifier(true),
                GetBoundedSmallMapObject(true));
                factory->add_type_object("BoundedSmallMap", GetBoundedSmallMapIdentifier(false),
                GetBoundedSmallMapObject(false));

                factory->add_type_object("BoundedLargeMap", GetBoundedLargeMapIdentifier(true),
                GetBoundedLargeMapObject(true));
                factory->add_type_object("BoundedLargeMap", GetBoundedLargeMapIdentifier(false),
                GetBoundedLargeMapObject(false));

            });
}

const TypeIdentifier* GetMapShortShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortShort", complete);
}

const TypeObject* GetMapShortShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortShortObject();
    }
    //else
    return GetMinimalMapShortShortObject();
}

const TypeObject* GetMinimalMapShortShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_short;
    mst_var_map_short_short.common().member_id(memberId++);
    mst_var_map_short_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_short.common().member_flags().IS_KEY(false);
    mst_var_map_short_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "int16_t", 100, false));


    MD5 var_map_short_short_hash("var_map_short_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_short.detail().name_hash()[i] = var_map_short_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortShort", false);
}

const TypeObject* GetCompleteMapShortShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_short;
    cst_var_map_short_short.common().member_id(memberId++);
    cst_var_map_short_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_short.common().member_flags().IS_KEY(false);
    cst_var_map_short_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "int16_t", 100, true));


    cst_var_map_short_short.detail().name("var_map_short_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortShort", true);
}

const TypeIdentifier* GetMapShortUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortUShort", complete);
}

const TypeObject* GetMapShortUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortUShortObject();
    }
    //else
    return GetMinimalMapShortUShortObject();
}

const TypeObject* GetMinimalMapShortUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_ushort;
    mst_var_map_short_ushort.common().member_id(memberId++);
    mst_var_map_short_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_ushort.common().member_flags().IS_KEY(false);
    mst_var_map_short_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "uint16_t", 100, false));


    MD5 var_map_short_ushort_hash("var_map_short_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_ushort.detail().name_hash()[i] = var_map_short_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortUShort", false);
}

const TypeObject* GetCompleteMapShortUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_ushort;
    cst_var_map_short_ushort.common().member_id(memberId++);
    cst_var_map_short_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_ushort.common().member_flags().IS_KEY(false);
    cst_var_map_short_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "uint16_t", 100, true));


    cst_var_map_short_ushort.detail().name("var_map_short_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortUShort", true);
}

const TypeIdentifier* GetMapShortLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortLong", complete);
}

const TypeObject* GetMapShortLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortLongObject();
    }
    //else
    return GetMinimalMapShortLongObject();
}

const TypeObject* GetMinimalMapShortLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_long;
    mst_var_map_short_long.common().member_id(memberId++);
    mst_var_map_short_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_long.common().member_flags().IS_KEY(false);
    mst_var_map_short_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "int32_t", 100, false));


    MD5 var_map_short_long_hash("var_map_short_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_long.detail().name_hash()[i] = var_map_short_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortLong", false);
}

const TypeObject* GetCompleteMapShortLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_long;
    cst_var_map_short_long.common().member_id(memberId++);
    cst_var_map_short_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_long.common().member_flags().IS_KEY(false);
    cst_var_map_short_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "int32_t", 100, true));


    cst_var_map_short_long.detail().name("var_map_short_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortLong", true);
}

const TypeIdentifier* GetMapShortULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortULong", complete);
}

const TypeObject* GetMapShortULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortULongObject();
    }
    //else
    return GetMinimalMapShortULongObject();
}

const TypeObject* GetMinimalMapShortULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_ulong;
    mst_var_map_short_ulong.common().member_id(memberId++);
    mst_var_map_short_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_ulong.common().member_flags().IS_KEY(false);
    mst_var_map_short_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "uint32_t", 100, false));


    MD5 var_map_short_ulong_hash("var_map_short_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_ulong.detail().name_hash()[i] = var_map_short_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortULong", false);
}

const TypeObject* GetCompleteMapShortULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_ulong;
    cst_var_map_short_ulong.common().member_id(memberId++);
    cst_var_map_short_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_ulong.common().member_flags().IS_KEY(false);
    cst_var_map_short_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "uint32_t", 100, true));


    cst_var_map_short_ulong.detail().name("var_map_short_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortULong", true);
}

const TypeIdentifier* GetMapShortLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortLongLong", complete);
}

const TypeObject* GetMapShortLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortLongLongObject();
    }
    //else
    return GetMinimalMapShortLongLongObject();
}

const TypeObject* GetMinimalMapShortLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_longlong;
    mst_var_map_short_longlong.common().member_id(memberId++);
    mst_var_map_short_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_longlong.common().member_flags().IS_KEY(false);
    mst_var_map_short_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "int64_t", 100, false));


    MD5 var_map_short_longlong_hash("var_map_short_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_longlong.detail().name_hash()[i] = var_map_short_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortLongLong", false);
}

const TypeObject* GetCompleteMapShortLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_longlong;
    cst_var_map_short_longlong.common().member_id(memberId++);
    cst_var_map_short_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_longlong.common().member_flags().IS_KEY(false);
    cst_var_map_short_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "int64_t", 100, true));


    cst_var_map_short_longlong.detail().name("var_map_short_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortLongLong", true);
}

const TypeIdentifier* GetMapShortULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortULongLong", complete);
}

const TypeObject* GetMapShortULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortULongLongObject();
    }
    //else
    return GetMinimalMapShortULongLongObject();
}

const TypeObject* GetMinimalMapShortULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_ulonglong;
    mst_var_map_short_ulonglong.common().member_id(memberId++);
    mst_var_map_short_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_map_short_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "uint64_t", 100, false));


    MD5 var_map_short_ulonglong_hash("var_map_short_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_ulonglong.detail().name_hash()[i] = var_map_short_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortULongLong", false);
}

const TypeObject* GetCompleteMapShortULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_ulonglong;
    cst_var_map_short_ulonglong.common().member_id(memberId++);
    cst_var_map_short_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_map_short_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "uint64_t", 100, true));


    cst_var_map_short_ulonglong.detail().name("var_map_short_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortULongLong", true);
}

const TypeIdentifier* GetMapShortFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortFloat", complete);
}

const TypeObject* GetMapShortFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortFloatObject();
    }
    //else
    return GetMinimalMapShortFloatObject();
}

const TypeObject* GetMinimalMapShortFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_float;
    mst_var_map_short_float.common().member_id(memberId++);
    mst_var_map_short_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_float.common().member_flags().IS_KEY(false);
    mst_var_map_short_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "float", 100, false));


    MD5 var_map_short_float_hash("var_map_short_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_float.detail().name_hash()[i] = var_map_short_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortFloat", false);
}

const TypeObject* GetCompleteMapShortFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_float;
    cst_var_map_short_float.common().member_id(memberId++);
    cst_var_map_short_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_float.common().member_flags().IS_KEY(false);
    cst_var_map_short_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "float", 100, true));


    cst_var_map_short_float.detail().name("var_map_short_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortFloat", true);
}

const TypeIdentifier* GetMapShortDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortDouble", complete);
}

const TypeObject* GetMapShortDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortDoubleObject();
    }
    //else
    return GetMinimalMapShortDoubleObject();
}

const TypeObject* GetMinimalMapShortDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_double;
    mst_var_map_short_double.common().member_id(memberId++);
    mst_var_map_short_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_double.common().member_flags().IS_KEY(false);
    mst_var_map_short_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "double", 100, false));


    MD5 var_map_short_double_hash("var_map_short_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_double.detail().name_hash()[i] = var_map_short_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortDouble", false);
}

const TypeObject* GetCompleteMapShortDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_double;
    cst_var_map_short_double.common().member_id(memberId++);
    cst_var_map_short_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_double.common().member_flags().IS_KEY(false);
    cst_var_map_short_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "double", 100, true));


    cst_var_map_short_double.detail().name("var_map_short_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortDouble", true);
}

const TypeIdentifier* GetMapShortLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortLongDouble", complete);
}

const TypeObject* GetMapShortLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortLongDoubleObject();
    }
    //else
    return GetMinimalMapShortLongDoubleObject();
}

const TypeObject* GetMinimalMapShortLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_longdouble;
    mst_var_map_short_longdouble.common().member_id(memberId++);
    mst_var_map_short_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_longdouble.common().member_flags().IS_KEY(false);
    mst_var_map_short_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "longdouble", 100, false));


    MD5 var_map_short_longdouble_hash("var_map_short_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_longdouble.detail().name_hash()[i] = var_map_short_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortLongDouble", false);
}

const TypeObject* GetCompleteMapShortLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_longdouble;
    cst_var_map_short_longdouble.common().member_id(memberId++);
    cst_var_map_short_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_longdouble.common().member_flags().IS_KEY(false);
    cst_var_map_short_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "longdouble", 100, true));


    cst_var_map_short_longdouble.detail().name("var_map_short_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortLongDouble", true);
}

const TypeIdentifier* GetMapShortBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortBoolean", complete);
}

const TypeObject* GetMapShortBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortBooleanObject();
    }
    //else
    return GetMinimalMapShortBooleanObject();
}

const TypeObject* GetMinimalMapShortBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_boolean;
    mst_var_map_short_boolean.common().member_id(memberId++);
    mst_var_map_short_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_boolean.common().member_flags().IS_KEY(false);
    mst_var_map_short_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "bool", 100, false));


    MD5 var_map_short_boolean_hash("var_map_short_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_boolean.detail().name_hash()[i] = var_map_short_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortBoolean", false);
}

const TypeObject* GetCompleteMapShortBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_boolean;
    cst_var_map_short_boolean.common().member_id(memberId++);
    cst_var_map_short_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_boolean.common().member_flags().IS_KEY(false);
    cst_var_map_short_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "bool", 100, true));


    cst_var_map_short_boolean.detail().name("var_map_short_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortBoolean", true);
}

const TypeIdentifier* GetMapShortOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortOctet", complete);
}

const TypeObject* GetMapShortOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortOctetObject();
    }
    //else
    return GetMinimalMapShortOctetObject();
}

const TypeObject* GetMinimalMapShortOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_octet;
    mst_var_map_short_octet.common().member_id(memberId++);
    mst_var_map_short_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_octet.common().member_flags().IS_KEY(false);
    mst_var_map_short_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "uint8_t", 100, false));


    MD5 var_map_short_octet_hash("var_map_short_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_octet.detail().name_hash()[i] = var_map_short_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortOctet", false);
}

const TypeObject* GetCompleteMapShortOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_octet;
    cst_var_map_short_octet.common().member_id(memberId++);
    cst_var_map_short_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_octet.common().member_flags().IS_KEY(false);
    cst_var_map_short_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "uint8_t", 100, true));


    cst_var_map_short_octet.detail().name("var_map_short_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortOctet", true);
}

const TypeIdentifier* GetMapShortCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortChar", complete);
}

const TypeObject* GetMapShortCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortCharObject();
    }
    //else
    return GetMinimalMapShortCharObject();
}

const TypeObject* GetMinimalMapShortCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_char;
    mst_var_map_short_char.common().member_id(memberId++);
    mst_var_map_short_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_char.common().member_flags().IS_KEY(false);
    mst_var_map_short_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "char", 100, false));


    MD5 var_map_short_char_hash("var_map_short_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_char.detail().name_hash()[i] = var_map_short_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortChar", false);
}

const TypeObject* GetCompleteMapShortCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_char;
    cst_var_map_short_char.common().member_id(memberId++);
    cst_var_map_short_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_char.common().member_flags().IS_KEY(false);
    cst_var_map_short_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "char", 100, true));


    cst_var_map_short_char.detail().name("var_map_short_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortChar", true);
}

const TypeIdentifier* GetMapShortWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortWChar", complete);
}

const TypeObject* GetMapShortWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortWCharObject();
    }
    //else
    return GetMinimalMapShortWCharObject();
}

const TypeObject* GetMinimalMapShortWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_wchar;
    mst_var_map_short_wchar.common().member_id(memberId++);
    mst_var_map_short_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_wchar.common().member_flags().IS_KEY(false);
    mst_var_map_short_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "wchar_t", 100, false));


    MD5 var_map_short_wchar_hash("var_map_short_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_wchar.detail().name_hash()[i] = var_map_short_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortWChar", false);
}

const TypeObject* GetCompleteMapShortWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_wchar;
    cst_var_map_short_wchar.common().member_id(memberId++);
    cst_var_map_short_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_wchar.common().member_flags().IS_KEY(false);
    cst_var_map_short_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "wchar_t", 100, true));


    cst_var_map_short_wchar.detail().name("var_map_short_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortWChar", true);
}

const TypeIdentifier* GetMapShortStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortString", complete);
}

const TypeObject* GetMapShortStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortStringObject();
    }
    //else
    return GetMinimalMapShortStringObject();
}

const TypeObject* GetMinimalMapShortStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_string;
    mst_var_map_short_string.common().member_id(memberId++);
    mst_var_map_short_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_string.common().member_flags().IS_KEY(false);
    mst_var_map_short_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", TypeNamesGenerator::get_string_type_name(255, false), 100, false));


    MD5 var_map_short_string_hash("var_map_short_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_string.detail().name_hash()[i] = var_map_short_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortString", false);
}

const TypeObject* GetCompleteMapShortStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_string;
    cst_var_map_short_string.common().member_id(memberId++);
    cst_var_map_short_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_string.common().member_flags().IS_KEY(false);
    cst_var_map_short_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", TypeNamesGenerator::get_string_type_name(255, false), 100, true));


    cst_var_map_short_string.detail().name("var_map_short_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortString", true);
}

const TypeIdentifier* GetMapShortWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortWString", complete);
}

const TypeObject* GetMapShortWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortWStringObject();
    }
    //else
    return GetMinimalMapShortWStringObject();
}

const TypeObject* GetMinimalMapShortWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_wstring;
    mst_var_map_short_wstring.common().member_id(memberId++);
    mst_var_map_short_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_wstring.common().member_flags().IS_KEY(false);
    mst_var_map_short_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", TypeNamesGenerator::get_string_type_name(255, true), 100, false));


    MD5 var_map_short_wstring_hash("var_map_short_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_wstring.detail().name_hash()[i] = var_map_short_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortWString", false);
}

const TypeObject* GetCompleteMapShortWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_wstring;
    cst_var_map_short_wstring.common().member_id(memberId++);
    cst_var_map_short_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_wstring.common().member_flags().IS_KEY(false);
    cst_var_map_short_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", TypeNamesGenerator::get_string_type_name(255, true), 100, true));


    cst_var_map_short_wstring.detail().name("var_map_short_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortWString", true);
}

const TypeIdentifier* GetMapShortInnerAliasBoundedStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerAliasBoundedStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortInnerAliasBoundedStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerAliasBoundedStringHelper", complete);
}

const TypeObject* GetMapShortInnerAliasBoundedStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasBoundedStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortInnerAliasBoundedStringHelperObject();
    }
    //else
    return GetMinimalMapShortInnerAliasBoundedStringHelperObject();
}

const TypeObject* GetMinimalMapShortInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasBoundedStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_inneraliasboundedstringhelper;
    mst_var_map_short_inneraliasboundedstringhelper.common().member_id(memberId++);
    mst_var_map_short_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_short_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "Inner_alias_bounded_string_helper", 100, false));


    MD5 var_map_short_inneraliasboundedstringhelper_hash("var_map_short_inneraliasboundedstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_inneraliasboundedstringhelper.detail().name_hash()[i] = var_map_short_inneraliasboundedstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_inneraliasboundedstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasBoundedStringHelper", false);
}

const TypeObject* GetCompleteMapShortInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasBoundedStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_inneraliasboundedstringhelper;
    cst_var_map_short_inneraliasboundedstringhelper.common().member_id(memberId++);
    cst_var_map_short_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_short_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "Inner_alias_bounded_string_helper", 100, true));


    cst_var_map_short_inneraliasboundedstringhelper.detail().name("var_map_short_inneraliasboundedstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_inneraliasboundedstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortInnerAliasBoundedStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasBoundedStringHelper", true);
}

const TypeIdentifier* GetMapShortInnerAliasBoundedWStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerAliasBoundedWStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortInnerAliasBoundedWStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerAliasBoundedWStringHelper", complete);
}

const TypeObject* GetMapShortInnerAliasBoundedWStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasBoundedWStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortInnerAliasBoundedWStringHelperObject();
    }
    //else
    return GetMinimalMapShortInnerAliasBoundedWStringHelperObject();
}

const TypeObject* GetMinimalMapShortInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasBoundedWStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_inneraliasboundedwstringhelper;
    mst_var_map_short_inneraliasboundedwstringhelper.common().member_id(memberId++);
    mst_var_map_short_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_short_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "Inner_alias_bounded_wstring_helper", 100, false));


    MD5 var_map_short_inneraliasboundedwstringhelper_hash("var_map_short_inneraliasboundedwstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_inneraliasboundedwstringhelper.detail().name_hash()[i] = var_map_short_inneraliasboundedwstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_inneraliasboundedwstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasBoundedWStringHelper", false);
}

const TypeObject* GetCompleteMapShortInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasBoundedWStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_inneraliasboundedwstringhelper;
    cst_var_map_short_inneraliasboundedwstringhelper.common().member_id(memberId++);
    cst_var_map_short_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_short_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "Inner_alias_bounded_wstring_helper", 100, true));


    cst_var_map_short_inneraliasboundedwstringhelper.detail().name("var_map_short_inneraliasboundedwstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_inneraliasboundedwstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortInnerAliasBoundedWStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasBoundedWStringHelper", true);
}

const TypeIdentifier* GetMapShortInnerEnumHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerEnumHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortInnerEnumHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerEnumHelper", complete);
}

const TypeObject* GetMapShortInnerEnumHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerEnumHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortInnerEnumHelperObject();
    }
    //else
    return GetMinimalMapShortInnerEnumHelperObject();
}

const TypeObject* GetMinimalMapShortInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerEnumHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_innerenumhelper;
    mst_var_map_short_innerenumhelper.common().member_id(memberId++);
    mst_var_map_short_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_innerenumhelper.common().member_flags().IS_KEY(false);
    mst_var_map_short_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "InnerEnumHelper", 100, false));


    MD5 var_map_short_innerenumhelper_hash("var_map_short_innerenumhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_innerenumhelper.detail().name_hash()[i] = var_map_short_innerenumhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_innerenumhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerEnumHelper", false);
}

const TypeObject* GetCompleteMapShortInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerEnumHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_innerenumhelper;
    cst_var_map_short_innerenumhelper.common().member_id(memberId++);
    cst_var_map_short_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_innerenumhelper.common().member_flags().IS_KEY(false);
    cst_var_map_short_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "InnerEnumHelper", 100, true));


    cst_var_map_short_innerenumhelper.detail().name("var_map_short_innerenumhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_innerenumhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortInnerEnumHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerEnumHelper", true);
}

const TypeIdentifier* GetMapShortInnerBitMaskHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerBitMaskHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortInnerBitMaskHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerBitMaskHelper", complete);
}

const TypeObject* GetMapShortInnerBitMaskHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerBitMaskHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortInnerBitMaskHelperObject();
    }
    //else
    return GetMinimalMapShortInnerBitMaskHelperObject();
}

const TypeObject* GetMinimalMapShortInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerBitMaskHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_innerbitmaskhelper;
    mst_var_map_short_innerbitmaskhelper.common().member_id(memberId++);
    mst_var_map_short_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    mst_var_map_short_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "InnerBitMaskHelper", 100, false));


    MD5 var_map_short_innerbitmaskhelper_hash("var_map_short_innerbitmaskhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_innerbitmaskhelper.detail().name_hash()[i] = var_map_short_innerbitmaskhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_innerbitmaskhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerBitMaskHelper", false);
}

const TypeObject* GetCompleteMapShortInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerBitMaskHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_innerbitmaskhelper;
    cst_var_map_short_innerbitmaskhelper.common().member_id(memberId++);
    cst_var_map_short_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    cst_var_map_short_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "InnerBitMaskHelper", 100, true));


    cst_var_map_short_innerbitmaskhelper.detail().name("var_map_short_innerbitmaskhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_innerbitmaskhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortInnerBitMaskHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerBitMaskHelper", true);
}

const TypeIdentifier* GetMapShortInnerAliasHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerAliasHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortInnerAliasHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerAliasHelper", complete);
}

const TypeObject* GetMapShortInnerAliasHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortInnerAliasHelperObject();
    }
    //else
    return GetMinimalMapShortInnerAliasHelperObject();
}

const TypeObject* GetMinimalMapShortInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_inneraliashelper;
    mst_var_map_short_inneraliashelper.common().member_id(memberId++);
    mst_var_map_short_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_inneraliashelper.common().member_flags().IS_KEY(false);
    mst_var_map_short_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "InnerAliasHelper", 100, false));


    MD5 var_map_short_inneraliashelper_hash("var_map_short_inneraliashelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_inneraliashelper.detail().name_hash()[i] = var_map_short_inneraliashelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_inneraliashelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasHelper", false);
}

const TypeObject* GetCompleteMapShortInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_inneraliashelper;
    cst_var_map_short_inneraliashelper.common().member_id(memberId++);
    cst_var_map_short_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_inneraliashelper.common().member_flags().IS_KEY(false);
    cst_var_map_short_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "InnerAliasHelper", 100, true));


    cst_var_map_short_inneraliashelper.detail().name("var_map_short_inneraliashelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_inneraliashelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortInnerAliasHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasHelper", true);
}

const TypeIdentifier* GetMapShortInnerAliasArrayHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerAliasArrayHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortInnerAliasArrayHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerAliasArrayHelper", complete);
}

const TypeObject* GetMapShortInnerAliasArrayHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasArrayHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortInnerAliasArrayHelperObject();
    }
    //else
    return GetMinimalMapShortInnerAliasArrayHelperObject();
}

const TypeObject* GetMinimalMapShortInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasArrayHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_inneraliasarrayhelper;
    mst_var_map_short_inneraliasarrayhelper.common().member_id(memberId++);
    mst_var_map_short_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    mst_var_map_short_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "Inner_alias_array_helper", 100, false));


    MD5 var_map_short_inneraliasarrayhelper_hash("var_map_short_inneraliasarrayhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_inneraliasarrayhelper.detail().name_hash()[i] = var_map_short_inneraliasarrayhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_inneraliasarrayhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasArrayHelper", false);
}

const TypeObject* GetCompleteMapShortInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasArrayHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_inneraliasarrayhelper;
    cst_var_map_short_inneraliasarrayhelper.common().member_id(memberId++);
    cst_var_map_short_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    cst_var_map_short_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "Inner_alias_array_helper", 100, true));


    cst_var_map_short_inneraliasarrayhelper.detail().name("var_map_short_inneraliasarrayhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_inneraliasarrayhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortInnerAliasArrayHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasArrayHelper", true);
}

const TypeIdentifier* GetMapShortInnerAliasSequenceHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerAliasSequenceHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortInnerAliasSequenceHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerAliasSequenceHelper", complete);
}

const TypeObject* GetMapShortInnerAliasSequenceHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasSequenceHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortInnerAliasSequenceHelperObject();
    }
    //else
    return GetMinimalMapShortInnerAliasSequenceHelperObject();
}

const TypeObject* GetMinimalMapShortInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasSequenceHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_inneraliassequencehelper;
    mst_var_map_short_inneraliassequencehelper.common().member_id(memberId++);
    mst_var_map_short_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    mst_var_map_short_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "Inner_alias_sequence_helper", 100, false));


    MD5 var_map_short_inneraliassequencehelper_hash("var_map_short_inneraliassequencehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_inneraliassequencehelper.detail().name_hash()[i] = var_map_short_inneraliassequencehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_inneraliassequencehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasSequenceHelper", false);
}

const TypeObject* GetCompleteMapShortInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasSequenceHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_inneraliassequencehelper;
    cst_var_map_short_inneraliassequencehelper.common().member_id(memberId++);
    cst_var_map_short_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    cst_var_map_short_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "Inner_alias_sequence_helper", 100, true));


    cst_var_map_short_inneraliassequencehelper.detail().name("var_map_short_inneraliassequencehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_inneraliassequencehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortInnerAliasSequenceHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasSequenceHelper", true);
}

const TypeIdentifier* GetMapShortInnerAliasMapHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerAliasMapHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortInnerAliasMapHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerAliasMapHelper", complete);
}

const TypeObject* GetMapShortInnerAliasMapHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasMapHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortInnerAliasMapHelperObject();
    }
    //else
    return GetMinimalMapShortInnerAliasMapHelperObject();
}

const TypeObject* GetMinimalMapShortInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasMapHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_inneraliasmaphelper;
    mst_var_map_short_inneraliasmaphelper.common().member_id(memberId++);
    mst_var_map_short_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    mst_var_map_short_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "Inner_alias_map_helper", 100, false));


    MD5 var_map_short_inneraliasmaphelper_hash("var_map_short_inneraliasmaphelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_inneraliasmaphelper.detail().name_hash()[i] = var_map_short_inneraliasmaphelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_inneraliasmaphelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasMapHelper", false);
}

const TypeObject* GetCompleteMapShortInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasMapHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_inneraliasmaphelper;
    cst_var_map_short_inneraliasmaphelper.common().member_id(memberId++);
    cst_var_map_short_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    cst_var_map_short_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "Inner_alias_map_helper", 100, true));


    cst_var_map_short_inneraliasmaphelper.detail().name("var_map_short_inneraliasmaphelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_inneraliasmaphelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortInnerAliasMapHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerAliasMapHelper", true);
}

const TypeIdentifier* GetMapShortInnerUnionHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerUnionHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortInnerUnionHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerUnionHelper", complete);
}

const TypeObject* GetMapShortInnerUnionHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerUnionHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortInnerUnionHelperObject();
    }
    //else
    return GetMinimalMapShortInnerUnionHelperObject();
}

const TypeObject* GetMinimalMapShortInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerUnionHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_innerunionhelper;
    mst_var_map_short_innerunionhelper.common().member_id(memberId++);
    mst_var_map_short_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_innerunionhelper.common().member_flags().IS_KEY(false);
    mst_var_map_short_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "InnerUnionHelper", 100, false));


    MD5 var_map_short_innerunionhelper_hash("var_map_short_innerunionhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_innerunionhelper.detail().name_hash()[i] = var_map_short_innerunionhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_innerunionhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerUnionHelper", false);
}

const TypeObject* GetCompleteMapShortInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerUnionHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_innerunionhelper;
    cst_var_map_short_innerunionhelper.common().member_id(memberId++);
    cst_var_map_short_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_innerunionhelper.common().member_flags().IS_KEY(false);
    cst_var_map_short_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "InnerUnionHelper", 100, true));


    cst_var_map_short_innerunionhelper.detail().name("var_map_short_innerunionhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_innerunionhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortInnerUnionHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerUnionHelper", true);
}

const TypeIdentifier* GetMapShortInnerStructureHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerStructureHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortInnerStructureHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerStructureHelper", complete);
}

const TypeObject* GetMapShortInnerStructureHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerStructureHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortInnerStructureHelperObject();
    }
    //else
    return GetMinimalMapShortInnerStructureHelperObject();
}

const TypeObject* GetMinimalMapShortInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerStructureHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_innerstructurehelper;
    mst_var_map_short_innerstructurehelper.common().member_id(memberId++);
    mst_var_map_short_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_innerstructurehelper.common().member_flags().IS_KEY(false);
    mst_var_map_short_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "InnerStructureHelper", 100, false));


    MD5 var_map_short_innerstructurehelper_hash("var_map_short_innerstructurehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_innerstructurehelper.detail().name_hash()[i] = var_map_short_innerstructurehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_innerstructurehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerStructureHelper", false);
}

const TypeObject* GetCompleteMapShortInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerStructureHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_innerstructurehelper;
    cst_var_map_short_innerstructurehelper.common().member_id(memberId++);
    cst_var_map_short_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_innerstructurehelper.common().member_flags().IS_KEY(false);
    cst_var_map_short_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "InnerStructureHelper", 100, true));


    cst_var_map_short_innerstructurehelper.detail().name("var_map_short_innerstructurehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_innerstructurehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortInnerStructureHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerStructureHelper", true);
}

const TypeIdentifier* GetMapShortInnerBitsetHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerBitsetHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapShortInnerBitsetHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapShortInnerBitsetHelper", complete);
}

const TypeObject* GetMapShortInnerBitsetHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerBitsetHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapShortInnerBitsetHelperObject();
    }
    //else
    return GetMinimalMapShortInnerBitsetHelperObject();
}

const TypeObject* GetMinimalMapShortInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerBitsetHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_short_innerbitsethelper;
    mst_var_map_short_innerbitsethelper.common().member_id(memberId++);
    mst_var_map_short_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_short_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_short_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_short_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_short_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_short_innerbitsethelper.common().member_flags().IS_KEY(false);
    mst_var_map_short_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_short_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "InnerBitsetHelper", 100, false));


    MD5 var_map_short_innerbitsethelper_hash("var_map_short_innerbitsethelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_short_innerbitsethelper.detail().name_hash()[i] = var_map_short_innerbitsethelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_short_innerbitsethelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerBitsetHelper", false);
}

const TypeObject* GetCompleteMapShortInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapShortInnerBitsetHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_short_innerbitsethelper;
    cst_var_map_short_innerbitsethelper.common().member_id(memberId++);
    cst_var_map_short_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_short_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_short_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_short_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_short_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_short_innerbitsethelper.common().member_flags().IS_KEY(false);
    cst_var_map_short_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_short_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int16_t", "InnerBitsetHelper", 100, true));


    cst_var_map_short_innerbitsethelper.detail().name("var_map_short_innerbitsethelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_short_innerbitsethelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapShortInnerBitsetHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapShortInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapShortInnerBitsetHelper", true);
}

const TypeIdentifier* GetMapUShortShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortShort", complete);
}

const TypeObject* GetMapUShortShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortShortObject();
    }
    //else
    return GetMinimalMapUShortShortObject();
}

const TypeObject* GetMinimalMapUShortShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_short;
    mst_var_map_ushort_short.common().member_id(memberId++);
    mst_var_map_ushort_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_short.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "int16_t", 100, false));


    MD5 var_map_ushort_short_hash("var_map_ushort_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_short.detail().name_hash()[i] = var_map_ushort_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortShort", false);
}

const TypeObject* GetCompleteMapUShortShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_short;
    cst_var_map_ushort_short.common().member_id(memberId++);
    cst_var_map_ushort_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_short.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "int16_t", 100, true));


    cst_var_map_ushort_short.detail().name("var_map_ushort_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortShort", true);
}

const TypeIdentifier* GetMapUShortUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortUShort", complete);
}

const TypeObject* GetMapUShortUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortUShortObject();
    }
    //else
    return GetMinimalMapUShortUShortObject();
}

const TypeObject* GetMinimalMapUShortUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_ushort;
    mst_var_map_ushort_ushort.common().member_id(memberId++);
    mst_var_map_ushort_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_ushort.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "uint16_t", 100, false));


    MD5 var_map_ushort_ushort_hash("var_map_ushort_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_ushort.detail().name_hash()[i] = var_map_ushort_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortUShort", false);
}

const TypeObject* GetCompleteMapUShortUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_ushort;
    cst_var_map_ushort_ushort.common().member_id(memberId++);
    cst_var_map_ushort_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_ushort.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "uint16_t", 100, true));


    cst_var_map_ushort_ushort.detail().name("var_map_ushort_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortUShort", true);
}

const TypeIdentifier* GetMapUShortLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortLong", complete);
}

const TypeObject* GetMapUShortLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortLongObject();
    }
    //else
    return GetMinimalMapUShortLongObject();
}

const TypeObject* GetMinimalMapUShortLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_long;
    mst_var_map_ushort_long.common().member_id(memberId++);
    mst_var_map_ushort_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_long.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "int32_t", 100, false));


    MD5 var_map_ushort_long_hash("var_map_ushort_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_long.detail().name_hash()[i] = var_map_ushort_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortLong", false);
}

const TypeObject* GetCompleteMapUShortLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_long;
    cst_var_map_ushort_long.common().member_id(memberId++);
    cst_var_map_ushort_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_long.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "int32_t", 100, true));


    cst_var_map_ushort_long.detail().name("var_map_ushort_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortLong", true);
}

const TypeIdentifier* GetMapUShortULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortULong", complete);
}

const TypeObject* GetMapUShortULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortULongObject();
    }
    //else
    return GetMinimalMapUShortULongObject();
}

const TypeObject* GetMinimalMapUShortULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_ulong;
    mst_var_map_ushort_ulong.common().member_id(memberId++);
    mst_var_map_ushort_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_ulong.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "uint32_t", 100, false));


    MD5 var_map_ushort_ulong_hash("var_map_ushort_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_ulong.detail().name_hash()[i] = var_map_ushort_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortULong", false);
}

const TypeObject* GetCompleteMapUShortULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_ulong;
    cst_var_map_ushort_ulong.common().member_id(memberId++);
    cst_var_map_ushort_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_ulong.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "uint32_t", 100, true));


    cst_var_map_ushort_ulong.detail().name("var_map_ushort_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortULong", true);
}

const TypeIdentifier* GetMapUShortLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortLongLong", complete);
}

const TypeObject* GetMapUShortLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortLongLongObject();
    }
    //else
    return GetMinimalMapUShortLongLongObject();
}

const TypeObject* GetMinimalMapUShortLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_longlong;
    mst_var_map_ushort_longlong.common().member_id(memberId++);
    mst_var_map_ushort_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_longlong.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "int64_t", 100, false));


    MD5 var_map_ushort_longlong_hash("var_map_ushort_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_longlong.detail().name_hash()[i] = var_map_ushort_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortLongLong", false);
}

const TypeObject* GetCompleteMapUShortLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_longlong;
    cst_var_map_ushort_longlong.common().member_id(memberId++);
    cst_var_map_ushort_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_longlong.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "int64_t", 100, true));


    cst_var_map_ushort_longlong.detail().name("var_map_ushort_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortLongLong", true);
}

const TypeIdentifier* GetMapUShortULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortULongLong", complete);
}

const TypeObject* GetMapUShortULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortULongLongObject();
    }
    //else
    return GetMinimalMapUShortULongLongObject();
}

const TypeObject* GetMinimalMapUShortULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_ulonglong;
    mst_var_map_ushort_ulonglong.common().member_id(memberId++);
    mst_var_map_ushort_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "uint64_t", 100, false));


    MD5 var_map_ushort_ulonglong_hash("var_map_ushort_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_ulonglong.detail().name_hash()[i] = var_map_ushort_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortULongLong", false);
}

const TypeObject* GetCompleteMapUShortULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_ulonglong;
    cst_var_map_ushort_ulonglong.common().member_id(memberId++);
    cst_var_map_ushort_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "uint64_t", 100, true));


    cst_var_map_ushort_ulonglong.detail().name("var_map_ushort_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortULongLong", true);
}

const TypeIdentifier* GetMapUShortFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortFloat", complete);
}

const TypeObject* GetMapUShortFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortFloatObject();
    }
    //else
    return GetMinimalMapUShortFloatObject();
}

const TypeObject* GetMinimalMapUShortFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_float;
    mst_var_map_ushort_float.common().member_id(memberId++);
    mst_var_map_ushort_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_float.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "float", 100, false));


    MD5 var_map_ushort_float_hash("var_map_ushort_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_float.detail().name_hash()[i] = var_map_ushort_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortFloat", false);
}

const TypeObject* GetCompleteMapUShortFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_float;
    cst_var_map_ushort_float.common().member_id(memberId++);
    cst_var_map_ushort_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_float.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "float", 100, true));


    cst_var_map_ushort_float.detail().name("var_map_ushort_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortFloat", true);
}

const TypeIdentifier* GetMapUShortDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortDouble", complete);
}

const TypeObject* GetMapUShortDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortDoubleObject();
    }
    //else
    return GetMinimalMapUShortDoubleObject();
}

const TypeObject* GetMinimalMapUShortDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_double;
    mst_var_map_ushort_double.common().member_id(memberId++);
    mst_var_map_ushort_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_double.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "double", 100, false));


    MD5 var_map_ushort_double_hash("var_map_ushort_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_double.detail().name_hash()[i] = var_map_ushort_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortDouble", false);
}

const TypeObject* GetCompleteMapUShortDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_double;
    cst_var_map_ushort_double.common().member_id(memberId++);
    cst_var_map_ushort_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_double.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "double", 100, true));


    cst_var_map_ushort_double.detail().name("var_map_ushort_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortDouble", true);
}

const TypeIdentifier* GetMapUShortLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortLongDouble", complete);
}

const TypeObject* GetMapUShortLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortLongDoubleObject();
    }
    //else
    return GetMinimalMapUShortLongDoubleObject();
}

const TypeObject* GetMinimalMapUShortLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_longdouble;
    mst_var_map_ushort_longdouble.common().member_id(memberId++);
    mst_var_map_ushort_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_longdouble.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "longdouble", 100, false));


    MD5 var_map_ushort_longdouble_hash("var_map_ushort_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_longdouble.detail().name_hash()[i] = var_map_ushort_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortLongDouble", false);
}

const TypeObject* GetCompleteMapUShortLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_longdouble;
    cst_var_map_ushort_longdouble.common().member_id(memberId++);
    cst_var_map_ushort_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_longdouble.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "longdouble", 100, true));


    cst_var_map_ushort_longdouble.detail().name("var_map_ushort_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortLongDouble", true);
}

const TypeIdentifier* GetMapUShortBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortBoolean", complete);
}

const TypeObject* GetMapUShortBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortBooleanObject();
    }
    //else
    return GetMinimalMapUShortBooleanObject();
}

const TypeObject* GetMinimalMapUShortBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_boolean;
    mst_var_map_ushort_boolean.common().member_id(memberId++);
    mst_var_map_ushort_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_boolean.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "bool", 100, false));


    MD5 var_map_ushort_boolean_hash("var_map_ushort_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_boolean.detail().name_hash()[i] = var_map_ushort_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortBoolean", false);
}

const TypeObject* GetCompleteMapUShortBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_boolean;
    cst_var_map_ushort_boolean.common().member_id(memberId++);
    cst_var_map_ushort_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_boolean.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "bool", 100, true));


    cst_var_map_ushort_boolean.detail().name("var_map_ushort_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortBoolean", true);
}

const TypeIdentifier* GetMapUShortOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortOctet", complete);
}

const TypeObject* GetMapUShortOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortOctetObject();
    }
    //else
    return GetMinimalMapUShortOctetObject();
}

const TypeObject* GetMinimalMapUShortOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_octet;
    mst_var_map_ushort_octet.common().member_id(memberId++);
    mst_var_map_ushort_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_octet.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "uint8_t", 100, false));


    MD5 var_map_ushort_octet_hash("var_map_ushort_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_octet.detail().name_hash()[i] = var_map_ushort_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortOctet", false);
}

const TypeObject* GetCompleteMapUShortOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_octet;
    cst_var_map_ushort_octet.common().member_id(memberId++);
    cst_var_map_ushort_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_octet.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "uint8_t", 100, true));


    cst_var_map_ushort_octet.detail().name("var_map_ushort_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortOctet", true);
}

const TypeIdentifier* GetMapUShortCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortChar", complete);
}

const TypeObject* GetMapUShortCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortCharObject();
    }
    //else
    return GetMinimalMapUShortCharObject();
}

const TypeObject* GetMinimalMapUShortCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_char;
    mst_var_map_ushort_char.common().member_id(memberId++);
    mst_var_map_ushort_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_char.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "char", 100, false));


    MD5 var_map_ushort_char_hash("var_map_ushort_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_char.detail().name_hash()[i] = var_map_ushort_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortChar", false);
}

const TypeObject* GetCompleteMapUShortCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_char;
    cst_var_map_ushort_char.common().member_id(memberId++);
    cst_var_map_ushort_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_char.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "char", 100, true));


    cst_var_map_ushort_char.detail().name("var_map_ushort_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortChar", true);
}

const TypeIdentifier* GetMapUShortWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortWChar", complete);
}

const TypeObject* GetMapUShortWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortWCharObject();
    }
    //else
    return GetMinimalMapUShortWCharObject();
}

const TypeObject* GetMinimalMapUShortWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_wchar;
    mst_var_map_ushort_wchar.common().member_id(memberId++);
    mst_var_map_ushort_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_wchar.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "wchar_t", 100, false));


    MD5 var_map_ushort_wchar_hash("var_map_ushort_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_wchar.detail().name_hash()[i] = var_map_ushort_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortWChar", false);
}

const TypeObject* GetCompleteMapUShortWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_wchar;
    cst_var_map_ushort_wchar.common().member_id(memberId++);
    cst_var_map_ushort_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_wchar.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "wchar_t", 100, true));


    cst_var_map_ushort_wchar.detail().name("var_map_ushort_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortWChar", true);
}

const TypeIdentifier* GetMapUShortStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortString", complete);
}

const TypeObject* GetMapUShortStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortStringObject();
    }
    //else
    return GetMinimalMapUShortStringObject();
}

const TypeObject* GetMinimalMapUShortStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_string;
    mst_var_map_ushort_string.common().member_id(memberId++);
    mst_var_map_ushort_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_string.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", TypeNamesGenerator::get_string_type_name(255, false), 100, false));


    MD5 var_map_ushort_string_hash("var_map_ushort_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_string.detail().name_hash()[i] = var_map_ushort_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortString", false);
}

const TypeObject* GetCompleteMapUShortStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_string;
    cst_var_map_ushort_string.common().member_id(memberId++);
    cst_var_map_ushort_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_string.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", TypeNamesGenerator::get_string_type_name(255, false), 100, true));


    cst_var_map_ushort_string.detail().name("var_map_ushort_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortString", true);
}

const TypeIdentifier* GetMapUShortWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortWString", complete);
}

const TypeObject* GetMapUShortWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortWStringObject();
    }
    //else
    return GetMinimalMapUShortWStringObject();
}

const TypeObject* GetMinimalMapUShortWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_wstring;
    mst_var_map_ushort_wstring.common().member_id(memberId++);
    mst_var_map_ushort_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_wstring.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", TypeNamesGenerator::get_string_type_name(255, true), 100, false));


    MD5 var_map_ushort_wstring_hash("var_map_ushort_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_wstring.detail().name_hash()[i] = var_map_ushort_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortWString", false);
}

const TypeObject* GetCompleteMapUShortWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_wstring;
    cst_var_map_ushort_wstring.common().member_id(memberId++);
    cst_var_map_ushort_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_wstring.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", TypeNamesGenerator::get_string_type_name(255, true), 100, true));


    cst_var_map_ushort_wstring.detail().name("var_map_ushort_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortWString", true);
}

const TypeIdentifier* GetMapUShortInnerAliasBoundedStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerAliasBoundedStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortInnerAliasBoundedStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerAliasBoundedStringHelper", complete);
}

const TypeObject* GetMapUShortInnerAliasBoundedStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasBoundedStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortInnerAliasBoundedStringHelperObject();
    }
    //else
    return GetMinimalMapUShortInnerAliasBoundedStringHelperObject();
}

const TypeObject* GetMinimalMapUShortInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasBoundedStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_inneraliasboundedstringhelper;
    mst_var_map_ushort_inneraliasboundedstringhelper.common().member_id(memberId++);
    mst_var_map_ushort_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "Inner_alias_bounded_string_helper", 100, false));


    MD5 var_map_ushort_inneraliasboundedstringhelper_hash("var_map_ushort_inneraliasboundedstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_inneraliasboundedstringhelper.detail().name_hash()[i] = var_map_ushort_inneraliasboundedstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_inneraliasboundedstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasBoundedStringHelper", false);
}

const TypeObject* GetCompleteMapUShortInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasBoundedStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_inneraliasboundedstringhelper;
    cst_var_map_ushort_inneraliasboundedstringhelper.common().member_id(memberId++);
    cst_var_map_ushort_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "Inner_alias_bounded_string_helper", 100, true));


    cst_var_map_ushort_inneraliasboundedstringhelper.detail().name("var_map_ushort_inneraliasboundedstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_inneraliasboundedstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortInnerAliasBoundedStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasBoundedStringHelper", true);
}

const TypeIdentifier* GetMapUShortInnerAliasBoundedWStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerAliasBoundedWStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortInnerAliasBoundedWStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerAliasBoundedWStringHelper", complete);
}

const TypeObject* GetMapUShortInnerAliasBoundedWStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasBoundedWStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortInnerAliasBoundedWStringHelperObject();
    }
    //else
    return GetMinimalMapUShortInnerAliasBoundedWStringHelperObject();
}

const TypeObject* GetMinimalMapUShortInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasBoundedWStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_inneraliasboundedwstringhelper;
    mst_var_map_ushort_inneraliasboundedwstringhelper.common().member_id(memberId++);
    mst_var_map_ushort_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "Inner_alias_bounded_wstring_helper", 100, false));


    MD5 var_map_ushort_inneraliasboundedwstringhelper_hash("var_map_ushort_inneraliasboundedwstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_inneraliasboundedwstringhelper.detail().name_hash()[i] = var_map_ushort_inneraliasboundedwstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_inneraliasboundedwstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasBoundedWStringHelper", false);
}

const TypeObject* GetCompleteMapUShortInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasBoundedWStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_inneraliasboundedwstringhelper;
    cst_var_map_ushort_inneraliasboundedwstringhelper.common().member_id(memberId++);
    cst_var_map_ushort_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "Inner_alias_bounded_wstring_helper", 100, true));


    cst_var_map_ushort_inneraliasboundedwstringhelper.detail().name("var_map_ushort_inneraliasboundedwstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_inneraliasboundedwstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortInnerAliasBoundedWStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasBoundedWStringHelper", true);
}

const TypeIdentifier* GetMapUShortInnerEnumHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerEnumHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortInnerEnumHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerEnumHelper", complete);
}

const TypeObject* GetMapUShortInnerEnumHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerEnumHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortInnerEnumHelperObject();
    }
    //else
    return GetMinimalMapUShortInnerEnumHelperObject();
}

const TypeObject* GetMinimalMapUShortInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerEnumHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_innerenumhelper;
    mst_var_map_ushort_innerenumhelper.common().member_id(memberId++);
    mst_var_map_ushort_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_innerenumhelper.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "InnerEnumHelper", 100, false));


    MD5 var_map_ushort_innerenumhelper_hash("var_map_ushort_innerenumhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_innerenumhelper.detail().name_hash()[i] = var_map_ushort_innerenumhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_innerenumhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerEnumHelper", false);
}

const TypeObject* GetCompleteMapUShortInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerEnumHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_innerenumhelper;
    cst_var_map_ushort_innerenumhelper.common().member_id(memberId++);
    cst_var_map_ushort_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_innerenumhelper.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "InnerEnumHelper", 100, true));


    cst_var_map_ushort_innerenumhelper.detail().name("var_map_ushort_innerenumhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_innerenumhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortInnerEnumHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerEnumHelper", true);
}

const TypeIdentifier* GetMapUShortInnerBitMaskHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerBitMaskHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortInnerBitMaskHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerBitMaskHelper", complete);
}

const TypeObject* GetMapUShortInnerBitMaskHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerBitMaskHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortInnerBitMaskHelperObject();
    }
    //else
    return GetMinimalMapUShortInnerBitMaskHelperObject();
}

const TypeObject* GetMinimalMapUShortInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerBitMaskHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_innerbitmaskhelper;
    mst_var_map_ushort_innerbitmaskhelper.common().member_id(memberId++);
    mst_var_map_ushort_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "InnerBitMaskHelper", 100, false));


    MD5 var_map_ushort_innerbitmaskhelper_hash("var_map_ushort_innerbitmaskhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_innerbitmaskhelper.detail().name_hash()[i] = var_map_ushort_innerbitmaskhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_innerbitmaskhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerBitMaskHelper", false);
}

const TypeObject* GetCompleteMapUShortInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerBitMaskHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_innerbitmaskhelper;
    cst_var_map_ushort_innerbitmaskhelper.common().member_id(memberId++);
    cst_var_map_ushort_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "InnerBitMaskHelper", 100, true));


    cst_var_map_ushort_innerbitmaskhelper.detail().name("var_map_ushort_innerbitmaskhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_innerbitmaskhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortInnerBitMaskHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerBitMaskHelper", true);
}

const TypeIdentifier* GetMapUShortInnerAliasHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerAliasHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortInnerAliasHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerAliasHelper", complete);
}

const TypeObject* GetMapUShortInnerAliasHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortInnerAliasHelperObject();
    }
    //else
    return GetMinimalMapUShortInnerAliasHelperObject();
}

const TypeObject* GetMinimalMapUShortInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_inneraliashelper;
    mst_var_map_ushort_inneraliashelper.common().member_id(memberId++);
    mst_var_map_ushort_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_inneraliashelper.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "InnerAliasHelper", 100, false));


    MD5 var_map_ushort_inneraliashelper_hash("var_map_ushort_inneraliashelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_inneraliashelper.detail().name_hash()[i] = var_map_ushort_inneraliashelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_inneraliashelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasHelper", false);
}

const TypeObject* GetCompleteMapUShortInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_inneraliashelper;
    cst_var_map_ushort_inneraliashelper.common().member_id(memberId++);
    cst_var_map_ushort_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_inneraliashelper.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "InnerAliasHelper", 100, true));


    cst_var_map_ushort_inneraliashelper.detail().name("var_map_ushort_inneraliashelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_inneraliashelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortInnerAliasHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasHelper", true);
}

const TypeIdentifier* GetMapUShortInnerAliasArrayHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerAliasArrayHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortInnerAliasArrayHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerAliasArrayHelper", complete);
}

const TypeObject* GetMapUShortInnerAliasArrayHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasArrayHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortInnerAliasArrayHelperObject();
    }
    //else
    return GetMinimalMapUShortInnerAliasArrayHelperObject();
}

const TypeObject* GetMinimalMapUShortInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasArrayHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_inneraliasarrayhelper;
    mst_var_map_ushort_inneraliasarrayhelper.common().member_id(memberId++);
    mst_var_map_ushort_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "Inner_alias_array_helper", 100, false));


    MD5 var_map_ushort_inneraliasarrayhelper_hash("var_map_ushort_inneraliasarrayhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_inneraliasarrayhelper.detail().name_hash()[i] = var_map_ushort_inneraliasarrayhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_inneraliasarrayhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasArrayHelper", false);
}

const TypeObject* GetCompleteMapUShortInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasArrayHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_inneraliasarrayhelper;
    cst_var_map_ushort_inneraliasarrayhelper.common().member_id(memberId++);
    cst_var_map_ushort_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "Inner_alias_array_helper", 100, true));


    cst_var_map_ushort_inneraliasarrayhelper.detail().name("var_map_ushort_inneraliasarrayhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_inneraliasarrayhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortInnerAliasArrayHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasArrayHelper", true);
}

const TypeIdentifier* GetMapUShortInnerAliasSequenceHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerAliasSequenceHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortInnerAliasSequenceHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerAliasSequenceHelper", complete);
}

const TypeObject* GetMapUShortInnerAliasSequenceHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasSequenceHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortInnerAliasSequenceHelperObject();
    }
    //else
    return GetMinimalMapUShortInnerAliasSequenceHelperObject();
}

const TypeObject* GetMinimalMapUShortInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasSequenceHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_inneraliassequencehelper;
    mst_var_map_ushort_inneraliassequencehelper.common().member_id(memberId++);
    mst_var_map_ushort_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "Inner_alias_sequence_helper", 100, false));


    MD5 var_map_ushort_inneraliassequencehelper_hash("var_map_ushort_inneraliassequencehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_inneraliassequencehelper.detail().name_hash()[i] = var_map_ushort_inneraliassequencehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_inneraliassequencehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasSequenceHelper", false);
}

const TypeObject* GetCompleteMapUShortInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasSequenceHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_inneraliassequencehelper;
    cst_var_map_ushort_inneraliassequencehelper.common().member_id(memberId++);
    cst_var_map_ushort_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "Inner_alias_sequence_helper", 100, true));


    cst_var_map_ushort_inneraliassequencehelper.detail().name("var_map_ushort_inneraliassequencehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_inneraliassequencehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortInnerAliasSequenceHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasSequenceHelper", true);
}

const TypeIdentifier* GetMapUShortInnerAliasMapHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerAliasMapHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortInnerAliasMapHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerAliasMapHelper", complete);
}

const TypeObject* GetMapUShortInnerAliasMapHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasMapHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortInnerAliasMapHelperObject();
    }
    //else
    return GetMinimalMapUShortInnerAliasMapHelperObject();
}

const TypeObject* GetMinimalMapUShortInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasMapHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_inneraliasmaphelper;
    mst_var_map_ushort_inneraliasmaphelper.common().member_id(memberId++);
    mst_var_map_ushort_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "Inner_alias_map_helper", 100, false));


    MD5 var_map_ushort_inneraliasmaphelper_hash("var_map_ushort_inneraliasmaphelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_inneraliasmaphelper.detail().name_hash()[i] = var_map_ushort_inneraliasmaphelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_inneraliasmaphelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasMapHelper", false);
}

const TypeObject* GetCompleteMapUShortInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasMapHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_inneraliasmaphelper;
    cst_var_map_ushort_inneraliasmaphelper.common().member_id(memberId++);
    cst_var_map_ushort_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "Inner_alias_map_helper", 100, true));


    cst_var_map_ushort_inneraliasmaphelper.detail().name("var_map_ushort_inneraliasmaphelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_inneraliasmaphelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortInnerAliasMapHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerAliasMapHelper", true);
}

const TypeIdentifier* GetMapUShortInnerUnionHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerUnionHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortInnerUnionHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerUnionHelper", complete);
}

const TypeObject* GetMapUShortInnerUnionHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerUnionHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortInnerUnionHelperObject();
    }
    //else
    return GetMinimalMapUShortInnerUnionHelperObject();
}

const TypeObject* GetMinimalMapUShortInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerUnionHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_innerunionhelper;
    mst_var_map_ushort_innerunionhelper.common().member_id(memberId++);
    mst_var_map_ushort_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_innerunionhelper.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "InnerUnionHelper", 100, false));


    MD5 var_map_ushort_innerunionhelper_hash("var_map_ushort_innerunionhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_innerunionhelper.detail().name_hash()[i] = var_map_ushort_innerunionhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_innerunionhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerUnionHelper", false);
}

const TypeObject* GetCompleteMapUShortInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerUnionHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_innerunionhelper;
    cst_var_map_ushort_innerunionhelper.common().member_id(memberId++);
    cst_var_map_ushort_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_innerunionhelper.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "InnerUnionHelper", 100, true));


    cst_var_map_ushort_innerunionhelper.detail().name("var_map_ushort_innerunionhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_innerunionhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortInnerUnionHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerUnionHelper", true);
}

const TypeIdentifier* GetMapUShortInnerStructureHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerStructureHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortInnerStructureHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerStructureHelper", complete);
}

const TypeObject* GetMapUShortInnerStructureHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerStructureHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortInnerStructureHelperObject();
    }
    //else
    return GetMinimalMapUShortInnerStructureHelperObject();
}

const TypeObject* GetMinimalMapUShortInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerStructureHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_innerstructurehelper;
    mst_var_map_ushort_innerstructurehelper.common().member_id(memberId++);
    mst_var_map_ushort_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_innerstructurehelper.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "InnerStructureHelper", 100, false));


    MD5 var_map_ushort_innerstructurehelper_hash("var_map_ushort_innerstructurehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_innerstructurehelper.detail().name_hash()[i] = var_map_ushort_innerstructurehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_innerstructurehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerStructureHelper", false);
}

const TypeObject* GetCompleteMapUShortInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerStructureHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_innerstructurehelper;
    cst_var_map_ushort_innerstructurehelper.common().member_id(memberId++);
    cst_var_map_ushort_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_innerstructurehelper.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "InnerStructureHelper", 100, true));


    cst_var_map_ushort_innerstructurehelper.detail().name("var_map_ushort_innerstructurehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_innerstructurehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortInnerStructureHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerStructureHelper", true);
}

const TypeIdentifier* GetMapUShortInnerBitsetHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerBitsetHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapUShortInnerBitsetHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapUShortInnerBitsetHelper", complete);
}

const TypeObject* GetMapUShortInnerBitsetHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerBitsetHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapUShortInnerBitsetHelperObject();
    }
    //else
    return GetMinimalMapUShortInnerBitsetHelperObject();
}

const TypeObject* GetMinimalMapUShortInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerBitsetHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ushort_innerbitsethelper;
    mst_var_map_ushort_innerbitsethelper.common().member_id(memberId++);
    mst_var_map_ushort_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ushort_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ushort_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ushort_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ushort_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ushort_innerbitsethelper.common().member_flags().IS_KEY(false);
    mst_var_map_ushort_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ushort_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "InnerBitsetHelper", 100, false));


    MD5 var_map_ushort_innerbitsethelper_hash("var_map_ushort_innerbitsethelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ushort_innerbitsethelper.detail().name_hash()[i] = var_map_ushort_innerbitsethelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ushort_innerbitsethelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerBitsetHelper", false);
}

const TypeObject* GetCompleteMapUShortInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerBitsetHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ushort_innerbitsethelper;
    cst_var_map_ushort_innerbitsethelper.common().member_id(memberId++);
    cst_var_map_ushort_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ushort_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ushort_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ushort_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ushort_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ushort_innerbitsethelper.common().member_flags().IS_KEY(false);
    cst_var_map_ushort_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ushort_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint16_t", "InnerBitsetHelper", 100, true));


    cst_var_map_ushort_innerbitsethelper.detail().name("var_map_ushort_innerbitsethelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ushort_innerbitsethelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapUShortInnerBitsetHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapUShortInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapUShortInnerBitsetHelper", true);
}

const TypeIdentifier* GetMapLongShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongShort", complete);
}

const TypeObject* GetMapLongShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongShortObject();
    }
    //else
    return GetMinimalMapLongShortObject();
}

const TypeObject* GetMinimalMapLongShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_short;
    mst_var_map_long_short.common().member_id(memberId++);
    mst_var_map_long_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_short.common().member_flags().IS_KEY(false);
    mst_var_map_long_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int16_t", 100, false));


    MD5 var_map_long_short_hash("var_map_long_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_short.detail().name_hash()[i] = var_map_long_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongShort", false);
}

const TypeObject* GetCompleteMapLongShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_short;
    cst_var_map_long_short.common().member_id(memberId++);
    cst_var_map_long_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_short.common().member_flags().IS_KEY(false);
    cst_var_map_long_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int16_t", 100, true));


    cst_var_map_long_short.detail().name("var_map_long_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongShort", true);
}

const TypeIdentifier* GetMapLongUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongUShort", complete);
}

const TypeObject* GetMapLongUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongUShortObject();
    }
    //else
    return GetMinimalMapLongUShortObject();
}

const TypeObject* GetMinimalMapLongUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_ushort;
    mst_var_map_long_ushort.common().member_id(memberId++);
    mst_var_map_long_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_ushort.common().member_flags().IS_KEY(false);
    mst_var_map_long_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "uint16_t", 100, false));


    MD5 var_map_long_ushort_hash("var_map_long_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_ushort.detail().name_hash()[i] = var_map_long_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongUShort", false);
}

const TypeObject* GetCompleteMapLongUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_ushort;
    cst_var_map_long_ushort.common().member_id(memberId++);
    cst_var_map_long_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_ushort.common().member_flags().IS_KEY(false);
    cst_var_map_long_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "uint16_t", 100, true));


    cst_var_map_long_ushort.detail().name("var_map_long_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongUShort", true);
}

const TypeIdentifier* GetMapLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLong", complete);
}

const TypeObject* GetMapLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongObject();
    }
    //else
    return GetMinimalMapLongLongObject();
}

const TypeObject* GetMinimalMapLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_long;
    mst_var_map_long_long.common().member_id(memberId++);
    mst_var_map_long_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_long.common().member_flags().IS_KEY(false);
    mst_var_map_long_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int32_t", 100, false));


    MD5 var_map_long_long_hash("var_map_long_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_long.detail().name_hash()[i] = var_map_long_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLong", false);
}

const TypeObject* GetCompleteMapLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_long;
    cst_var_map_long_long.common().member_id(memberId++);
    cst_var_map_long_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_long.common().member_flags().IS_KEY(false);
    cst_var_map_long_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int32_t", 100, true));


    cst_var_map_long_long.detail().name("var_map_long_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLong", true);
}

const TypeIdentifier* GetMapLongULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongULong", complete);
}

const TypeObject* GetMapLongULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongULongObject();
    }
    //else
    return GetMinimalMapLongULongObject();
}

const TypeObject* GetMinimalMapLongULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_ulong;
    mst_var_map_long_ulong.common().member_id(memberId++);
    mst_var_map_long_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_ulong.common().member_flags().IS_KEY(false);
    mst_var_map_long_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "uint32_t", 100, false));


    MD5 var_map_long_ulong_hash("var_map_long_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_ulong.detail().name_hash()[i] = var_map_long_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongULong", false);
}

const TypeObject* GetCompleteMapLongULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_ulong;
    cst_var_map_long_ulong.common().member_id(memberId++);
    cst_var_map_long_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_ulong.common().member_flags().IS_KEY(false);
    cst_var_map_long_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "uint32_t", 100, true));


    cst_var_map_long_ulong.detail().name("var_map_long_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongULong", true);
}

const TypeIdentifier* GetMapLongKeyLongLongValueIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongKeyLongLongValue", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongKeyLongLongValueObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongKeyLongLongValue", complete);
}

const TypeObject* GetMapLongKeyLongLongValueObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongKeyLongLongValue", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongKeyLongLongValueObject();
    }
    //else
    return GetMinimalMapLongKeyLongLongValueObject();
}

const TypeObject* GetMinimalMapLongKeyLongLongValueObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongKeyLongLongValue", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_longlong;
    mst_var_map_long_longlong.common().member_id(memberId++);
    mst_var_map_long_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_longlong.common().member_flags().IS_KEY(false);
    mst_var_map_long_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int64_t", 100, false));


    MD5 var_map_long_longlong_hash("var_map_long_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_longlong.detail().name_hash()[i] = var_map_long_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongKeyLongLongValue", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongKeyLongLongValue", false);
}

const TypeObject* GetCompleteMapLongKeyLongLongValueObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongKeyLongLongValue", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_longlong;
    cst_var_map_long_longlong.common().member_id(memberId++);
    cst_var_map_long_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_longlong.common().member_flags().IS_KEY(false);
    cst_var_map_long_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int64_t", 100, true));


    cst_var_map_long_longlong.detail().name("var_map_long_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongKeyLongLongValue");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongKeyLongLongValue", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongKeyLongLongValue", true);
}

const TypeIdentifier* GetMapLongULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongULongLong", complete);
}

const TypeObject* GetMapLongULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongULongLongObject();
    }
    //else
    return GetMinimalMapLongULongLongObject();
}

const TypeObject* GetMinimalMapLongULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_ulonglong;
    mst_var_map_long_ulonglong.common().member_id(memberId++);
    mst_var_map_long_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_map_long_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "uint64_t", 100, false));


    MD5 var_map_long_ulonglong_hash("var_map_long_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_ulonglong.detail().name_hash()[i] = var_map_long_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongULongLong", false);
}

const TypeObject* GetCompleteMapLongULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_ulonglong;
    cst_var_map_long_ulonglong.common().member_id(memberId++);
    cst_var_map_long_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_map_long_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "uint64_t", 100, true));


    cst_var_map_long_ulonglong.detail().name("var_map_long_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongULongLong", true);
}

const TypeIdentifier* GetMapLongFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongFloat", complete);
}

const TypeObject* GetMapLongFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongFloatObject();
    }
    //else
    return GetMinimalMapLongFloatObject();
}

const TypeObject* GetMinimalMapLongFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_float;
    mst_var_map_long_float.common().member_id(memberId++);
    mst_var_map_long_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_float.common().member_flags().IS_KEY(false);
    mst_var_map_long_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "float", 100, false));


    MD5 var_map_long_float_hash("var_map_long_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_float.detail().name_hash()[i] = var_map_long_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongFloat", false);
}

const TypeObject* GetCompleteMapLongFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_float;
    cst_var_map_long_float.common().member_id(memberId++);
    cst_var_map_long_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_float.common().member_flags().IS_KEY(false);
    cst_var_map_long_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "float", 100, true));


    cst_var_map_long_float.detail().name("var_map_long_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongFloat", true);
}

const TypeIdentifier* GetMapLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongDouble", complete);
}

const TypeObject* GetMapLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongDoubleObject();
    }
    //else
    return GetMinimalMapLongDoubleObject();
}

const TypeObject* GetMinimalMapLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_double;
    mst_var_map_long_double.common().member_id(memberId++);
    mst_var_map_long_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_double.common().member_flags().IS_KEY(false);
    mst_var_map_long_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "double", 100, false));


    MD5 var_map_long_double_hash("var_map_long_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_double.detail().name_hash()[i] = var_map_long_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongDouble", false);
}

const TypeObject* GetCompleteMapLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_double;
    cst_var_map_long_double.common().member_id(memberId++);
    cst_var_map_long_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_double.common().member_flags().IS_KEY(false);
    cst_var_map_long_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "double", 100, true));


    cst_var_map_long_double.detail().name("var_map_long_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongDouble", true);
}

const TypeIdentifier* GetMapLongKeyLongDoubleValueIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongKeyLongDoubleValue", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongKeyLongDoubleValueObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongKeyLongDoubleValue", complete);
}

const TypeObject* GetMapLongKeyLongDoubleValueObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongKeyLongDoubleValue", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongKeyLongDoubleValueObject();
    }
    //else
    return GetMinimalMapLongKeyLongDoubleValueObject();
}

const TypeObject* GetMinimalMapLongKeyLongDoubleValueObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongKeyLongDoubleValue", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_longdouble;
    mst_var_map_long_longdouble.common().member_id(memberId++);
    mst_var_map_long_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_longdouble.common().member_flags().IS_KEY(false);
    mst_var_map_long_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "longdouble", 100, false));


    MD5 var_map_long_longdouble_hash("var_map_long_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_longdouble.detail().name_hash()[i] = var_map_long_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongKeyLongDoubleValue", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongKeyLongDoubleValue", false);
}

const TypeObject* GetCompleteMapLongKeyLongDoubleValueObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongKeyLongDoubleValue", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_longdouble;
    cst_var_map_long_longdouble.common().member_id(memberId++);
    cst_var_map_long_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_longdouble.common().member_flags().IS_KEY(false);
    cst_var_map_long_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "longdouble", 100, true));


    cst_var_map_long_longdouble.detail().name("var_map_long_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongKeyLongDoubleValue");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongKeyLongDoubleValue", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongKeyLongDoubleValue", true);
}

const TypeIdentifier* GetMapLongBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongBoolean", complete);
}

const TypeObject* GetMapLongBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongBooleanObject();
    }
    //else
    return GetMinimalMapLongBooleanObject();
}

const TypeObject* GetMinimalMapLongBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_boolean;
    mst_var_map_long_boolean.common().member_id(memberId++);
    mst_var_map_long_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_boolean.common().member_flags().IS_KEY(false);
    mst_var_map_long_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "bool", 100, false));


    MD5 var_map_long_boolean_hash("var_map_long_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_boolean.detail().name_hash()[i] = var_map_long_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongBoolean", false);
}

const TypeObject* GetCompleteMapLongBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_boolean;
    cst_var_map_long_boolean.common().member_id(memberId++);
    cst_var_map_long_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_boolean.common().member_flags().IS_KEY(false);
    cst_var_map_long_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "bool", 100, true));


    cst_var_map_long_boolean.detail().name("var_map_long_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongBoolean", true);
}

const TypeIdentifier* GetMapLongOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongOctet", complete);
}

const TypeObject* GetMapLongOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongOctetObject();
    }
    //else
    return GetMinimalMapLongOctetObject();
}

const TypeObject* GetMinimalMapLongOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_octet;
    mst_var_map_long_octet.common().member_id(memberId++);
    mst_var_map_long_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_octet.common().member_flags().IS_KEY(false);
    mst_var_map_long_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "uint8_t", 100, false));


    MD5 var_map_long_octet_hash("var_map_long_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_octet.detail().name_hash()[i] = var_map_long_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongOctet", false);
}

const TypeObject* GetCompleteMapLongOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_octet;
    cst_var_map_long_octet.common().member_id(memberId++);
    cst_var_map_long_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_octet.common().member_flags().IS_KEY(false);
    cst_var_map_long_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "uint8_t", 100, true));


    cst_var_map_long_octet.detail().name("var_map_long_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongOctet", true);
}

const TypeIdentifier* GetMapLongCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongChar", complete);
}

const TypeObject* GetMapLongCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongCharObject();
    }
    //else
    return GetMinimalMapLongCharObject();
}

const TypeObject* GetMinimalMapLongCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_char;
    mst_var_map_long_char.common().member_id(memberId++);
    mst_var_map_long_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_char.common().member_flags().IS_KEY(false);
    mst_var_map_long_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "char", 100, false));


    MD5 var_map_long_char_hash("var_map_long_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_char.detail().name_hash()[i] = var_map_long_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongChar", false);
}

const TypeObject* GetCompleteMapLongCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_char;
    cst_var_map_long_char.common().member_id(memberId++);
    cst_var_map_long_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_char.common().member_flags().IS_KEY(false);
    cst_var_map_long_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "char", 100, true));


    cst_var_map_long_char.detail().name("var_map_long_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongChar", true);
}

const TypeIdentifier* GetMapLongWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongWChar", complete);
}

const TypeObject* GetMapLongWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongWCharObject();
    }
    //else
    return GetMinimalMapLongWCharObject();
}

const TypeObject* GetMinimalMapLongWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_wchar;
    mst_var_map_long_wchar.common().member_id(memberId++);
    mst_var_map_long_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_wchar.common().member_flags().IS_KEY(false);
    mst_var_map_long_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "wchar_t", 100, false));


    MD5 var_map_long_wchar_hash("var_map_long_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_wchar.detail().name_hash()[i] = var_map_long_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongWChar", false);
}

const TypeObject* GetCompleteMapLongWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_wchar;
    cst_var_map_long_wchar.common().member_id(memberId++);
    cst_var_map_long_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_wchar.common().member_flags().IS_KEY(false);
    cst_var_map_long_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "wchar_t", 100, true));


    cst_var_map_long_wchar.detail().name("var_map_long_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongWChar", true);
}

const TypeIdentifier* GetMapLongStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongString", complete);
}

const TypeObject* GetMapLongStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongStringObject();
    }
    //else
    return GetMinimalMapLongStringObject();
}

const TypeObject* GetMinimalMapLongStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_string;
    mst_var_map_long_string.common().member_id(memberId++);
    mst_var_map_long_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_string.common().member_flags().IS_KEY(false);
    mst_var_map_long_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", TypeNamesGenerator::get_string_type_name(255, false), 100, false));


    MD5 var_map_long_string_hash("var_map_long_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_string.detail().name_hash()[i] = var_map_long_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongString", false);
}

const TypeObject* GetCompleteMapLongStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_string;
    cst_var_map_long_string.common().member_id(memberId++);
    cst_var_map_long_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_string.common().member_flags().IS_KEY(false);
    cst_var_map_long_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", TypeNamesGenerator::get_string_type_name(255, false), 100, true));


    cst_var_map_long_string.detail().name("var_map_long_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongString", true);
}

const TypeIdentifier* GetMapLongWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongWString", complete);
}

const TypeObject* GetMapLongWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongWStringObject();
    }
    //else
    return GetMinimalMapLongWStringObject();
}

const TypeObject* GetMinimalMapLongWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_wstring;
    mst_var_map_long_wstring.common().member_id(memberId++);
    mst_var_map_long_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_wstring.common().member_flags().IS_KEY(false);
    mst_var_map_long_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", TypeNamesGenerator::get_string_type_name(255, true), 100, false));


    MD5 var_map_long_wstring_hash("var_map_long_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_wstring.detail().name_hash()[i] = var_map_long_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongWString", false);
}

const TypeObject* GetCompleteMapLongWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_wstring;
    cst_var_map_long_wstring.common().member_id(memberId++);
    cst_var_map_long_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_wstring.common().member_flags().IS_KEY(false);
    cst_var_map_long_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", TypeNamesGenerator::get_string_type_name(255, true), 100, true));


    cst_var_map_long_wstring.detail().name("var_map_long_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongWString", true);
}

const TypeIdentifier* GetMapLongInnerAliasBoundedStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerAliasBoundedStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongInnerAliasBoundedStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerAliasBoundedStringHelper", complete);
}

const TypeObject* GetMapLongInnerAliasBoundedStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasBoundedStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongInnerAliasBoundedStringHelperObject();
    }
    //else
    return GetMinimalMapLongInnerAliasBoundedStringHelperObject();
}

const TypeObject* GetMinimalMapLongInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasBoundedStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_inneraliasboundedstringhelper;
    mst_var_map_long_inneraliasboundedstringhelper.common().member_id(memberId++);
    mst_var_map_long_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_long_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "Inner_alias_bounded_string_helper", 100, false));


    MD5 var_map_long_inneraliasboundedstringhelper_hash("var_map_long_inneraliasboundedstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_inneraliasboundedstringhelper.detail().name_hash()[i] = var_map_long_inneraliasboundedstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_inneraliasboundedstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasBoundedStringHelper", false);
}

const TypeObject* GetCompleteMapLongInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasBoundedStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_inneraliasboundedstringhelper;
    cst_var_map_long_inneraliasboundedstringhelper.common().member_id(memberId++);
    cst_var_map_long_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_long_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "Inner_alias_bounded_string_helper", 100, true));


    cst_var_map_long_inneraliasboundedstringhelper.detail().name("var_map_long_inneraliasboundedstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_inneraliasboundedstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongInnerAliasBoundedStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasBoundedStringHelper", true);
}

const TypeIdentifier* GetMapLongInnerAliasBoundedWStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerAliasBoundedWStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongInnerAliasBoundedWStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerAliasBoundedWStringHelper", complete);
}

const TypeObject* GetMapLongInnerAliasBoundedWStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasBoundedWStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongInnerAliasBoundedWStringHelperObject();
    }
    //else
    return GetMinimalMapLongInnerAliasBoundedWStringHelperObject();
}

const TypeObject* GetMinimalMapLongInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasBoundedWStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_inneraliasboundedwstringhelper;
    mst_var_map_long_inneraliasboundedwstringhelper.common().member_id(memberId++);
    mst_var_map_long_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_long_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "Inner_alias_bounded_wstring_helper", 100, false));


    MD5 var_map_long_inneraliasboundedwstringhelper_hash("var_map_long_inneraliasboundedwstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_inneraliasboundedwstringhelper.detail().name_hash()[i] = var_map_long_inneraliasboundedwstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_inneraliasboundedwstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasBoundedWStringHelper", false);
}

const TypeObject* GetCompleteMapLongInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasBoundedWStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_inneraliasboundedwstringhelper;
    cst_var_map_long_inneraliasboundedwstringhelper.common().member_id(memberId++);
    cst_var_map_long_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_long_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "Inner_alias_bounded_wstring_helper", 100, true));


    cst_var_map_long_inneraliasboundedwstringhelper.detail().name("var_map_long_inneraliasboundedwstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_inneraliasboundedwstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongInnerAliasBoundedWStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasBoundedWStringHelper", true);
}

const TypeIdentifier* GetMapLongInnerEnumHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerEnumHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongInnerEnumHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerEnumHelper", complete);
}

const TypeObject* GetMapLongInnerEnumHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerEnumHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongInnerEnumHelperObject();
    }
    //else
    return GetMinimalMapLongInnerEnumHelperObject();
}

const TypeObject* GetMinimalMapLongInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerEnumHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_innerenumhelper;
    mst_var_map_long_innerenumhelper.common().member_id(memberId++);
    mst_var_map_long_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_innerenumhelper.common().member_flags().IS_KEY(false);
    mst_var_map_long_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "InnerEnumHelper", 100, false));


    MD5 var_map_long_innerenumhelper_hash("var_map_long_innerenumhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_innerenumhelper.detail().name_hash()[i] = var_map_long_innerenumhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_innerenumhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerEnumHelper", false);
}

const TypeObject* GetCompleteMapLongInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerEnumHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_innerenumhelper;
    cst_var_map_long_innerenumhelper.common().member_id(memberId++);
    cst_var_map_long_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_innerenumhelper.common().member_flags().IS_KEY(false);
    cst_var_map_long_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "InnerEnumHelper", 100, true));


    cst_var_map_long_innerenumhelper.detail().name("var_map_long_innerenumhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_innerenumhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongInnerEnumHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerEnumHelper", true);
}

const TypeIdentifier* GetMapLongInnerBitMaskHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerBitMaskHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongInnerBitMaskHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerBitMaskHelper", complete);
}

const TypeObject* GetMapLongInnerBitMaskHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerBitMaskHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongInnerBitMaskHelperObject();
    }
    //else
    return GetMinimalMapLongInnerBitMaskHelperObject();
}

const TypeObject* GetMinimalMapLongInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerBitMaskHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_innerbitmaskhelper;
    mst_var_map_long_innerbitmaskhelper.common().member_id(memberId++);
    mst_var_map_long_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    mst_var_map_long_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "InnerBitMaskHelper", 100, false));


    MD5 var_map_long_innerbitmaskhelper_hash("var_map_long_innerbitmaskhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_innerbitmaskhelper.detail().name_hash()[i] = var_map_long_innerbitmaskhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_innerbitmaskhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerBitMaskHelper", false);
}

const TypeObject* GetCompleteMapLongInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerBitMaskHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_innerbitmaskhelper;
    cst_var_map_long_innerbitmaskhelper.common().member_id(memberId++);
    cst_var_map_long_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    cst_var_map_long_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "InnerBitMaskHelper", 100, true));


    cst_var_map_long_innerbitmaskhelper.detail().name("var_map_long_innerbitmaskhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_innerbitmaskhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongInnerBitMaskHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerBitMaskHelper", true);
}

const TypeIdentifier* GetMapLongInnerAliasHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerAliasHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongInnerAliasHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerAliasHelper", complete);
}

const TypeObject* GetMapLongInnerAliasHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongInnerAliasHelperObject();
    }
    //else
    return GetMinimalMapLongInnerAliasHelperObject();
}

const TypeObject* GetMinimalMapLongInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_inneraliashelper;
    mst_var_map_long_inneraliashelper.common().member_id(memberId++);
    mst_var_map_long_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_inneraliashelper.common().member_flags().IS_KEY(false);
    mst_var_map_long_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "InnerAliasHelper", 100, false));


    MD5 var_map_long_inneraliashelper_hash("var_map_long_inneraliashelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_inneraliashelper.detail().name_hash()[i] = var_map_long_inneraliashelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_inneraliashelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasHelper", false);
}

const TypeObject* GetCompleteMapLongInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_inneraliashelper;
    cst_var_map_long_inneraliashelper.common().member_id(memberId++);
    cst_var_map_long_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_inneraliashelper.common().member_flags().IS_KEY(false);
    cst_var_map_long_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "InnerAliasHelper", 100, true));


    cst_var_map_long_inneraliashelper.detail().name("var_map_long_inneraliashelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_inneraliashelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongInnerAliasHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasHelper", true);
}

const TypeIdentifier* GetMapLongInnerAliasArrayHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerAliasArrayHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongInnerAliasArrayHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerAliasArrayHelper", complete);
}

const TypeObject* GetMapLongInnerAliasArrayHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasArrayHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongInnerAliasArrayHelperObject();
    }
    //else
    return GetMinimalMapLongInnerAliasArrayHelperObject();
}

const TypeObject* GetMinimalMapLongInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasArrayHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_inneraliasarrayhelper;
    mst_var_map_long_inneraliasarrayhelper.common().member_id(memberId++);
    mst_var_map_long_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    mst_var_map_long_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "Inner_alias_array_helper", 100, false));


    MD5 var_map_long_inneraliasarrayhelper_hash("var_map_long_inneraliasarrayhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_inneraliasarrayhelper.detail().name_hash()[i] = var_map_long_inneraliasarrayhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_inneraliasarrayhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasArrayHelper", false);
}

const TypeObject* GetCompleteMapLongInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasArrayHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_inneraliasarrayhelper;
    cst_var_map_long_inneraliasarrayhelper.common().member_id(memberId++);
    cst_var_map_long_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    cst_var_map_long_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "Inner_alias_array_helper", 100, true));


    cst_var_map_long_inneraliasarrayhelper.detail().name("var_map_long_inneraliasarrayhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_inneraliasarrayhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongInnerAliasArrayHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasArrayHelper", true);
}

const TypeIdentifier* GetMapLongInnerAliasSequenceHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerAliasSequenceHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongInnerAliasSequenceHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerAliasSequenceHelper", complete);
}

const TypeObject* GetMapLongInnerAliasSequenceHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasSequenceHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongInnerAliasSequenceHelperObject();
    }
    //else
    return GetMinimalMapLongInnerAliasSequenceHelperObject();
}

const TypeObject* GetMinimalMapLongInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasSequenceHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_inneraliassequencehelper;
    mst_var_map_long_inneraliassequencehelper.common().member_id(memberId++);
    mst_var_map_long_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    mst_var_map_long_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "Inner_alias_sequence_helper", 100, false));


    MD5 var_map_long_inneraliassequencehelper_hash("var_map_long_inneraliassequencehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_inneraliassequencehelper.detail().name_hash()[i] = var_map_long_inneraliassequencehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_inneraliassequencehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasSequenceHelper", false);
}

const TypeObject* GetCompleteMapLongInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasSequenceHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_inneraliassequencehelper;
    cst_var_map_long_inneraliassequencehelper.common().member_id(memberId++);
    cst_var_map_long_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    cst_var_map_long_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "Inner_alias_sequence_helper", 100, true));


    cst_var_map_long_inneraliassequencehelper.detail().name("var_map_long_inneraliassequencehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_inneraliassequencehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongInnerAliasSequenceHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasSequenceHelper", true);
}

const TypeIdentifier* GetMapLongInnerAliasMapHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerAliasMapHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongInnerAliasMapHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerAliasMapHelper", complete);
}

const TypeObject* GetMapLongInnerAliasMapHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasMapHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongInnerAliasMapHelperObject();
    }
    //else
    return GetMinimalMapLongInnerAliasMapHelperObject();
}

const TypeObject* GetMinimalMapLongInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasMapHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_inneraliasmaphelper;
    mst_var_map_long_inneraliasmaphelper.common().member_id(memberId++);
    mst_var_map_long_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    mst_var_map_long_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "Inner_alias_map_helper", 100, false));


    MD5 var_map_long_inneraliasmaphelper_hash("var_map_long_inneraliasmaphelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_inneraliasmaphelper.detail().name_hash()[i] = var_map_long_inneraliasmaphelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_inneraliasmaphelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasMapHelper", false);
}

const TypeObject* GetCompleteMapLongInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasMapHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_inneraliasmaphelper;
    cst_var_map_long_inneraliasmaphelper.common().member_id(memberId++);
    cst_var_map_long_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    cst_var_map_long_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "Inner_alias_map_helper", 100, true));


    cst_var_map_long_inneraliasmaphelper.detail().name("var_map_long_inneraliasmaphelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_inneraliasmaphelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongInnerAliasMapHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerAliasMapHelper", true);
}

const TypeIdentifier* GetMapLongInnerUnionHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerUnionHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongInnerUnionHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerUnionHelper", complete);
}

const TypeObject* GetMapLongInnerUnionHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerUnionHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongInnerUnionHelperObject();
    }
    //else
    return GetMinimalMapLongInnerUnionHelperObject();
}

const TypeObject* GetMinimalMapLongInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerUnionHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_innerunionhelper;
    mst_var_map_long_innerunionhelper.common().member_id(memberId++);
    mst_var_map_long_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_innerunionhelper.common().member_flags().IS_KEY(false);
    mst_var_map_long_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "InnerUnionHelper", 100, false));


    MD5 var_map_long_innerunionhelper_hash("var_map_long_innerunionhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_innerunionhelper.detail().name_hash()[i] = var_map_long_innerunionhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_innerunionhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerUnionHelper", false);
}

const TypeObject* GetCompleteMapLongInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerUnionHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_innerunionhelper;
    cst_var_map_long_innerunionhelper.common().member_id(memberId++);
    cst_var_map_long_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_innerunionhelper.common().member_flags().IS_KEY(false);
    cst_var_map_long_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "InnerUnionHelper", 100, true));


    cst_var_map_long_innerunionhelper.detail().name("var_map_long_innerunionhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_innerunionhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongInnerUnionHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerUnionHelper", true);
}

const TypeIdentifier* GetMapLongInnerStructureHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerStructureHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongInnerStructureHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerStructureHelper", complete);
}

const TypeObject* GetMapLongInnerStructureHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerStructureHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongInnerStructureHelperObject();
    }
    //else
    return GetMinimalMapLongInnerStructureHelperObject();
}

const TypeObject* GetMinimalMapLongInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerStructureHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_innerstructurehelper;
    mst_var_map_long_innerstructurehelper.common().member_id(memberId++);
    mst_var_map_long_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_innerstructurehelper.common().member_flags().IS_KEY(false);
    mst_var_map_long_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "InnerStructureHelper", 100, false));


    MD5 var_map_long_innerstructurehelper_hash("var_map_long_innerstructurehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_innerstructurehelper.detail().name_hash()[i] = var_map_long_innerstructurehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_innerstructurehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerStructureHelper", false);
}

const TypeObject* GetCompleteMapLongInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerStructureHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_innerstructurehelper;
    cst_var_map_long_innerstructurehelper.common().member_id(memberId++);
    cst_var_map_long_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_innerstructurehelper.common().member_flags().IS_KEY(false);
    cst_var_map_long_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "InnerStructureHelper", 100, true));


    cst_var_map_long_innerstructurehelper.detail().name("var_map_long_innerstructurehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_innerstructurehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongInnerStructureHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerStructureHelper", true);
}

const TypeIdentifier* GetMapLongInnerBitsetHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerBitsetHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongInnerBitsetHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongInnerBitsetHelper", complete);
}

const TypeObject* GetMapLongInnerBitsetHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerBitsetHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongInnerBitsetHelperObject();
    }
    //else
    return GetMinimalMapLongInnerBitsetHelperObject();
}

const TypeObject* GetMinimalMapLongInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerBitsetHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_long_innerbitsethelper;
    mst_var_map_long_innerbitsethelper.common().member_id(memberId++);
    mst_var_map_long_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_long_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_long_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_long_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_long_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_long_innerbitsethelper.common().member_flags().IS_KEY(false);
    mst_var_map_long_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_long_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "InnerBitsetHelper", 100, false));


    MD5 var_map_long_innerbitsethelper_hash("var_map_long_innerbitsethelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_long_innerbitsethelper.detail().name_hash()[i] = var_map_long_innerbitsethelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_long_innerbitsethelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerBitsetHelper", false);
}

const TypeObject* GetCompleteMapLongInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongInnerBitsetHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_long_innerbitsethelper;
    cst_var_map_long_innerbitsethelper.common().member_id(memberId++);
    cst_var_map_long_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_long_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_long_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_long_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_long_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_long_innerbitsethelper.common().member_flags().IS_KEY(false);
    cst_var_map_long_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_long_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "InnerBitsetHelper", 100, true));


    cst_var_map_long_innerbitsethelper.detail().name("var_map_long_innerbitsethelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_long_innerbitsethelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongInnerBitsetHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongInnerBitsetHelper", true);
}

const TypeIdentifier* GetMapULongShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongShort", complete);
}

const TypeObject* GetMapULongShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongShortObject();
    }
    //else
    return GetMinimalMapULongShortObject();
}

const TypeObject* GetMinimalMapULongShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_short;
    mst_var_map_ulong_short.common().member_id(memberId++);
    mst_var_map_ulong_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_short.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "int16_t", 100, false));


    MD5 var_map_ulong_short_hash("var_map_ulong_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_short.detail().name_hash()[i] = var_map_ulong_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongShort", false);
}

const TypeObject* GetCompleteMapULongShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_short;
    cst_var_map_ulong_short.common().member_id(memberId++);
    cst_var_map_ulong_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_short.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "int16_t", 100, true));


    cst_var_map_ulong_short.detail().name("var_map_ulong_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongShort", true);
}

const TypeIdentifier* GetMapULongUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongUShort", complete);
}

const TypeObject* GetMapULongUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongUShortObject();
    }
    //else
    return GetMinimalMapULongUShortObject();
}

const TypeObject* GetMinimalMapULongUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_ushort;
    mst_var_map_ulong_ushort.common().member_id(memberId++);
    mst_var_map_ulong_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_ushort.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "uint16_t", 100, false));


    MD5 var_map_ulong_ushort_hash("var_map_ulong_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_ushort.detail().name_hash()[i] = var_map_ulong_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongUShort", false);
}

const TypeObject* GetCompleteMapULongUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_ushort;
    cst_var_map_ulong_ushort.common().member_id(memberId++);
    cst_var_map_ulong_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_ushort.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "uint16_t", 100, true));


    cst_var_map_ulong_ushort.detail().name("var_map_ulong_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongUShort", true);
}

const TypeIdentifier* GetMapULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLong", complete);
}

const TypeObject* GetMapULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongObject();
    }
    //else
    return GetMinimalMapULongLongObject();
}

const TypeObject* GetMinimalMapULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_long;
    mst_var_map_ulong_long.common().member_id(memberId++);
    mst_var_map_ulong_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_long.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "int32_t", 100, false));


    MD5 var_map_ulong_long_hash("var_map_ulong_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_long.detail().name_hash()[i] = var_map_ulong_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLong", false);
}

const TypeObject* GetCompleteMapULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_long;
    cst_var_map_ulong_long.common().member_id(memberId++);
    cst_var_map_ulong_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_long.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "int32_t", 100, true));


    cst_var_map_ulong_long.detail().name("var_map_ulong_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLong", true);
}

const TypeIdentifier* GetMapULongULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongULong", complete);
}

const TypeObject* GetMapULongULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongULongObject();
    }
    //else
    return GetMinimalMapULongULongObject();
}

const TypeObject* GetMinimalMapULongULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_ulong;
    mst_var_map_ulong_ulong.common().member_id(memberId++);
    mst_var_map_ulong_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_ulong.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "uint32_t", 100, false));


    MD5 var_map_ulong_ulong_hash("var_map_ulong_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_ulong.detail().name_hash()[i] = var_map_ulong_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongULong", false);
}

const TypeObject* GetCompleteMapULongULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_ulong;
    cst_var_map_ulong_ulong.common().member_id(memberId++);
    cst_var_map_ulong_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_ulong.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "uint32_t", 100, true));


    cst_var_map_ulong_ulong.detail().name("var_map_ulong_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongULong", true);
}

const TypeIdentifier* GetMapKeyULongValueLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapKeyULongValueLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapKeyULongValueLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapKeyULongValueLongLong", complete);
}

const TypeObject* GetMapKeyULongValueLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapKeyULongValueLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapKeyULongValueLongLongObject();
    }
    //else
    return GetMinimalMapKeyULongValueLongLongObject();
}

const TypeObject* GetMinimalMapKeyULongValueLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapKeyULongValueLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_longlong;
    mst_var_map_ulong_longlong.common().member_id(memberId++);
    mst_var_map_ulong_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_longlong.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "int64_t", 100, false));


    MD5 var_map_ulong_longlong_hash("var_map_ulong_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_longlong.detail().name_hash()[i] = var_map_ulong_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapKeyULongValueLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapKeyULongValueLongLong", false);
}

const TypeObject* GetCompleteMapKeyULongValueLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapKeyULongValueLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_longlong;
    cst_var_map_ulong_longlong.common().member_id(memberId++);
    cst_var_map_ulong_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_longlong.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "int64_t", 100, true));


    cst_var_map_ulong_longlong.detail().name("var_map_ulong_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapKeyULongValueLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapKeyULongValueLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapKeyULongValueLongLong", true);
}

const TypeIdentifier* GetMapULongULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongULongLong", complete);
}

const TypeObject* GetMapULongULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongULongLongObject();
    }
    //else
    return GetMinimalMapULongULongLongObject();
}

const TypeObject* GetMinimalMapULongULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_ulonglong;
    mst_var_map_ulong_ulonglong.common().member_id(memberId++);
    mst_var_map_ulong_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "uint64_t", 100, false));


    MD5 var_map_ulong_ulonglong_hash("var_map_ulong_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_ulonglong.detail().name_hash()[i] = var_map_ulong_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongULongLong", false);
}

const TypeObject* GetCompleteMapULongULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_ulonglong;
    cst_var_map_ulong_ulonglong.common().member_id(memberId++);
    cst_var_map_ulong_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "uint64_t", 100, true));


    cst_var_map_ulong_ulonglong.detail().name("var_map_ulong_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongULongLong", true);
}

const TypeIdentifier* GetMapULongFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongFloat", complete);
}

const TypeObject* GetMapULongFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongFloatObject();
    }
    //else
    return GetMinimalMapULongFloatObject();
}

const TypeObject* GetMinimalMapULongFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_float;
    mst_var_map_ulong_float.common().member_id(memberId++);
    mst_var_map_ulong_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_float.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "float", 100, false));


    MD5 var_map_ulong_float_hash("var_map_ulong_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_float.detail().name_hash()[i] = var_map_ulong_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongFloat", false);
}

const TypeObject* GetCompleteMapULongFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_float;
    cst_var_map_ulong_float.common().member_id(memberId++);
    cst_var_map_ulong_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_float.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "float", 100, true));


    cst_var_map_ulong_float.detail().name("var_map_ulong_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongFloat", true);
}

const TypeIdentifier* GetMapULongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongDouble", complete);
}

const TypeObject* GetMapULongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongDoubleObject();
    }
    //else
    return GetMinimalMapULongDoubleObject();
}

const TypeObject* GetMinimalMapULongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_double;
    mst_var_map_ulong_double.common().member_id(memberId++);
    mst_var_map_ulong_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_double.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "double", 100, false));


    MD5 var_map_ulong_double_hash("var_map_ulong_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_double.detail().name_hash()[i] = var_map_ulong_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongDouble", false);
}

const TypeObject* GetCompleteMapULongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_double;
    cst_var_map_ulong_double.common().member_id(memberId++);
    cst_var_map_ulong_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_double.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "double", 100, true));


    cst_var_map_ulong_double.detail().name("var_map_ulong_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongDouble", true);
}

const TypeIdentifier* GetMapKeyULongValueLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapKeyULongValueLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapKeyULongValueLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapKeyULongValueLongDouble", complete);
}

const TypeObject* GetMapKeyULongValueLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapKeyULongValueLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapKeyULongValueLongDoubleObject();
    }
    //else
    return GetMinimalMapKeyULongValueLongDoubleObject();
}

const TypeObject* GetMinimalMapKeyULongValueLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapKeyULongValueLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_longdouble;
    mst_var_map_ulong_longdouble.common().member_id(memberId++);
    mst_var_map_ulong_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_longdouble.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "longdouble", 100, false));


    MD5 var_map_ulong_longdouble_hash("var_map_ulong_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_longdouble.detail().name_hash()[i] = var_map_ulong_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapKeyULongValueLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapKeyULongValueLongDouble", false);
}

const TypeObject* GetCompleteMapKeyULongValueLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapKeyULongValueLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_longdouble;
    cst_var_map_ulong_longdouble.common().member_id(memberId++);
    cst_var_map_ulong_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_longdouble.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "longdouble", 100, true));


    cst_var_map_ulong_longdouble.detail().name("var_map_ulong_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapKeyULongValueLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapKeyULongValueLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapKeyULongValueLongDouble", true);
}

const TypeIdentifier* GetMapULongBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongBoolean", complete);
}

const TypeObject* GetMapULongBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongBooleanObject();
    }
    //else
    return GetMinimalMapULongBooleanObject();
}

const TypeObject* GetMinimalMapULongBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_boolean;
    mst_var_map_ulong_boolean.common().member_id(memberId++);
    mst_var_map_ulong_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_boolean.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "bool", 100, false));


    MD5 var_map_ulong_boolean_hash("var_map_ulong_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_boolean.detail().name_hash()[i] = var_map_ulong_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongBoolean", false);
}

const TypeObject* GetCompleteMapULongBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_boolean;
    cst_var_map_ulong_boolean.common().member_id(memberId++);
    cst_var_map_ulong_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_boolean.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "bool", 100, true));


    cst_var_map_ulong_boolean.detail().name("var_map_ulong_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongBoolean", true);
}

const TypeIdentifier* GetMapULongOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongOctet", complete);
}

const TypeObject* GetMapULongOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongOctetObject();
    }
    //else
    return GetMinimalMapULongOctetObject();
}

const TypeObject* GetMinimalMapULongOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_octet;
    mst_var_map_ulong_octet.common().member_id(memberId++);
    mst_var_map_ulong_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_octet.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "uint8_t", 100, false));


    MD5 var_map_ulong_octet_hash("var_map_ulong_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_octet.detail().name_hash()[i] = var_map_ulong_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongOctet", false);
}

const TypeObject* GetCompleteMapULongOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_octet;
    cst_var_map_ulong_octet.common().member_id(memberId++);
    cst_var_map_ulong_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_octet.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "uint8_t", 100, true));


    cst_var_map_ulong_octet.detail().name("var_map_ulong_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongOctet", true);
}

const TypeIdentifier* GetMapULongCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongChar", complete);
}

const TypeObject* GetMapULongCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongCharObject();
    }
    //else
    return GetMinimalMapULongCharObject();
}

const TypeObject* GetMinimalMapULongCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_char;
    mst_var_map_ulong_char.common().member_id(memberId++);
    mst_var_map_ulong_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_char.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "char", 100, false));


    MD5 var_map_ulong_char_hash("var_map_ulong_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_char.detail().name_hash()[i] = var_map_ulong_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongChar", false);
}

const TypeObject* GetCompleteMapULongCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_char;
    cst_var_map_ulong_char.common().member_id(memberId++);
    cst_var_map_ulong_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_char.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "char", 100, true));


    cst_var_map_ulong_char.detail().name("var_map_ulong_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongChar", true);
}

const TypeIdentifier* GetMapULongWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongWChar", complete);
}

const TypeObject* GetMapULongWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongWCharObject();
    }
    //else
    return GetMinimalMapULongWCharObject();
}

const TypeObject* GetMinimalMapULongWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_wchar;
    mst_var_map_ulong_wchar.common().member_id(memberId++);
    mst_var_map_ulong_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_wchar.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "wchar_t", 100, false));


    MD5 var_map_ulong_wchar_hash("var_map_ulong_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_wchar.detail().name_hash()[i] = var_map_ulong_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongWChar", false);
}

const TypeObject* GetCompleteMapULongWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_wchar;
    cst_var_map_ulong_wchar.common().member_id(memberId++);
    cst_var_map_ulong_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_wchar.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "wchar_t", 100, true));


    cst_var_map_ulong_wchar.detail().name("var_map_ulong_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongWChar", true);
}

const TypeIdentifier* GetMapULongStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongString", complete);
}

const TypeObject* GetMapULongStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongStringObject();
    }
    //else
    return GetMinimalMapULongStringObject();
}

const TypeObject* GetMinimalMapULongStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_string;
    mst_var_map_ulong_string.common().member_id(memberId++);
    mst_var_map_ulong_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_string.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", TypeNamesGenerator::get_string_type_name(255, false), 100, false));


    MD5 var_map_ulong_string_hash("var_map_ulong_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_string.detail().name_hash()[i] = var_map_ulong_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongString", false);
}

const TypeObject* GetCompleteMapULongStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_string;
    cst_var_map_ulong_string.common().member_id(memberId++);
    cst_var_map_ulong_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_string.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", TypeNamesGenerator::get_string_type_name(255, false), 100, true));


    cst_var_map_ulong_string.detail().name("var_map_ulong_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongString", true);
}

const TypeIdentifier* GetMapULongWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongWString", complete);
}

const TypeObject* GetMapULongWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongWStringObject();
    }
    //else
    return GetMinimalMapULongWStringObject();
}

const TypeObject* GetMinimalMapULongWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_wstring;
    mst_var_map_ulong_wstring.common().member_id(memberId++);
    mst_var_map_ulong_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_wstring.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", TypeNamesGenerator::get_string_type_name(255, true), 100, false));


    MD5 var_map_ulong_wstring_hash("var_map_ulong_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_wstring.detail().name_hash()[i] = var_map_ulong_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongWString", false);
}

const TypeObject* GetCompleteMapULongWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_wstring;
    cst_var_map_ulong_wstring.common().member_id(memberId++);
    cst_var_map_ulong_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_wstring.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", TypeNamesGenerator::get_string_type_name(255, true), 100, true));


    cst_var_map_ulong_wstring.detail().name("var_map_ulong_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongWString", true);
}

const TypeIdentifier* GetMapULongInnerAliasBoundedStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerAliasBoundedStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongInnerAliasBoundedStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerAliasBoundedStringHelper", complete);
}

const TypeObject* GetMapULongInnerAliasBoundedStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasBoundedStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongInnerAliasBoundedStringHelperObject();
    }
    //else
    return GetMinimalMapULongInnerAliasBoundedStringHelperObject();
}

const TypeObject* GetMinimalMapULongInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasBoundedStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_inneraliasboundedstringhelper;
    mst_var_map_ulong_inneraliasboundedstringhelper.common().member_id(memberId++);
    mst_var_map_ulong_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "Inner_alias_bounded_string_helper", 100, false));


    MD5 var_map_ulong_inneraliasboundedstringhelper_hash("var_map_ulong_inneraliasboundedstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_inneraliasboundedstringhelper.detail().name_hash()[i] = var_map_ulong_inneraliasboundedstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_inneraliasboundedstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasBoundedStringHelper", false);
}

const TypeObject* GetCompleteMapULongInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasBoundedStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_inneraliasboundedstringhelper;
    cst_var_map_ulong_inneraliasboundedstringhelper.common().member_id(memberId++);
    cst_var_map_ulong_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "Inner_alias_bounded_string_helper", 100, true));


    cst_var_map_ulong_inneraliasboundedstringhelper.detail().name("var_map_ulong_inneraliasboundedstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_inneraliasboundedstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongInnerAliasBoundedStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasBoundedStringHelper", true);
}

const TypeIdentifier* GetMapULongInnerAliasBoundedWStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerAliasBoundedWStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongInnerAliasBoundedWStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerAliasBoundedWStringHelper", complete);
}

const TypeObject* GetMapULongInnerAliasBoundedWStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasBoundedWStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongInnerAliasBoundedWStringHelperObject();
    }
    //else
    return GetMinimalMapULongInnerAliasBoundedWStringHelperObject();
}

const TypeObject* GetMinimalMapULongInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasBoundedWStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_inneraliasboundedwstringhelper;
    mst_var_map_ulong_inneraliasboundedwstringhelper.common().member_id(memberId++);
    mst_var_map_ulong_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "Inner_alias_bounded_wstring_helper", 100, false));


    MD5 var_map_ulong_inneraliasboundedwstringhelper_hash("var_map_ulong_inneraliasboundedwstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_inneraliasboundedwstringhelper.detail().name_hash()[i] = var_map_ulong_inneraliasboundedwstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_inneraliasboundedwstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasBoundedWStringHelper", false);
}

const TypeObject* GetCompleteMapULongInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasBoundedWStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_inneraliasboundedwstringhelper;
    cst_var_map_ulong_inneraliasboundedwstringhelper.common().member_id(memberId++);
    cst_var_map_ulong_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "Inner_alias_bounded_wstring_helper", 100, true));


    cst_var_map_ulong_inneraliasboundedwstringhelper.detail().name("var_map_ulong_inneraliasboundedwstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_inneraliasboundedwstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongInnerAliasBoundedWStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasBoundedWStringHelper", true);
}

const TypeIdentifier* GetMapULongInnerEnumHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerEnumHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongInnerEnumHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerEnumHelper", complete);
}

const TypeObject* GetMapULongInnerEnumHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerEnumHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongInnerEnumHelperObject();
    }
    //else
    return GetMinimalMapULongInnerEnumHelperObject();
}

const TypeObject* GetMinimalMapULongInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerEnumHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_innerenumhelper;
    mst_var_map_ulong_innerenumhelper.common().member_id(memberId++);
    mst_var_map_ulong_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_innerenumhelper.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "InnerEnumHelper", 100, false));


    MD5 var_map_ulong_innerenumhelper_hash("var_map_ulong_innerenumhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_innerenumhelper.detail().name_hash()[i] = var_map_ulong_innerenumhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_innerenumhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerEnumHelper", false);
}

const TypeObject* GetCompleteMapULongInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerEnumHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_innerenumhelper;
    cst_var_map_ulong_innerenumhelper.common().member_id(memberId++);
    cst_var_map_ulong_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_innerenumhelper.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "InnerEnumHelper", 100, true));


    cst_var_map_ulong_innerenumhelper.detail().name("var_map_ulong_innerenumhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_innerenumhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongInnerEnumHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerEnumHelper", true);
}

const TypeIdentifier* GetMapULongInnerBitMaskHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerBitMaskHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongInnerBitMaskHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerBitMaskHelper", complete);
}

const TypeObject* GetMapULongInnerBitMaskHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerBitMaskHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongInnerBitMaskHelperObject();
    }
    //else
    return GetMinimalMapULongInnerBitMaskHelperObject();
}

const TypeObject* GetMinimalMapULongInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerBitMaskHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_innerbitmaskhelper;
    mst_var_map_ulong_innerbitmaskhelper.common().member_id(memberId++);
    mst_var_map_ulong_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "InnerBitMaskHelper", 100, false));


    MD5 var_map_ulong_innerbitmaskhelper_hash("var_map_ulong_innerbitmaskhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_innerbitmaskhelper.detail().name_hash()[i] = var_map_ulong_innerbitmaskhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_innerbitmaskhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerBitMaskHelper", false);
}

const TypeObject* GetCompleteMapULongInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerBitMaskHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_innerbitmaskhelper;
    cst_var_map_ulong_innerbitmaskhelper.common().member_id(memberId++);
    cst_var_map_ulong_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "InnerBitMaskHelper", 100, true));


    cst_var_map_ulong_innerbitmaskhelper.detail().name("var_map_ulong_innerbitmaskhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_innerbitmaskhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongInnerBitMaskHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerBitMaskHelper", true);
}

const TypeIdentifier* GetMapULongInnerAliasHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerAliasHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongInnerAliasHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerAliasHelper", complete);
}

const TypeObject* GetMapULongInnerAliasHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongInnerAliasHelperObject();
    }
    //else
    return GetMinimalMapULongInnerAliasHelperObject();
}

const TypeObject* GetMinimalMapULongInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_inneraliashelper;
    mst_var_map_ulong_inneraliashelper.common().member_id(memberId++);
    mst_var_map_ulong_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_inneraliashelper.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "InnerAliasHelper", 100, false));


    MD5 var_map_ulong_inneraliashelper_hash("var_map_ulong_inneraliashelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_inneraliashelper.detail().name_hash()[i] = var_map_ulong_inneraliashelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_inneraliashelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasHelper", false);
}

const TypeObject* GetCompleteMapULongInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_inneraliashelper;
    cst_var_map_ulong_inneraliashelper.common().member_id(memberId++);
    cst_var_map_ulong_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_inneraliashelper.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "InnerAliasHelper", 100, true));


    cst_var_map_ulong_inneraliashelper.detail().name("var_map_ulong_inneraliashelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_inneraliashelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongInnerAliasHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasHelper", true);
}

const TypeIdentifier* GetMapULongInnerAliasArrayHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerAliasArrayHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongInnerAliasArrayHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerAliasArrayHelper", complete);
}

const TypeObject* GetMapULongInnerAliasArrayHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasArrayHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongInnerAliasArrayHelperObject();
    }
    //else
    return GetMinimalMapULongInnerAliasArrayHelperObject();
}

const TypeObject* GetMinimalMapULongInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasArrayHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_inneraliasarrayhelper;
    mst_var_map_ulong_inneraliasarrayhelper.common().member_id(memberId++);
    mst_var_map_ulong_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "Inner_alias_array_helper", 100, false));


    MD5 var_map_ulong_inneraliasarrayhelper_hash("var_map_ulong_inneraliasarrayhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_inneraliasarrayhelper.detail().name_hash()[i] = var_map_ulong_inneraliasarrayhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_inneraliasarrayhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasArrayHelper", false);
}

const TypeObject* GetCompleteMapULongInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasArrayHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_inneraliasarrayhelper;
    cst_var_map_ulong_inneraliasarrayhelper.common().member_id(memberId++);
    cst_var_map_ulong_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "Inner_alias_array_helper", 100, true));


    cst_var_map_ulong_inneraliasarrayhelper.detail().name("var_map_ulong_inneraliasarrayhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_inneraliasarrayhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongInnerAliasArrayHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasArrayHelper", true);
}

const TypeIdentifier* GetMapULongInnerAliasSequenceHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerAliasSequenceHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongInnerAliasSequenceHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerAliasSequenceHelper", complete);
}

const TypeObject* GetMapULongInnerAliasSequenceHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasSequenceHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongInnerAliasSequenceHelperObject();
    }
    //else
    return GetMinimalMapULongInnerAliasSequenceHelperObject();
}

const TypeObject* GetMinimalMapULongInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasSequenceHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_inneraliassequencehelper;
    mst_var_map_ulong_inneraliassequencehelper.common().member_id(memberId++);
    mst_var_map_ulong_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "Inner_alias_sequence_helper", 100, false));


    MD5 var_map_ulong_inneraliassequencehelper_hash("var_map_ulong_inneraliassequencehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_inneraliassequencehelper.detail().name_hash()[i] = var_map_ulong_inneraliassequencehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_inneraliassequencehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasSequenceHelper", false);
}

const TypeObject* GetCompleteMapULongInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasSequenceHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_inneraliassequencehelper;
    cst_var_map_ulong_inneraliassequencehelper.common().member_id(memberId++);
    cst_var_map_ulong_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "Inner_alias_sequence_helper", 100, true));


    cst_var_map_ulong_inneraliassequencehelper.detail().name("var_map_ulong_inneraliassequencehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_inneraliassequencehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongInnerAliasSequenceHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasSequenceHelper", true);
}

const TypeIdentifier* GetMapULongInnerAliasMapHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerAliasMapHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongInnerAliasMapHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerAliasMapHelper", complete);
}

const TypeObject* GetMapULongInnerAliasMapHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasMapHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongInnerAliasMapHelperObject();
    }
    //else
    return GetMinimalMapULongInnerAliasMapHelperObject();
}

const TypeObject* GetMinimalMapULongInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasMapHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_inneraliasmaphelper;
    mst_var_map_ulong_inneraliasmaphelper.common().member_id(memberId++);
    mst_var_map_ulong_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "Inner_alias_map_helper", 100, false));


    MD5 var_map_ulong_inneraliasmaphelper_hash("var_map_ulong_inneraliasmaphelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_inneraliasmaphelper.detail().name_hash()[i] = var_map_ulong_inneraliasmaphelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_inneraliasmaphelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasMapHelper", false);
}

const TypeObject* GetCompleteMapULongInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasMapHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_inneraliasmaphelper;
    cst_var_map_ulong_inneraliasmaphelper.common().member_id(memberId++);
    cst_var_map_ulong_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "Inner_alias_map_helper", 100, true));


    cst_var_map_ulong_inneraliasmaphelper.detail().name("var_map_ulong_inneraliasmaphelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_inneraliasmaphelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongInnerAliasMapHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerAliasMapHelper", true);
}

const TypeIdentifier* GetMapULongInnerUnionHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerUnionHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongInnerUnionHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerUnionHelper", complete);
}

const TypeObject* GetMapULongInnerUnionHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerUnionHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongInnerUnionHelperObject();
    }
    //else
    return GetMinimalMapULongInnerUnionHelperObject();
}

const TypeObject* GetMinimalMapULongInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerUnionHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_innerunionhelper;
    mst_var_map_ulong_innerunionhelper.common().member_id(memberId++);
    mst_var_map_ulong_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_innerunionhelper.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "InnerUnionHelper", 100, false));


    MD5 var_map_ulong_innerunionhelper_hash("var_map_ulong_innerunionhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_innerunionhelper.detail().name_hash()[i] = var_map_ulong_innerunionhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_innerunionhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerUnionHelper", false);
}

const TypeObject* GetCompleteMapULongInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerUnionHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_innerunionhelper;
    cst_var_map_ulong_innerunionhelper.common().member_id(memberId++);
    cst_var_map_ulong_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_innerunionhelper.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "InnerUnionHelper", 100, true));


    cst_var_map_ulong_innerunionhelper.detail().name("var_map_ulong_innerunionhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_innerunionhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongInnerUnionHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerUnionHelper", true);
}

const TypeIdentifier* GetMapULongInnerStructureHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerStructureHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongInnerStructureHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerStructureHelper", complete);
}

const TypeObject* GetMapULongInnerStructureHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerStructureHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongInnerStructureHelperObject();
    }
    //else
    return GetMinimalMapULongInnerStructureHelperObject();
}

const TypeObject* GetMinimalMapULongInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerStructureHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_innerstructurehelper;
    mst_var_map_ulong_innerstructurehelper.common().member_id(memberId++);
    mst_var_map_ulong_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_innerstructurehelper.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "InnerStructureHelper", 100, false));


    MD5 var_map_ulong_innerstructurehelper_hash("var_map_ulong_innerstructurehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_innerstructurehelper.detail().name_hash()[i] = var_map_ulong_innerstructurehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_innerstructurehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerStructureHelper", false);
}

const TypeObject* GetCompleteMapULongInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerStructureHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_innerstructurehelper;
    cst_var_map_ulong_innerstructurehelper.common().member_id(memberId++);
    cst_var_map_ulong_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_innerstructurehelper.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "InnerStructureHelper", 100, true));


    cst_var_map_ulong_innerstructurehelper.detail().name("var_map_ulong_innerstructurehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_innerstructurehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongInnerStructureHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerStructureHelper", true);
}

const TypeIdentifier* GetMapULongInnerBitsetHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerBitsetHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongInnerBitsetHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongInnerBitsetHelper", complete);
}

const TypeObject* GetMapULongInnerBitsetHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerBitsetHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongInnerBitsetHelperObject();
    }
    //else
    return GetMinimalMapULongInnerBitsetHelperObject();
}

const TypeObject* GetMinimalMapULongInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerBitsetHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_ulong_innerbitsethelper;
    mst_var_map_ulong_innerbitsethelper.common().member_id(memberId++);
    mst_var_map_ulong_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_ulong_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_ulong_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_ulong_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_ulong_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_ulong_innerbitsethelper.common().member_flags().IS_KEY(false);
    mst_var_map_ulong_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_ulong_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "InnerBitsetHelper", 100, false));


    MD5 var_map_ulong_innerbitsethelper_hash("var_map_ulong_innerbitsethelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_ulong_innerbitsethelper.detail().name_hash()[i] = var_map_ulong_innerbitsethelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_ulong_innerbitsethelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerBitsetHelper", false);
}

const TypeObject* GetCompleteMapULongInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongInnerBitsetHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_ulong_innerbitsethelper;
    cst_var_map_ulong_innerbitsethelper.common().member_id(memberId++);
    cst_var_map_ulong_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_ulong_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_ulong_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_ulong_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_ulong_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_ulong_innerbitsethelper.common().member_flags().IS_KEY(false);
    cst_var_map_ulong_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_ulong_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint32_t", "InnerBitsetHelper", 100, true));


    cst_var_map_ulong_innerbitsethelper.detail().name("var_map_ulong_innerbitsethelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_ulong_innerbitsethelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongInnerBitsetHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongInnerBitsetHelper", true);
}

const TypeIdentifier* GetMapLongLongShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongShort", complete);
}

const TypeObject* GetMapLongLongShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongShortObject();
    }
    //else
    return GetMinimalMapLongLongShortObject();
}

const TypeObject* GetMinimalMapLongLongShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_short;
    mst_var_map_longlong_short.common().member_id(memberId++);
    mst_var_map_longlong_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_short.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "int16_t", 100, false));


    MD5 var_map_longlong_short_hash("var_map_longlong_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_short.detail().name_hash()[i] = var_map_longlong_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongShort", false);
}

const TypeObject* GetCompleteMapLongLongShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_short;
    cst_var_map_longlong_short.common().member_id(memberId++);
    cst_var_map_longlong_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_short.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "int16_t", 100, true));


    cst_var_map_longlong_short.detail().name("var_map_longlong_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongShort", true);
}

const TypeIdentifier* GetMapLongLongUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongUShort", complete);
}

const TypeObject* GetMapLongLongUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongUShortObject();
    }
    //else
    return GetMinimalMapLongLongUShortObject();
}

const TypeObject* GetMinimalMapLongLongUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_ushort;
    mst_var_map_longlong_ushort.common().member_id(memberId++);
    mst_var_map_longlong_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_ushort.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "uint16_t", 100, false));


    MD5 var_map_longlong_ushort_hash("var_map_longlong_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_ushort.detail().name_hash()[i] = var_map_longlong_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongUShort", false);
}

const TypeObject* GetCompleteMapLongLongUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_ushort;
    cst_var_map_longlong_ushort.common().member_id(memberId++);
    cst_var_map_longlong_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_ushort.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "uint16_t", 100, true));


    cst_var_map_longlong_ushort.detail().name("var_map_longlong_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongUShort", true);
}

const TypeIdentifier* GetMapLongLongKeyLongValueIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongKeyLongValue", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongKeyLongValueObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongKeyLongValue", complete);
}

const TypeObject* GetMapLongLongKeyLongValueObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongKeyLongValue", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongKeyLongValueObject();
    }
    //else
    return GetMinimalMapLongLongKeyLongValueObject();
}

const TypeObject* GetMinimalMapLongLongKeyLongValueObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongKeyLongValue", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_long;
    mst_var_map_longlong_long.common().member_id(memberId++);
    mst_var_map_longlong_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_long.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "int32_t", 100, false));


    MD5 var_map_longlong_long_hash("var_map_longlong_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_long.detail().name_hash()[i] = var_map_longlong_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongKeyLongValue", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongKeyLongValue", false);
}

const TypeObject* GetCompleteMapLongLongKeyLongValueObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongKeyLongValue", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_long;
    cst_var_map_longlong_long.common().member_id(memberId++);
    cst_var_map_longlong_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_long.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "int32_t", 100, true));


    cst_var_map_longlong_long.detail().name("var_map_longlong_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongKeyLongValue");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongKeyLongValue", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongKeyLongValue", true);
}

const TypeIdentifier* GetMapLongLongULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongULong", complete);
}

const TypeObject* GetMapLongLongULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongULongObject();
    }
    //else
    return GetMinimalMapLongLongULongObject();
}

const TypeObject* GetMinimalMapLongLongULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_ulong;
    mst_var_map_longlong_ulong.common().member_id(memberId++);
    mst_var_map_longlong_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_ulong.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "uint32_t", 100, false));


    MD5 var_map_longlong_ulong_hash("var_map_longlong_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_ulong.detail().name_hash()[i] = var_map_longlong_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongULong", false);
}

const TypeObject* GetCompleteMapLongLongULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_ulong;
    cst_var_map_longlong_ulong.common().member_id(memberId++);
    cst_var_map_longlong_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_ulong.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "uint32_t", 100, true));


    cst_var_map_longlong_ulong.detail().name("var_map_longlong_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongULong", true);
}

const TypeIdentifier* GetMapLongLongLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongLongLong", complete);
}

const TypeObject* GetMapLongLongLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongLongLongObject();
    }
    //else
    return GetMinimalMapLongLongLongLongObject();
}

const TypeObject* GetMinimalMapLongLongLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_longlong;
    mst_var_map_longlong_longlong.common().member_id(memberId++);
    mst_var_map_longlong_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_longlong.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "int64_t", 100, false));


    MD5 var_map_longlong_longlong_hash("var_map_longlong_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_longlong.detail().name_hash()[i] = var_map_longlong_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongLongLong", false);
}

const TypeObject* GetCompleteMapLongLongLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_longlong;
    cst_var_map_longlong_longlong.common().member_id(memberId++);
    cst_var_map_longlong_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_longlong.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "int64_t", 100, true));


    cst_var_map_longlong_longlong.detail().name("var_map_longlong_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongLongLong", true);
}

const TypeIdentifier* GetMapLongLongULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongULongLong", complete);
}

const TypeObject* GetMapLongLongULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongULongLongObject();
    }
    //else
    return GetMinimalMapLongLongULongLongObject();
}

const TypeObject* GetMinimalMapLongLongULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_ulonglong;
    mst_var_map_longlong_ulonglong.common().member_id(memberId++);
    mst_var_map_longlong_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "uint64_t", 100, false));


    MD5 var_map_longlong_ulonglong_hash("var_map_longlong_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_ulonglong.detail().name_hash()[i] = var_map_longlong_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongULongLong", false);
}

const TypeObject* GetCompleteMapLongLongULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_ulonglong;
    cst_var_map_longlong_ulonglong.common().member_id(memberId++);
    cst_var_map_longlong_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "uint64_t", 100, true));


    cst_var_map_longlong_ulonglong.detail().name("var_map_longlong_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongULongLong", true);
}

const TypeIdentifier* GetMapLongLongFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongFloat", complete);
}

const TypeObject* GetMapLongLongFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongFloatObject();
    }
    //else
    return GetMinimalMapLongLongFloatObject();
}

const TypeObject* GetMinimalMapLongLongFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_float;
    mst_var_map_longlong_float.common().member_id(memberId++);
    mst_var_map_longlong_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_float.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "float", 100, false));


    MD5 var_map_longlong_float_hash("var_map_longlong_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_float.detail().name_hash()[i] = var_map_longlong_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongFloat", false);
}

const TypeObject* GetCompleteMapLongLongFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_float;
    cst_var_map_longlong_float.common().member_id(memberId++);
    cst_var_map_longlong_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_float.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "float", 100, true));


    cst_var_map_longlong_float.detail().name("var_map_longlong_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongFloat", true);
}

const TypeIdentifier* GetMapLongLongKeyDoubleValueIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongKeyDoubleValue", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongKeyDoubleValueObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongKeyDoubleValue", complete);
}

const TypeObject* GetMapLongLongKeyDoubleValueObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongKeyDoubleValue", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongKeyDoubleValueObject();
    }
    //else
    return GetMinimalMapLongLongKeyDoubleValueObject();
}

const TypeObject* GetMinimalMapLongLongKeyDoubleValueObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongKeyDoubleValue", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_double;
    mst_var_map_longlong_double.common().member_id(memberId++);
    mst_var_map_longlong_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_double.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "double", 100, false));


    MD5 var_map_longlong_double_hash("var_map_longlong_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_double.detail().name_hash()[i] = var_map_longlong_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongKeyDoubleValue", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongKeyDoubleValue", false);
}

const TypeObject* GetCompleteMapLongLongKeyDoubleValueObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongKeyDoubleValue", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_double;
    cst_var_map_longlong_double.common().member_id(memberId++);
    cst_var_map_longlong_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_double.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "double", 100, true));


    cst_var_map_longlong_double.detail().name("var_map_longlong_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongKeyDoubleValue");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongKeyDoubleValue", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongKeyDoubleValue", true);
}

const TypeIdentifier* GetMapLongLongLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongLongDouble", complete);
}

const TypeObject* GetMapLongLongLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongLongDoubleObject();
    }
    //else
    return GetMinimalMapLongLongLongDoubleObject();
}

const TypeObject* GetMinimalMapLongLongLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_longdouble;
    mst_var_map_longlong_longdouble.common().member_id(memberId++);
    mst_var_map_longlong_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_longdouble.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "longdouble", 100, false));


    MD5 var_map_longlong_longdouble_hash("var_map_longlong_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_longdouble.detail().name_hash()[i] = var_map_longlong_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongLongDouble", false);
}

const TypeObject* GetCompleteMapLongLongLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_longdouble;
    cst_var_map_longlong_longdouble.common().member_id(memberId++);
    cst_var_map_longlong_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_longdouble.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "longdouble", 100, true));


    cst_var_map_longlong_longdouble.detail().name("var_map_longlong_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongLongDouble", true);
}

const TypeIdentifier* GetMapLongLongBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongBoolean", complete);
}

const TypeObject* GetMapLongLongBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongBooleanObject();
    }
    //else
    return GetMinimalMapLongLongBooleanObject();
}

const TypeObject* GetMinimalMapLongLongBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_boolean;
    mst_var_map_longlong_boolean.common().member_id(memberId++);
    mst_var_map_longlong_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_boolean.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "bool", 100, false));


    MD5 var_map_longlong_boolean_hash("var_map_longlong_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_boolean.detail().name_hash()[i] = var_map_longlong_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongBoolean", false);
}

const TypeObject* GetCompleteMapLongLongBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_boolean;
    cst_var_map_longlong_boolean.common().member_id(memberId++);
    cst_var_map_longlong_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_boolean.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "bool", 100, true));


    cst_var_map_longlong_boolean.detail().name("var_map_longlong_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongBoolean", true);
}

const TypeIdentifier* GetMapLongLongOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongOctet", complete);
}

const TypeObject* GetMapLongLongOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongOctetObject();
    }
    //else
    return GetMinimalMapLongLongOctetObject();
}

const TypeObject* GetMinimalMapLongLongOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_octet;
    mst_var_map_longlong_octet.common().member_id(memberId++);
    mst_var_map_longlong_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_octet.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "uint8_t", 100, false));


    MD5 var_map_longlong_octet_hash("var_map_longlong_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_octet.detail().name_hash()[i] = var_map_longlong_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongOctet", false);
}

const TypeObject* GetCompleteMapLongLongOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_octet;
    cst_var_map_longlong_octet.common().member_id(memberId++);
    cst_var_map_longlong_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_octet.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "uint8_t", 100, true));


    cst_var_map_longlong_octet.detail().name("var_map_longlong_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongOctet", true);
}

const TypeIdentifier* GetMapLongLongCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongChar", complete);
}

const TypeObject* GetMapLongLongCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongCharObject();
    }
    //else
    return GetMinimalMapLongLongCharObject();
}

const TypeObject* GetMinimalMapLongLongCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_char;
    mst_var_map_longlong_char.common().member_id(memberId++);
    mst_var_map_longlong_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_char.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "char", 100, false));


    MD5 var_map_longlong_char_hash("var_map_longlong_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_char.detail().name_hash()[i] = var_map_longlong_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongChar", false);
}

const TypeObject* GetCompleteMapLongLongCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_char;
    cst_var_map_longlong_char.common().member_id(memberId++);
    cst_var_map_longlong_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_char.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "char", 100, true));


    cst_var_map_longlong_char.detail().name("var_map_longlong_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongChar", true);
}

const TypeIdentifier* GetMapLongLongWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongWChar", complete);
}

const TypeObject* GetMapLongLongWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongWCharObject();
    }
    //else
    return GetMinimalMapLongLongWCharObject();
}

const TypeObject* GetMinimalMapLongLongWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_wchar;
    mst_var_map_longlong_wchar.common().member_id(memberId++);
    mst_var_map_longlong_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_wchar.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "wchar_t", 100, false));


    MD5 var_map_longlong_wchar_hash("var_map_longlong_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_wchar.detail().name_hash()[i] = var_map_longlong_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongWChar", false);
}

const TypeObject* GetCompleteMapLongLongWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_wchar;
    cst_var_map_longlong_wchar.common().member_id(memberId++);
    cst_var_map_longlong_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_wchar.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "wchar_t", 100, true));


    cst_var_map_longlong_wchar.detail().name("var_map_longlong_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongWChar", true);
}

const TypeIdentifier* GetMapLongLongStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongString", complete);
}

const TypeObject* GetMapLongLongStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongStringObject();
    }
    //else
    return GetMinimalMapLongLongStringObject();
}

const TypeObject* GetMinimalMapLongLongStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_string;
    mst_var_map_longlong_string.common().member_id(memberId++);
    mst_var_map_longlong_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_string.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", TypeNamesGenerator::get_string_type_name(255, false), 100, false));


    MD5 var_map_longlong_string_hash("var_map_longlong_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_string.detail().name_hash()[i] = var_map_longlong_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongString", false);
}

const TypeObject* GetCompleteMapLongLongStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_string;
    cst_var_map_longlong_string.common().member_id(memberId++);
    cst_var_map_longlong_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_string.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", TypeNamesGenerator::get_string_type_name(255, false), 100, true));


    cst_var_map_longlong_string.detail().name("var_map_longlong_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongString", true);
}

const TypeIdentifier* GetMapLongLongWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongWString", complete);
}

const TypeObject* GetMapLongLongWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongWStringObject();
    }
    //else
    return GetMinimalMapLongLongWStringObject();
}

const TypeObject* GetMinimalMapLongLongWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_wstring;
    mst_var_map_longlong_wstring.common().member_id(memberId++);
    mst_var_map_longlong_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_wstring.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", TypeNamesGenerator::get_string_type_name(255, true), 100, false));


    MD5 var_map_longlong_wstring_hash("var_map_longlong_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_wstring.detail().name_hash()[i] = var_map_longlong_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongWString", false);
}

const TypeObject* GetCompleteMapLongLongWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_wstring;
    cst_var_map_longlong_wstring.common().member_id(memberId++);
    cst_var_map_longlong_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_wstring.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", TypeNamesGenerator::get_string_type_name(255, true), 100, true));


    cst_var_map_longlong_wstring.detail().name("var_map_longlong_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongWString", true);
}

const TypeIdentifier* GetMapLongLongInnerAliasBoundedStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerAliasBoundedStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongInnerAliasBoundedStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerAliasBoundedStringHelper", complete);
}

const TypeObject* GetMapLongLongInnerAliasBoundedStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasBoundedStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongInnerAliasBoundedStringHelperObject();
    }
    //else
    return GetMinimalMapLongLongInnerAliasBoundedStringHelperObject();
}

const TypeObject* GetMinimalMapLongLongInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasBoundedStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_inneraliasboundedstringhelper;
    mst_var_map_longlong_inneraliasboundedstringhelper.common().member_id(memberId++);
    mst_var_map_longlong_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "Inner_alias_bounded_string_helper", 100, false));


    MD5 var_map_longlong_inneraliasboundedstringhelper_hash("var_map_longlong_inneraliasboundedstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_inneraliasboundedstringhelper.detail().name_hash()[i] = var_map_longlong_inneraliasboundedstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_inneraliasboundedstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasBoundedStringHelper", false);
}

const TypeObject* GetCompleteMapLongLongInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasBoundedStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_inneraliasboundedstringhelper;
    cst_var_map_longlong_inneraliasboundedstringhelper.common().member_id(memberId++);
    cst_var_map_longlong_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "Inner_alias_bounded_string_helper", 100, true));


    cst_var_map_longlong_inneraliasboundedstringhelper.detail().name("var_map_longlong_inneraliasboundedstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_inneraliasboundedstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongInnerAliasBoundedStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasBoundedStringHelper", true);
}

const TypeIdentifier* GetMapLongLongInnerAliasBoundedWStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerAliasBoundedWStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongInnerAliasBoundedWStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerAliasBoundedWStringHelper", complete);
}

const TypeObject* GetMapLongLongInnerAliasBoundedWStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasBoundedWStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongInnerAliasBoundedWStringHelperObject();
    }
    //else
    return GetMinimalMapLongLongInnerAliasBoundedWStringHelperObject();
}

const TypeObject* GetMinimalMapLongLongInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasBoundedWStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_inneraliasboundedwstringhelper;
    mst_var_map_longlong_inneraliasboundedwstringhelper.common().member_id(memberId++);
    mst_var_map_longlong_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "Inner_alias_bounded_wstring_helper", 100, false));


    MD5 var_map_longlong_inneraliasboundedwstringhelper_hash("var_map_longlong_inneraliasboundedwstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_inneraliasboundedwstringhelper.detail().name_hash()[i] = var_map_longlong_inneraliasboundedwstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_inneraliasboundedwstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasBoundedWStringHelper", false);
}

const TypeObject* GetCompleteMapLongLongInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasBoundedWStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_inneraliasboundedwstringhelper;
    cst_var_map_longlong_inneraliasboundedwstringhelper.common().member_id(memberId++);
    cst_var_map_longlong_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "Inner_alias_bounded_wstring_helper", 100, true));


    cst_var_map_longlong_inneraliasboundedwstringhelper.detail().name("var_map_longlong_inneraliasboundedwstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_inneraliasboundedwstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongInnerAliasBoundedWStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasBoundedWStringHelper", true);
}

const TypeIdentifier* GetMapLongLongInnerEnumHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerEnumHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongInnerEnumHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerEnumHelper", complete);
}

const TypeObject* GetMapLongLongInnerEnumHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerEnumHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongInnerEnumHelperObject();
    }
    //else
    return GetMinimalMapLongLongInnerEnumHelperObject();
}

const TypeObject* GetMinimalMapLongLongInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerEnumHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_innerenumhelper;
    mst_var_map_longlong_innerenumhelper.common().member_id(memberId++);
    mst_var_map_longlong_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_innerenumhelper.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "InnerEnumHelper", 100, false));


    MD5 var_map_longlong_innerenumhelper_hash("var_map_longlong_innerenumhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_innerenumhelper.detail().name_hash()[i] = var_map_longlong_innerenumhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_innerenumhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerEnumHelper", false);
}

const TypeObject* GetCompleteMapLongLongInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerEnumHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_innerenumhelper;
    cst_var_map_longlong_innerenumhelper.common().member_id(memberId++);
    cst_var_map_longlong_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_innerenumhelper.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "InnerEnumHelper", 100, true));


    cst_var_map_longlong_innerenumhelper.detail().name("var_map_longlong_innerenumhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_innerenumhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongInnerEnumHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerEnumHelper", true);
}

const TypeIdentifier* GetMapLongLongInnerBitMaskHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerBitMaskHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongInnerBitMaskHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerBitMaskHelper", complete);
}

const TypeObject* GetMapLongLongInnerBitMaskHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerBitMaskHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongInnerBitMaskHelperObject();
    }
    //else
    return GetMinimalMapLongLongInnerBitMaskHelperObject();
}

const TypeObject* GetMinimalMapLongLongInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerBitMaskHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_innerbitmaskhelper;
    mst_var_map_longlong_innerbitmaskhelper.common().member_id(memberId++);
    mst_var_map_longlong_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "InnerBitMaskHelper", 100, false));


    MD5 var_map_longlong_innerbitmaskhelper_hash("var_map_longlong_innerbitmaskhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_innerbitmaskhelper.detail().name_hash()[i] = var_map_longlong_innerbitmaskhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_innerbitmaskhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerBitMaskHelper", false);
}

const TypeObject* GetCompleteMapLongLongInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerBitMaskHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_innerbitmaskhelper;
    cst_var_map_longlong_innerbitmaskhelper.common().member_id(memberId++);
    cst_var_map_longlong_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "InnerBitMaskHelper", 100, true));


    cst_var_map_longlong_innerbitmaskhelper.detail().name("var_map_longlong_innerbitmaskhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_innerbitmaskhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongInnerBitMaskHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerBitMaskHelper", true);
}

const TypeIdentifier* GetMapLongLongInnerAliasHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerAliasHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongInnerAliasHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerAliasHelper", complete);
}

const TypeObject* GetMapLongLongInnerAliasHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongInnerAliasHelperObject();
    }
    //else
    return GetMinimalMapLongLongInnerAliasHelperObject();
}

const TypeObject* GetMinimalMapLongLongInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_inneraliashelper;
    mst_var_map_longlong_inneraliashelper.common().member_id(memberId++);
    mst_var_map_longlong_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_inneraliashelper.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "InnerAliasHelper", 100, false));


    MD5 var_map_longlong_inneraliashelper_hash("var_map_longlong_inneraliashelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_inneraliashelper.detail().name_hash()[i] = var_map_longlong_inneraliashelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_inneraliashelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasHelper", false);
}

const TypeObject* GetCompleteMapLongLongInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_inneraliashelper;
    cst_var_map_longlong_inneraliashelper.common().member_id(memberId++);
    cst_var_map_longlong_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_inneraliashelper.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "InnerAliasHelper", 100, true));


    cst_var_map_longlong_inneraliashelper.detail().name("var_map_longlong_inneraliashelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_inneraliashelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongInnerAliasHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasHelper", true);
}

const TypeIdentifier* GetMapLongLongInnerAliasArrayHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerAliasArrayHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongInnerAliasArrayHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerAliasArrayHelper", complete);
}

const TypeObject* GetMapLongLongInnerAliasArrayHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasArrayHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongInnerAliasArrayHelperObject();
    }
    //else
    return GetMinimalMapLongLongInnerAliasArrayHelperObject();
}

const TypeObject* GetMinimalMapLongLongInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasArrayHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_inneraliasarrayhelper;
    mst_var_map_longlong_inneraliasarrayhelper.common().member_id(memberId++);
    mst_var_map_longlong_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "Inner_alias_array_helper", 100, false));


    MD5 var_map_longlong_inneraliasarrayhelper_hash("var_map_longlong_inneraliasarrayhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_inneraliasarrayhelper.detail().name_hash()[i] = var_map_longlong_inneraliasarrayhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_inneraliasarrayhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasArrayHelper", false);
}

const TypeObject* GetCompleteMapLongLongInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasArrayHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_inneraliasarrayhelper;
    cst_var_map_longlong_inneraliasarrayhelper.common().member_id(memberId++);
    cst_var_map_longlong_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "Inner_alias_array_helper", 100, true));


    cst_var_map_longlong_inneraliasarrayhelper.detail().name("var_map_longlong_inneraliasarrayhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_inneraliasarrayhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongInnerAliasArrayHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasArrayHelper", true);
}

const TypeIdentifier* GetMapLongLongInnerAliasSequenceHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerAliasSequenceHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongInnerAliasSequenceHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerAliasSequenceHelper", complete);
}

const TypeObject* GetMapLongLongInnerAliasSequenceHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasSequenceHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongInnerAliasSequenceHelperObject();
    }
    //else
    return GetMinimalMapLongLongInnerAliasSequenceHelperObject();
}

const TypeObject* GetMinimalMapLongLongInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasSequenceHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_inneraliassequencehelper;
    mst_var_map_longlong_inneraliassequencehelper.common().member_id(memberId++);
    mst_var_map_longlong_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "Inner_alias_sequence_helper", 100, false));


    MD5 var_map_longlong_inneraliassequencehelper_hash("var_map_longlong_inneraliassequencehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_inneraliassequencehelper.detail().name_hash()[i] = var_map_longlong_inneraliassequencehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_inneraliassequencehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasSequenceHelper", false);
}

const TypeObject* GetCompleteMapLongLongInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasSequenceHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_inneraliassequencehelper;
    cst_var_map_longlong_inneraliassequencehelper.common().member_id(memberId++);
    cst_var_map_longlong_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "Inner_alias_sequence_helper", 100, true));


    cst_var_map_longlong_inneraliassequencehelper.detail().name("var_map_longlong_inneraliassequencehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_inneraliassequencehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongInnerAliasSequenceHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasSequenceHelper", true);
}

const TypeIdentifier* GetMapLongLongInnerAliasMapHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerAliasMapHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongInnerAliasMapHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerAliasMapHelper", complete);
}

const TypeObject* GetMapLongLongInnerAliasMapHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasMapHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongInnerAliasMapHelperObject();
    }
    //else
    return GetMinimalMapLongLongInnerAliasMapHelperObject();
}

const TypeObject* GetMinimalMapLongLongInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasMapHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_inneraliasmaphelper;
    mst_var_map_longlong_inneraliasmaphelper.common().member_id(memberId++);
    mst_var_map_longlong_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "Inner_alias_map_helper", 100, false));


    MD5 var_map_longlong_inneraliasmaphelper_hash("var_map_longlong_inneraliasmaphelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_inneraliasmaphelper.detail().name_hash()[i] = var_map_longlong_inneraliasmaphelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_inneraliasmaphelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasMapHelper", false);
}

const TypeObject* GetCompleteMapLongLongInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasMapHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_inneraliasmaphelper;
    cst_var_map_longlong_inneraliasmaphelper.common().member_id(memberId++);
    cst_var_map_longlong_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "Inner_alias_map_helper", 100, true));


    cst_var_map_longlong_inneraliasmaphelper.detail().name("var_map_longlong_inneraliasmaphelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_inneraliasmaphelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongInnerAliasMapHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerAliasMapHelper", true);
}

const TypeIdentifier* GetMapLongLongInnerUnionHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerUnionHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongInnerUnionHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerUnionHelper", complete);
}

const TypeObject* GetMapLongLongInnerUnionHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerUnionHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongInnerUnionHelperObject();
    }
    //else
    return GetMinimalMapLongLongInnerUnionHelperObject();
}

const TypeObject* GetMinimalMapLongLongInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerUnionHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_innerunionhelper;
    mst_var_map_longlong_innerunionhelper.common().member_id(memberId++);
    mst_var_map_longlong_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_innerunionhelper.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "InnerUnionHelper", 100, false));


    MD5 var_map_longlong_innerunionhelper_hash("var_map_longlong_innerunionhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_innerunionhelper.detail().name_hash()[i] = var_map_longlong_innerunionhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_innerunionhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerUnionHelper", false);
}

const TypeObject* GetCompleteMapLongLongInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerUnionHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_innerunionhelper;
    cst_var_map_longlong_innerunionhelper.common().member_id(memberId++);
    cst_var_map_longlong_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_innerunionhelper.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "InnerUnionHelper", 100, true));


    cst_var_map_longlong_innerunionhelper.detail().name("var_map_longlong_innerunionhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_innerunionhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongInnerUnionHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerUnionHelper", true);
}

const TypeIdentifier* GetMapLongLongInnerStructureHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerStructureHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongInnerStructureHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerStructureHelper", complete);
}

const TypeObject* GetMapLongLongInnerStructureHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerStructureHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongInnerStructureHelperObject();
    }
    //else
    return GetMinimalMapLongLongInnerStructureHelperObject();
}

const TypeObject* GetMinimalMapLongLongInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerStructureHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_innerstructurehelper;
    mst_var_map_longlong_innerstructurehelper.common().member_id(memberId++);
    mst_var_map_longlong_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_innerstructurehelper.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "InnerStructureHelper", 100, false));


    MD5 var_map_longlong_innerstructurehelper_hash("var_map_longlong_innerstructurehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_innerstructurehelper.detail().name_hash()[i] = var_map_longlong_innerstructurehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_innerstructurehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerStructureHelper", false);
}

const TypeObject* GetCompleteMapLongLongInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerStructureHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_innerstructurehelper;
    cst_var_map_longlong_innerstructurehelper.common().member_id(memberId++);
    cst_var_map_longlong_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_innerstructurehelper.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "InnerStructureHelper", 100, true));


    cst_var_map_longlong_innerstructurehelper.detail().name("var_map_longlong_innerstructurehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_innerstructurehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongInnerStructureHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerStructureHelper", true);
}

const TypeIdentifier* GetMapLongLongInnerBitsetHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerBitsetHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapLongLongInnerBitsetHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapLongLongInnerBitsetHelper", complete);
}

const TypeObject* GetMapLongLongInnerBitsetHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerBitsetHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapLongLongInnerBitsetHelperObject();
    }
    //else
    return GetMinimalMapLongLongInnerBitsetHelperObject();
}

const TypeObject* GetMinimalMapLongLongInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerBitsetHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_longlong_innerbitsethelper;
    mst_var_map_longlong_innerbitsethelper.common().member_id(memberId++);
    mst_var_map_longlong_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_longlong_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_longlong_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_longlong_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_longlong_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_longlong_innerbitsethelper.common().member_flags().IS_KEY(false);
    mst_var_map_longlong_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_longlong_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "InnerBitsetHelper", 100, false));


    MD5 var_map_longlong_innerbitsethelper_hash("var_map_longlong_innerbitsethelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_longlong_innerbitsethelper.detail().name_hash()[i] = var_map_longlong_innerbitsethelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_longlong_innerbitsethelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerBitsetHelper", false);
}

const TypeObject* GetCompleteMapLongLongInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerBitsetHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_longlong_innerbitsethelper;
    cst_var_map_longlong_innerbitsethelper.common().member_id(memberId++);
    cst_var_map_longlong_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_longlong_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_longlong_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_longlong_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_longlong_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_longlong_innerbitsethelper.common().member_flags().IS_KEY(false);
    cst_var_map_longlong_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_longlong_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int64_t", "InnerBitsetHelper", 100, true));


    cst_var_map_longlong_innerbitsethelper.detail().name("var_map_longlong_innerbitsethelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_longlong_innerbitsethelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapLongLongInnerBitsetHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapLongLongInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapLongLongInnerBitsetHelper", true);
}

const TypeIdentifier* GetMapULongLongShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongShort", complete);
}

const TypeObject* GetMapULongLongShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongShortObject();
    }
    //else
    return GetMinimalMapULongLongShortObject();
}

const TypeObject* GetMinimalMapULongLongShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_short;
    mst_var_map_u_long_long_short.common().member_id(memberId++);
    mst_var_map_u_long_long_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_short.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "int16_t", 100, false));


    MD5 var_map_u_long_long_short_hash("var_map_u_long_long_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_short.detail().name_hash()[i] = var_map_u_long_long_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongShort", false);
}

const TypeObject* GetCompleteMapULongLongShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_short;
    cst_var_map_u_long_long_short.common().member_id(memberId++);
    cst_var_map_u_long_long_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_short.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "int16_t", 100, true));


    cst_var_map_u_long_long_short.detail().name("var_map_u_long_long_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongShort", true);
}

const TypeIdentifier* GetMapULongLongUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongUShort", complete);
}

const TypeObject* GetMapULongLongUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongUShortObject();
    }
    //else
    return GetMinimalMapULongLongUShortObject();
}

const TypeObject* GetMinimalMapULongLongUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_u_short;
    mst_var_map_u_long_long_u_short.common().member_id(memberId++);
    mst_var_map_u_long_long_u_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_u_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_u_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_u_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_u_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_u_short.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_u_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_u_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "uint16_t", 100, false));


    MD5 var_map_u_long_long_u_short_hash("var_map_u_long_long_u_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_u_short.detail().name_hash()[i] = var_map_u_long_long_u_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_u_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongUShort", false);
}

const TypeObject* GetCompleteMapULongLongUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_u_short;
    cst_var_map_u_long_long_u_short.common().member_id(memberId++);
    cst_var_map_u_long_long_u_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_u_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_u_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_u_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_u_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_u_short.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_u_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_u_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "uint16_t", 100, true));


    cst_var_map_u_long_long_u_short.detail().name("var_map_u_long_long_u_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_u_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongUShort", true);
}

const TypeIdentifier* GetMapULongLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongLong", complete);
}

const TypeObject* GetMapULongLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongLongObject();
    }
    //else
    return GetMinimalMapULongLongLongObject();
}

const TypeObject* GetMinimalMapULongLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_long;
    mst_var_map_u_long_long_long.common().member_id(memberId++);
    mst_var_map_u_long_long_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_long.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "int32_t", 100, false));


    MD5 var_map_u_long_long_long_hash("var_map_u_long_long_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_long.detail().name_hash()[i] = var_map_u_long_long_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongLong", false);
}

const TypeObject* GetCompleteMapULongLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_long;
    cst_var_map_u_long_long_long.common().member_id(memberId++);
    cst_var_map_u_long_long_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_long.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "int32_t", 100, true));


    cst_var_map_u_long_long_long.detail().name("var_map_u_long_long_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongLong", true);
}

const TypeIdentifier* GetMapULongLongULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongULong", complete);
}

const TypeObject* GetMapULongLongULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongULongObject();
    }
    //else
    return GetMinimalMapULongLongULongObject();
}

const TypeObject* GetMinimalMapULongLongULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_u_long;
    mst_var_map_u_long_long_u_long.common().member_id(memberId++);
    mst_var_map_u_long_long_u_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_u_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_u_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_u_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_u_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_u_long.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_u_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_u_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "uint32_t", 100, false));


    MD5 var_map_u_long_long_u_long_hash("var_map_u_long_long_u_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_u_long.detail().name_hash()[i] = var_map_u_long_long_u_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_u_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongULong", false);
}

const TypeObject* GetCompleteMapULongLongULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_u_long;
    cst_var_map_u_long_long_u_long.common().member_id(memberId++);
    cst_var_map_u_long_long_u_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_u_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_u_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_u_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_u_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_u_long.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_u_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_u_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "uint32_t", 100, true));


    cst_var_map_u_long_long_u_long.detail().name("var_map_u_long_long_u_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_u_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongULong", true);
}

const TypeIdentifier* GetMapULongLongLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongLongLong", complete);
}

const TypeObject* GetMapULongLongLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongLongLongObject();
    }
    //else
    return GetMinimalMapULongLongLongLongObject();
}

const TypeObject* GetMinimalMapULongLongLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_long_long;
    mst_var_map_u_long_long_long_long.common().member_id(memberId++);
    mst_var_map_u_long_long_long_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_long_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_long_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_long_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_long_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_long_long.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_long_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_long_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "int64_t", 100, false));


    MD5 var_map_u_long_long_long_long_hash("var_map_u_long_long_long_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_long_long.detail().name_hash()[i] = var_map_u_long_long_long_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_long_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongLongLong", false);
}

const TypeObject* GetCompleteMapULongLongLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_long_long;
    cst_var_map_u_long_long_long_long.common().member_id(memberId++);
    cst_var_map_u_long_long_long_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_long_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_long_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_long_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_long_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_long_long.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_long_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_long_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "int64_t", 100, true));


    cst_var_map_u_long_long_long_long.detail().name("var_map_u_long_long_long_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_long_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongLongLong", true);
}

const TypeIdentifier* GetMapULongLongULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongULongLong", complete);
}

const TypeObject* GetMapULongLongULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongULongLongObject();
    }
    //else
    return GetMinimalMapULongLongULongLongObject();
}

const TypeObject* GetMinimalMapULongLongULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_u_long_long;
    mst_var_map_u_long_long_u_long_long.common().member_id(memberId++);
    mst_var_map_u_long_long_u_long_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_u_long_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_u_long_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_u_long_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_u_long_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_u_long_long.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_u_long_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_u_long_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "uint64_t", 100, false));


    MD5 var_map_u_long_long_u_long_long_hash("var_map_u_long_long_u_long_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_u_long_long.detail().name_hash()[i] = var_map_u_long_long_u_long_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_u_long_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongULongLong", false);
}

const TypeObject* GetCompleteMapULongLongULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_u_long_long;
    cst_var_map_u_long_long_u_long_long.common().member_id(memberId++);
    cst_var_map_u_long_long_u_long_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_u_long_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_u_long_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_u_long_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_u_long_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_u_long_long.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_u_long_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_u_long_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "uint64_t", 100, true));


    cst_var_map_u_long_long_u_long_long.detail().name("var_map_u_long_long_u_long_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_u_long_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongULongLong", true);
}

const TypeIdentifier* GetMapULongLongFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongFloat", complete);
}

const TypeObject* GetMapULongLongFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongFloatObject();
    }
    //else
    return GetMinimalMapULongLongFloatObject();
}

const TypeObject* GetMinimalMapULongLongFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_float;
    mst_var_map_u_long_long_float.common().member_id(memberId++);
    mst_var_map_u_long_long_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_float.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "float", 100, false));


    MD5 var_map_u_long_long_float_hash("var_map_u_long_long_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_float.detail().name_hash()[i] = var_map_u_long_long_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongFloat", false);
}

const TypeObject* GetCompleteMapULongLongFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_float;
    cst_var_map_u_long_long_float.common().member_id(memberId++);
    cst_var_map_u_long_long_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_float.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "float", 100, true));


    cst_var_map_u_long_long_float.detail().name("var_map_u_long_long_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongFloat", true);
}

const TypeIdentifier* GetMapKeyULongLongValueDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapKeyULongLongValueDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapKeyULongLongValueDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapKeyULongLongValueDouble", complete);
}

const TypeObject* GetMapKeyULongLongValueDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapKeyULongLongValueDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapKeyULongLongValueDoubleObject();
    }
    //else
    return GetMinimalMapKeyULongLongValueDoubleObject();
}

const TypeObject* GetMinimalMapKeyULongLongValueDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapKeyULongLongValueDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_double;
    mst_var_map_u_long_long_double.common().member_id(memberId++);
    mst_var_map_u_long_long_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_double.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "double", 100, false));


    MD5 var_map_u_long_long_double_hash("var_map_u_long_long_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_double.detail().name_hash()[i] = var_map_u_long_long_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapKeyULongLongValueDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapKeyULongLongValueDouble", false);
}

const TypeObject* GetCompleteMapKeyULongLongValueDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapKeyULongLongValueDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_double;
    cst_var_map_u_long_long_double.common().member_id(memberId++);
    cst_var_map_u_long_long_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_double.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "double", 100, true));


    cst_var_map_u_long_long_double.detail().name("var_map_u_long_long_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapKeyULongLongValueDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapKeyULongLongValueDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapKeyULongLongValueDouble", true);
}

const TypeIdentifier* GetMapULongLongLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongLongDouble", complete);
}

const TypeObject* GetMapULongLongLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongLongDoubleObject();
    }
    //else
    return GetMinimalMapULongLongLongDoubleObject();
}

const TypeObject* GetMinimalMapULongLongLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_long_double;
    mst_var_map_u_long_long_long_double.common().member_id(memberId++);
    mst_var_map_u_long_long_long_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_long_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_long_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_long_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_long_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_long_double.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_long_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_long_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "longdouble", 100, false));


    MD5 var_map_u_long_long_long_double_hash("var_map_u_long_long_long_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_long_double.detail().name_hash()[i] = var_map_u_long_long_long_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_long_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongLongDouble", false);
}

const TypeObject* GetCompleteMapULongLongLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_long_double;
    cst_var_map_u_long_long_long_double.common().member_id(memberId++);
    cst_var_map_u_long_long_long_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_long_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_long_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_long_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_long_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_long_double.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_long_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_long_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "longdouble", 100, true));


    cst_var_map_u_long_long_long_double.detail().name("var_map_u_long_long_long_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_long_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongLongDouble", true);
}

const TypeIdentifier* GetMapULongLongBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongBoolean", complete);
}

const TypeObject* GetMapULongLongBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongBooleanObject();
    }
    //else
    return GetMinimalMapULongLongBooleanObject();
}

const TypeObject* GetMinimalMapULongLongBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_boolean;
    mst_var_map_u_long_long_boolean.common().member_id(memberId++);
    mst_var_map_u_long_long_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_boolean.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "bool", 100, false));


    MD5 var_map_u_long_long_boolean_hash("var_map_u_long_long_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_boolean.detail().name_hash()[i] = var_map_u_long_long_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongBoolean", false);
}

const TypeObject* GetCompleteMapULongLongBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_boolean;
    cst_var_map_u_long_long_boolean.common().member_id(memberId++);
    cst_var_map_u_long_long_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_boolean.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "bool", 100, true));


    cst_var_map_u_long_long_boolean.detail().name("var_map_u_long_long_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongBoolean", true);
}

const TypeIdentifier* GetMapULongLongOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongOctet", complete);
}

const TypeObject* GetMapULongLongOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongOctetObject();
    }
    //else
    return GetMinimalMapULongLongOctetObject();
}

const TypeObject* GetMinimalMapULongLongOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_octet;
    mst_var_map_u_long_long_octet.common().member_id(memberId++);
    mst_var_map_u_long_long_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_octet.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "uint8_t", 100, false));


    MD5 var_map_u_long_long_octet_hash("var_map_u_long_long_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_octet.detail().name_hash()[i] = var_map_u_long_long_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongOctet", false);
}

const TypeObject* GetCompleteMapULongLongOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_octet;
    cst_var_map_u_long_long_octet.common().member_id(memberId++);
    cst_var_map_u_long_long_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_octet.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "uint8_t", 100, true));


    cst_var_map_u_long_long_octet.detail().name("var_map_u_long_long_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongOctet", true);
}

const TypeIdentifier* GetMapULongLongCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongChar", complete);
}

const TypeObject* GetMapULongLongCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongCharObject();
    }
    //else
    return GetMinimalMapULongLongCharObject();
}

const TypeObject* GetMinimalMapULongLongCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_char;
    mst_var_map_u_long_long_char.common().member_id(memberId++);
    mst_var_map_u_long_long_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_char.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "char", 100, false));


    MD5 var_map_u_long_long_char_hash("var_map_u_long_long_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_char.detail().name_hash()[i] = var_map_u_long_long_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongChar", false);
}

const TypeObject* GetCompleteMapULongLongCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_char;
    cst_var_map_u_long_long_char.common().member_id(memberId++);
    cst_var_map_u_long_long_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_char.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "char", 100, true));


    cst_var_map_u_long_long_char.detail().name("var_map_u_long_long_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongChar", true);
}

const TypeIdentifier* GetMapULongLongWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongWChar", complete);
}

const TypeObject* GetMapULongLongWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongWCharObject();
    }
    //else
    return GetMinimalMapULongLongWCharObject();
}

const TypeObject* GetMinimalMapULongLongWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_wchar;
    mst_var_map_u_long_long_wchar.common().member_id(memberId++);
    mst_var_map_u_long_long_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_wchar.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "wchar_t", 100, false));


    MD5 var_map_u_long_long_wchar_hash("var_map_u_long_long_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_wchar.detail().name_hash()[i] = var_map_u_long_long_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongWChar", false);
}

const TypeObject* GetCompleteMapULongLongWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_wchar;
    cst_var_map_u_long_long_wchar.common().member_id(memberId++);
    cst_var_map_u_long_long_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_wchar.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "wchar_t", 100, true));


    cst_var_map_u_long_long_wchar.detail().name("var_map_u_long_long_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongWChar", true);
}

const TypeIdentifier* GetMapULongLongStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongString", complete);
}

const TypeObject* GetMapULongLongStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongStringObject();
    }
    //else
    return GetMinimalMapULongLongStringObject();
}

const TypeObject* GetMinimalMapULongLongStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_string;
    mst_var_map_u_long_long_string.common().member_id(memberId++);
    mst_var_map_u_long_long_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_string.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", TypeNamesGenerator::get_string_type_name(255, false), 100, false));


    MD5 var_map_u_long_long_string_hash("var_map_u_long_long_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_string.detail().name_hash()[i] = var_map_u_long_long_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongString", false);
}

const TypeObject* GetCompleteMapULongLongStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_string;
    cst_var_map_u_long_long_string.common().member_id(memberId++);
    cst_var_map_u_long_long_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_string.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", TypeNamesGenerator::get_string_type_name(255, false), 100, true));


    cst_var_map_u_long_long_string.detail().name("var_map_u_long_long_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongString", true);
}

const TypeIdentifier* GetMapULongLongWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongWString", complete);
}

const TypeObject* GetMapULongLongWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongWStringObject();
    }
    //else
    return GetMinimalMapULongLongWStringObject();
}

const TypeObject* GetMinimalMapULongLongWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_wstring;
    mst_var_map_u_long_long_wstring.common().member_id(memberId++);
    mst_var_map_u_long_long_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_wstring.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", TypeNamesGenerator::get_string_type_name(255, true), 100, false));


    MD5 var_map_u_long_long_wstring_hash("var_map_u_long_long_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_wstring.detail().name_hash()[i] = var_map_u_long_long_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongWString", false);
}

const TypeObject* GetCompleteMapULongLongWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_wstring;
    cst_var_map_u_long_long_wstring.common().member_id(memberId++);
    cst_var_map_u_long_long_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_wstring.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", TypeNamesGenerator::get_string_type_name(255, true), 100, true));


    cst_var_map_u_long_long_wstring.detail().name("var_map_u_long_long_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongWString", true);
}

const TypeIdentifier* GetMapULongLongInnerAliasBoundedStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerAliasBoundedStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongInnerAliasBoundedStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerAliasBoundedStringHelper", complete);
}

const TypeObject* GetMapULongLongInnerAliasBoundedStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasBoundedStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongInnerAliasBoundedStringHelperObject();
    }
    //else
    return GetMinimalMapULongLongInnerAliasBoundedStringHelperObject();
}

const TypeObject* GetMinimalMapULongLongInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasBoundedStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_inner_alias_bounded_string_helper;
    mst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_id(memberId++);
    mst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "Inner_alias_bounded_string_helper", 100, false));


    MD5 var_map_u_long_long_inner_alias_bounded_string_helper_hash("var_map_u_long_long_inner_alias_bounded_string_helper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_inner_alias_bounded_string_helper.detail().name_hash()[i] = var_map_u_long_long_inner_alias_bounded_string_helper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_inner_alias_bounded_string_helper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasBoundedStringHelper", false);
}

const TypeObject* GetCompleteMapULongLongInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasBoundedStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_inner_alias_bounded_string_helper;
    cst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_id(memberId++);
    cst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_inner_alias_bounded_string_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "Inner_alias_bounded_string_helper", 100, true));


    cst_var_map_u_long_long_inner_alias_bounded_string_helper.detail().name("var_map_u_long_long_inner_alias_bounded_string_helper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_inner_alias_bounded_string_helper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongInnerAliasBoundedStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasBoundedStringHelper", true);
}

const TypeIdentifier* GetMapULongLongInnerAliasBoundedWStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerAliasBoundedWStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongInnerAliasBoundedWStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerAliasBoundedWStringHelper", complete);
}

const TypeObject* GetMapULongLongInnerAliasBoundedWStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasBoundedWStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongInnerAliasBoundedWStringHelperObject();
    }
    //else
    return GetMinimalMapULongLongInnerAliasBoundedWStringHelperObject();
}

const TypeObject* GetMinimalMapULongLongInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasBoundedWStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_inner_alias_bounded_wstring_helper;
    mst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_id(memberId++);
    mst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "Inner_alias_bounded_wstring_helper", 100, false));


    MD5 var_map_u_long_long_inner_alias_bounded_wstring_helper_hash("var_map_u_long_long_inner_alias_bounded_wstring_helper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_inner_alias_bounded_wstring_helper.detail().name_hash()[i] = var_map_u_long_long_inner_alias_bounded_wstring_helper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_inner_alias_bounded_wstring_helper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasBoundedWStringHelper", false);
}

const TypeObject* GetCompleteMapULongLongInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasBoundedWStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_inner_alias_bounded_wstring_helper;
    cst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_id(memberId++);
    cst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_inner_alias_bounded_wstring_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "Inner_alias_bounded_wstring_helper", 100, true));


    cst_var_map_u_long_long_inner_alias_bounded_wstring_helper.detail().name("var_map_u_long_long_inner_alias_bounded_wstring_helper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_inner_alias_bounded_wstring_helper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongInnerAliasBoundedWStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasBoundedWStringHelper", true);
}

const TypeIdentifier* GetMapULongLongInnerEnumHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerEnumHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongInnerEnumHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerEnumHelper", complete);
}

const TypeObject* GetMapULongLongInnerEnumHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerEnumHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongInnerEnumHelperObject();
    }
    //else
    return GetMinimalMapULongLongInnerEnumHelperObject();
}

const TypeObject* GetMinimalMapULongLongInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerEnumHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_inner_enum_helper;
    mst_var_map_u_long_long_inner_enum_helper.common().member_id(memberId++);
    mst_var_map_u_long_long_inner_enum_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_inner_enum_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_inner_enum_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_inner_enum_helper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_inner_enum_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_inner_enum_helper.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_inner_enum_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_inner_enum_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "InnerEnumHelper", 100, false));


    MD5 var_map_u_long_long_inner_enum_helper_hash("var_map_u_long_long_inner_enum_helper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_inner_enum_helper.detail().name_hash()[i] = var_map_u_long_long_inner_enum_helper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_inner_enum_helper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerEnumHelper", false);
}

const TypeObject* GetCompleteMapULongLongInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerEnumHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_inner_enum_helper;
    cst_var_map_u_long_long_inner_enum_helper.common().member_id(memberId++);
    cst_var_map_u_long_long_inner_enum_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_inner_enum_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_inner_enum_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_inner_enum_helper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_inner_enum_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_inner_enum_helper.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_inner_enum_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_inner_enum_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "InnerEnumHelper", 100, true));


    cst_var_map_u_long_long_inner_enum_helper.detail().name("var_map_u_long_long_inner_enum_helper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_inner_enum_helper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongInnerEnumHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerEnumHelper", true);
}

const TypeIdentifier* GetMapULongLongInnerBitMaskHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerBitMaskHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongInnerBitMaskHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerBitMaskHelper", complete);
}

const TypeObject* GetMapULongLongInnerBitMaskHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerBitMaskHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongInnerBitMaskHelperObject();
    }
    //else
    return GetMinimalMapULongLongInnerBitMaskHelperObject();
}

const TypeObject* GetMinimalMapULongLongInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerBitMaskHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_inner_bit_mask_helper;
    mst_var_map_u_long_long_inner_bit_mask_helper.common().member_id(memberId++);
    mst_var_map_u_long_long_inner_bit_mask_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_inner_bit_mask_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_inner_bit_mask_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_inner_bit_mask_helper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_inner_bit_mask_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_inner_bit_mask_helper.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_inner_bit_mask_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_inner_bit_mask_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "InnerBitMaskHelper", 100, false));


    MD5 var_map_u_long_long_inner_bit_mask_helper_hash("var_map_u_long_long_inner_bit_mask_helper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_inner_bit_mask_helper.detail().name_hash()[i] = var_map_u_long_long_inner_bit_mask_helper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_inner_bit_mask_helper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerBitMaskHelper", false);
}

const TypeObject* GetCompleteMapULongLongInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerBitMaskHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_inner_bit_mask_helper;
    cst_var_map_u_long_long_inner_bit_mask_helper.common().member_id(memberId++);
    cst_var_map_u_long_long_inner_bit_mask_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_inner_bit_mask_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_inner_bit_mask_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_inner_bit_mask_helper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_inner_bit_mask_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_inner_bit_mask_helper.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_inner_bit_mask_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_inner_bit_mask_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "InnerBitMaskHelper", 100, true));


    cst_var_map_u_long_long_inner_bit_mask_helper.detail().name("var_map_u_long_long_inner_bit_mask_helper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_inner_bit_mask_helper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongInnerBitMaskHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerBitMaskHelper", true);
}

const TypeIdentifier* GetMapULongLongInnerAliasHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerAliasHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongInnerAliasHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerAliasHelper", complete);
}

const TypeObject* GetMapULongLongInnerAliasHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongInnerAliasHelperObject();
    }
    //else
    return GetMinimalMapULongLongInnerAliasHelperObject();
}

const TypeObject* GetMinimalMapULongLongInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_inner_alias_helper;
    mst_var_map_u_long_long_inner_alias_helper.common().member_id(memberId++);
    mst_var_map_u_long_long_inner_alias_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_helper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_inner_alias_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_inner_alias_helper.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_inner_alias_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_inner_alias_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "InnerAliasHelper", 100, false));


    MD5 var_map_u_long_long_inner_alias_helper_hash("var_map_u_long_long_inner_alias_helper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_inner_alias_helper.detail().name_hash()[i] = var_map_u_long_long_inner_alias_helper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_inner_alias_helper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasHelper", false);
}

const TypeObject* GetCompleteMapULongLongInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_inner_alias_helper;
    cst_var_map_u_long_long_inner_alias_helper.common().member_id(memberId++);
    cst_var_map_u_long_long_inner_alias_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_helper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_inner_alias_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_inner_alias_helper.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_inner_alias_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_inner_alias_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "InnerAliasHelper", 100, true));


    cst_var_map_u_long_long_inner_alias_helper.detail().name("var_map_u_long_long_inner_alias_helper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_inner_alias_helper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongInnerAliasHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasHelper", true);
}

const TypeIdentifier* GetMapULongLongInnerAliasArrayHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerAliasArrayHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongInnerAliasArrayHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerAliasArrayHelper", complete);
}

const TypeObject* GetMapULongLongInnerAliasArrayHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasArrayHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongInnerAliasArrayHelperObject();
    }
    //else
    return GetMinimalMapULongLongInnerAliasArrayHelperObject();
}

const TypeObject* GetMinimalMapULongLongInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasArrayHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_inner_alias_array_helper;
    mst_var_map_u_long_long_inner_alias_array_helper.common().member_id(memberId++);
    mst_var_map_u_long_long_inner_alias_array_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_array_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_array_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_array_helper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_inner_alias_array_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_inner_alias_array_helper.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_inner_alias_array_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_inner_alias_array_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "Inner_alias_array_helper", 100, false));


    MD5 var_map_u_long_long_inner_alias_array_helper_hash("var_map_u_long_long_inner_alias_array_helper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_inner_alias_array_helper.detail().name_hash()[i] = var_map_u_long_long_inner_alias_array_helper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_inner_alias_array_helper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasArrayHelper", false);
}

const TypeObject* GetCompleteMapULongLongInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasArrayHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_inner_alias_array_helper;
    cst_var_map_u_long_long_inner_alias_array_helper.common().member_id(memberId++);
    cst_var_map_u_long_long_inner_alias_array_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_array_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_array_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_array_helper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_inner_alias_array_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_inner_alias_array_helper.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_inner_alias_array_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_inner_alias_array_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "Inner_alias_array_helper", 100, true));


    cst_var_map_u_long_long_inner_alias_array_helper.detail().name("var_map_u_long_long_inner_alias_array_helper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_inner_alias_array_helper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongInnerAliasArrayHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasArrayHelper", true);
}

const TypeIdentifier* GetMapULongLongInnerAliasSequenceHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerAliasSequenceHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongInnerAliasSequenceHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerAliasSequenceHelper", complete);
}

const TypeObject* GetMapULongLongInnerAliasSequenceHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasSequenceHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongInnerAliasSequenceHelperObject();
    }
    //else
    return GetMinimalMapULongLongInnerAliasSequenceHelperObject();
}

const TypeObject* GetMinimalMapULongLongInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasSequenceHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_inner_alias_sequence_helper;
    mst_var_map_u_long_long_inner_alias_sequence_helper.common().member_id(memberId++);
    mst_var_map_u_long_long_inner_alias_sequence_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_sequence_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_sequence_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_sequence_helper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_inner_alias_sequence_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_inner_alias_sequence_helper.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_inner_alias_sequence_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_inner_alias_sequence_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "Inner_alias_sequence_helper", 100, false));


    MD5 var_map_u_long_long_inner_alias_sequence_helper_hash("var_map_u_long_long_inner_alias_sequence_helper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_inner_alias_sequence_helper.detail().name_hash()[i] = var_map_u_long_long_inner_alias_sequence_helper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_inner_alias_sequence_helper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasSequenceHelper", false);
}

const TypeObject* GetCompleteMapULongLongInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasSequenceHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_inner_alias_sequence_helper;
    cst_var_map_u_long_long_inner_alias_sequence_helper.common().member_id(memberId++);
    cst_var_map_u_long_long_inner_alias_sequence_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_sequence_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_sequence_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_sequence_helper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_inner_alias_sequence_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_inner_alias_sequence_helper.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_inner_alias_sequence_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_inner_alias_sequence_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "Inner_alias_sequence_helper", 100, true));


    cst_var_map_u_long_long_inner_alias_sequence_helper.detail().name("var_map_u_long_long_inner_alias_sequence_helper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_inner_alias_sequence_helper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongInnerAliasSequenceHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasSequenceHelper", true);
}

const TypeIdentifier* GetMapULongLongInnerAliasMapHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerAliasMapHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongInnerAliasMapHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerAliasMapHelper", complete);
}

const TypeObject* GetMapULongLongInnerAliasMapHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasMapHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongInnerAliasMapHelperObject();
    }
    //else
    return GetMinimalMapULongLongInnerAliasMapHelperObject();
}

const TypeObject* GetMinimalMapULongLongInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasMapHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_inner_alias_map_helper;
    mst_var_map_u_long_long_inner_alias_map_helper.common().member_id(memberId++);
    mst_var_map_u_long_long_inner_alias_map_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_map_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_map_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_inner_alias_map_helper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_inner_alias_map_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_inner_alias_map_helper.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_inner_alias_map_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_inner_alias_map_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "Inner_alias_map_helper", 100, false));


    MD5 var_map_u_long_long_inner_alias_map_helper_hash("var_map_u_long_long_inner_alias_map_helper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_inner_alias_map_helper.detail().name_hash()[i] = var_map_u_long_long_inner_alias_map_helper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_inner_alias_map_helper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasMapHelper", false);
}

const TypeObject* GetCompleteMapULongLongInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasMapHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_inner_alias_map_helper;
    cst_var_map_u_long_long_inner_alias_map_helper.common().member_id(memberId++);
    cst_var_map_u_long_long_inner_alias_map_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_map_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_map_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_inner_alias_map_helper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_inner_alias_map_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_inner_alias_map_helper.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_inner_alias_map_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_inner_alias_map_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "Inner_alias_map_helper", 100, true));


    cst_var_map_u_long_long_inner_alias_map_helper.detail().name("var_map_u_long_long_inner_alias_map_helper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_inner_alias_map_helper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongInnerAliasMapHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerAliasMapHelper", true);
}

const TypeIdentifier* GetMapULongLongInnerUnionHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerUnionHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongInnerUnionHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerUnionHelper", complete);
}

const TypeObject* GetMapULongLongInnerUnionHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerUnionHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongInnerUnionHelperObject();
    }
    //else
    return GetMinimalMapULongLongInnerUnionHelperObject();
}

const TypeObject* GetMinimalMapULongLongInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerUnionHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_inner_union_helper;
    mst_var_map_u_long_long_inner_union_helper.common().member_id(memberId++);
    mst_var_map_u_long_long_inner_union_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_inner_union_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_inner_union_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_inner_union_helper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_inner_union_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_inner_union_helper.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_inner_union_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_inner_union_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "InnerUnionHelper", 100, false));


    MD5 var_map_u_long_long_inner_union_helper_hash("var_map_u_long_long_inner_union_helper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_inner_union_helper.detail().name_hash()[i] = var_map_u_long_long_inner_union_helper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_inner_union_helper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerUnionHelper", false);
}

const TypeObject* GetCompleteMapULongLongInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerUnionHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_inner_union_helper;
    cst_var_map_u_long_long_inner_union_helper.common().member_id(memberId++);
    cst_var_map_u_long_long_inner_union_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_inner_union_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_inner_union_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_inner_union_helper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_inner_union_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_inner_union_helper.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_inner_union_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_inner_union_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "InnerUnionHelper", 100, true));


    cst_var_map_u_long_long_inner_union_helper.detail().name("var_map_u_long_long_inner_union_helper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_inner_union_helper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongInnerUnionHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerUnionHelper", true);
}

const TypeIdentifier* GetMapULongLongInnerStructureHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerStructureHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongInnerStructureHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerStructureHelper", complete);
}

const TypeObject* GetMapULongLongInnerStructureHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerStructureHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongInnerStructureHelperObject();
    }
    //else
    return GetMinimalMapULongLongInnerStructureHelperObject();
}

const TypeObject* GetMinimalMapULongLongInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerStructureHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_inner_structure_helper;
    mst_var_map_u_long_long_inner_structure_helper.common().member_id(memberId++);
    mst_var_map_u_long_long_inner_structure_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_inner_structure_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_inner_structure_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_inner_structure_helper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_inner_structure_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_inner_structure_helper.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_inner_structure_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_inner_structure_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "InnerStructureHelper", 100, false));


    MD5 var_map_u_long_long_inner_structure_helper_hash("var_map_u_long_long_inner_structure_helper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_inner_structure_helper.detail().name_hash()[i] = var_map_u_long_long_inner_structure_helper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_inner_structure_helper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerStructureHelper", false);
}

const TypeObject* GetCompleteMapULongLongInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerStructureHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_inner_structure_helper;
    cst_var_map_u_long_long_inner_structure_helper.common().member_id(memberId++);
    cst_var_map_u_long_long_inner_structure_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_inner_structure_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_inner_structure_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_inner_structure_helper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_inner_structure_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_inner_structure_helper.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_inner_structure_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_inner_structure_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "InnerStructureHelper", 100, true));


    cst_var_map_u_long_long_inner_structure_helper.detail().name("var_map_u_long_long_inner_structure_helper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_inner_structure_helper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongInnerStructureHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerStructureHelper", true);
}

const TypeIdentifier* GetMapULongLongInnerBitsetHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerBitsetHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapULongLongInnerBitsetHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapULongLongInnerBitsetHelper", complete);
}

const TypeObject* GetMapULongLongInnerBitsetHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerBitsetHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapULongLongInnerBitsetHelperObject();
    }
    //else
    return GetMinimalMapULongLongInnerBitsetHelperObject();
}

const TypeObject* GetMinimalMapULongLongInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerBitsetHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_u_long_long_inner_bitset_helper;
    mst_var_map_u_long_long_inner_bitset_helper.common().member_id(memberId++);
    mst_var_map_u_long_long_inner_bitset_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_u_long_long_inner_bitset_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_u_long_long_inner_bitset_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_u_long_long_inner_bitset_helper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_u_long_long_inner_bitset_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_u_long_long_inner_bitset_helper.common().member_flags().IS_KEY(false);
    mst_var_map_u_long_long_inner_bitset_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_u_long_long_inner_bitset_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "InnerBitsetHelper", 100, false));


    MD5 var_map_u_long_long_inner_bitset_helper_hash("var_map_u_long_long_inner_bitset_helper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_u_long_long_inner_bitset_helper.detail().name_hash()[i] = var_map_u_long_long_inner_bitset_helper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_u_long_long_inner_bitset_helper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerBitsetHelper", false);
}

const TypeObject* GetCompleteMapULongLongInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerBitsetHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_u_long_long_inner_bitset_helper;
    cst_var_map_u_long_long_inner_bitset_helper.common().member_id(memberId++);
    cst_var_map_u_long_long_inner_bitset_helper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_u_long_long_inner_bitset_helper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_u_long_long_inner_bitset_helper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_u_long_long_inner_bitset_helper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_u_long_long_inner_bitset_helper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_u_long_long_inner_bitset_helper.common().member_flags().IS_KEY(false);
    cst_var_map_u_long_long_inner_bitset_helper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_u_long_long_inner_bitset_helper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("uint64_t", "InnerBitsetHelper", 100, true));


    cst_var_map_u_long_long_inner_bitset_helper.detail().name("var_map_u_long_long_inner_bitset_helper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_u_long_long_inner_bitset_helper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapULongLongInnerBitsetHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapULongLongInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapULongLongInnerBitsetHelper", true);
}

const TypeIdentifier* GetMapStringShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringShort", complete);
}

const TypeObject* GetMapStringShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringShortObject();
    }
    //else
    return GetMinimalMapStringShortObject();
}

const TypeObject* GetMinimalMapStringShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_short;
    mst_var_map_string_short.common().member_id(memberId++);
    mst_var_map_string_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_short.common().member_flags().IS_KEY(false);
    mst_var_map_string_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "int16_t", 100, false));


    MD5 var_map_string_short_hash("var_map_string_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_short.detail().name_hash()[i] = var_map_string_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringShort", false);
}

const TypeObject* GetCompleteMapStringShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_short;
    cst_var_map_string_short.common().member_id(memberId++);
    cst_var_map_string_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_short.common().member_flags().IS_KEY(false);
    cst_var_map_string_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "int16_t", 100, true));


    cst_var_map_string_short.detail().name("var_map_string_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringShort", true);
}

const TypeIdentifier* GetMapStringUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringUShort", complete);
}

const TypeObject* GetMapStringUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringUShortObject();
    }
    //else
    return GetMinimalMapStringUShortObject();
}

const TypeObject* GetMinimalMapStringUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_ushort;
    mst_var_map_string_ushort.common().member_id(memberId++);
    mst_var_map_string_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_ushort.common().member_flags().IS_KEY(false);
    mst_var_map_string_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "uint16_t", 100, false));


    MD5 var_map_string_ushort_hash("var_map_string_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_ushort.detail().name_hash()[i] = var_map_string_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringUShort", false);
}

const TypeObject* GetCompleteMapStringUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_ushort;
    cst_var_map_string_ushort.common().member_id(memberId++);
    cst_var_map_string_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_ushort.common().member_flags().IS_KEY(false);
    cst_var_map_string_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "uint16_t", 100, true));


    cst_var_map_string_ushort.detail().name("var_map_string_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringUShort", true);
}

const TypeIdentifier* GetMapStringLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringLong", complete);
}

const TypeObject* GetMapStringLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringLongObject();
    }
    //else
    return GetMinimalMapStringLongObject();
}

const TypeObject* GetMinimalMapStringLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_long;
    mst_var_map_string_long.common().member_id(memberId++);
    mst_var_map_string_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_long.common().member_flags().IS_KEY(false);
    mst_var_map_string_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "int32_t", 100, false));


    MD5 var_map_string_long_hash("var_map_string_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_long.detail().name_hash()[i] = var_map_string_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringLong", false);
}

const TypeObject* GetCompleteMapStringLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_long;
    cst_var_map_string_long.common().member_id(memberId++);
    cst_var_map_string_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_long.common().member_flags().IS_KEY(false);
    cst_var_map_string_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "int32_t", 100, true));


    cst_var_map_string_long.detail().name("var_map_string_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringLong", true);
}

const TypeIdentifier* GetMapStringULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringULong", complete);
}

const TypeObject* GetMapStringULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringULongObject();
    }
    //else
    return GetMinimalMapStringULongObject();
}

const TypeObject* GetMinimalMapStringULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_ulong;
    mst_var_map_string_ulong.common().member_id(memberId++);
    mst_var_map_string_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_ulong.common().member_flags().IS_KEY(false);
    mst_var_map_string_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "uint32_t", 100, false));


    MD5 var_map_string_ulong_hash("var_map_string_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_ulong.detail().name_hash()[i] = var_map_string_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringULong", false);
}

const TypeObject* GetCompleteMapStringULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_ulong;
    cst_var_map_string_ulong.common().member_id(memberId++);
    cst_var_map_string_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_ulong.common().member_flags().IS_KEY(false);
    cst_var_map_string_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "uint32_t", 100, true));


    cst_var_map_string_ulong.detail().name("var_map_string_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringULong", true);
}

const TypeIdentifier* GetMapStringLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringLongLong", complete);
}

const TypeObject* GetMapStringLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringLongLongObject();
    }
    //else
    return GetMinimalMapStringLongLongObject();
}

const TypeObject* GetMinimalMapStringLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_longlong;
    mst_var_map_string_longlong.common().member_id(memberId++);
    mst_var_map_string_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_longlong.common().member_flags().IS_KEY(false);
    mst_var_map_string_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "int64_t", 100, false));


    MD5 var_map_string_longlong_hash("var_map_string_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_longlong.detail().name_hash()[i] = var_map_string_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringLongLong", false);
}

const TypeObject* GetCompleteMapStringLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_longlong;
    cst_var_map_string_longlong.common().member_id(memberId++);
    cst_var_map_string_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_longlong.common().member_flags().IS_KEY(false);
    cst_var_map_string_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "int64_t", 100, true));


    cst_var_map_string_longlong.detail().name("var_map_string_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringLongLong", true);
}

const TypeIdentifier* GetMapStringULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringULongLong", complete);
}

const TypeObject* GetMapStringULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringULongLongObject();
    }
    //else
    return GetMinimalMapStringULongLongObject();
}

const TypeObject* GetMinimalMapStringULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_ulonglong;
    mst_var_map_string_ulonglong.common().member_id(memberId++);
    mst_var_map_string_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_map_string_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "uint64_t", 100, false));


    MD5 var_map_string_ulonglong_hash("var_map_string_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_ulonglong.detail().name_hash()[i] = var_map_string_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringULongLong", false);
}

const TypeObject* GetCompleteMapStringULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_ulonglong;
    cst_var_map_string_ulonglong.common().member_id(memberId++);
    cst_var_map_string_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_map_string_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "uint64_t", 100, true));


    cst_var_map_string_ulonglong.detail().name("var_map_string_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringULongLong", true);
}

const TypeIdentifier* GetMapStringFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringFloat", complete);
}

const TypeObject* GetMapStringFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringFloatObject();
    }
    //else
    return GetMinimalMapStringFloatObject();
}

const TypeObject* GetMinimalMapStringFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_float;
    mst_var_map_string_float.common().member_id(memberId++);
    mst_var_map_string_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_float.common().member_flags().IS_KEY(false);
    mst_var_map_string_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "float", 100, false));


    MD5 var_map_string_float_hash("var_map_string_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_float.detail().name_hash()[i] = var_map_string_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringFloat", false);
}

const TypeObject* GetCompleteMapStringFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_float;
    cst_var_map_string_float.common().member_id(memberId++);
    cst_var_map_string_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_float.common().member_flags().IS_KEY(false);
    cst_var_map_string_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "float", 100, true));


    cst_var_map_string_float.detail().name("var_map_string_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringFloat", true);
}

const TypeIdentifier* GetMapStringDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringDouble", complete);
}

const TypeObject* GetMapStringDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringDoubleObject();
    }
    //else
    return GetMinimalMapStringDoubleObject();
}

const TypeObject* GetMinimalMapStringDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_double;
    mst_var_map_string_double.common().member_id(memberId++);
    mst_var_map_string_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_double.common().member_flags().IS_KEY(false);
    mst_var_map_string_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "double", 100, false));


    MD5 var_map_string_double_hash("var_map_string_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_double.detail().name_hash()[i] = var_map_string_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringDouble", false);
}

const TypeObject* GetCompleteMapStringDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_double;
    cst_var_map_string_double.common().member_id(memberId++);
    cst_var_map_string_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_double.common().member_flags().IS_KEY(false);
    cst_var_map_string_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "double", 100, true));


    cst_var_map_string_double.detail().name("var_map_string_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringDouble", true);
}

const TypeIdentifier* GetMapStringLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringLongDouble", complete);
}

const TypeObject* GetMapStringLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringLongDoubleObject();
    }
    //else
    return GetMinimalMapStringLongDoubleObject();
}

const TypeObject* GetMinimalMapStringLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_longdouble;
    mst_var_map_string_longdouble.common().member_id(memberId++);
    mst_var_map_string_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_longdouble.common().member_flags().IS_KEY(false);
    mst_var_map_string_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "longdouble", 100, false));


    MD5 var_map_string_longdouble_hash("var_map_string_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_longdouble.detail().name_hash()[i] = var_map_string_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringLongDouble", false);
}

const TypeObject* GetCompleteMapStringLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_longdouble;
    cst_var_map_string_longdouble.common().member_id(memberId++);
    cst_var_map_string_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_longdouble.common().member_flags().IS_KEY(false);
    cst_var_map_string_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "longdouble", 100, true));


    cst_var_map_string_longdouble.detail().name("var_map_string_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringLongDouble", true);
}

const TypeIdentifier* GetMapStringBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringBoolean", complete);
}

const TypeObject* GetMapStringBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringBooleanObject();
    }
    //else
    return GetMinimalMapStringBooleanObject();
}

const TypeObject* GetMinimalMapStringBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_boolean;
    mst_var_map_string_boolean.common().member_id(memberId++);
    mst_var_map_string_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_boolean.common().member_flags().IS_KEY(false);
    mst_var_map_string_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "bool", 100, false));


    MD5 var_map_string_boolean_hash("var_map_string_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_boolean.detail().name_hash()[i] = var_map_string_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringBoolean", false);
}

const TypeObject* GetCompleteMapStringBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_boolean;
    cst_var_map_string_boolean.common().member_id(memberId++);
    cst_var_map_string_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_boolean.common().member_flags().IS_KEY(false);
    cst_var_map_string_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "bool", 100, true));


    cst_var_map_string_boolean.detail().name("var_map_string_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringBoolean", true);
}

const TypeIdentifier* GetMapStringOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringOctet", complete);
}

const TypeObject* GetMapStringOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringOctetObject();
    }
    //else
    return GetMinimalMapStringOctetObject();
}

const TypeObject* GetMinimalMapStringOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_octet;
    mst_var_map_string_octet.common().member_id(memberId++);
    mst_var_map_string_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_octet.common().member_flags().IS_KEY(false);
    mst_var_map_string_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "uint8_t", 100, false));


    MD5 var_map_string_octet_hash("var_map_string_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_octet.detail().name_hash()[i] = var_map_string_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringOctet", false);
}

const TypeObject* GetCompleteMapStringOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_octet;
    cst_var_map_string_octet.common().member_id(memberId++);
    cst_var_map_string_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_octet.common().member_flags().IS_KEY(false);
    cst_var_map_string_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "uint8_t", 100, true));


    cst_var_map_string_octet.detail().name("var_map_string_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringOctet", true);
}

const TypeIdentifier* GetMapStringCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringChar", complete);
}

const TypeObject* GetMapStringCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringCharObject();
    }
    //else
    return GetMinimalMapStringCharObject();
}

const TypeObject* GetMinimalMapStringCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_char;
    mst_var_map_string_char.common().member_id(memberId++);
    mst_var_map_string_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_char.common().member_flags().IS_KEY(false);
    mst_var_map_string_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "char", 100, false));


    MD5 var_map_string_char_hash("var_map_string_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_char.detail().name_hash()[i] = var_map_string_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringChar", false);
}

const TypeObject* GetCompleteMapStringCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_char;
    cst_var_map_string_char.common().member_id(memberId++);
    cst_var_map_string_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_char.common().member_flags().IS_KEY(false);
    cst_var_map_string_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "char", 100, true));


    cst_var_map_string_char.detail().name("var_map_string_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringChar", true);
}

const TypeIdentifier* GetMapStringWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringWChar", complete);
}

const TypeObject* GetMapStringWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringWCharObject();
    }
    //else
    return GetMinimalMapStringWCharObject();
}

const TypeObject* GetMinimalMapStringWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_wchar;
    mst_var_map_string_wchar.common().member_id(memberId++);
    mst_var_map_string_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_wchar.common().member_flags().IS_KEY(false);
    mst_var_map_string_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "wchar_t", 100, false));


    MD5 var_map_string_wchar_hash("var_map_string_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_wchar.detail().name_hash()[i] = var_map_string_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringWChar", false);
}

const TypeObject* GetCompleteMapStringWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_wchar;
    cst_var_map_string_wchar.common().member_id(memberId++);
    cst_var_map_string_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_wchar.common().member_flags().IS_KEY(false);
    cst_var_map_string_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "wchar_t", 100, true));


    cst_var_map_string_wchar.detail().name("var_map_string_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringWChar", true);
}

const TypeIdentifier* GetMapStringStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringString", complete);
}

const TypeObject* GetMapStringStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringStringObject();
    }
    //else
    return GetMinimalMapStringStringObject();
}

const TypeObject* GetMinimalMapStringStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_string;
    mst_var_map_string_string.common().member_id(memberId++);
    mst_var_map_string_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_string.common().member_flags().IS_KEY(false);
    mst_var_map_string_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), TypeNamesGenerator::get_string_type_name(255, false), 100, false));


    MD5 var_map_string_string_hash("var_map_string_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_string.detail().name_hash()[i] = var_map_string_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringString", false);
}

const TypeObject* GetCompleteMapStringStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_string;
    cst_var_map_string_string.common().member_id(memberId++);
    cst_var_map_string_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_string.common().member_flags().IS_KEY(false);
    cst_var_map_string_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), TypeNamesGenerator::get_string_type_name(255, false), 100, true));


    cst_var_map_string_string.detail().name("var_map_string_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringString", true);
}

const TypeIdentifier* GetMapStringWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringWString", complete);
}

const TypeObject* GetMapStringWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringWStringObject();
    }
    //else
    return GetMinimalMapStringWStringObject();
}

const TypeObject* GetMinimalMapStringWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_wstring;
    mst_var_map_string_wstring.common().member_id(memberId++);
    mst_var_map_string_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_wstring.common().member_flags().IS_KEY(false);
    mst_var_map_string_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), TypeNamesGenerator::get_string_type_name(255, true), 100, false));


    MD5 var_map_string_wstring_hash("var_map_string_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_wstring.detail().name_hash()[i] = var_map_string_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringWString", false);
}

const TypeObject* GetCompleteMapStringWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_wstring;
    cst_var_map_string_wstring.common().member_id(memberId++);
    cst_var_map_string_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_wstring.common().member_flags().IS_KEY(false);
    cst_var_map_string_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), TypeNamesGenerator::get_string_type_name(255, true), 100, true));


    cst_var_map_string_wstring.detail().name("var_map_string_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringWString", true);
}

const TypeIdentifier* GetMapStringInnerAliasBoundedStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerAliasBoundedStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringInnerAliasBoundedStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerAliasBoundedStringHelper", complete);
}

const TypeObject* GetMapStringInnerAliasBoundedStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasBoundedStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringInnerAliasBoundedStringHelperObject();
    }
    //else
    return GetMinimalMapStringInnerAliasBoundedStringHelperObject();
}

const TypeObject* GetMinimalMapStringInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasBoundedStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_inneraliasboundedstringhelper;
    mst_var_map_string_inneraliasboundedstringhelper.common().member_id(memberId++);
    mst_var_map_string_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_string_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "Inner_alias_bounded_string_helper", 100, false));


    MD5 var_map_string_inneraliasboundedstringhelper_hash("var_map_string_inneraliasboundedstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_inneraliasboundedstringhelper.detail().name_hash()[i] = var_map_string_inneraliasboundedstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_inneraliasboundedstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasBoundedStringHelper", false);
}

const TypeObject* GetCompleteMapStringInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasBoundedStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_inneraliasboundedstringhelper;
    cst_var_map_string_inneraliasboundedstringhelper.common().member_id(memberId++);
    cst_var_map_string_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_string_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "Inner_alias_bounded_string_helper", 100, true));


    cst_var_map_string_inneraliasboundedstringhelper.detail().name("var_map_string_inneraliasboundedstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_inneraliasboundedstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringInnerAliasBoundedStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasBoundedStringHelper", true);
}

const TypeIdentifier* GetMapStringInnerAliasBoundedWStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerAliasBoundedWStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringInnerAliasBoundedWStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerAliasBoundedWStringHelper", complete);
}

const TypeObject* GetMapStringInnerAliasBoundedWStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasBoundedWStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringInnerAliasBoundedWStringHelperObject();
    }
    //else
    return GetMinimalMapStringInnerAliasBoundedWStringHelperObject();
}

const TypeObject* GetMinimalMapStringInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasBoundedWStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_inneraliasboundedwstringhelper;
    mst_var_map_string_inneraliasboundedwstringhelper.common().member_id(memberId++);
    mst_var_map_string_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_string_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "Inner_alias_bounded_wstring_helper", 100, false));


    MD5 var_map_string_inneraliasboundedwstringhelper_hash("var_map_string_inneraliasboundedwstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_inneraliasboundedwstringhelper.detail().name_hash()[i] = var_map_string_inneraliasboundedwstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_inneraliasboundedwstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasBoundedWStringHelper", false);
}

const TypeObject* GetCompleteMapStringInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasBoundedWStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_inneraliasboundedwstringhelper;
    cst_var_map_string_inneraliasboundedwstringhelper.common().member_id(memberId++);
    cst_var_map_string_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_string_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "Inner_alias_bounded_wstring_helper", 100, true));


    cst_var_map_string_inneraliasboundedwstringhelper.detail().name("var_map_string_inneraliasboundedwstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_inneraliasboundedwstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringInnerAliasBoundedWStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasBoundedWStringHelper", true);
}

const TypeIdentifier* GetMapStringInnerEnumHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerEnumHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringInnerEnumHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerEnumHelper", complete);
}

const TypeObject* GetMapStringInnerEnumHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerEnumHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringInnerEnumHelperObject();
    }
    //else
    return GetMinimalMapStringInnerEnumHelperObject();
}

const TypeObject* GetMinimalMapStringInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerEnumHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_innerenumhelper;
    mst_var_map_string_innerenumhelper.common().member_id(memberId++);
    mst_var_map_string_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_innerenumhelper.common().member_flags().IS_KEY(false);
    mst_var_map_string_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "InnerEnumHelper", 100, false));


    MD5 var_map_string_innerenumhelper_hash("var_map_string_innerenumhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_innerenumhelper.detail().name_hash()[i] = var_map_string_innerenumhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_innerenumhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerEnumHelper", false);
}

const TypeObject* GetCompleteMapStringInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerEnumHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_innerenumhelper;
    cst_var_map_string_innerenumhelper.common().member_id(memberId++);
    cst_var_map_string_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_innerenumhelper.common().member_flags().IS_KEY(false);
    cst_var_map_string_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "InnerEnumHelper", 100, true));


    cst_var_map_string_innerenumhelper.detail().name("var_map_string_innerenumhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_innerenumhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringInnerEnumHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerEnumHelper", true);
}

const TypeIdentifier* GetMapStringInnerBitMaskHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerBitMaskHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringInnerBitMaskHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerBitMaskHelper", complete);
}

const TypeObject* GetMapStringInnerBitMaskHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerBitMaskHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringInnerBitMaskHelperObject();
    }
    //else
    return GetMinimalMapStringInnerBitMaskHelperObject();
}

const TypeObject* GetMinimalMapStringInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerBitMaskHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_innerbitmaskhelper;
    mst_var_map_string_innerbitmaskhelper.common().member_id(memberId++);
    mst_var_map_string_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    mst_var_map_string_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "InnerBitMaskHelper", 100, false));


    MD5 var_map_string_innerbitmaskhelper_hash("var_map_string_innerbitmaskhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_innerbitmaskhelper.detail().name_hash()[i] = var_map_string_innerbitmaskhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_innerbitmaskhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerBitMaskHelper", false);
}

const TypeObject* GetCompleteMapStringInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerBitMaskHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_innerbitmaskhelper;
    cst_var_map_string_innerbitmaskhelper.common().member_id(memberId++);
    cst_var_map_string_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    cst_var_map_string_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "InnerBitMaskHelper", 100, true));


    cst_var_map_string_innerbitmaskhelper.detail().name("var_map_string_innerbitmaskhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_innerbitmaskhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringInnerBitMaskHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerBitMaskHelper", true);
}

const TypeIdentifier* GetMapStringInnerAliasHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerAliasHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringInnerAliasHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerAliasHelper", complete);
}

const TypeObject* GetMapStringInnerAliasHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringInnerAliasHelperObject();
    }
    //else
    return GetMinimalMapStringInnerAliasHelperObject();
}

const TypeObject* GetMinimalMapStringInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_inneraliashelper;
    mst_var_map_string_inneraliashelper.common().member_id(memberId++);
    mst_var_map_string_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_inneraliashelper.common().member_flags().IS_KEY(false);
    mst_var_map_string_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "InnerAliasHelper", 100, false));


    MD5 var_map_string_inneraliashelper_hash("var_map_string_inneraliashelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_inneraliashelper.detail().name_hash()[i] = var_map_string_inneraliashelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_inneraliashelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasHelper", false);
}

const TypeObject* GetCompleteMapStringInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_inneraliashelper;
    cst_var_map_string_inneraliashelper.common().member_id(memberId++);
    cst_var_map_string_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_inneraliashelper.common().member_flags().IS_KEY(false);
    cst_var_map_string_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "InnerAliasHelper", 100, true));


    cst_var_map_string_inneraliashelper.detail().name("var_map_string_inneraliashelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_inneraliashelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringInnerAliasHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasHelper", true);
}

const TypeIdentifier* GetMapStringInnerAliasArrayHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerAliasArrayHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringInnerAliasArrayHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerAliasArrayHelper", complete);
}

const TypeObject* GetMapStringInnerAliasArrayHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasArrayHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringInnerAliasArrayHelperObject();
    }
    //else
    return GetMinimalMapStringInnerAliasArrayHelperObject();
}

const TypeObject* GetMinimalMapStringInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasArrayHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_inneraliasarrayhelper;
    mst_var_map_string_inneraliasarrayhelper.common().member_id(memberId++);
    mst_var_map_string_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    mst_var_map_string_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "Inner_alias_array_helper", 100, false));


    MD5 var_map_string_inneraliasarrayhelper_hash("var_map_string_inneraliasarrayhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_inneraliasarrayhelper.detail().name_hash()[i] = var_map_string_inneraliasarrayhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_inneraliasarrayhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasArrayHelper", false);
}

const TypeObject* GetCompleteMapStringInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasArrayHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_inneraliasarrayhelper;
    cst_var_map_string_inneraliasarrayhelper.common().member_id(memberId++);
    cst_var_map_string_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    cst_var_map_string_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "Inner_alias_array_helper", 100, true));


    cst_var_map_string_inneraliasarrayhelper.detail().name("var_map_string_inneraliasarrayhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_inneraliasarrayhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringInnerAliasArrayHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasArrayHelper", true);
}

const TypeIdentifier* GetMapStringInnerAliasSequenceHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerAliasSequenceHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringInnerAliasSequenceHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerAliasSequenceHelper", complete);
}

const TypeObject* GetMapStringInnerAliasSequenceHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasSequenceHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringInnerAliasSequenceHelperObject();
    }
    //else
    return GetMinimalMapStringInnerAliasSequenceHelperObject();
}

const TypeObject* GetMinimalMapStringInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasSequenceHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_inneraliassequencehelper;
    mst_var_map_string_inneraliassequencehelper.common().member_id(memberId++);
    mst_var_map_string_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    mst_var_map_string_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "Inner_alias_sequence_helper", 100, false));


    MD5 var_map_string_inneraliassequencehelper_hash("var_map_string_inneraliassequencehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_inneraliassequencehelper.detail().name_hash()[i] = var_map_string_inneraliassequencehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_inneraliassequencehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasSequenceHelper", false);
}

const TypeObject* GetCompleteMapStringInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasSequenceHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_inneraliassequencehelper;
    cst_var_map_string_inneraliassequencehelper.common().member_id(memberId++);
    cst_var_map_string_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    cst_var_map_string_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "Inner_alias_sequence_helper", 100, true));


    cst_var_map_string_inneraliassequencehelper.detail().name("var_map_string_inneraliassequencehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_inneraliassequencehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringInnerAliasSequenceHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasSequenceHelper", true);
}

const TypeIdentifier* GetMapStringInnerAliasMapHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerAliasMapHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringInnerAliasMapHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerAliasMapHelper", complete);
}

const TypeObject* GetMapStringInnerAliasMapHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasMapHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringInnerAliasMapHelperObject();
    }
    //else
    return GetMinimalMapStringInnerAliasMapHelperObject();
}

const TypeObject* GetMinimalMapStringInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasMapHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_inneraliasmaphelper;
    mst_var_map_string_inneraliasmaphelper.common().member_id(memberId++);
    mst_var_map_string_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    mst_var_map_string_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "Inner_alias_map_helper", 100, false));


    MD5 var_map_string_inneraliasmaphelper_hash("var_map_string_inneraliasmaphelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_inneraliasmaphelper.detail().name_hash()[i] = var_map_string_inneraliasmaphelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_inneraliasmaphelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasMapHelper", false);
}

const TypeObject* GetCompleteMapStringInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasMapHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_inneraliasmaphelper;
    cst_var_map_string_inneraliasmaphelper.common().member_id(memberId++);
    cst_var_map_string_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    cst_var_map_string_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "Inner_alias_map_helper", 100, true));


    cst_var_map_string_inneraliasmaphelper.detail().name("var_map_string_inneraliasmaphelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_inneraliasmaphelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringInnerAliasMapHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerAliasMapHelper", true);
}

const TypeIdentifier* GetMapStringInnerUnionHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerUnionHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringInnerUnionHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerUnionHelper", complete);
}

const TypeObject* GetMapStringInnerUnionHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerUnionHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringInnerUnionHelperObject();
    }
    //else
    return GetMinimalMapStringInnerUnionHelperObject();
}

const TypeObject* GetMinimalMapStringInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerUnionHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_innerunionhelper;
    mst_var_map_string_innerunionhelper.common().member_id(memberId++);
    mst_var_map_string_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_innerunionhelper.common().member_flags().IS_KEY(false);
    mst_var_map_string_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "InnerUnionHelper", 100, false));


    MD5 var_map_string_innerunionhelper_hash("var_map_string_innerunionhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_innerunionhelper.detail().name_hash()[i] = var_map_string_innerunionhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_innerunionhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerUnionHelper", false);
}

const TypeObject* GetCompleteMapStringInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerUnionHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_innerunionhelper;
    cst_var_map_string_innerunionhelper.common().member_id(memberId++);
    cst_var_map_string_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_innerunionhelper.common().member_flags().IS_KEY(false);
    cst_var_map_string_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "InnerUnionHelper", 100, true));


    cst_var_map_string_innerunionhelper.detail().name("var_map_string_innerunionhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_innerunionhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringInnerUnionHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerUnionHelper", true);
}

const TypeIdentifier* GetMapStringInnerStructureHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerStructureHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringInnerStructureHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerStructureHelper", complete);
}

const TypeObject* GetMapStringInnerStructureHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerStructureHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringInnerStructureHelperObject();
    }
    //else
    return GetMinimalMapStringInnerStructureHelperObject();
}

const TypeObject* GetMinimalMapStringInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerStructureHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_innerstructurehelper;
    mst_var_map_string_innerstructurehelper.common().member_id(memberId++);
    mst_var_map_string_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_innerstructurehelper.common().member_flags().IS_KEY(false);
    mst_var_map_string_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "InnerStructureHelper", 100, false));


    MD5 var_map_string_innerstructurehelper_hash("var_map_string_innerstructurehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_innerstructurehelper.detail().name_hash()[i] = var_map_string_innerstructurehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_innerstructurehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerStructureHelper", false);
}

const TypeObject* GetCompleteMapStringInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerStructureHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_innerstructurehelper;
    cst_var_map_string_innerstructurehelper.common().member_id(memberId++);
    cst_var_map_string_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_innerstructurehelper.common().member_flags().IS_KEY(false);
    cst_var_map_string_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "InnerStructureHelper", 100, true));


    cst_var_map_string_innerstructurehelper.detail().name("var_map_string_innerstructurehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_innerstructurehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringInnerStructureHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerStructureHelper", true);
}

const TypeIdentifier* GetMapStringInnerBitsetHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerBitsetHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStringInnerBitsetHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStringInnerBitsetHelper", complete);
}

const TypeObject* GetMapStringInnerBitsetHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerBitsetHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStringInnerBitsetHelperObject();
    }
    //else
    return GetMinimalMapStringInnerBitsetHelperObject();
}

const TypeObject* GetMinimalMapStringInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerBitsetHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_string_innerbitsethelper;
    mst_var_map_string_innerbitsethelper.common().member_id(memberId++);
    mst_var_map_string_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_string_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_string_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_string_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_string_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_string_innerbitsethelper.common().member_flags().IS_KEY(false);
    mst_var_map_string_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_string_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "InnerBitsetHelper", 100, false));


    MD5 var_map_string_innerbitsethelper_hash("var_map_string_innerbitsethelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_string_innerbitsethelper.detail().name_hash()[i] = var_map_string_innerbitsethelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_string_innerbitsethelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerBitsetHelper", false);
}

const TypeObject* GetCompleteMapStringInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStringInnerBitsetHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_string_innerbitsethelper;
    cst_var_map_string_innerbitsethelper.common().member_id(memberId++);
    cst_var_map_string_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_string_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_string_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_string_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_string_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_string_innerbitsethelper.common().member_flags().IS_KEY(false);
    cst_var_map_string_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_string_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, false), "InnerBitsetHelper", 100, true));


    cst_var_map_string_innerbitsethelper.detail().name("var_map_string_innerbitsethelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_string_innerbitsethelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStringInnerBitsetHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStringInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStringInnerBitsetHelper", true);
}

const TypeIdentifier* GetMapWStringShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringShort", complete);
}

const TypeObject* GetMapWStringShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringShortObject();
    }
    //else
    return GetMinimalMapWStringShortObject();
}

const TypeObject* GetMinimalMapWStringShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_short;
    mst_var_map_wstring_short.common().member_id(memberId++);
    mst_var_map_wstring_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_short.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "int16_t", 100, false));


    MD5 var_map_wstring_short_hash("var_map_wstring_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_short.detail().name_hash()[i] = var_map_wstring_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringShort", false);
}

const TypeObject* GetCompleteMapWStringShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_short;
    cst_var_map_wstring_short.common().member_id(memberId++);
    cst_var_map_wstring_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_short.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "int16_t", 100, true));


    cst_var_map_wstring_short.detail().name("var_map_wstring_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringShort", true);
}

const TypeIdentifier* GetMapWStringUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringUShort", complete);
}

const TypeObject* GetMapWStringUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringUShortObject();
    }
    //else
    return GetMinimalMapWStringUShortObject();
}

const TypeObject* GetMinimalMapWStringUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_ushort;
    mst_var_map_wstring_ushort.common().member_id(memberId++);
    mst_var_map_wstring_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_ushort.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "uint16_t", 100, false));


    MD5 var_map_wstring_ushort_hash("var_map_wstring_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_ushort.detail().name_hash()[i] = var_map_wstring_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringUShort", false);
}

const TypeObject* GetCompleteMapWStringUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_ushort;
    cst_var_map_wstring_ushort.common().member_id(memberId++);
    cst_var_map_wstring_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_ushort.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "uint16_t", 100, true));


    cst_var_map_wstring_ushort.detail().name("var_map_wstring_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringUShort", true);
}

const TypeIdentifier* GetMapWStringLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringLong", complete);
}

const TypeObject* GetMapWStringLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringLongObject();
    }
    //else
    return GetMinimalMapWStringLongObject();
}

const TypeObject* GetMinimalMapWStringLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_long;
    mst_var_map_wstring_long.common().member_id(memberId++);
    mst_var_map_wstring_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_long.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "int32_t", 100, false));


    MD5 var_map_wstring_long_hash("var_map_wstring_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_long.detail().name_hash()[i] = var_map_wstring_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringLong", false);
}

const TypeObject* GetCompleteMapWStringLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_long;
    cst_var_map_wstring_long.common().member_id(memberId++);
    cst_var_map_wstring_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_long.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "int32_t", 100, true));


    cst_var_map_wstring_long.detail().name("var_map_wstring_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringLong", true);
}

const TypeIdentifier* GetMapWStringULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringULong", complete);
}

const TypeObject* GetMapWStringULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringULongObject();
    }
    //else
    return GetMinimalMapWStringULongObject();
}

const TypeObject* GetMinimalMapWStringULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_ulong;
    mst_var_map_wstring_ulong.common().member_id(memberId++);
    mst_var_map_wstring_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_ulong.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "uint32_t", 100, false));


    MD5 var_map_wstring_ulong_hash("var_map_wstring_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_ulong.detail().name_hash()[i] = var_map_wstring_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringULong", false);
}

const TypeObject* GetCompleteMapWStringULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_ulong;
    cst_var_map_wstring_ulong.common().member_id(memberId++);
    cst_var_map_wstring_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_ulong.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "uint32_t", 100, true));


    cst_var_map_wstring_ulong.detail().name("var_map_wstring_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringULong", true);
}

const TypeIdentifier* GetMapWStringLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringLongLong", complete);
}

const TypeObject* GetMapWStringLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringLongLongObject();
    }
    //else
    return GetMinimalMapWStringLongLongObject();
}

const TypeObject* GetMinimalMapWStringLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_longlong;
    mst_var_map_wstring_longlong.common().member_id(memberId++);
    mst_var_map_wstring_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_longlong.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "int64_t", 100, false));


    MD5 var_map_wstring_longlong_hash("var_map_wstring_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_longlong.detail().name_hash()[i] = var_map_wstring_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringLongLong", false);
}

const TypeObject* GetCompleteMapWStringLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_longlong;
    cst_var_map_wstring_longlong.common().member_id(memberId++);
    cst_var_map_wstring_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_longlong.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "int64_t", 100, true));


    cst_var_map_wstring_longlong.detail().name("var_map_wstring_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringLongLong", true);
}

const TypeIdentifier* GetMapWStringULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringULongLong", complete);
}

const TypeObject* GetMapWStringULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringULongLongObject();
    }
    //else
    return GetMinimalMapWStringULongLongObject();
}

const TypeObject* GetMinimalMapWStringULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_ulonglong;
    mst_var_map_wstring_ulonglong.common().member_id(memberId++);
    mst_var_map_wstring_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "uint64_t", 100, false));


    MD5 var_map_wstring_ulonglong_hash("var_map_wstring_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_ulonglong.detail().name_hash()[i] = var_map_wstring_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringULongLong", false);
}

const TypeObject* GetCompleteMapWStringULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_ulonglong;
    cst_var_map_wstring_ulonglong.common().member_id(memberId++);
    cst_var_map_wstring_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "uint64_t", 100, true));


    cst_var_map_wstring_ulonglong.detail().name("var_map_wstring_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringULongLong", true);
}

const TypeIdentifier* GetMapWStringFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringFloat", complete);
}

const TypeObject* GetMapWStringFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringFloatObject();
    }
    //else
    return GetMinimalMapWStringFloatObject();
}

const TypeObject* GetMinimalMapWStringFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_float;
    mst_var_map_wstring_float.common().member_id(memberId++);
    mst_var_map_wstring_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_float.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "float", 100, false));


    MD5 var_map_wstring_float_hash("var_map_wstring_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_float.detail().name_hash()[i] = var_map_wstring_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringFloat", false);
}

const TypeObject* GetCompleteMapWStringFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_float;
    cst_var_map_wstring_float.common().member_id(memberId++);
    cst_var_map_wstring_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_float.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "float", 100, true));


    cst_var_map_wstring_float.detail().name("var_map_wstring_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringFloat", true);
}

const TypeIdentifier* GetMapWStringDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringDouble", complete);
}

const TypeObject* GetMapWStringDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringDoubleObject();
    }
    //else
    return GetMinimalMapWStringDoubleObject();
}

const TypeObject* GetMinimalMapWStringDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_double;
    mst_var_map_wstring_double.common().member_id(memberId++);
    mst_var_map_wstring_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_double.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "double", 100, false));


    MD5 var_map_wstring_double_hash("var_map_wstring_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_double.detail().name_hash()[i] = var_map_wstring_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringDouble", false);
}

const TypeObject* GetCompleteMapWStringDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_double;
    cst_var_map_wstring_double.common().member_id(memberId++);
    cst_var_map_wstring_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_double.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "double", 100, true));


    cst_var_map_wstring_double.detail().name("var_map_wstring_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringDouble", true);
}

const TypeIdentifier* GetMapWStringLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringLongDouble", complete);
}

const TypeObject* GetMapWStringLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringLongDoubleObject();
    }
    //else
    return GetMinimalMapWStringLongDoubleObject();
}

const TypeObject* GetMinimalMapWStringLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_longdouble;
    mst_var_map_wstring_longdouble.common().member_id(memberId++);
    mst_var_map_wstring_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_longdouble.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "longdouble", 100, false));


    MD5 var_map_wstring_longdouble_hash("var_map_wstring_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_longdouble.detail().name_hash()[i] = var_map_wstring_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringLongDouble", false);
}

const TypeObject* GetCompleteMapWStringLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_longdouble;
    cst_var_map_wstring_longdouble.common().member_id(memberId++);
    cst_var_map_wstring_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_longdouble.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "longdouble", 100, true));


    cst_var_map_wstring_longdouble.detail().name("var_map_wstring_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringLongDouble", true);
}

const TypeIdentifier* GetMapWStringBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringBoolean", complete);
}

const TypeObject* GetMapWStringBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringBooleanObject();
    }
    //else
    return GetMinimalMapWStringBooleanObject();
}

const TypeObject* GetMinimalMapWStringBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_boolean;
    mst_var_map_wstring_boolean.common().member_id(memberId++);
    mst_var_map_wstring_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_boolean.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "bool", 100, false));


    MD5 var_map_wstring_boolean_hash("var_map_wstring_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_boolean.detail().name_hash()[i] = var_map_wstring_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringBoolean", false);
}

const TypeObject* GetCompleteMapWStringBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_boolean;
    cst_var_map_wstring_boolean.common().member_id(memberId++);
    cst_var_map_wstring_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_boolean.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "bool", 100, true));


    cst_var_map_wstring_boolean.detail().name("var_map_wstring_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringBoolean", true);
}

const TypeIdentifier* GetMapWStringOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringOctet", complete);
}

const TypeObject* GetMapWStringOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringOctetObject();
    }
    //else
    return GetMinimalMapWStringOctetObject();
}

const TypeObject* GetMinimalMapWStringOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_octet;
    mst_var_map_wstring_octet.common().member_id(memberId++);
    mst_var_map_wstring_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_octet.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "uint8_t", 100, false));


    MD5 var_map_wstring_octet_hash("var_map_wstring_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_octet.detail().name_hash()[i] = var_map_wstring_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringOctet", false);
}

const TypeObject* GetCompleteMapWStringOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_octet;
    cst_var_map_wstring_octet.common().member_id(memberId++);
    cst_var_map_wstring_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_octet.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "uint8_t", 100, true));


    cst_var_map_wstring_octet.detail().name("var_map_wstring_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringOctet", true);
}

const TypeIdentifier* GetMapWStringCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringChar", complete);
}

const TypeObject* GetMapWStringCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringCharObject();
    }
    //else
    return GetMinimalMapWStringCharObject();
}

const TypeObject* GetMinimalMapWStringCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_char;
    mst_var_map_wstring_char.common().member_id(memberId++);
    mst_var_map_wstring_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_char.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "char", 100, false));


    MD5 var_map_wstring_char_hash("var_map_wstring_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_char.detail().name_hash()[i] = var_map_wstring_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringChar", false);
}

const TypeObject* GetCompleteMapWStringCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_char;
    cst_var_map_wstring_char.common().member_id(memberId++);
    cst_var_map_wstring_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_char.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "char", 100, true));


    cst_var_map_wstring_char.detail().name("var_map_wstring_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringChar", true);
}

const TypeIdentifier* GetMapWStringWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringWChar", complete);
}

const TypeObject* GetMapWStringWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringWCharObject();
    }
    //else
    return GetMinimalMapWStringWCharObject();
}

const TypeObject* GetMinimalMapWStringWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_wchar;
    mst_var_map_wstring_wchar.common().member_id(memberId++);
    mst_var_map_wstring_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_wchar.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "wchar_t", 100, false));


    MD5 var_map_wstring_wchar_hash("var_map_wstring_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_wchar.detail().name_hash()[i] = var_map_wstring_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringWChar", false);
}

const TypeObject* GetCompleteMapWStringWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_wchar;
    cst_var_map_wstring_wchar.common().member_id(memberId++);
    cst_var_map_wstring_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_wchar.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "wchar_t", 100, true));


    cst_var_map_wstring_wchar.detail().name("var_map_wstring_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringWChar", true);
}

const TypeIdentifier* GetMapWStringStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringString", complete);
}

const TypeObject* GetMapWStringStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringStringObject();
    }
    //else
    return GetMinimalMapWStringStringObject();
}

const TypeObject* GetMinimalMapWStringStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_string;
    mst_var_map_wstring_string.common().member_id(memberId++);
    mst_var_map_wstring_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_string.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), TypeNamesGenerator::get_string_type_name(255, false), 100, false));


    MD5 var_map_wstring_string_hash("var_map_wstring_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_string.detail().name_hash()[i] = var_map_wstring_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringString", false);
}

const TypeObject* GetCompleteMapWStringStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_string;
    cst_var_map_wstring_string.common().member_id(memberId++);
    cst_var_map_wstring_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_string.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), TypeNamesGenerator::get_string_type_name(255, false), 100, true));


    cst_var_map_wstring_string.detail().name("var_map_wstring_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringString", true);
}

const TypeIdentifier* GetMapWStringWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringWString", complete);
}

const TypeObject* GetMapWStringWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringWStringObject();
    }
    //else
    return GetMinimalMapWStringWStringObject();
}

const TypeObject* GetMinimalMapWStringWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_wstring;
    mst_var_map_wstring_wstring.common().member_id(memberId++);
    mst_var_map_wstring_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_wstring.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), TypeNamesGenerator::get_string_type_name(255, true), 100, false));


    MD5 var_map_wstring_wstring_hash("var_map_wstring_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_wstring.detail().name_hash()[i] = var_map_wstring_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringWString", false);
}

const TypeObject* GetCompleteMapWStringWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_wstring;
    cst_var_map_wstring_wstring.common().member_id(memberId++);
    cst_var_map_wstring_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_wstring.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), TypeNamesGenerator::get_string_type_name(255, true), 100, true));


    cst_var_map_wstring_wstring.detail().name("var_map_wstring_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringWString", true);
}

const TypeIdentifier* GetMapWStringInnerAliasBoundedStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerAliasBoundedStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringInnerAliasBoundedStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerAliasBoundedStringHelper", complete);
}

const TypeObject* GetMapWStringInnerAliasBoundedStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasBoundedStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringInnerAliasBoundedStringHelperObject();
    }
    //else
    return GetMinimalMapWStringInnerAliasBoundedStringHelperObject();
}

const TypeObject* GetMinimalMapWStringInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasBoundedStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_inneraliasboundedstringhelper;
    mst_var_map_wstring_inneraliasboundedstringhelper.common().member_id(memberId++);
    mst_var_map_wstring_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "Inner_alias_bounded_string_helper", 100, false));


    MD5 var_map_wstring_inneraliasboundedstringhelper_hash("var_map_wstring_inneraliasboundedstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_inneraliasboundedstringhelper.detail().name_hash()[i] = var_map_wstring_inneraliasboundedstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_inneraliasboundedstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasBoundedStringHelper", false);
}

const TypeObject* GetCompleteMapWStringInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasBoundedStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_inneraliasboundedstringhelper;
    cst_var_map_wstring_inneraliasboundedstringhelper.common().member_id(memberId++);
    cst_var_map_wstring_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "Inner_alias_bounded_string_helper", 100, true));


    cst_var_map_wstring_inneraliasboundedstringhelper.detail().name("var_map_wstring_inneraliasboundedstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_inneraliasboundedstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringInnerAliasBoundedStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasBoundedStringHelper", true);
}

const TypeIdentifier* GetMapWStringInnerAliasBoundedWStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerAliasBoundedWStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringInnerAliasBoundedWStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerAliasBoundedWStringHelper", complete);
}

const TypeObject* GetMapWStringInnerAliasBoundedWStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasBoundedWStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringInnerAliasBoundedWStringHelperObject();
    }
    //else
    return GetMinimalMapWStringInnerAliasBoundedWStringHelperObject();
}

const TypeObject* GetMinimalMapWStringInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasBoundedWStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_inneraliasboundedwstringhelper;
    mst_var_map_wstring_inneraliasboundedwstringhelper.common().member_id(memberId++);
    mst_var_map_wstring_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "Inner_alias_bounded_wstring_helper", 100, false));


    MD5 var_map_wstring_inneraliasboundedwstringhelper_hash("var_map_wstring_inneraliasboundedwstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_inneraliasboundedwstringhelper.detail().name_hash()[i] = var_map_wstring_inneraliasboundedwstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_inneraliasboundedwstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasBoundedWStringHelper", false);
}

const TypeObject* GetCompleteMapWStringInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasBoundedWStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_inneraliasboundedwstringhelper;
    cst_var_map_wstring_inneraliasboundedwstringhelper.common().member_id(memberId++);
    cst_var_map_wstring_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "Inner_alias_bounded_wstring_helper", 100, true));


    cst_var_map_wstring_inneraliasboundedwstringhelper.detail().name("var_map_wstring_inneraliasboundedwstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_inneraliasboundedwstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringInnerAliasBoundedWStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasBoundedWStringHelper", true);
}

const TypeIdentifier* GetMapWStringInnerEnumHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerEnumHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringInnerEnumHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerEnumHelper", complete);
}

const TypeObject* GetMapWStringInnerEnumHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerEnumHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringInnerEnumHelperObject();
    }
    //else
    return GetMinimalMapWStringInnerEnumHelperObject();
}

const TypeObject* GetMinimalMapWStringInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerEnumHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_innerenumhelper;
    mst_var_map_wstring_innerenumhelper.common().member_id(memberId++);
    mst_var_map_wstring_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_innerenumhelper.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "InnerEnumHelper", 100, false));


    MD5 var_map_wstring_innerenumhelper_hash("var_map_wstring_innerenumhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_innerenumhelper.detail().name_hash()[i] = var_map_wstring_innerenumhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_innerenumhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerEnumHelper", false);
}

const TypeObject* GetCompleteMapWStringInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerEnumHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_innerenumhelper;
    cst_var_map_wstring_innerenumhelper.common().member_id(memberId++);
    cst_var_map_wstring_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_innerenumhelper.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "InnerEnumHelper", 100, true));


    cst_var_map_wstring_innerenumhelper.detail().name("var_map_wstring_innerenumhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_innerenumhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringInnerEnumHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerEnumHelper", true);
}

const TypeIdentifier* GetMapWStringInnerBitMaskHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerBitMaskHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringInnerBitMaskHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerBitMaskHelper", complete);
}

const TypeObject* GetMapWStringInnerBitMaskHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerBitMaskHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringInnerBitMaskHelperObject();
    }
    //else
    return GetMinimalMapWStringInnerBitMaskHelperObject();
}

const TypeObject* GetMinimalMapWStringInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerBitMaskHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_innerbitmaskhelper;
    mst_var_map_wstring_innerbitmaskhelper.common().member_id(memberId++);
    mst_var_map_wstring_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "InnerBitMaskHelper", 100, false));


    MD5 var_map_wstring_innerbitmaskhelper_hash("var_map_wstring_innerbitmaskhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_innerbitmaskhelper.detail().name_hash()[i] = var_map_wstring_innerbitmaskhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_innerbitmaskhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerBitMaskHelper", false);
}

const TypeObject* GetCompleteMapWStringInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerBitMaskHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_innerbitmaskhelper;
    cst_var_map_wstring_innerbitmaskhelper.common().member_id(memberId++);
    cst_var_map_wstring_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "InnerBitMaskHelper", 100, true));


    cst_var_map_wstring_innerbitmaskhelper.detail().name("var_map_wstring_innerbitmaskhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_innerbitmaskhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringInnerBitMaskHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerBitMaskHelper", true);
}

const TypeIdentifier* GetMapWStringInnerAliasHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerAliasHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringInnerAliasHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerAliasHelper", complete);
}

const TypeObject* GetMapWStringInnerAliasHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringInnerAliasHelperObject();
    }
    //else
    return GetMinimalMapWStringInnerAliasHelperObject();
}

const TypeObject* GetMinimalMapWStringInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_inneraliashelper;
    mst_var_map_wstring_inneraliashelper.common().member_id(memberId++);
    mst_var_map_wstring_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_inneraliashelper.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "InnerAliasHelper", 100, false));


    MD5 var_map_wstring_inneraliashelper_hash("var_map_wstring_inneraliashelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_inneraliashelper.detail().name_hash()[i] = var_map_wstring_inneraliashelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_inneraliashelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasHelper", false);
}

const TypeObject* GetCompleteMapWStringInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_inneraliashelper;
    cst_var_map_wstring_inneraliashelper.common().member_id(memberId++);
    cst_var_map_wstring_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_inneraliashelper.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "InnerAliasHelper", 100, true));


    cst_var_map_wstring_inneraliashelper.detail().name("var_map_wstring_inneraliashelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_inneraliashelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringInnerAliasHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasHelper", true);
}

const TypeIdentifier* GetMapWStringInnerAliasArrayHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerAliasArrayHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringInnerAliasArrayHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerAliasArrayHelper", complete);
}

const TypeObject* GetMapWStringInnerAliasArrayHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasArrayHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringInnerAliasArrayHelperObject();
    }
    //else
    return GetMinimalMapWStringInnerAliasArrayHelperObject();
}

const TypeObject* GetMinimalMapWStringInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasArrayHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_inneraliasarrayhelper;
    mst_var_map_wstring_inneraliasarrayhelper.common().member_id(memberId++);
    mst_var_map_wstring_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "Inner_alias_array_helper", 100, false));


    MD5 var_map_wstring_inneraliasarrayhelper_hash("var_map_wstring_inneraliasarrayhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_inneraliasarrayhelper.detail().name_hash()[i] = var_map_wstring_inneraliasarrayhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_inneraliasarrayhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasArrayHelper", false);
}

const TypeObject* GetCompleteMapWStringInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasArrayHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_inneraliasarrayhelper;
    cst_var_map_wstring_inneraliasarrayhelper.common().member_id(memberId++);
    cst_var_map_wstring_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "Inner_alias_array_helper", 100, true));


    cst_var_map_wstring_inneraliasarrayhelper.detail().name("var_map_wstring_inneraliasarrayhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_inneraliasarrayhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringInnerAliasArrayHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasArrayHelper", true);
}

const TypeIdentifier* GetMapWStringInnerAliasSequenceHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerAliasSequenceHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringInnerAliasSequenceHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerAliasSequenceHelper", complete);
}

const TypeObject* GetMapWStringInnerAliasSequenceHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasSequenceHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringInnerAliasSequenceHelperObject();
    }
    //else
    return GetMinimalMapWStringInnerAliasSequenceHelperObject();
}

const TypeObject* GetMinimalMapWStringInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasSequenceHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_inneraliassequencehelper;
    mst_var_map_wstring_inneraliassequencehelper.common().member_id(memberId++);
    mst_var_map_wstring_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "Inner_alias_sequence_helper", 100, false));


    MD5 var_map_wstring_inneraliassequencehelper_hash("var_map_wstring_inneraliassequencehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_inneraliassequencehelper.detail().name_hash()[i] = var_map_wstring_inneraliassequencehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_inneraliassequencehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasSequenceHelper", false);
}

const TypeObject* GetCompleteMapWStringInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasSequenceHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_inneraliassequencehelper;
    cst_var_map_wstring_inneraliassequencehelper.common().member_id(memberId++);
    cst_var_map_wstring_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "Inner_alias_sequence_helper", 100, true));


    cst_var_map_wstring_inneraliassequencehelper.detail().name("var_map_wstring_inneraliassequencehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_inneraliassequencehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringInnerAliasSequenceHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasSequenceHelper", true);
}

const TypeIdentifier* GetMapWStringInnerAliasMapHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerAliasMapHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringInnerAliasMapHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerAliasMapHelper", complete);
}

const TypeObject* GetMapWStringInnerAliasMapHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasMapHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringInnerAliasMapHelperObject();
    }
    //else
    return GetMinimalMapWStringInnerAliasMapHelperObject();
}

const TypeObject* GetMinimalMapWStringInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasMapHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_inneraliasmaphelper;
    mst_var_map_wstring_inneraliasmaphelper.common().member_id(memberId++);
    mst_var_map_wstring_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "Inner_alias_map_helper", 100, false));


    MD5 var_map_wstring_inneraliasmaphelper_hash("var_map_wstring_inneraliasmaphelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_inneraliasmaphelper.detail().name_hash()[i] = var_map_wstring_inneraliasmaphelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_inneraliasmaphelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasMapHelper", false);
}

const TypeObject* GetCompleteMapWStringInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasMapHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_inneraliasmaphelper;
    cst_var_map_wstring_inneraliasmaphelper.common().member_id(memberId++);
    cst_var_map_wstring_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "Inner_alias_map_helper", 100, true));


    cst_var_map_wstring_inneraliasmaphelper.detail().name("var_map_wstring_inneraliasmaphelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_inneraliasmaphelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringInnerAliasMapHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerAliasMapHelper", true);
}

const TypeIdentifier* GetMapWStringInnerUnionHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerUnionHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringInnerUnionHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerUnionHelper", complete);
}

const TypeObject* GetMapWStringInnerUnionHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerUnionHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringInnerUnionHelperObject();
    }
    //else
    return GetMinimalMapWStringInnerUnionHelperObject();
}

const TypeObject* GetMinimalMapWStringInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerUnionHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_innerunionhelper;
    mst_var_map_wstring_innerunionhelper.common().member_id(memberId++);
    mst_var_map_wstring_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_innerunionhelper.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "InnerUnionHelper", 100, false));


    MD5 var_map_wstring_innerunionhelper_hash("var_map_wstring_innerunionhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_innerunionhelper.detail().name_hash()[i] = var_map_wstring_innerunionhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_innerunionhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerUnionHelper", false);
}

const TypeObject* GetCompleteMapWStringInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerUnionHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_innerunionhelper;
    cst_var_map_wstring_innerunionhelper.common().member_id(memberId++);
    cst_var_map_wstring_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_innerunionhelper.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "InnerUnionHelper", 100, true));


    cst_var_map_wstring_innerunionhelper.detail().name("var_map_wstring_innerunionhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_innerunionhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringInnerUnionHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerUnionHelper", true);
}

const TypeIdentifier* GetMapWStringInnerStructureHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerStructureHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringInnerStructureHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerStructureHelper", complete);
}

const TypeObject* GetMapWStringInnerStructureHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerStructureHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringInnerStructureHelperObject();
    }
    //else
    return GetMinimalMapWStringInnerStructureHelperObject();
}

const TypeObject* GetMinimalMapWStringInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerStructureHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_innerstructurehelper;
    mst_var_map_wstring_innerstructurehelper.common().member_id(memberId++);
    mst_var_map_wstring_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_innerstructurehelper.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "InnerStructureHelper", 100, false));


    MD5 var_map_wstring_innerstructurehelper_hash("var_map_wstring_innerstructurehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_innerstructurehelper.detail().name_hash()[i] = var_map_wstring_innerstructurehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_innerstructurehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerStructureHelper", false);
}

const TypeObject* GetCompleteMapWStringInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerStructureHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_innerstructurehelper;
    cst_var_map_wstring_innerstructurehelper.common().member_id(memberId++);
    cst_var_map_wstring_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_innerstructurehelper.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "InnerStructureHelper", 100, true));


    cst_var_map_wstring_innerstructurehelper.detail().name("var_map_wstring_innerstructurehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_innerstructurehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringInnerStructureHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerStructureHelper", true);
}

const TypeIdentifier* GetMapWStringInnerBitsetHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerBitsetHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapWStringInnerBitsetHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapWStringInnerBitsetHelper", complete);
}

const TypeObject* GetMapWStringInnerBitsetHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerBitsetHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapWStringInnerBitsetHelperObject();
    }
    //else
    return GetMinimalMapWStringInnerBitsetHelperObject();
}

const TypeObject* GetMinimalMapWStringInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerBitsetHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_wstring_innerbitsethelper;
    mst_var_map_wstring_innerbitsethelper.common().member_id(memberId++);
    mst_var_map_wstring_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_wstring_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_wstring_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_wstring_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_wstring_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_wstring_innerbitsethelper.common().member_flags().IS_KEY(false);
    mst_var_map_wstring_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_wstring_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "InnerBitsetHelper", 100, false));


    MD5 var_map_wstring_innerbitsethelper_hash("var_map_wstring_innerbitsethelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_wstring_innerbitsethelper.detail().name_hash()[i] = var_map_wstring_innerbitsethelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_wstring_innerbitsethelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerBitsetHelper", false);
}

const TypeObject* GetCompleteMapWStringInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerBitsetHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_wstring_innerbitsethelper;
    cst_var_map_wstring_innerbitsethelper.common().member_id(memberId++);
    cst_var_map_wstring_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_wstring_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_wstring_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_wstring_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_wstring_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_wstring_innerbitsethelper.common().member_flags().IS_KEY(false);
    cst_var_map_wstring_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_wstring_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier(TypeNamesGenerator::get_string_type_name(255, true), "InnerBitsetHelper", 100, true));


    cst_var_map_wstring_innerbitsethelper.detail().name("var_map_wstring_innerbitsethelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_wstring_innerbitsethelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapWStringInnerBitsetHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapWStringInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapWStringInnerBitsetHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperShort", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperShortObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperShortObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_short;
    mst_var_map_inneraliasboundedstringhelper_short.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_short.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "int16_t", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_short_hash("var_map_inneraliasboundedstringhelper_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_short.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperShort", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_short;
    cst_var_map_inneraliasboundedstringhelper_short.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_short.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "int16_t", 100, true));


    cst_var_map_inneraliasboundedstringhelper_short.detail().name("var_map_inneraliasboundedstringhelper_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperShort", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperUShort", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperUShortObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperUShortObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_ushort;
    mst_var_map_inneraliasboundedstringhelper_ushort.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_ushort.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "uint16_t", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_ushort_hash("var_map_inneraliasboundedstringhelper_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_ushort.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperUShort", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_ushort;
    cst_var_map_inneraliasboundedstringhelper_ushort.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_ushort.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "uint16_t", 100, true));


    cst_var_map_inneraliasboundedstringhelper_ushort.detail().name("var_map_inneraliasboundedstringhelper_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperUShort", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperLong", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperLongObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperLongObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_long;
    mst_var_map_inneraliasboundedstringhelper_long.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_long.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "int32_t", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_long_hash("var_map_inneraliasboundedstringhelper_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_long.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLong", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_long;
    cst_var_map_inneraliasboundedstringhelper_long.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_long.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "int32_t", 100, true));


    cst_var_map_inneraliasboundedstringhelper_long.detail().name("var_map_inneraliasboundedstringhelper_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLong", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperULong", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperULongObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperULongObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_ulong;
    mst_var_map_inneraliasboundedstringhelper_ulong.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_ulong.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "uint32_t", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_ulong_hash("var_map_inneraliasboundedstringhelper_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_ulong.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperULong", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_ulong;
    cst_var_map_inneraliasboundedstringhelper_ulong.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_ulong.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "uint32_t", 100, true));


    cst_var_map_inneraliasboundedstringhelper_ulong.detail().name("var_map_inneraliasboundedstringhelper_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperULong", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperLongLong", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperLongLongObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperLongLongObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_longlong;
    mst_var_map_inneraliasboundedstringhelper_longlong.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_longlong.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "int64_t", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_longlong_hash("var_map_inneraliasboundedstringhelper_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_longlong.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLongLong", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_longlong;
    cst_var_map_inneraliasboundedstringhelper_longlong.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_longlong.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "int64_t", 100, true));


    cst_var_map_inneraliasboundedstringhelper_longlong.detail().name("var_map_inneraliasboundedstringhelper_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLongLong", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperULongLong", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperULongLongObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperULongLongObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_ulonglong;
    mst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "uint64_t", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_ulonglong_hash("var_map_inneraliasboundedstringhelper_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_ulonglong.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperULongLong", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_ulonglong;
    cst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "uint64_t", 100, true));


    cst_var_map_inneraliasboundedstringhelper_ulonglong.detail().name("var_map_inneraliasboundedstringhelper_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperULongLong", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperFloat", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperFloatObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperFloatObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_float;
    mst_var_map_inneraliasboundedstringhelper_float.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_float.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "float", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_float_hash("var_map_inneraliasboundedstringhelper_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_float.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperFloat", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_float;
    cst_var_map_inneraliasboundedstringhelper_float.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_float.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "float", 100, true));


    cst_var_map_inneraliasboundedstringhelper_float.detail().name("var_map_inneraliasboundedstringhelper_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperFloat", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperDouble", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperDoubleObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperDoubleObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_double;
    mst_var_map_inneraliasboundedstringhelper_double.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_double.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "double", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_double_hash("var_map_inneraliasboundedstringhelper_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_double.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperDouble", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_double;
    cst_var_map_inneraliasboundedstringhelper_double.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_double.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "double", 100, true));


    cst_var_map_inneraliasboundedstringhelper_double.detail().name("var_map_inneraliasboundedstringhelper_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperDouble", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperLongDouble", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperLongDoubleObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperLongDoubleObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_longdouble;
    mst_var_map_inneraliasboundedstringhelper_longdouble.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_longdouble.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "longdouble", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_longdouble_hash("var_map_inneraliasboundedstringhelper_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_longdouble.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLongDouble", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_longdouble;
    cst_var_map_inneraliasboundedstringhelper_longdouble.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_longdouble.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "longdouble", 100, true));


    cst_var_map_inneraliasboundedstringhelper_longdouble.detail().name("var_map_inneraliasboundedstringhelper_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperLongDouble", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperBoolean", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperBooleanObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperBooleanObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_boolean;
    mst_var_map_inneraliasboundedstringhelper_boolean.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_boolean.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "bool", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_boolean_hash("var_map_inneraliasboundedstringhelper_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_boolean.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperBoolean", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_boolean;
    cst_var_map_inneraliasboundedstringhelper_boolean.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_boolean.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "bool", 100, true));


    cst_var_map_inneraliasboundedstringhelper_boolean.detail().name("var_map_inneraliasboundedstringhelper_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperBoolean", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperOctet", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperOctetObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperOctetObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_octet;
    mst_var_map_inneraliasboundedstringhelper_octet.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_octet.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "uint8_t", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_octet_hash("var_map_inneraliasboundedstringhelper_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_octet.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperOctet", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_octet;
    cst_var_map_inneraliasboundedstringhelper_octet.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_octet.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "uint8_t", 100, true));


    cst_var_map_inneraliasboundedstringhelper_octet.detail().name("var_map_inneraliasboundedstringhelper_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperOctet", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperChar", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperCharObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperCharObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_char;
    mst_var_map_inneraliasboundedstringhelper_char.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_char.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "char", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_char_hash("var_map_inneraliasboundedstringhelper_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_char.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperChar", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_char;
    cst_var_map_inneraliasboundedstringhelper_char.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_char.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "char", 100, true));


    cst_var_map_inneraliasboundedstringhelper_char.detail().name("var_map_inneraliasboundedstringhelper_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperChar", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperWChar", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperWCharObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperWCharObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_wchar;
    mst_var_map_inneraliasboundedstringhelper_wchar.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_wchar.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "wchar_t", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_wchar_hash("var_map_inneraliasboundedstringhelper_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_wchar.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperWChar", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_wchar;
    cst_var_map_inneraliasboundedstringhelper_wchar.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_wchar.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "wchar_t", 100, true));


    cst_var_map_inneraliasboundedstringhelper_wchar.detail().name("var_map_inneraliasboundedstringhelper_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperWChar", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperString", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperStringObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperStringObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_string;
    mst_var_map_inneraliasboundedstringhelper_string.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_string.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", TypeNamesGenerator::get_string_type_name(255, false), 100, false));


    MD5 var_map_inneraliasboundedstringhelper_string_hash("var_map_inneraliasboundedstringhelper_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_string.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperString", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_string;
    cst_var_map_inneraliasboundedstringhelper_string.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_string.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", TypeNamesGenerator::get_string_type_name(255, false), 100, true));


    cst_var_map_inneraliasboundedstringhelper_string.detail().name("var_map_inneraliasboundedstringhelper_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperString", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperWString", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperWStringObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperWStringObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_wstring;
    mst_var_map_inneraliasboundedstringhelper_wstring.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_wstring.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", TypeNamesGenerator::get_string_type_name(255, true), 100, false));


    MD5 var_map_inneraliasboundedstringhelper_wstring_hash("var_map_inneraliasboundedstringhelper_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_wstring.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperWString", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_wstring;
    cst_var_map_inneraliasboundedstringhelper_wstring.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_wstring.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", TypeNamesGenerator::get_string_type_name(255, true), 100, true));


    cst_var_map_inneraliasboundedstringhelper_wstring.detail().name("var_map_inneraliasboundedstringhelper_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperWString", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper;
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "Inner_alias_bounded_string_helper", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper_hash("var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper;
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "Inner_alias_bounded_string_helper", 100, true));


    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper.detail().name("var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper;
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "Inner_alias_bounded_wstring_helper", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper_hash("var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper;
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "Inner_alias_bounded_wstring_helper", 100, true));


    cst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper.detail().name("var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperInnerEnumHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerEnumHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperInnerEnumHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerEnumHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperInnerEnumHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerEnumHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperInnerEnumHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperInnerEnumHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerEnumHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_innerenumhelper;
    mst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "InnerEnumHelper", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_innerenumhelper_hash("var_map_inneraliasboundedstringhelper_innerenumhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_innerenumhelper.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_innerenumhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_innerenumhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerEnumHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerEnumHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_innerenumhelper;
    cst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "InnerEnumHelper", 100, true));


    cst_var_map_inneraliasboundedstringhelper_innerenumhelper.detail().name("var_map_inneraliasboundedstringhelper_innerenumhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_innerenumhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperInnerEnumHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerEnumHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperInnerBitMaskHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerBitMaskHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperInnerBitMaskHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerBitMaskHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperInnerBitMaskHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerBitMaskHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperInnerBitMaskHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperInnerBitMaskHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerBitMaskHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper;
    mst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "InnerBitMaskHelper", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_innerbitmaskhelper_hash("var_map_inneraliasboundedstringhelper_innerbitmaskhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_innerbitmaskhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerBitMaskHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerBitMaskHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper;
    cst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "InnerBitMaskHelper", 100, true));


    cst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper.detail().name("var_map_inneraliasboundedstringhelper_innerbitmaskhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_innerbitmaskhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperInnerBitMaskHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerBitMaskHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperInnerAliasHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerAliasHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperInnerAliasHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerAliasHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperInnerAliasHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperInnerAliasHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperInnerAliasHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_inneraliashelper;
    mst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "InnerAliasHelper", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_inneraliashelper_hash("var_map_inneraliasboundedstringhelper_inneraliashelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_inneraliashelper.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_inneraliashelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_inneraliashelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_inneraliashelper;
    cst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "InnerAliasHelper", 100, true));


    cst_var_map_inneraliasboundedstringhelper_inneraliashelper.detail().name("var_map_inneraliasboundedstringhelper_inneraliashelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_inneraliashelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperInnerAliasHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperInnerAliasArrayHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerAliasArrayHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperInnerAliasArrayHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerAliasArrayHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperInnerAliasArrayHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasArrayHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperInnerAliasArrayHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperInnerAliasArrayHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasArrayHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper;
    mst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "Inner_alias_array_helper", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_inneraliasarrayhelper_hash("var_map_inneraliasboundedstringhelper_inneraliasarrayhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_inneraliasarrayhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasArrayHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasArrayHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper;
    cst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "Inner_alias_array_helper", 100, true));


    cst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper.detail().name("var_map_inneraliasboundedstringhelper_inneraliasarrayhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_inneraliasarrayhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperInnerAliasArrayHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasArrayHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperInnerAliasSequenceHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperInnerAliasSequenceHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperInnerAliasSequenceHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperInnerAliasSequenceHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperInnerAliasSequenceHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper;
    mst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "Inner_alias_sequence_helper", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_inneraliassequencehelper_hash("var_map_inneraliasboundedstringhelper_inneraliassequencehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_inneraliassequencehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper;
    cst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "Inner_alias_sequence_helper", 100, true));


    cst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper.detail().name("var_map_inneraliasboundedstringhelper_inneraliassequencehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_inneraliassequencehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperInnerAliasMapHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerAliasMapHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperInnerAliasMapHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerAliasMapHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperInnerAliasMapHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasMapHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperInnerAliasMapHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperInnerAliasMapHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasMapHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper;
    mst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "Inner_alias_map_helper", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_inneraliasmaphelper_hash("var_map_inneraliasboundedstringhelper_inneraliasmaphelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_inneraliasmaphelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasMapHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasMapHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper;
    cst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "Inner_alias_map_helper", 100, true));


    cst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper.detail().name("var_map_inneraliasboundedstringhelper_inneraliasmaphelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_inneraliasmaphelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperInnerAliasMapHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerAliasMapHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperInnerUnionHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerUnionHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperInnerUnionHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerUnionHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperInnerUnionHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerUnionHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperInnerUnionHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperInnerUnionHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerUnionHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_innerunionhelper;
    mst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "InnerUnionHelper", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_innerunionhelper_hash("var_map_inneraliasboundedstringhelper_innerunionhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_innerunionhelper.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_innerunionhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_innerunionhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerUnionHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerUnionHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_innerunionhelper;
    cst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "InnerUnionHelper", 100, true));


    cst_var_map_inneraliasboundedstringhelper_innerunionhelper.detail().name("var_map_inneraliasboundedstringhelper_innerunionhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_innerunionhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperInnerUnionHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerUnionHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperInnerStructureHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerStructureHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperInnerStructureHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerStructureHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperInnerStructureHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerStructureHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperInnerStructureHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperInnerStructureHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerStructureHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_innerstructurehelper;
    mst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "InnerStructureHelper", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_innerstructurehelper_hash("var_map_inneraliasboundedstringhelper_innerstructurehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_innerstructurehelper.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_innerstructurehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_innerstructurehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerStructureHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerStructureHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_innerstructurehelper;
    cst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "InnerStructureHelper", 100, true));


    cst_var_map_inneraliasboundedstringhelper_innerstructurehelper.detail().name("var_map_inneraliasboundedstringhelper_innerstructurehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_innerstructurehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperInnerStructureHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerStructureHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedStringHelperInnerBitsetHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerBitsetHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedStringHelperInnerBitsetHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedStringHelperInnerBitsetHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedStringHelperInnerBitsetHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerBitsetHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedStringHelperInnerBitsetHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedStringHelperInnerBitsetHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedStringHelperInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerBitsetHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedstringhelper_innerbitsethelper;
    mst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "InnerBitsetHelper", 100, false));


    MD5 var_map_inneraliasboundedstringhelper_innerbitsethelper_hash("var_map_inneraliasboundedstringhelper_innerbitsethelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedstringhelper_innerbitsethelper.detail().name_hash()[i] = var_map_inneraliasboundedstringhelper_innerbitsethelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedstringhelper_innerbitsethelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerBitsetHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedStringHelperInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerBitsetHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedstringhelper_innerbitsethelper;
    cst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedstringhelper_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_string_helper", "InnerBitsetHelper", 100, true));


    cst_var_map_inneraliasboundedstringhelper_innerbitsethelper.detail().name("var_map_inneraliasboundedstringhelper_innerbitsethelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedstringhelper_innerbitsethelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedStringHelperInnerBitsetHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedStringHelperInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedStringHelperInnerBitsetHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperShort", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperShortObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperShortObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_short;
    mst_var_map_inneraliasboundedwstringhelper_short.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_short.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "int16_t", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_short_hash("var_map_inneraliasboundedwstringhelper_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_short.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperShort", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_short;
    cst_var_map_inneraliasboundedwstringhelper_short.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_short.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "int16_t", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_short.detail().name("var_map_inneraliasboundedwstringhelper_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperShort", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperUShort", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperUShortObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperUShortObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_ushort;
    mst_var_map_inneraliasboundedwstringhelper_ushort.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_ushort.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "uint16_t", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_ushort_hash("var_map_inneraliasboundedwstringhelper_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_ushort.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperUShort", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_ushort;
    cst_var_map_inneraliasboundedwstringhelper_ushort.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_ushort.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "uint16_t", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_ushort.detail().name("var_map_inneraliasboundedwstringhelper_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperUShort", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperLong", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperLongObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperLongObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_long;
    mst_var_map_inneraliasboundedwstringhelper_long.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_long.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "int32_t", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_long_hash("var_map_inneraliasboundedwstringhelper_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_long.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLong", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_long;
    cst_var_map_inneraliasboundedwstringhelper_long.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_long.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "int32_t", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_long.detail().name("var_map_inneraliasboundedwstringhelper_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLong", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperULong", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperULongObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperULongObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_ulong;
    mst_var_map_inneraliasboundedwstringhelper_ulong.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_ulong.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "uint32_t", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_ulong_hash("var_map_inneraliasboundedwstringhelper_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_ulong.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperULong", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_ulong;
    cst_var_map_inneraliasboundedwstringhelper_ulong.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_ulong.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "uint32_t", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_ulong.detail().name("var_map_inneraliasboundedwstringhelper_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperULong", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperLongLong", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperLongLongObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperLongLongObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_longlong;
    mst_var_map_inneraliasboundedwstringhelper_longlong.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_longlong.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "int64_t", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_longlong_hash("var_map_inneraliasboundedwstringhelper_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_longlong.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLongLong", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_longlong;
    cst_var_map_inneraliasboundedwstringhelper_longlong.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_longlong.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "int64_t", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_longlong.detail().name("var_map_inneraliasboundedwstringhelper_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLongLong", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperULongLong", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperULongLongObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperULongLongObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_ulonglong;
    mst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "uint64_t", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_ulonglong_hash("var_map_inneraliasboundedwstringhelper_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_ulonglong.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperULongLong", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_ulonglong;
    cst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "uint64_t", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_ulonglong.detail().name("var_map_inneraliasboundedwstringhelper_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperULongLong", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperFloat", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperFloatObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperFloatObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_float;
    mst_var_map_inneraliasboundedwstringhelper_float.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_float.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "float", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_float_hash("var_map_inneraliasboundedwstringhelper_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_float.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperFloat", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_float;
    cst_var_map_inneraliasboundedwstringhelper_float.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_float.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "float", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_float.detail().name("var_map_inneraliasboundedwstringhelper_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperFloat", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperDouble", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperDoubleObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperDoubleObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_double;
    mst_var_map_inneraliasboundedwstringhelper_double.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_double.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "double", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_double_hash("var_map_inneraliasboundedwstringhelper_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_double.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperDouble", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_double;
    cst_var_map_inneraliasboundedwstringhelper_double.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_double.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "double", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_double.detail().name("var_map_inneraliasboundedwstringhelper_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperDouble", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperLongDouble", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperLongDoubleObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperLongDoubleObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_longdouble;
    mst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "longdouble", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_longdouble_hash("var_map_inneraliasboundedwstringhelper_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_longdouble.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLongDouble", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_longdouble;
    cst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "longdouble", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_longdouble.detail().name("var_map_inneraliasboundedwstringhelper_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperLongDouble", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperBoolean", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperBooleanObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperBooleanObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_boolean;
    mst_var_map_inneraliasboundedwstringhelper_boolean.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_boolean.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "bool", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_boolean_hash("var_map_inneraliasboundedwstringhelper_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_boolean.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperBoolean", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_boolean;
    cst_var_map_inneraliasboundedwstringhelper_boolean.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_boolean.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "bool", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_boolean.detail().name("var_map_inneraliasboundedwstringhelper_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperBoolean", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperOctet", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperOctetObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperOctetObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_octet;
    mst_var_map_inneraliasboundedwstringhelper_octet.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_octet.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "uint8_t", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_octet_hash("var_map_inneraliasboundedwstringhelper_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_octet.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperOctet", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_octet;
    cst_var_map_inneraliasboundedwstringhelper_octet.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_octet.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "uint8_t", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_octet.detail().name("var_map_inneraliasboundedwstringhelper_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperOctet", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperChar", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperCharObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperCharObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_char;
    mst_var_map_inneraliasboundedwstringhelper_char.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_char.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "char", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_char_hash("var_map_inneraliasboundedwstringhelper_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_char.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperChar", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_char;
    cst_var_map_inneraliasboundedwstringhelper_char.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_char.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "char", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_char.detail().name("var_map_inneraliasboundedwstringhelper_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperChar", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperWChar", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperWCharObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperWCharObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_wchar;
    mst_var_map_inneraliasboundedwstringhelper_wchar.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_wchar.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "wchar_t", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_wchar_hash("var_map_inneraliasboundedwstringhelper_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_wchar.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperWChar", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_wchar;
    cst_var_map_inneraliasboundedwstringhelper_wchar.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_wchar.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "wchar_t", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_wchar.detail().name("var_map_inneraliasboundedwstringhelper_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperWChar", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperString", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperStringObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperStringObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_string;
    mst_var_map_inneraliasboundedwstringhelper_string.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_string.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", TypeNamesGenerator::get_string_type_name(255, false), 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_string_hash("var_map_inneraliasboundedwstringhelper_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_string.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperString", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_string;
    cst_var_map_inneraliasboundedwstringhelper_string.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_string.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", TypeNamesGenerator::get_string_type_name(255, false), 100, true));


    cst_var_map_inneraliasboundedwstringhelper_string.detail().name("var_map_inneraliasboundedwstringhelper_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperString", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperWString", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperWStringObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperWStringObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_wstring;
    mst_var_map_inneraliasboundedwstringhelper_wstring.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_wstring.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", TypeNamesGenerator::get_string_type_name(255, true), 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_wstring_hash("var_map_inneraliasboundedwstringhelper_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_wstring.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperWString", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_wstring;
    cst_var_map_inneraliasboundedwstringhelper_wstring.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_wstring.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", TypeNamesGenerator::get_string_type_name(255, true), 100, true));


    cst_var_map_inneraliasboundedwstringhelper_wstring.detail().name("var_map_inneraliasboundedwstringhelper_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperWString", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper;
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "Inner_alias_bounded_string_helper", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper_hash("var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper;
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "Inner_alias_bounded_string_helper", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper.detail().name("var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper;
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "Inner_alias_bounded_wstring_helper", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper_hash("var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper;
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "Inner_alias_bounded_wstring_helper", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper.detail().name("var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperInnerEnumHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerEnumHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperInnerEnumHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerEnumHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperInnerEnumHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerEnumHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperInnerEnumHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperInnerEnumHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerEnumHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_innerenumhelper;
    mst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "InnerEnumHelper", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_innerenumhelper_hash("var_map_inneraliasboundedwstringhelper_innerenumhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_innerenumhelper.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_innerenumhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_innerenumhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerEnumHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerEnumHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_innerenumhelper;
    cst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_innerenumhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "InnerEnumHelper", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_innerenumhelper.detail().name("var_map_inneraliasboundedwstringhelper_innerenumhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_innerenumhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperInnerEnumHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerEnumHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperInnerBitMaskHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerBitMaskHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperInnerBitMaskHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerBitMaskHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperInnerBitMaskHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerBitMaskHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperInnerBitMaskHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperInnerBitMaskHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerBitMaskHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper;
    mst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "InnerBitMaskHelper", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_innerbitmaskhelper_hash("var_map_inneraliasboundedwstringhelper_innerbitmaskhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_innerbitmaskhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerBitMaskHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerBitMaskHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper;
    cst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "InnerBitMaskHelper", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper.detail().name("var_map_inneraliasboundedwstringhelper_innerbitmaskhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_innerbitmaskhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperInnerBitMaskHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerBitMaskHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperInnerAliasHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerAliasHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperInnerAliasHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerAliasHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperInnerAliasHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperInnerAliasHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperInnerAliasHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_inneraliashelper;
    mst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "InnerAliasHelper", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_inneraliashelper_hash("var_map_inneraliasboundedwstringhelper_inneraliashelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_inneraliashelper.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_inneraliashelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_inneraliashelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_inneraliashelper;
    cst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_inneraliashelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "InnerAliasHelper", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_inneraliashelper.detail().name("var_map_inneraliasboundedwstringhelper_inneraliashelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_inneraliashelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperInnerAliasHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperInnerAliasArrayHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperInnerAliasArrayHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperInnerAliasArrayHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperInnerAliasArrayHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperInnerAliasArrayHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper;
    mst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "Inner_alias_array_helper", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper_hash("var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperInnerAliasArrayHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper;
    cst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "Inner_alias_array_helper", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper.detail().name("var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperInnerAliasSequenceHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperInnerAliasSequenceHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperInnerAliasSequenceHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperInnerAliasSequenceHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperInnerAliasSequenceHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper;
    mst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "Inner_alias_sequence_helper", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_inneraliassequencehelper_hash("var_map_inneraliasboundedwstringhelper_inneraliassequencehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_inneraliassequencehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperInnerAliasSequenceHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper;
    cst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "Inner_alias_sequence_helper", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper.detail().name("var_map_inneraliasboundedwstringhelper_inneraliassequencehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_inneraliassequencehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperInnerAliasMapHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerAliasMapHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperInnerAliasMapHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerAliasMapHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperInnerAliasMapHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasMapHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperInnerAliasMapHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperInnerAliasMapHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasMapHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper;
    mst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "Inner_alias_map_helper", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_inneraliasmaphelper_hash("var_map_inneraliasboundedwstringhelper_inneraliasmaphelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_inneraliasmaphelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasMapHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperInnerAliasMapHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasMapHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper;
    cst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "Inner_alias_map_helper", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper.detail().name("var_map_inneraliasboundedwstringhelper_inneraliasmaphelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_inneraliasmaphelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperInnerAliasMapHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerAliasMapHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerAliasMapHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperInnerUnionHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerUnionHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperInnerUnionHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerUnionHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperInnerUnionHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerUnionHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperInnerUnionHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperInnerUnionHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerUnionHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_innerunionhelper;
    mst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "InnerUnionHelper", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_innerunionhelper_hash("var_map_inneraliasboundedwstringhelper_innerunionhelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_innerunionhelper.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_innerunionhelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_innerunionhelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerUnionHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerUnionHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_innerunionhelper;
    cst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_innerunionhelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "InnerUnionHelper", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_innerunionhelper.detail().name("var_map_inneraliasboundedwstringhelper_innerunionhelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_innerunionhelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperInnerUnionHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerUnionHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperInnerStructureHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerStructureHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperInnerStructureHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerStructureHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperInnerStructureHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerStructureHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperInnerStructureHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperInnerStructureHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerStructureHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_innerstructurehelper;
    mst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "InnerStructureHelper", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_innerstructurehelper_hash("var_map_inneraliasboundedwstringhelper_innerstructurehelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_innerstructurehelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_innerstructurehelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerStructureHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerStructureHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_innerstructurehelper;
    cst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "InnerStructureHelper", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_innerstructurehelper.detail().name("var_map_inneraliasboundedwstringhelper_innerstructurehelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_innerstructurehelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperInnerStructureHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerStructureHelper", true);
}

const TypeIdentifier* GetMapInnerAliasBoundedWStringHelperInnerBitsetHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerBitsetHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapInnerAliasBoundedWStringHelperInnerBitsetHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapInnerAliasBoundedWStringHelperInnerBitsetHelper", complete);
}

const TypeObject* GetMapInnerAliasBoundedWStringHelperInnerBitsetHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerBitsetHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapInnerAliasBoundedWStringHelperInnerBitsetHelperObject();
    }
    //else
    return GetMinimalMapInnerAliasBoundedWStringHelperInnerBitsetHelperObject();
}

const TypeObject* GetMinimalMapInnerAliasBoundedWStringHelperInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerBitsetHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map_inneraliasboundedwstringhelper_innerbitsethelper;
    mst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_id(memberId++);
    mst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    mst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_flags().IS_KEY(false);
    mst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "InnerBitsetHelper", 100, false));


    MD5 var_map_inneraliasboundedwstringhelper_innerbitsethelper_hash("var_map_inneraliasboundedwstringhelper_innerbitsethelper");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.detail().name_hash()[i] = var_map_inneraliasboundedwstringhelper_innerbitsethelper_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map_inneraliasboundedwstringhelper_innerbitsethelper);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerBitsetHelper", false);
}

const TypeObject* GetCompleteMapInnerAliasBoundedWStringHelperInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerBitsetHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map_inneraliasboundedwstringhelper_innerbitsethelper;
    cst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_id(memberId++);
    cst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_flags().IS_OPTIONAL(false);
    cst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_flags().IS_KEY(false);
    cst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("Inner_alias_bounded_wstring_helper", "InnerBitsetHelper", 100, true));


    cst_var_map_inneraliasboundedwstringhelper_innerbitsethelper.detail().name("var_map_inneraliasboundedwstringhelper_innerbitsethelper");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map_inneraliasboundedwstringhelper_innerbitsethelper);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapInnerAliasBoundedWStringHelperInnerBitsetHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapInnerAliasBoundedWStringHelperInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapInnerAliasBoundedWStringHelperInnerBitsetHelper", true);
}

const TypeIdentifier* GetBoundedSmallMapIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("BoundedSmallMap", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBoundedSmallMapObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("BoundedSmallMap", complete);
}

const TypeObject* GetBoundedSmallMapObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedSmallMap", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBoundedSmallMapObject();
    }
    //else
    return GetMinimalBoundedSmallMapObject();
}

const TypeObject* GetMinimalBoundedSmallMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedSmallMap", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_small_map;
    mst_var_small_map.common().member_id(memberId++);
    mst_var_small_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_small_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_small_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_small_map.common().member_flags().IS_OPTIONAL(false);
    mst_var_small_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_small_map.common().member_flags().IS_KEY(false);
    mst_var_small_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_small_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int32_t", 1, false));


    MD5 var_small_map_hash("var_small_map");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_small_map.detail().name_hash()[i] = var_small_map_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_small_map);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedSmallMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedSmallMap", false);
}

const TypeObject* GetCompleteBoundedSmallMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedSmallMap", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_small_map;
    cst_var_small_map.common().member_id(memberId++);
    cst_var_small_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_small_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_small_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_small_map.common().member_flags().IS_OPTIONAL(false);
    cst_var_small_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_small_map.common().member_flags().IS_KEY(false);
    cst_var_small_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_small_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int32_t", 1, true));


    cst_var_small_map.detail().name("var_small_map");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_small_map);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BoundedSmallMap");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedSmallMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedSmallMap", true);
}

const TypeIdentifier* GetBoundedLargeMapIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("BoundedLargeMap", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBoundedLargeMapObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("BoundedLargeMap", complete);
}

const TypeObject* GetBoundedLargeMapObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedLargeMap", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBoundedLargeMapObject();
    }
    //else
    return GetMinimalBoundedLargeMapObject();
}

const TypeObject* GetMinimalBoundedLargeMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedLargeMap", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_large_map;
    mst_var_large_map.common().member_id(memberId++);
    mst_var_large_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_large_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_large_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_large_map.common().member_flags().IS_OPTIONAL(false);
    mst_var_large_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_large_map.common().member_flags().IS_KEY(false);
    mst_var_large_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_large_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int32_t", 41925, false));


    MD5 var_large_map_hash("var_large_map");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_large_map.detail().name_hash()[i] = var_large_map_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_large_map);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedLargeMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedLargeMap", false);
}

const TypeObject* GetCompleteBoundedLargeMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedLargeMap", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_large_map;
    cst_var_large_map.common().member_id(memberId++);
    cst_var_large_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_large_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_large_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_large_map.common().member_flags().IS_OPTIONAL(false);
    cst_var_large_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_large_map.common().member_flags().IS_KEY(false);
    cst_var_large_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_large_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int32_t", 41925, true));


    cst_var_large_map.detail().name("var_large_map");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_large_map);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BoundedLargeMap");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedLargeMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedLargeMap", true);
}
