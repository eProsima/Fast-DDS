// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file mutable.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "mutable.h"
#include "mutableTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define ULongStruct_max_cdr_typesize 4ULL;
#define FloatStruct_max_cdr_typesize 4ULL;
#define LongDoubleStruct_max_cdr_typesize 16ULL;
#define OctetStruct_max_cdr_typesize 1ULL;
#define LongStruct_max_cdr_typesize 4ULL;
#define InheritanceStruct_max_cdr_typesize 264ULL;
#define ShortStruct_max_cdr_typesize 2ULL;
#define UShortStruct_max_cdr_typesize 2ULL;
#define EmptyInheritanceStruct_max_cdr_typesize 260ULL;
#define EmptyStruct_max_cdr_typesize 0ULL;
#define DoubleStruct_max_cdr_typesize 8ULL;
#define ULongLongStruct_max_cdr_typesize 8ULL;
#define BooleanStruct_max_cdr_typesize 1ULL;
#define CharStruct_max_cdr_typesize 1ULL;
#define WCharStruct_max_cdr_typesize 4ULL;
#define InheritanceEmptyStruct_max_cdr_typesize 2ULL;
#define LongLongStruct_max_cdr_typesize 8ULL;
#define ULongStruct_max_key_cdr_typesize 0ULL;
#define FloatStruct_max_key_cdr_typesize 0ULL;
#define LongDoubleStruct_max_key_cdr_typesize 0ULL;
#define OctetStruct_max_key_cdr_typesize 0ULL;
#define LongStruct_max_key_cdr_typesize 0ULL;
#define InheritanceStruct_max_key_cdr_typesize 0ULL;
#define ShortStruct_max_key_cdr_typesize 0ULL;
#define UShortStruct_max_key_cdr_typesize 0ULL;
#define EmptyInheritanceStruct_max_key_cdr_typesize 0ULL;
#define EmptyStruct_max_key_cdr_typesize 0ULL;
#define DoubleStruct_max_key_cdr_typesize 0ULL;
#define ULongLongStruct_max_key_cdr_typesize 0ULL;
#define BooleanStruct_max_key_cdr_typesize 0ULL;
#define CharStruct_max_key_cdr_typesize 0ULL;
#define WCharStruct_max_key_cdr_typesize 0ULL;
#define InheritanceEmptyStruct_max_key_cdr_typesize 0ULL;
#define LongLongStruct_max_key_cdr_typesize 0ULL;

ShortStruct::ShortStruct()
{
    // short m_var_short
    m_var_short = 0;

    // Just to register all known types
    registermutableTypes();
}

ShortStruct::~ShortStruct()
{
}

ShortStruct::ShortStruct(
        const ShortStruct& x)
{
    m_var_short = x.m_var_short;
}

ShortStruct::ShortStruct(
        ShortStruct&& x) noexcept 
{
    m_var_short = x.m_var_short;
}

ShortStruct& ShortStruct::operator =(
        const ShortStruct& x)
{

    m_var_short = x.m_var_short;

    return *this;
}

ShortStruct& ShortStruct::operator =(
        ShortStruct&& x) noexcept
{

    m_var_short = x.m_var_short;

    return *this;
}

bool ShortStruct::operator ==(
        const ShortStruct& x) const
{

    return (m_var_short == x.m_var_short);
}

bool ShortStruct::operator !=(
        const ShortStruct& x) const
{
    return !(*this == x);
}

size_t ShortStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ShortStruct_max_cdr_typesize;
}

size_t ShortStruct::getCdrSerializedSize(
        const ShortStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void ShortStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_short;
}

void ShortStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_short;
}

/*!
 * @brief This function sets a value in member var_short
 * @param _var_short New value for member var_short
 */
void ShortStruct::var_short(
        int16_t _var_short)
{
    m_var_short = _var_short;
}

/*!
 * @brief This function returns the value of member var_short
 * @return Value of member var_short
 */
int16_t ShortStruct::var_short() const
{
    return m_var_short;
}

/*!
 * @brief This function returns a reference to member var_short
 * @return Reference to member var_short
 */
int16_t& ShortStruct::var_short()
{
    return m_var_short;
}



size_t ShortStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ShortStruct_max_key_cdr_typesize;
}

bool ShortStruct::isKeyDefined()
{
    return false;
}

void ShortStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UShortStruct::UShortStruct()
{
    // unsigned short m_var_ushort
    m_var_ushort = 0;

    // Just to register all known types
    registermutableTypes();
}

UShortStruct::~UShortStruct()
{
}

UShortStruct::UShortStruct(
        const UShortStruct& x)
{
    m_var_ushort = x.m_var_ushort;
}

UShortStruct::UShortStruct(
        UShortStruct&& x) noexcept 
{
    m_var_ushort = x.m_var_ushort;
}

UShortStruct& UShortStruct::operator =(
        const UShortStruct& x)
{

    m_var_ushort = x.m_var_ushort;

    return *this;
}

UShortStruct& UShortStruct::operator =(
        UShortStruct&& x) noexcept
{

    m_var_ushort = x.m_var_ushort;

    return *this;
}

bool UShortStruct::operator ==(
        const UShortStruct& x) const
{

    return (m_var_ushort == x.m_var_ushort);
}

bool UShortStruct::operator !=(
        const UShortStruct& x) const
{
    return !(*this == x);
}

size_t UShortStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UShortStruct_max_cdr_typesize;
}

size_t UShortStruct::getCdrSerializedSize(
        const UShortStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void UShortStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ushort;
}

void UShortStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ushort;
}

/*!
 * @brief This function sets a value in member var_ushort
 * @param _var_ushort New value for member var_ushort
 */
void UShortStruct::var_ushort(
        uint16_t _var_ushort)
{
    m_var_ushort = _var_ushort;
}

/*!
 * @brief This function returns the value of member var_ushort
 * @return Value of member var_ushort
 */
uint16_t UShortStruct::var_ushort() const
{
    return m_var_ushort;
}

/*!
 * @brief This function returns a reference to member var_ushort
 * @return Reference to member var_ushort
 */
uint16_t& UShortStruct::var_ushort()
{
    return m_var_ushort;
}



size_t UShortStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UShortStruct_max_key_cdr_typesize;
}

bool UShortStruct::isKeyDefined()
{
    return false;
}

void UShortStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


LongStruct::LongStruct()
{
    // long m_var_long
    m_var_long = 0;

    // Just to register all known types
    registermutableTypes();
}

LongStruct::~LongStruct()
{
}

LongStruct::LongStruct(
        const LongStruct& x)
{
    m_var_long = x.m_var_long;
}

LongStruct::LongStruct(
        LongStruct&& x) noexcept 
{
    m_var_long = x.m_var_long;
}

LongStruct& LongStruct::operator =(
        const LongStruct& x)
{

    m_var_long = x.m_var_long;

    return *this;
}

LongStruct& LongStruct::operator =(
        LongStruct&& x) noexcept
{

    m_var_long = x.m_var_long;

    return *this;
}

bool LongStruct::operator ==(
        const LongStruct& x) const
{

    return (m_var_long == x.m_var_long);
}

bool LongStruct::operator !=(
        const LongStruct& x) const
{
    return !(*this == x);
}

size_t LongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LongStruct_max_cdr_typesize;
}

size_t LongStruct::getCdrSerializedSize(
        const LongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void LongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_long;
}

void LongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_long;
}

/*!
 * @brief This function sets a value in member var_long
 * @param _var_long New value for member var_long
 */
void LongStruct::var_long(
        int32_t _var_long)
{
    m_var_long = _var_long;
}

/*!
 * @brief This function returns the value of member var_long
 * @return Value of member var_long
 */
int32_t LongStruct::var_long() const
{
    return m_var_long;
}

/*!
 * @brief This function returns a reference to member var_long
 * @return Reference to member var_long
 */
int32_t& LongStruct::var_long()
{
    return m_var_long;
}



size_t LongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LongStruct_max_key_cdr_typesize;
}

bool LongStruct::isKeyDefined()
{
    return false;
}

void LongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ULongStruct::ULongStruct()
{
    // unsigned long m_var_ulong
    m_var_ulong = 0;

    // Just to register all known types
    registermutableTypes();
}

ULongStruct::~ULongStruct()
{
}

ULongStruct::ULongStruct(
        const ULongStruct& x)
{
    m_var_ulong = x.m_var_ulong;
}

ULongStruct::ULongStruct(
        ULongStruct&& x) noexcept 
{
    m_var_ulong = x.m_var_ulong;
}

ULongStruct& ULongStruct::operator =(
        const ULongStruct& x)
{

    m_var_ulong = x.m_var_ulong;

    return *this;
}

ULongStruct& ULongStruct::operator =(
        ULongStruct&& x) noexcept
{

    m_var_ulong = x.m_var_ulong;

    return *this;
}

bool ULongStruct::operator ==(
        const ULongStruct& x) const
{

    return (m_var_ulong == x.m_var_ulong);
}

bool ULongStruct::operator !=(
        const ULongStruct& x) const
{
    return !(*this == x);
}

size_t ULongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ULongStruct_max_cdr_typesize;
}

size_t ULongStruct::getCdrSerializedSize(
        const ULongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void ULongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ulong;
}

void ULongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ulong;
}

/*!
 * @brief This function sets a value in member var_ulong
 * @param _var_ulong New value for member var_ulong
 */
void ULongStruct::var_ulong(
        uint32_t _var_ulong)
{
    m_var_ulong = _var_ulong;
}

/*!
 * @brief This function returns the value of member var_ulong
 * @return Value of member var_ulong
 */
uint32_t ULongStruct::var_ulong() const
{
    return m_var_ulong;
}

/*!
 * @brief This function returns a reference to member var_ulong
 * @return Reference to member var_ulong
 */
uint32_t& ULongStruct::var_ulong()
{
    return m_var_ulong;
}



size_t ULongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ULongStruct_max_key_cdr_typesize;
}

bool ULongStruct::isKeyDefined()
{
    return false;
}

void ULongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


LongLongStruct::LongLongStruct()
{
    // long long m_var_longlong
    m_var_longlong = 0;

    // Just to register all known types
    registermutableTypes();
}

LongLongStruct::~LongLongStruct()
{
}

LongLongStruct::LongLongStruct(
        const LongLongStruct& x)
{
    m_var_longlong = x.m_var_longlong;
}

LongLongStruct::LongLongStruct(
        LongLongStruct&& x) noexcept 
{
    m_var_longlong = x.m_var_longlong;
}

LongLongStruct& LongLongStruct::operator =(
        const LongLongStruct& x)
{

    m_var_longlong = x.m_var_longlong;

    return *this;
}

LongLongStruct& LongLongStruct::operator =(
        LongLongStruct&& x) noexcept
{

    m_var_longlong = x.m_var_longlong;

    return *this;
}

bool LongLongStruct::operator ==(
        const LongLongStruct& x) const
{

    return (m_var_longlong == x.m_var_longlong);
}

bool LongLongStruct::operator !=(
        const LongLongStruct& x) const
{
    return !(*this == x);
}

size_t LongLongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LongLongStruct_max_cdr_typesize;
}

size_t LongLongStruct::getCdrSerializedSize(
        const LongLongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void LongLongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_longlong;
}

void LongLongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_longlong;
}

/*!
 * @brief This function sets a value in member var_longlong
 * @param _var_longlong New value for member var_longlong
 */
void LongLongStruct::var_longlong(
        int64_t _var_longlong)
{
    m_var_longlong = _var_longlong;
}

/*!
 * @brief This function returns the value of member var_longlong
 * @return Value of member var_longlong
 */
int64_t LongLongStruct::var_longlong() const
{
    return m_var_longlong;
}

/*!
 * @brief This function returns a reference to member var_longlong
 * @return Reference to member var_longlong
 */
int64_t& LongLongStruct::var_longlong()
{
    return m_var_longlong;
}



size_t LongLongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LongLongStruct_max_key_cdr_typesize;
}

bool LongLongStruct::isKeyDefined()
{
    return false;
}

void LongLongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ULongLongStruct::ULongLongStruct()
{
    // unsigned long long m_var_ulonglong
    m_var_ulonglong = 0;

    // Just to register all known types
    registermutableTypes();
}

ULongLongStruct::~ULongLongStruct()
{
}

ULongLongStruct::ULongLongStruct(
        const ULongLongStruct& x)
{
    m_var_ulonglong = x.m_var_ulonglong;
}

ULongLongStruct::ULongLongStruct(
        ULongLongStruct&& x) noexcept 
{
    m_var_ulonglong = x.m_var_ulonglong;
}

ULongLongStruct& ULongLongStruct::operator =(
        const ULongLongStruct& x)
{

    m_var_ulonglong = x.m_var_ulonglong;

    return *this;
}

ULongLongStruct& ULongLongStruct::operator =(
        ULongLongStruct&& x) noexcept
{

    m_var_ulonglong = x.m_var_ulonglong;

    return *this;
}

bool ULongLongStruct::operator ==(
        const ULongLongStruct& x) const
{

    return (m_var_ulonglong == x.m_var_ulonglong);
}

bool ULongLongStruct::operator !=(
        const ULongLongStruct& x) const
{
    return !(*this == x);
}

size_t ULongLongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ULongLongStruct_max_cdr_typesize;
}

size_t ULongLongStruct::getCdrSerializedSize(
        const ULongLongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void ULongLongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ulonglong;
}

void ULongLongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ulonglong;
}

/*!
 * @brief This function sets a value in member var_ulonglong
 * @param _var_ulonglong New value for member var_ulonglong
 */
void ULongLongStruct::var_ulonglong(
        uint64_t _var_ulonglong)
{
    m_var_ulonglong = _var_ulonglong;
}

/*!
 * @brief This function returns the value of member var_ulonglong
 * @return Value of member var_ulonglong
 */
uint64_t ULongLongStruct::var_ulonglong() const
{
    return m_var_ulonglong;
}

/*!
 * @brief This function returns a reference to member var_ulonglong
 * @return Reference to member var_ulonglong
 */
uint64_t& ULongLongStruct::var_ulonglong()
{
    return m_var_ulonglong;
}



size_t ULongLongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ULongLongStruct_max_key_cdr_typesize;
}

bool ULongLongStruct::isKeyDefined()
{
    return false;
}

void ULongLongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FloatStruct::FloatStruct()
{
    // float m_var_float
    m_var_float = 0.0;

    // Just to register all known types
    registermutableTypes();
}

FloatStruct::~FloatStruct()
{
}

FloatStruct::FloatStruct(
        const FloatStruct& x)
{
    m_var_float = x.m_var_float;
}

FloatStruct::FloatStruct(
        FloatStruct&& x) noexcept 
{
    m_var_float = x.m_var_float;
}

FloatStruct& FloatStruct::operator =(
        const FloatStruct& x)
{

    m_var_float = x.m_var_float;

    return *this;
}

FloatStruct& FloatStruct::operator =(
        FloatStruct&& x) noexcept
{

    m_var_float = x.m_var_float;

    return *this;
}

bool FloatStruct::operator ==(
        const FloatStruct& x) const
{

    return (m_var_float == x.m_var_float);
}

bool FloatStruct::operator !=(
        const FloatStruct& x) const
{
    return !(*this == x);
}

size_t FloatStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FloatStruct_max_cdr_typesize;
}

size_t FloatStruct::getCdrSerializedSize(
        const FloatStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void FloatStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_float;
}

void FloatStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_float;
}

/*!
 * @brief This function sets a value in member var_float
 * @param _var_float New value for member var_float
 */
void FloatStruct::var_float(
        float _var_float)
{
    m_var_float = _var_float;
}

/*!
 * @brief This function returns the value of member var_float
 * @return Value of member var_float
 */
float FloatStruct::var_float() const
{
    return m_var_float;
}

/*!
 * @brief This function returns a reference to member var_float
 * @return Reference to member var_float
 */
float& FloatStruct::var_float()
{
    return m_var_float;
}



size_t FloatStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FloatStruct_max_key_cdr_typesize;
}

bool FloatStruct::isKeyDefined()
{
    return false;
}

void FloatStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


DoubleStruct::DoubleStruct()
{
    // double m_var_double
    m_var_double = 0.0;

    // Just to register all known types
    registermutableTypes();
}

DoubleStruct::~DoubleStruct()
{
}

DoubleStruct::DoubleStruct(
        const DoubleStruct& x)
{
    m_var_double = x.m_var_double;
}

DoubleStruct::DoubleStruct(
        DoubleStruct&& x) noexcept 
{
    m_var_double = x.m_var_double;
}

DoubleStruct& DoubleStruct::operator =(
        const DoubleStruct& x)
{

    m_var_double = x.m_var_double;

    return *this;
}

DoubleStruct& DoubleStruct::operator =(
        DoubleStruct&& x) noexcept
{

    m_var_double = x.m_var_double;

    return *this;
}

bool DoubleStruct::operator ==(
        const DoubleStruct& x) const
{

    return (m_var_double == x.m_var_double);
}

bool DoubleStruct::operator !=(
        const DoubleStruct& x) const
{
    return !(*this == x);
}

size_t DoubleStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return DoubleStruct_max_cdr_typesize;
}

size_t DoubleStruct::getCdrSerializedSize(
        const DoubleStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void DoubleStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_double;
}

void DoubleStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_double;
}

/*!
 * @brief This function sets a value in member var_double
 * @param _var_double New value for member var_double
 */
void DoubleStruct::var_double(
        double _var_double)
{
    m_var_double = _var_double;
}

/*!
 * @brief This function returns the value of member var_double
 * @return Value of member var_double
 */
double DoubleStruct::var_double() const
{
    return m_var_double;
}

/*!
 * @brief This function returns a reference to member var_double
 * @return Reference to member var_double
 */
double& DoubleStruct::var_double()
{
    return m_var_double;
}



size_t DoubleStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return DoubleStruct_max_key_cdr_typesize;
}

bool DoubleStruct::isKeyDefined()
{
    return false;
}

void DoubleStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


LongDoubleStruct::LongDoubleStruct()
{
    // long double m_var_longdouble
    m_var_longdouble = 0.0;

    // Just to register all known types
    registermutableTypes();
}

LongDoubleStruct::~LongDoubleStruct()
{
}

LongDoubleStruct::LongDoubleStruct(
        const LongDoubleStruct& x)
{
    m_var_longdouble = x.m_var_longdouble;
}

LongDoubleStruct::LongDoubleStruct(
        LongDoubleStruct&& x) noexcept 
{
    m_var_longdouble = x.m_var_longdouble;
}

LongDoubleStruct& LongDoubleStruct::operator =(
        const LongDoubleStruct& x)
{

    m_var_longdouble = x.m_var_longdouble;

    return *this;
}

LongDoubleStruct& LongDoubleStruct::operator =(
        LongDoubleStruct&& x) noexcept
{

    m_var_longdouble = x.m_var_longdouble;

    return *this;
}

bool LongDoubleStruct::operator ==(
        const LongDoubleStruct& x) const
{

    return (m_var_longdouble == x.m_var_longdouble);
}

bool LongDoubleStruct::operator !=(
        const LongDoubleStruct& x) const
{
    return !(*this == x);
}

size_t LongDoubleStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LongDoubleStruct_max_cdr_typesize;
}

size_t LongDoubleStruct::getCdrSerializedSize(
        const LongDoubleStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 16 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8); // 128 bits, but aligned as 64


    return current_alignment - initial_alignment;
}

void LongDoubleStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_longdouble;
}

void LongDoubleStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_longdouble;
}

/*!
 * @brief This function sets a value in member var_longdouble
 * @param _var_longdouble New value for member var_longdouble
 */
void LongDoubleStruct::var_longdouble(
        long double _var_longdouble)
{
    m_var_longdouble = _var_longdouble;
}

/*!
 * @brief This function returns the value of member var_longdouble
 * @return Value of member var_longdouble
 */
long double LongDoubleStruct::var_longdouble() const
{
    return m_var_longdouble;
}

/*!
 * @brief This function returns a reference to member var_longdouble
 * @return Reference to member var_longdouble
 */
long double& LongDoubleStruct::var_longdouble()
{
    return m_var_longdouble;
}



size_t LongDoubleStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LongDoubleStruct_max_key_cdr_typesize;
}

bool LongDoubleStruct::isKeyDefined()
{
    return false;
}

void LongDoubleStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


BooleanStruct::BooleanStruct()
{
    // boolean m_var_boolean
    m_var_boolean = false;

    // Just to register all known types
    registermutableTypes();
}

BooleanStruct::~BooleanStruct()
{
}

BooleanStruct::BooleanStruct(
        const BooleanStruct& x)
{
    m_var_boolean = x.m_var_boolean;
}

BooleanStruct::BooleanStruct(
        BooleanStruct&& x) noexcept 
{
    m_var_boolean = x.m_var_boolean;
}

BooleanStruct& BooleanStruct::operator =(
        const BooleanStruct& x)
{

    m_var_boolean = x.m_var_boolean;

    return *this;
}

BooleanStruct& BooleanStruct::operator =(
        BooleanStruct&& x) noexcept
{

    m_var_boolean = x.m_var_boolean;

    return *this;
}

bool BooleanStruct::operator ==(
        const BooleanStruct& x) const
{

    return (m_var_boolean == x.m_var_boolean);
}

bool BooleanStruct::operator !=(
        const BooleanStruct& x) const
{
    return !(*this == x);
}

size_t BooleanStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BooleanStruct_max_cdr_typesize;
}

size_t BooleanStruct::getCdrSerializedSize(
        const BooleanStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void BooleanStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_boolean;
}

void BooleanStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_boolean;
}

/*!
 * @brief This function sets a value in member var_boolean
 * @param _var_boolean New value for member var_boolean
 */
void BooleanStruct::var_boolean(
        bool _var_boolean)
{
    m_var_boolean = _var_boolean;
}

/*!
 * @brief This function returns the value of member var_boolean
 * @return Value of member var_boolean
 */
bool BooleanStruct::var_boolean() const
{
    return m_var_boolean;
}

/*!
 * @brief This function returns a reference to member var_boolean
 * @return Reference to member var_boolean
 */
bool& BooleanStruct::var_boolean()
{
    return m_var_boolean;
}



size_t BooleanStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BooleanStruct_max_key_cdr_typesize;
}

bool BooleanStruct::isKeyDefined()
{
    return false;
}

void BooleanStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


OctetStruct::OctetStruct()
{
    // octet m_var_octet
    m_var_octet = 0;

    // Just to register all known types
    registermutableTypes();
}

OctetStruct::~OctetStruct()
{
}

OctetStruct::OctetStruct(
        const OctetStruct& x)
{
    m_var_octet = x.m_var_octet;
}

OctetStruct::OctetStruct(
        OctetStruct&& x) noexcept 
{
    m_var_octet = x.m_var_octet;
}

OctetStruct& OctetStruct::operator =(
        const OctetStruct& x)
{

    m_var_octet = x.m_var_octet;

    return *this;
}

OctetStruct& OctetStruct::operator =(
        OctetStruct&& x) noexcept
{

    m_var_octet = x.m_var_octet;

    return *this;
}

bool OctetStruct::operator ==(
        const OctetStruct& x) const
{

    return (m_var_octet == x.m_var_octet);
}

bool OctetStruct::operator !=(
        const OctetStruct& x) const
{
    return !(*this == x);
}

size_t OctetStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return OctetStruct_max_cdr_typesize;
}

size_t OctetStruct::getCdrSerializedSize(
        const OctetStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void OctetStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_octet;
}

void OctetStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_octet;
}

/*!
 * @brief This function sets a value in member var_octet
 * @param _var_octet New value for member var_octet
 */
void OctetStruct::var_octet(
        uint8_t _var_octet)
{
    m_var_octet = _var_octet;
}

/*!
 * @brief This function returns the value of member var_octet
 * @return Value of member var_octet
 */
uint8_t OctetStruct::var_octet() const
{
    return m_var_octet;
}

/*!
 * @brief This function returns a reference to member var_octet
 * @return Reference to member var_octet
 */
uint8_t& OctetStruct::var_octet()
{
    return m_var_octet;
}



size_t OctetStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return OctetStruct_max_key_cdr_typesize;
}

bool OctetStruct::isKeyDefined()
{
    return false;
}

void OctetStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


CharStruct::CharStruct()
{
    // char m_var_char8
    m_var_char8 = 0;

    // Just to register all known types
    registermutableTypes();
}

CharStruct::~CharStruct()
{
}

CharStruct::CharStruct(
        const CharStruct& x)
{
    m_var_char8 = x.m_var_char8;
}

CharStruct::CharStruct(
        CharStruct&& x) noexcept 
{
    m_var_char8 = x.m_var_char8;
}

CharStruct& CharStruct::operator =(
        const CharStruct& x)
{

    m_var_char8 = x.m_var_char8;

    return *this;
}

CharStruct& CharStruct::operator =(
        CharStruct&& x) noexcept
{

    m_var_char8 = x.m_var_char8;

    return *this;
}

bool CharStruct::operator ==(
        const CharStruct& x) const
{

    return (m_var_char8 == x.m_var_char8);
}

bool CharStruct::operator !=(
        const CharStruct& x) const
{
    return !(*this == x);
}

size_t CharStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return CharStruct_max_cdr_typesize;
}

size_t CharStruct::getCdrSerializedSize(
        const CharStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void CharStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_char8;
}

void CharStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_char8;
}

/*!
 * @brief This function sets a value in member var_char8
 * @param _var_char8 New value for member var_char8
 */
void CharStruct::var_char8(
        char _var_char8)
{
    m_var_char8 = _var_char8;
}

/*!
 * @brief This function returns the value of member var_char8
 * @return Value of member var_char8
 */
char CharStruct::var_char8() const
{
    return m_var_char8;
}

/*!
 * @brief This function returns a reference to member var_char8
 * @return Reference to member var_char8
 */
char& CharStruct::var_char8()
{
    return m_var_char8;
}



size_t CharStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return CharStruct_max_key_cdr_typesize;
}

bool CharStruct::isKeyDefined()
{
    return false;
}

void CharStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


WCharStruct::WCharStruct()
{
    // wchar m_var_char16
    m_var_char16 = 0;

    // Just to register all known types
    registermutableTypes();
}

WCharStruct::~WCharStruct()
{
}

WCharStruct::WCharStruct(
        const WCharStruct& x)
{
    m_var_char16 = x.m_var_char16;
}

WCharStruct::WCharStruct(
        WCharStruct&& x) noexcept 
{
    m_var_char16 = x.m_var_char16;
}

WCharStruct& WCharStruct::operator =(
        const WCharStruct& x)
{

    m_var_char16 = x.m_var_char16;

    return *this;
}

WCharStruct& WCharStruct::operator =(
        WCharStruct&& x) noexcept
{

    m_var_char16 = x.m_var_char16;

    return *this;
}

bool WCharStruct::operator ==(
        const WCharStruct& x) const
{

    return (m_var_char16 == x.m_var_char16);
}

bool WCharStruct::operator !=(
        const WCharStruct& x) const
{
    return !(*this == x);
}

size_t WCharStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return WCharStruct_max_cdr_typesize;
}

size_t WCharStruct::getCdrSerializedSize(
        const WCharStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void WCharStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_char16;
}

void WCharStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_char16;
}

/*!
 * @brief This function sets a value in member var_char16
 * @param _var_char16 New value for member var_char16
 */
void WCharStruct::var_char16(
        wchar_t _var_char16)
{
    m_var_char16 = _var_char16;
}

/*!
 * @brief This function returns the value of member var_char16
 * @return Value of member var_char16
 */
wchar_t WCharStruct::var_char16() const
{
    return m_var_char16;
}

/*!
 * @brief This function returns a reference to member var_char16
 * @return Reference to member var_char16
 */
wchar_t& WCharStruct::var_char16()
{
    return m_var_char16;
}



size_t WCharStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return WCharStruct_max_key_cdr_typesize;
}

bool WCharStruct::isKeyDefined()
{
    return false;
}

void WCharStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


EmptyStruct::EmptyStruct()
{

    // Just to register all known types
    registermutableTypes();
}

EmptyStruct::~EmptyStruct()
{
}

EmptyStruct::EmptyStruct(
        const EmptyStruct& x)
{
}

EmptyStruct::EmptyStruct(
        EmptyStruct&& x) noexcept 
{
}

EmptyStruct& EmptyStruct::operator =(
        const EmptyStruct& x)
{


    return *this;
}

EmptyStruct& EmptyStruct::operator =(
        EmptyStruct&& x) noexcept
{


    return *this;
}

bool EmptyStruct::operator ==(
        const EmptyStruct& x) const
{

    return true;
}

bool EmptyStruct::operator !=(
        const EmptyStruct& x) const
{
    return !(*this == x);
}

size_t EmptyStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return EmptyStruct_max_cdr_typesize;
}

size_t EmptyStruct::getCdrSerializedSize(
        const EmptyStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    return current_alignment - initial_alignment;
}

void EmptyStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

}

void EmptyStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

}



size_t EmptyStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return EmptyStruct_max_key_cdr_typesize;
}

bool EmptyStruct::isKeyDefined()
{
    return false;
}

void EmptyStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


EmptyInheritanceStruct::EmptyInheritanceStruct()    : EmptyStruct() 
{
    // string m_var_str
    m_var_str = "";


    // Just to register all known types
    registermutableTypes();
}

EmptyInheritanceStruct::~EmptyInheritanceStruct()
{
}

EmptyInheritanceStruct::EmptyInheritanceStruct(
        const EmptyInheritanceStruct& x)    : EmptyStruct(x) 
{
    m_var_str = x.m_var_str;
}

EmptyInheritanceStruct::EmptyInheritanceStruct(
        EmptyInheritanceStruct&& x) noexcept     : EmptyStruct(std::move(x)) 
{
    m_var_str = std::move(x.m_var_str);
}

EmptyInheritanceStruct& EmptyInheritanceStruct::operator =(
        const EmptyInheritanceStruct& x)
{
    EmptyStruct::operator =(x); 

    m_var_str = x.m_var_str;

    return *this;
}

EmptyInheritanceStruct& EmptyInheritanceStruct::operator =(
        EmptyInheritanceStruct&& x) noexcept
{
    EmptyStruct::operator =(std::move(x)); 

    m_var_str = std::move(x.m_var_str);

    return *this;
}

bool EmptyInheritanceStruct::operator ==(
        const EmptyInheritanceStruct& x) const
{
     if (EmptyStruct::operator !=(x)) return false; 

    return (m_var_str == x.m_var_str);
}

bool EmptyInheritanceStruct::operator !=(
        const EmptyInheritanceStruct& x) const
{
    return !(*this == x);
}

size_t EmptyInheritanceStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return EmptyInheritanceStruct_max_cdr_typesize;
}

size_t EmptyInheritanceStruct::getCdrSerializedSize(
        const EmptyInheritanceStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += EmptyStruct::getCdrSerializedSize(data, current_alignment); 

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_str().size() + 1;

    return current_alignment - initial_alignment;
}

void EmptyInheritanceStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    EmptyStruct::serialize(scdr); 

    scdr << m_var_str.c_str();
}

void EmptyInheritanceStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    EmptyStruct::deserialize(dcdr); 

    dcdr >> m_var_str;}

/*!
 * @brief This function copies the value in member var_str
 * @param _var_str New value to be copied in member var_str
 */
void EmptyInheritanceStruct::var_str(
        const std::string& _var_str)
{
    m_var_str = _var_str;
}

/*!
 * @brief This function moves the value in member var_str
 * @param _var_str New value to be moved in member var_str
 */
void EmptyInheritanceStruct::var_str(
        std::string&& _var_str)
{
    m_var_str = std::move(_var_str);
}

/*!
 * @brief This function returns a constant reference to member var_str
 * @return Constant reference to member var_str
 */
const std::string& EmptyInheritanceStruct::var_str() const
{
    return m_var_str;
}

/*!
 * @brief This function returns a reference to member var_str
 * @return Reference to member var_str
 */
std::string& EmptyInheritanceStruct::var_str()
{
    return m_var_str;
}


size_t EmptyInheritanceStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return EmptyInheritanceStruct_max_key_cdr_typesize;
}

bool EmptyInheritanceStruct::isKeyDefined()
{
    if (EmptyStruct::isKeyDefined())
        return true;
     return false;
}

void EmptyInheritanceStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
 EmptyStruct::serializeKey(scdr);  
}


InheritanceStruct::InheritanceStruct()    : ShortStruct() 
{
    // string m_var_str
    m_var_str = "";


    // Just to register all known types
    registermutableTypes();
}

InheritanceStruct::~InheritanceStruct()
{
}

InheritanceStruct::InheritanceStruct(
        const InheritanceStruct& x)    : ShortStruct(x) 
{
    m_var_str = x.m_var_str;
}

InheritanceStruct::InheritanceStruct(
        InheritanceStruct&& x) noexcept     : ShortStruct(std::move(x)) 
{
    m_var_str = std::move(x.m_var_str);
}

InheritanceStruct& InheritanceStruct::operator =(
        const InheritanceStruct& x)
{
    ShortStruct::operator =(x); 

    m_var_str = x.m_var_str;

    return *this;
}

InheritanceStruct& InheritanceStruct::operator =(
        InheritanceStruct&& x) noexcept
{
    ShortStruct::operator =(std::move(x)); 

    m_var_str = std::move(x.m_var_str);

    return *this;
}

bool InheritanceStruct::operator ==(
        const InheritanceStruct& x) const
{
     if (ShortStruct::operator !=(x)) return false; 

    return (m_var_str == x.m_var_str);
}

bool InheritanceStruct::operator !=(
        const InheritanceStruct& x) const
{
    return !(*this == x);
}

size_t InheritanceStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return InheritanceStruct_max_cdr_typesize;
}

size_t InheritanceStruct::getCdrSerializedSize(
        const InheritanceStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += ShortStruct::getCdrSerializedSize(data, current_alignment); 

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_str().size() + 1;

    return current_alignment - initial_alignment;
}

void InheritanceStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    ShortStruct::serialize(scdr); 

    scdr << m_var_str.c_str();
}

void InheritanceStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    ShortStruct::deserialize(dcdr); 

    dcdr >> m_var_str;}

/*!
 * @brief This function copies the value in member var_str
 * @param _var_str New value to be copied in member var_str
 */
void InheritanceStruct::var_str(
        const std::string& _var_str)
{
    m_var_str = _var_str;
}

/*!
 * @brief This function moves the value in member var_str
 * @param _var_str New value to be moved in member var_str
 */
void InheritanceStruct::var_str(
        std::string&& _var_str)
{
    m_var_str = std::move(_var_str);
}

/*!
 * @brief This function returns a constant reference to member var_str
 * @return Constant reference to member var_str
 */
const std::string& InheritanceStruct::var_str() const
{
    return m_var_str;
}

/*!
 * @brief This function returns a reference to member var_str
 * @return Reference to member var_str
 */
std::string& InheritanceStruct::var_str()
{
    return m_var_str;
}


size_t InheritanceStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return InheritanceStruct_max_key_cdr_typesize;
}

bool InheritanceStruct::isKeyDefined()
{
    if (ShortStruct::isKeyDefined())
        return true;
     return false;
}

void InheritanceStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
 ShortStruct::serializeKey(scdr);  
}


InheritanceEmptyStruct::InheritanceEmptyStruct()    : ShortStruct() 
{

    // Just to register all known types
    registermutableTypes();
}

InheritanceEmptyStruct::~InheritanceEmptyStruct()
{
}

InheritanceEmptyStruct::InheritanceEmptyStruct(
        const InheritanceEmptyStruct& x)    : ShortStruct(x) 
{
}

InheritanceEmptyStruct::InheritanceEmptyStruct(
        InheritanceEmptyStruct&& x) noexcept     : ShortStruct(std::move(x)) 
{
}

InheritanceEmptyStruct& InheritanceEmptyStruct::operator =(
        const InheritanceEmptyStruct& x)
{
    ShortStruct::operator =(x); 


    return *this;
}

InheritanceEmptyStruct& InheritanceEmptyStruct::operator =(
        InheritanceEmptyStruct&& x) noexcept
{
    ShortStruct::operator =(std::move(x)); 


    return *this;
}

bool InheritanceEmptyStruct::operator ==(
        const InheritanceEmptyStruct& x) const
{
     if (ShortStruct::operator !=(x)) return false; 

    return true;
}

bool InheritanceEmptyStruct::operator !=(
        const InheritanceEmptyStruct& x) const
{
    return !(*this == x);
}

size_t InheritanceEmptyStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return InheritanceEmptyStruct_max_cdr_typesize;
}

size_t InheritanceEmptyStruct::getCdrSerializedSize(
        const InheritanceEmptyStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += ShortStruct::getCdrSerializedSize(data, current_alignment); 


    return current_alignment - initial_alignment;
}

void InheritanceEmptyStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    ShortStruct::serialize(scdr); 

}

void InheritanceEmptyStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    ShortStruct::deserialize(dcdr); 

}



size_t InheritanceEmptyStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return InheritanceEmptyStruct_max_key_cdr_typesize;
}

bool InheritanceEmptyStruct::isKeyDefined()
{
    if (ShortStruct::isKeyDefined())
        return true;
     return false;
}

void InheritanceEmptyStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
 ShortStruct::serializeKey(scdr);  
}

