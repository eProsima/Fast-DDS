// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file optional.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "optional.h"
#include "optionalTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define ushort_optional_max_cdr_typesize 2ULL;
#define boolean_align_2_optional_max_cdr_typesize 3ULL;
#define InnerStructureHelper_max_cdr_typesize 8ULL;
#define double_align_2_optional_max_cdr_typesize 16ULL;
#define ulong_align_4_optional_max_cdr_typesize 8ULL;
#define char_align_4_optional_max_cdr_typesize 5ULL;
#define map_short_align_1_optional_max_cdr_typesize 806ULL;
#define float_align_4_optional_max_cdr_typesize 8ULL;
#define struct_optional_max_cdr_typesize 8ULL;
#define opt_struct_align_2_optional_max_cdr_typesize 8ULL;
#define short_align_2_optional_max_cdr_typesize 4ULL;
#define long_optional_max_cdr_typesize 4ULL;
#define ushort_align_2_optional_max_cdr_typesize 4ULL;
#define float_align_1_optional_max_cdr_typesize 8ULL;
#define ulong_align_1_optional_max_cdr_typesize 8ULL;
#define map_short_align_4_optional_max_cdr_typesize 806ULL;
#define long_align_1_optional_max_cdr_typesize 8ULL;
#define ulonglong_optional_max_cdr_typesize 8ULL;
#define char_align_1_optional_max_cdr_typesize 2ULL;
#define long_align_4_optional_max_cdr_typesize 8ULL;
#define struct_align_1_optional_max_cdr_typesize 12ULL;
#define ulonglong_align_1_optional_max_cdr_typesize 16ULL;
#define octet_align_2_optional_max_cdr_typesize 3ULL;
#define sequence_short_align_1_optional_max_cdr_typesize 208ULL;
#define opt_struct_align_4_optional_max_cdr_typesize 12ULL;
#define InnerEmptyStructureHelper_max_cdr_typesize 0ULL;
#define float_align_2_optional_max_cdr_typesize 8ULL;
#define longdouble_optional_max_cdr_typesize 16ULL;
#define char_align_2_optional_max_cdr_typesize 3ULL;
#define wchar_align_2_optional_max_cdr_typesize 8ULL;
#define float_optional_max_cdr_typesize 4ULL;
#define string_unbounded_align_1_optional_max_cdr_typesize 264ULL;

#define longdouble_align_1_optional_max_cdr_typesize 24ULL;
#define boolean_align_4_optional_max_cdr_typesize 5ULL;
#define double_align_4_optional_max_cdr_typesize 16ULL;
#define array_short_align_4_optional_max_cdr_typesize 24ULL;
#define opt_struct_optional_max_cdr_typesize 8ULL;
#define string_unbounded_align_2_optional_max_cdr_typesize 264ULL;

#define longdouble_align_2_optional_max_cdr_typesize 24ULL;
#define ulonglong_align_2_optional_max_cdr_typesize 16ULL;

#define longlong_align_2_optional_max_cdr_typesize 16ULL;

#define string_bounded_optional_max_cdr_typesize 13ULL;
#define ulong_optional_max_cdr_typesize 4ULL;
#define wchar_align_4_optional_max_cdr_typesize 8ULL;
#define ushort_align_1_optional_max_cdr_typesize 4ULL;
#define string_bounded_align_1_optional_max_cdr_typesize 17ULL;
#define longlong_align_1_optional_max_cdr_typesize 16ULL;
#define sequence_short_optional_max_cdr_typesize 204ULL;
#define char_optional_max_cdr_typesize 1ULL;
#define struct_align_2_optional_max_cdr_typesize 12ULL;
#define long_align_2_optional_max_cdr_typesize 8ULL;
#define longlong_align_4_optional_max_cdr_typesize 16ULL;
#define wchar_align_1_optional_max_cdr_typesize 8ULL;
#define short_align_4_optional_max_cdr_typesize 6ULL;
#define InnerStructOptional_max_cdr_typesize 8ULL;
#define octet_align_4_optional_max_cdr_typesize 5ULL;
#define octet_align_1_optional_max_cdr_typesize 2ULL;
#define array_short_align_1_optional_max_cdr_typesize 22ULL;
#define octet_optional_max_cdr_typesize 1ULL;
#define ulong_align_2_optional_max_cdr_typesize 8ULL;
#define short_align_1_optional_max_cdr_typesize 4ULL;
#define string_bounded_align_4_optional_max_cdr_typesize 17ULL;
#define sequence_short_align_2_optional_max_cdr_typesize 208ULL;
#define struct_align_4_optional_max_cdr_typesize 12ULL;

#define ulonglong_align_4_optional_max_cdr_typesize 16ULL;
#define sequence_short_align_4_optional_max_cdr_typesize 208ULL;
#define opt_struct_align_1_optional_max_cdr_typesize 8ULL;
#define longdouble_align_4_optional_max_cdr_typesize 24ULL;
#define double_optional_max_cdr_typesize 8ULL;
#define wchar_optional_max_cdr_typesize 4ULL;

#define boolean_align_1_optional_max_cdr_typesize 2ULL;
#define string_bounded_align_2_optional_max_cdr_typesize 17ULL;
#define map_short_optional_max_cdr_typesize 802ULL;
#define boolean_optional_max_cdr_typesize 1ULL;
#define double_align_1_optional_max_cdr_typesize 16ULL;
#define short_optional_max_cdr_typesize 2ULL;


#define ushort_align_4_optional_max_cdr_typesize 6ULL;
#define string_unbounded_align_4_optional_max_cdr_typesize 264ULL;
#define array_short_align_2_optional_max_cdr_typesize 22ULL;
#define array_short_optional_max_cdr_typesize 20ULL;
#define longlong_optional_max_cdr_typesize 8ULL;
#define string_unbounded_optional_max_cdr_typesize 260ULL;


#define map_short_align_2_optional_max_cdr_typesize 806ULL;
#define ushort_optional_max_key_cdr_typesize 0ULL;
#define boolean_align_2_optional_max_key_cdr_typesize 0ULL;
#define InnerStructureHelper_max_key_cdr_typesize 0ULL;
#define double_align_2_optional_max_key_cdr_typesize 0ULL;
#define ulong_align_4_optional_max_key_cdr_typesize 0ULL;
#define char_align_4_optional_max_key_cdr_typesize 0ULL;
#define map_short_align_1_optional_max_key_cdr_typesize 0ULL;
#define float_align_4_optional_max_key_cdr_typesize 0ULL;
#define struct_optional_max_key_cdr_typesize 0ULL;
#define opt_struct_align_2_optional_max_key_cdr_typesize 0ULL;
#define short_align_2_optional_max_key_cdr_typesize 0ULL;
#define long_optional_max_key_cdr_typesize 0ULL;
#define ushort_align_2_optional_max_key_cdr_typesize 0ULL;
#define float_align_1_optional_max_key_cdr_typesize 0ULL;
#define ulong_align_1_optional_max_key_cdr_typesize 0ULL;
#define map_short_align_4_optional_max_key_cdr_typesize 0ULL;
#define long_align_1_optional_max_key_cdr_typesize 0ULL;
#define ulonglong_optional_max_key_cdr_typesize 0ULL;
#define char_align_1_optional_max_key_cdr_typesize 0ULL;
#define long_align_4_optional_max_key_cdr_typesize 0ULL;
#define struct_align_1_optional_max_key_cdr_typesize 0ULL;
#define ulonglong_align_1_optional_max_key_cdr_typesize 0ULL;
#define octet_align_2_optional_max_key_cdr_typesize 0ULL;
#define sequence_short_align_1_optional_max_key_cdr_typesize 0ULL;
#define opt_struct_align_4_optional_max_key_cdr_typesize 0ULL;
#define InnerEmptyStructureHelper_max_key_cdr_typesize 0ULL;
#define float_align_2_optional_max_key_cdr_typesize 0ULL;
#define longdouble_optional_max_key_cdr_typesize 0ULL;
#define char_align_2_optional_max_key_cdr_typesize 0ULL;
#define wchar_align_2_optional_max_key_cdr_typesize 0ULL;
#define float_optional_max_key_cdr_typesize 0ULL;
#define string_unbounded_align_1_optional_max_key_cdr_typesize 0ULL;

#define longdouble_align_1_optional_max_key_cdr_typesize 0ULL;
#define boolean_align_4_optional_max_key_cdr_typesize 0ULL;
#define double_align_4_optional_max_key_cdr_typesize 0ULL;
#define array_short_align_4_optional_max_key_cdr_typesize 0ULL;
#define opt_struct_optional_max_key_cdr_typesize 0ULL;
#define string_unbounded_align_2_optional_max_key_cdr_typesize 0ULL;

#define longdouble_align_2_optional_max_key_cdr_typesize 0ULL;
#define ulonglong_align_2_optional_max_key_cdr_typesize 0ULL;

#define longlong_align_2_optional_max_key_cdr_typesize 0ULL;

#define string_bounded_optional_max_key_cdr_typesize 0ULL;
#define ulong_optional_max_key_cdr_typesize 0ULL;
#define wchar_align_4_optional_max_key_cdr_typesize 0ULL;
#define ushort_align_1_optional_max_key_cdr_typesize 0ULL;
#define string_bounded_align_1_optional_max_key_cdr_typesize 0ULL;
#define longlong_align_1_optional_max_key_cdr_typesize 0ULL;
#define sequence_short_optional_max_key_cdr_typesize 0ULL;
#define char_optional_max_key_cdr_typesize 0ULL;
#define struct_align_2_optional_max_key_cdr_typesize 0ULL;
#define long_align_2_optional_max_key_cdr_typesize 0ULL;
#define longlong_align_4_optional_max_key_cdr_typesize 0ULL;
#define wchar_align_1_optional_max_key_cdr_typesize 0ULL;
#define short_align_4_optional_max_key_cdr_typesize 0ULL;
#define InnerStructOptional_max_key_cdr_typesize 0ULL;
#define octet_align_4_optional_max_key_cdr_typesize 0ULL;
#define octet_align_1_optional_max_key_cdr_typesize 0ULL;
#define array_short_align_1_optional_max_key_cdr_typesize 0ULL;
#define octet_optional_max_key_cdr_typesize 0ULL;
#define ulong_align_2_optional_max_key_cdr_typesize 0ULL;
#define short_align_1_optional_max_key_cdr_typesize 0ULL;
#define string_bounded_align_4_optional_max_key_cdr_typesize 0ULL;
#define sequence_short_align_2_optional_max_key_cdr_typesize 0ULL;
#define struct_align_4_optional_max_key_cdr_typesize 0ULL;

#define ulonglong_align_4_optional_max_key_cdr_typesize 0ULL;
#define sequence_short_align_4_optional_max_key_cdr_typesize 0ULL;
#define opt_struct_align_1_optional_max_key_cdr_typesize 0ULL;
#define longdouble_align_4_optional_max_key_cdr_typesize 0ULL;
#define double_optional_max_key_cdr_typesize 0ULL;
#define wchar_optional_max_key_cdr_typesize 0ULL;

#define boolean_align_1_optional_max_key_cdr_typesize 0ULL;
#define string_bounded_align_2_optional_max_key_cdr_typesize 0ULL;
#define map_short_optional_max_key_cdr_typesize 0ULL;
#define boolean_optional_max_key_cdr_typesize 0ULL;
#define double_align_1_optional_max_key_cdr_typesize 0ULL;
#define short_optional_max_key_cdr_typesize 0ULL;


#define ushort_align_4_optional_max_key_cdr_typesize 0ULL;
#define string_unbounded_align_4_optional_max_key_cdr_typesize 0ULL;
#define array_short_align_2_optional_max_key_cdr_typesize 0ULL;
#define array_short_optional_max_key_cdr_typesize 0ULL;
#define longlong_optional_max_key_cdr_typesize 0ULL;
#define string_unbounded_optional_max_key_cdr_typesize 0ULL;


#define map_short_align_2_optional_max_key_cdr_typesize 0ULL;

short_optional::short_optional()
{
    // short m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

short_optional::~short_optional()
{
}

short_optional::short_optional(
        const short_optional& x)
{
    m_value = x.m_value;
}

short_optional::short_optional(
        short_optional&& x) noexcept 
{
    m_value = x.m_value;
}

short_optional& short_optional::operator =(
        const short_optional& x)
{

    m_value = x.m_value;

    return *this;
}

short_optional& short_optional::operator =(
        short_optional&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool short_optional::operator ==(
        const short_optional& x) const
{

    return (m_value == x.m_value);
}

bool short_optional::operator !=(
        const short_optional& x) const
{
    return !(*this == x);
}

size_t short_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return short_optional_max_cdr_typesize;
}

size_t short_optional::getCdrSerializedSize(
        const short_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void short_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void short_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void short_optional::value(
        int16_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
int16_t short_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
int16_t& short_optional::value()
{
    return m_value;
}



size_t short_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return short_optional_max_key_cdr_typesize;
}

bool short_optional::isKeyDefined()
{
    return false;
}

void short_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ushort_optional::ushort_optional()
{
    // unsigned short m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

ushort_optional::~ushort_optional()
{
}

ushort_optional::ushort_optional(
        const ushort_optional& x)
{
    m_value = x.m_value;
}

ushort_optional::ushort_optional(
        ushort_optional&& x) noexcept 
{
    m_value = x.m_value;
}

ushort_optional& ushort_optional::operator =(
        const ushort_optional& x)
{

    m_value = x.m_value;

    return *this;
}

ushort_optional& ushort_optional::operator =(
        ushort_optional&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool ushort_optional::operator ==(
        const ushort_optional& x) const
{

    return (m_value == x.m_value);
}

bool ushort_optional::operator !=(
        const ushort_optional& x) const
{
    return !(*this == x);
}

size_t ushort_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ushort_optional_max_cdr_typesize;
}

size_t ushort_optional::getCdrSerializedSize(
        const ushort_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void ushort_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void ushort_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void ushort_optional::value(
        uint16_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint16_t ushort_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint16_t& ushort_optional::value()
{
    return m_value;
}



size_t ushort_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ushort_optional_max_key_cdr_typesize;
}

bool ushort_optional::isKeyDefined()
{
    return false;
}

void ushort_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


long_optional::long_optional()
{
    // long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

long_optional::~long_optional()
{
}

long_optional::long_optional(
        const long_optional& x)
{
    m_value = x.m_value;
}

long_optional::long_optional(
        long_optional&& x) noexcept 
{
    m_value = x.m_value;
}

long_optional& long_optional::operator =(
        const long_optional& x)
{

    m_value = x.m_value;

    return *this;
}

long_optional& long_optional::operator =(
        long_optional&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool long_optional::operator ==(
        const long_optional& x) const
{

    return (m_value == x.m_value);
}

bool long_optional::operator !=(
        const long_optional& x) const
{
    return !(*this == x);
}

size_t long_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return long_optional_max_cdr_typesize;
}

size_t long_optional::getCdrSerializedSize(
        const long_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void long_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void long_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void long_optional::value(
        int32_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
int32_t long_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
int32_t& long_optional::value()
{
    return m_value;
}



size_t long_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return long_optional_max_key_cdr_typesize;
}

bool long_optional::isKeyDefined()
{
    return false;
}

void long_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ulong_optional::ulong_optional()
{
    // unsigned long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

ulong_optional::~ulong_optional()
{
}

ulong_optional::ulong_optional(
        const ulong_optional& x)
{
    m_value = x.m_value;
}

ulong_optional::ulong_optional(
        ulong_optional&& x) noexcept 
{
    m_value = x.m_value;
}

ulong_optional& ulong_optional::operator =(
        const ulong_optional& x)
{

    m_value = x.m_value;

    return *this;
}

ulong_optional& ulong_optional::operator =(
        ulong_optional&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool ulong_optional::operator ==(
        const ulong_optional& x) const
{

    return (m_value == x.m_value);
}

bool ulong_optional::operator !=(
        const ulong_optional& x) const
{
    return !(*this == x);
}

size_t ulong_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulong_optional_max_cdr_typesize;
}

size_t ulong_optional::getCdrSerializedSize(
        const ulong_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void ulong_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void ulong_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void ulong_optional::value(
        uint32_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint32_t ulong_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint32_t& ulong_optional::value()
{
    return m_value;
}



size_t ulong_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulong_optional_max_key_cdr_typesize;
}

bool ulong_optional::isKeyDefined()
{
    return false;
}

void ulong_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


longlong_optional::longlong_optional()
{
    // long long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

longlong_optional::~longlong_optional()
{
}

longlong_optional::longlong_optional(
        const longlong_optional& x)
{
    m_value = x.m_value;
}

longlong_optional::longlong_optional(
        longlong_optional&& x) noexcept 
{
    m_value = x.m_value;
}

longlong_optional& longlong_optional::operator =(
        const longlong_optional& x)
{

    m_value = x.m_value;

    return *this;
}

longlong_optional& longlong_optional::operator =(
        longlong_optional&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool longlong_optional::operator ==(
        const longlong_optional& x) const
{

    return (m_value == x.m_value);
}

bool longlong_optional::operator !=(
        const longlong_optional& x) const
{
    return !(*this == x);
}

size_t longlong_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longlong_optional_max_cdr_typesize;
}

size_t longlong_optional::getCdrSerializedSize(
        const longlong_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void longlong_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void longlong_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void longlong_optional::value(
        int64_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
int64_t longlong_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
int64_t& longlong_optional::value()
{
    return m_value;
}



size_t longlong_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longlong_optional_max_key_cdr_typesize;
}

bool longlong_optional::isKeyDefined()
{
    return false;
}

void longlong_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ulonglong_optional::ulonglong_optional()
{
    // unsigned long long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

ulonglong_optional::~ulonglong_optional()
{
}

ulonglong_optional::ulonglong_optional(
        const ulonglong_optional& x)
{
    m_value = x.m_value;
}

ulonglong_optional::ulonglong_optional(
        ulonglong_optional&& x) noexcept 
{
    m_value = x.m_value;
}

ulonglong_optional& ulonglong_optional::operator =(
        const ulonglong_optional& x)
{

    m_value = x.m_value;

    return *this;
}

ulonglong_optional& ulonglong_optional::operator =(
        ulonglong_optional&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool ulonglong_optional::operator ==(
        const ulonglong_optional& x) const
{

    return (m_value == x.m_value);
}

bool ulonglong_optional::operator !=(
        const ulonglong_optional& x) const
{
    return !(*this == x);
}

size_t ulonglong_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulonglong_optional_max_cdr_typesize;
}

size_t ulonglong_optional::getCdrSerializedSize(
        const ulonglong_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void ulonglong_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void ulonglong_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void ulonglong_optional::value(
        uint64_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint64_t ulonglong_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint64_t& ulonglong_optional::value()
{
    return m_value;
}



size_t ulonglong_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulonglong_optional_max_key_cdr_typesize;
}

bool ulonglong_optional::isKeyDefined()
{
    return false;
}

void ulonglong_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


float_optional::float_optional()
{
    // float m_value
    m_value = 0.0;

    // Just to register all known types
    registeroptionalTypes();
}

float_optional::~float_optional()
{
}

float_optional::float_optional(
        const float_optional& x)
{
    m_value = x.m_value;
}

float_optional::float_optional(
        float_optional&& x) noexcept 
{
    m_value = x.m_value;
}

float_optional& float_optional::operator =(
        const float_optional& x)
{

    m_value = x.m_value;

    return *this;
}

float_optional& float_optional::operator =(
        float_optional&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool float_optional::operator ==(
        const float_optional& x) const
{

    return (m_value == x.m_value);
}

bool float_optional::operator !=(
        const float_optional& x) const
{
    return !(*this == x);
}

size_t float_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return float_optional_max_cdr_typesize;
}

size_t float_optional::getCdrSerializedSize(
        const float_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void float_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void float_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void float_optional::value(
        float _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
float float_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
float& float_optional::value()
{
    return m_value;
}



size_t float_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return float_optional_max_key_cdr_typesize;
}

bool float_optional::isKeyDefined()
{
    return false;
}

void float_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


double_optional::double_optional()
{
    // double m_value
    m_value = 0.0;

    // Just to register all known types
    registeroptionalTypes();
}

double_optional::~double_optional()
{
}

double_optional::double_optional(
        const double_optional& x)
{
    m_value = x.m_value;
}

double_optional::double_optional(
        double_optional&& x) noexcept 
{
    m_value = x.m_value;
}

double_optional& double_optional::operator =(
        const double_optional& x)
{

    m_value = x.m_value;

    return *this;
}

double_optional& double_optional::operator =(
        double_optional&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool double_optional::operator ==(
        const double_optional& x) const
{

    return (m_value == x.m_value);
}

bool double_optional::operator !=(
        const double_optional& x) const
{
    return !(*this == x);
}

size_t double_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return double_optional_max_cdr_typesize;
}

size_t double_optional::getCdrSerializedSize(
        const double_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void double_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void double_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void double_optional::value(
        double _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
double double_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
double& double_optional::value()
{
    return m_value;
}



size_t double_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return double_optional_max_key_cdr_typesize;
}

bool double_optional::isKeyDefined()
{
    return false;
}

void double_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


longdouble_optional::longdouble_optional()
{
    // long double m_value
    m_value = 0.0;

    // Just to register all known types
    registeroptionalTypes();
}

longdouble_optional::~longdouble_optional()
{
}

longdouble_optional::longdouble_optional(
        const longdouble_optional& x)
{
    m_value = x.m_value;
}

longdouble_optional::longdouble_optional(
        longdouble_optional&& x) noexcept 
{
    m_value = x.m_value;
}

longdouble_optional& longdouble_optional::operator =(
        const longdouble_optional& x)
{

    m_value = x.m_value;

    return *this;
}

longdouble_optional& longdouble_optional::operator =(
        longdouble_optional&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool longdouble_optional::operator ==(
        const longdouble_optional& x) const
{

    return (m_value == x.m_value);
}

bool longdouble_optional::operator !=(
        const longdouble_optional& x) const
{
    return !(*this == x);
}

size_t longdouble_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longdouble_optional_max_cdr_typesize;
}

size_t longdouble_optional::getCdrSerializedSize(
        const longdouble_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 16 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8); // 128 bits, but aligned as 64


    return current_alignment - initial_alignment;
}

void longdouble_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void longdouble_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void longdouble_optional::value(
        long double _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
long double longdouble_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
long double& longdouble_optional::value()
{
    return m_value;
}



size_t longdouble_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longdouble_optional_max_key_cdr_typesize;
}

bool longdouble_optional::isKeyDefined()
{
    return false;
}

void longdouble_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


boolean_optional::boolean_optional()
{
    // boolean m_value
    m_value = false;

    // Just to register all known types
    registeroptionalTypes();
}

boolean_optional::~boolean_optional()
{
}

boolean_optional::boolean_optional(
        const boolean_optional& x)
{
    m_value = x.m_value;
}

boolean_optional::boolean_optional(
        boolean_optional&& x) noexcept 
{
    m_value = x.m_value;
}

boolean_optional& boolean_optional::operator =(
        const boolean_optional& x)
{

    m_value = x.m_value;

    return *this;
}

boolean_optional& boolean_optional::operator =(
        boolean_optional&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool boolean_optional::operator ==(
        const boolean_optional& x) const
{

    return (m_value == x.m_value);
}

bool boolean_optional::operator !=(
        const boolean_optional& x) const
{
    return !(*this == x);
}

size_t boolean_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return boolean_optional_max_cdr_typesize;
}

size_t boolean_optional::getCdrSerializedSize(
        const boolean_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void boolean_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void boolean_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void boolean_optional::value(
        bool _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
bool boolean_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
bool& boolean_optional::value()
{
    return m_value;
}



size_t boolean_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return boolean_optional_max_key_cdr_typesize;
}

bool boolean_optional::isKeyDefined()
{
    return false;
}

void boolean_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


octet_optional::octet_optional()
{
    // octet m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

octet_optional::~octet_optional()
{
}

octet_optional::octet_optional(
        const octet_optional& x)
{
    m_value = x.m_value;
}

octet_optional::octet_optional(
        octet_optional&& x) noexcept 
{
    m_value = x.m_value;
}

octet_optional& octet_optional::operator =(
        const octet_optional& x)
{

    m_value = x.m_value;

    return *this;
}

octet_optional& octet_optional::operator =(
        octet_optional&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool octet_optional::operator ==(
        const octet_optional& x) const
{

    return (m_value == x.m_value);
}

bool octet_optional::operator !=(
        const octet_optional& x) const
{
    return !(*this == x);
}

size_t octet_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return octet_optional_max_cdr_typesize;
}

size_t octet_optional::getCdrSerializedSize(
        const octet_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void octet_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void octet_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void octet_optional::value(
        uint8_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint8_t octet_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint8_t& octet_optional::value()
{
    return m_value;
}



size_t octet_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return octet_optional_max_key_cdr_typesize;
}

bool octet_optional::isKeyDefined()
{
    return false;
}

void octet_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


char_optional::char_optional()
{
    // char m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

char_optional::~char_optional()
{
}

char_optional::char_optional(
        const char_optional& x)
{
    m_value = x.m_value;
}

char_optional::char_optional(
        char_optional&& x) noexcept 
{
    m_value = x.m_value;
}

char_optional& char_optional::operator =(
        const char_optional& x)
{

    m_value = x.m_value;

    return *this;
}

char_optional& char_optional::operator =(
        char_optional&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool char_optional::operator ==(
        const char_optional& x) const
{

    return (m_value == x.m_value);
}

bool char_optional::operator !=(
        const char_optional& x) const
{
    return !(*this == x);
}

size_t char_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return char_optional_max_cdr_typesize;
}

size_t char_optional::getCdrSerializedSize(
        const char_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void char_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void char_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void char_optional::value(
        char _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
char char_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
char& char_optional::value()
{
    return m_value;
}



size_t char_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return char_optional_max_key_cdr_typesize;
}

bool char_optional::isKeyDefined()
{
    return false;
}

void char_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


wchar_optional::wchar_optional()
{
    // wchar m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

wchar_optional::~wchar_optional()
{
}

wchar_optional::wchar_optional(
        const wchar_optional& x)
{
    m_value = x.m_value;
}

wchar_optional::wchar_optional(
        wchar_optional&& x) noexcept 
{
    m_value = x.m_value;
}

wchar_optional& wchar_optional::operator =(
        const wchar_optional& x)
{

    m_value = x.m_value;

    return *this;
}

wchar_optional& wchar_optional::operator =(
        wchar_optional&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool wchar_optional::operator ==(
        const wchar_optional& x) const
{

    return (m_value == x.m_value);
}

bool wchar_optional::operator !=(
        const wchar_optional& x) const
{
    return !(*this == x);
}

size_t wchar_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return wchar_optional_max_cdr_typesize;
}

size_t wchar_optional::getCdrSerializedSize(
        const wchar_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void wchar_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void wchar_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void wchar_optional::value(
        wchar_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
wchar_t wchar_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
wchar_t& wchar_optional::value()
{
    return m_value;
}



size_t wchar_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return wchar_optional_max_key_cdr_typesize;
}

bool wchar_optional::isKeyDefined()
{
    return false;
}

void wchar_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


short_align_1_optional::short_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // short m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

short_align_1_optional::~short_align_1_optional()
{


}

short_align_1_optional::short_align_1_optional(
        const short_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

short_align_1_optional::short_align_1_optional(
        short_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

short_align_1_optional& short_align_1_optional::operator =(
        const short_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

short_align_1_optional& short_align_1_optional::operator =(
        short_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool short_align_1_optional::operator ==(
        const short_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool short_align_1_optional::operator !=(
        const short_align_1_optional& x) const
{
    return !(*this == x);
}

size_t short_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return short_align_1_optional_max_cdr_typesize;
}

size_t short_align_1_optional::getCdrSerializedSize(
        const short_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

void short_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void short_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void short_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t short_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& short_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void short_align_1_optional::value(
        int16_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
int16_t short_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
int16_t& short_align_1_optional::value()
{
    return m_value;
}



size_t short_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return short_align_1_optional_max_key_cdr_typesize;
}

bool short_align_1_optional::isKeyDefined()
{
    return false;
}

void short_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


short_align_2_optional::short_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // short m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

short_align_2_optional::~short_align_2_optional()
{


}

short_align_2_optional::short_align_2_optional(
        const short_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

short_align_2_optional::short_align_2_optional(
        short_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

short_align_2_optional& short_align_2_optional::operator =(
        const short_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

short_align_2_optional& short_align_2_optional::operator =(
        short_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool short_align_2_optional::operator ==(
        const short_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool short_align_2_optional::operator !=(
        const short_align_2_optional& x) const
{
    return !(*this == x);
}

size_t short_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return short_align_2_optional_max_cdr_typesize;
}

size_t short_align_2_optional::getCdrSerializedSize(
        const short_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

void short_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void short_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void short_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t short_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& short_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void short_align_2_optional::value(
        int16_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
int16_t short_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
int16_t& short_align_2_optional::value()
{
    return m_value;
}



size_t short_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return short_align_2_optional_max_key_cdr_typesize;
}

bool short_align_2_optional::isKeyDefined()
{
    return false;
}

void short_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


short_align_4_optional::short_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // short m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

short_align_4_optional::~short_align_4_optional()
{


}

short_align_4_optional::short_align_4_optional(
        const short_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

short_align_4_optional::short_align_4_optional(
        short_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

short_align_4_optional& short_align_4_optional::operator =(
        const short_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

short_align_4_optional& short_align_4_optional::operator =(
        short_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool short_align_4_optional::operator ==(
        const short_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool short_align_4_optional::operator !=(
        const short_align_4_optional& x) const
{
    return !(*this == x);
}

size_t short_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return short_align_4_optional_max_cdr_typesize;
}

size_t short_align_4_optional::getCdrSerializedSize(
        const short_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

void short_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void short_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void short_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t short_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& short_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void short_align_4_optional::value(
        int16_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
int16_t short_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
int16_t& short_align_4_optional::value()
{
    return m_value;
}



size_t short_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return short_align_4_optional_max_key_cdr_typesize;
}

bool short_align_4_optional::isKeyDefined()
{
    return false;
}

void short_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ushort_align_1_optional::ushort_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // unsigned short m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

ushort_align_1_optional::~ushort_align_1_optional()
{


}

ushort_align_1_optional::ushort_align_1_optional(
        const ushort_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ushort_align_1_optional::ushort_align_1_optional(
        ushort_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ushort_align_1_optional& ushort_align_1_optional::operator =(
        const ushort_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

ushort_align_1_optional& ushort_align_1_optional::operator =(
        ushort_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool ushort_align_1_optional::operator ==(
        const ushort_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool ushort_align_1_optional::operator !=(
        const ushort_align_1_optional& x) const
{
    return !(*this == x);
}

size_t ushort_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ushort_align_1_optional_max_cdr_typesize;
}

size_t ushort_align_1_optional::getCdrSerializedSize(
        const ushort_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

void ushort_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void ushort_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void ushort_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t ushort_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& ushort_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void ushort_align_1_optional::value(
        uint16_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint16_t ushort_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint16_t& ushort_align_1_optional::value()
{
    return m_value;
}



size_t ushort_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ushort_align_1_optional_max_key_cdr_typesize;
}

bool ushort_align_1_optional::isKeyDefined()
{
    return false;
}

void ushort_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ushort_align_2_optional::ushort_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // unsigned short m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

ushort_align_2_optional::~ushort_align_2_optional()
{


}

ushort_align_2_optional::ushort_align_2_optional(
        const ushort_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ushort_align_2_optional::ushort_align_2_optional(
        ushort_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ushort_align_2_optional& ushort_align_2_optional::operator =(
        const ushort_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

ushort_align_2_optional& ushort_align_2_optional::operator =(
        ushort_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool ushort_align_2_optional::operator ==(
        const ushort_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool ushort_align_2_optional::operator !=(
        const ushort_align_2_optional& x) const
{
    return !(*this == x);
}

size_t ushort_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ushort_align_2_optional_max_cdr_typesize;
}

size_t ushort_align_2_optional::getCdrSerializedSize(
        const ushort_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

void ushort_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void ushort_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void ushort_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t ushort_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& ushort_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void ushort_align_2_optional::value(
        uint16_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint16_t ushort_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint16_t& ushort_align_2_optional::value()
{
    return m_value;
}



size_t ushort_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ushort_align_2_optional_max_key_cdr_typesize;
}

bool ushort_align_2_optional::isKeyDefined()
{
    return false;
}

void ushort_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ushort_align_4_optional::ushort_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // unsigned short m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

ushort_align_4_optional::~ushort_align_4_optional()
{


}

ushort_align_4_optional::ushort_align_4_optional(
        const ushort_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ushort_align_4_optional::ushort_align_4_optional(
        ushort_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ushort_align_4_optional& ushort_align_4_optional::operator =(
        const ushort_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

ushort_align_4_optional& ushort_align_4_optional::operator =(
        ushort_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool ushort_align_4_optional::operator ==(
        const ushort_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool ushort_align_4_optional::operator !=(
        const ushort_align_4_optional& x) const
{
    return !(*this == x);
}

size_t ushort_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ushort_align_4_optional_max_cdr_typesize;
}

size_t ushort_align_4_optional::getCdrSerializedSize(
        const ushort_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

void ushort_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void ushort_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void ushort_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t ushort_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& ushort_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void ushort_align_4_optional::value(
        uint16_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint16_t ushort_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint16_t& ushort_align_4_optional::value()
{
    return m_value;
}



size_t ushort_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ushort_align_4_optional_max_key_cdr_typesize;
}

bool ushort_align_4_optional::isKeyDefined()
{
    return false;
}

void ushort_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


long_align_1_optional::long_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

long_align_1_optional::~long_align_1_optional()
{


}

long_align_1_optional::long_align_1_optional(
        const long_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

long_align_1_optional::long_align_1_optional(
        long_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

long_align_1_optional& long_align_1_optional::operator =(
        const long_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

long_align_1_optional& long_align_1_optional::operator =(
        long_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool long_align_1_optional::operator ==(
        const long_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool long_align_1_optional::operator !=(
        const long_align_1_optional& x) const
{
    return !(*this == x);
}

size_t long_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return long_align_1_optional_max_cdr_typesize;
}

size_t long_align_1_optional::getCdrSerializedSize(
        const long_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void long_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void long_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void long_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t long_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& long_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void long_align_1_optional::value(
        int32_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
int32_t long_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
int32_t& long_align_1_optional::value()
{
    return m_value;
}



size_t long_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return long_align_1_optional_max_key_cdr_typesize;
}

bool long_align_1_optional::isKeyDefined()
{
    return false;
}

void long_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


long_align_2_optional::long_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

long_align_2_optional::~long_align_2_optional()
{


}

long_align_2_optional::long_align_2_optional(
        const long_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

long_align_2_optional::long_align_2_optional(
        long_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

long_align_2_optional& long_align_2_optional::operator =(
        const long_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

long_align_2_optional& long_align_2_optional::operator =(
        long_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool long_align_2_optional::operator ==(
        const long_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool long_align_2_optional::operator !=(
        const long_align_2_optional& x) const
{
    return !(*this == x);
}

size_t long_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return long_align_2_optional_max_cdr_typesize;
}

size_t long_align_2_optional::getCdrSerializedSize(
        const long_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void long_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void long_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void long_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t long_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& long_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void long_align_2_optional::value(
        int32_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
int32_t long_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
int32_t& long_align_2_optional::value()
{
    return m_value;
}



size_t long_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return long_align_2_optional_max_key_cdr_typesize;
}

bool long_align_2_optional::isKeyDefined()
{
    return false;
}

void long_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


long_align_4_optional::long_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

long_align_4_optional::~long_align_4_optional()
{


}

long_align_4_optional::long_align_4_optional(
        const long_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

long_align_4_optional::long_align_4_optional(
        long_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

long_align_4_optional& long_align_4_optional::operator =(
        const long_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

long_align_4_optional& long_align_4_optional::operator =(
        long_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool long_align_4_optional::operator ==(
        const long_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool long_align_4_optional::operator !=(
        const long_align_4_optional& x) const
{
    return !(*this == x);
}

size_t long_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return long_align_4_optional_max_cdr_typesize;
}

size_t long_align_4_optional::getCdrSerializedSize(
        const long_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void long_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void long_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void long_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t long_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& long_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void long_align_4_optional::value(
        int32_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
int32_t long_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
int32_t& long_align_4_optional::value()
{
    return m_value;
}



size_t long_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return long_align_4_optional_max_key_cdr_typesize;
}

bool long_align_4_optional::isKeyDefined()
{
    return false;
}

void long_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ulong_align_1_optional::ulong_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // unsigned long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

ulong_align_1_optional::~ulong_align_1_optional()
{


}

ulong_align_1_optional::ulong_align_1_optional(
        const ulong_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ulong_align_1_optional::ulong_align_1_optional(
        ulong_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ulong_align_1_optional& ulong_align_1_optional::operator =(
        const ulong_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

ulong_align_1_optional& ulong_align_1_optional::operator =(
        ulong_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool ulong_align_1_optional::operator ==(
        const ulong_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool ulong_align_1_optional::operator !=(
        const ulong_align_1_optional& x) const
{
    return !(*this == x);
}

size_t ulong_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulong_align_1_optional_max_cdr_typesize;
}

size_t ulong_align_1_optional::getCdrSerializedSize(
        const ulong_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void ulong_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void ulong_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void ulong_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t ulong_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& ulong_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void ulong_align_1_optional::value(
        uint32_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint32_t ulong_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint32_t& ulong_align_1_optional::value()
{
    return m_value;
}



size_t ulong_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulong_align_1_optional_max_key_cdr_typesize;
}

bool ulong_align_1_optional::isKeyDefined()
{
    return false;
}

void ulong_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ulong_align_2_optional::ulong_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // unsigned long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

ulong_align_2_optional::~ulong_align_2_optional()
{


}

ulong_align_2_optional::ulong_align_2_optional(
        const ulong_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ulong_align_2_optional::ulong_align_2_optional(
        ulong_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ulong_align_2_optional& ulong_align_2_optional::operator =(
        const ulong_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

ulong_align_2_optional& ulong_align_2_optional::operator =(
        ulong_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool ulong_align_2_optional::operator ==(
        const ulong_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool ulong_align_2_optional::operator !=(
        const ulong_align_2_optional& x) const
{
    return !(*this == x);
}

size_t ulong_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulong_align_2_optional_max_cdr_typesize;
}

size_t ulong_align_2_optional::getCdrSerializedSize(
        const ulong_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void ulong_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void ulong_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void ulong_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t ulong_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& ulong_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void ulong_align_2_optional::value(
        uint32_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint32_t ulong_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint32_t& ulong_align_2_optional::value()
{
    return m_value;
}



size_t ulong_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulong_align_2_optional_max_key_cdr_typesize;
}

bool ulong_align_2_optional::isKeyDefined()
{
    return false;
}

void ulong_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ulong_align_4_optional::ulong_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // unsigned long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

ulong_align_4_optional::~ulong_align_4_optional()
{


}

ulong_align_4_optional::ulong_align_4_optional(
        const ulong_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ulong_align_4_optional::ulong_align_4_optional(
        ulong_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ulong_align_4_optional& ulong_align_4_optional::operator =(
        const ulong_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

ulong_align_4_optional& ulong_align_4_optional::operator =(
        ulong_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool ulong_align_4_optional::operator ==(
        const ulong_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool ulong_align_4_optional::operator !=(
        const ulong_align_4_optional& x) const
{
    return !(*this == x);
}

size_t ulong_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulong_align_4_optional_max_cdr_typesize;
}

size_t ulong_align_4_optional::getCdrSerializedSize(
        const ulong_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void ulong_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void ulong_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void ulong_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t ulong_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& ulong_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void ulong_align_4_optional::value(
        uint32_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint32_t ulong_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint32_t& ulong_align_4_optional::value()
{
    return m_value;
}



size_t ulong_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulong_align_4_optional_max_key_cdr_typesize;
}

bool ulong_align_4_optional::isKeyDefined()
{
    return false;
}

void ulong_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


longlong_align_1_optional::longlong_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // long long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

longlong_align_1_optional::~longlong_align_1_optional()
{


}

longlong_align_1_optional::longlong_align_1_optional(
        const longlong_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

longlong_align_1_optional::longlong_align_1_optional(
        longlong_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

longlong_align_1_optional& longlong_align_1_optional::operator =(
        const longlong_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

longlong_align_1_optional& longlong_align_1_optional::operator =(
        longlong_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool longlong_align_1_optional::operator ==(
        const longlong_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool longlong_align_1_optional::operator !=(
        const longlong_align_1_optional& x) const
{
    return !(*this == x);
}

size_t longlong_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longlong_align_1_optional_max_cdr_typesize;
}

size_t longlong_align_1_optional::getCdrSerializedSize(
        const longlong_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void longlong_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void longlong_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void longlong_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t longlong_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& longlong_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void longlong_align_1_optional::value(
        int64_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
int64_t longlong_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
int64_t& longlong_align_1_optional::value()
{
    return m_value;
}



size_t longlong_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longlong_align_1_optional_max_key_cdr_typesize;
}

bool longlong_align_1_optional::isKeyDefined()
{
    return false;
}

void longlong_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


longlong_align_2_optional::longlong_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // long long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

longlong_align_2_optional::~longlong_align_2_optional()
{


}

longlong_align_2_optional::longlong_align_2_optional(
        const longlong_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

longlong_align_2_optional::longlong_align_2_optional(
        longlong_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

longlong_align_2_optional& longlong_align_2_optional::operator =(
        const longlong_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

longlong_align_2_optional& longlong_align_2_optional::operator =(
        longlong_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool longlong_align_2_optional::operator ==(
        const longlong_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool longlong_align_2_optional::operator !=(
        const longlong_align_2_optional& x) const
{
    return !(*this == x);
}

size_t longlong_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longlong_align_2_optional_max_cdr_typesize;
}

size_t longlong_align_2_optional::getCdrSerializedSize(
        const longlong_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void longlong_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void longlong_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void longlong_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t longlong_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& longlong_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void longlong_align_2_optional::value(
        int64_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
int64_t longlong_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
int64_t& longlong_align_2_optional::value()
{
    return m_value;
}



size_t longlong_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longlong_align_2_optional_max_key_cdr_typesize;
}

bool longlong_align_2_optional::isKeyDefined()
{
    return false;
}

void longlong_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


longlong_align_4_optional::longlong_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // long long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

longlong_align_4_optional::~longlong_align_4_optional()
{


}

longlong_align_4_optional::longlong_align_4_optional(
        const longlong_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

longlong_align_4_optional::longlong_align_4_optional(
        longlong_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

longlong_align_4_optional& longlong_align_4_optional::operator =(
        const longlong_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

longlong_align_4_optional& longlong_align_4_optional::operator =(
        longlong_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool longlong_align_4_optional::operator ==(
        const longlong_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool longlong_align_4_optional::operator !=(
        const longlong_align_4_optional& x) const
{
    return !(*this == x);
}

size_t longlong_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longlong_align_4_optional_max_cdr_typesize;
}

size_t longlong_align_4_optional::getCdrSerializedSize(
        const longlong_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void longlong_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void longlong_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void longlong_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t longlong_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& longlong_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void longlong_align_4_optional::value(
        int64_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
int64_t longlong_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
int64_t& longlong_align_4_optional::value()
{
    return m_value;
}



size_t longlong_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longlong_align_4_optional_max_key_cdr_typesize;
}

bool longlong_align_4_optional::isKeyDefined()
{
    return false;
}

void longlong_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ulonglong_align_1_optional::ulonglong_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // unsigned long long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

ulonglong_align_1_optional::~ulonglong_align_1_optional()
{


}

ulonglong_align_1_optional::ulonglong_align_1_optional(
        const ulonglong_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ulonglong_align_1_optional::ulonglong_align_1_optional(
        ulonglong_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ulonglong_align_1_optional& ulonglong_align_1_optional::operator =(
        const ulonglong_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

ulonglong_align_1_optional& ulonglong_align_1_optional::operator =(
        ulonglong_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool ulonglong_align_1_optional::operator ==(
        const ulonglong_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool ulonglong_align_1_optional::operator !=(
        const ulonglong_align_1_optional& x) const
{
    return !(*this == x);
}

size_t ulonglong_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulonglong_align_1_optional_max_cdr_typesize;
}

size_t ulonglong_align_1_optional::getCdrSerializedSize(
        const ulonglong_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void ulonglong_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void ulonglong_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void ulonglong_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t ulonglong_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& ulonglong_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void ulonglong_align_1_optional::value(
        uint64_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint64_t ulonglong_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint64_t& ulonglong_align_1_optional::value()
{
    return m_value;
}



size_t ulonglong_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulonglong_align_1_optional_max_key_cdr_typesize;
}

bool ulonglong_align_1_optional::isKeyDefined()
{
    return false;
}

void ulonglong_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ulonglong_align_2_optional::ulonglong_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // unsigned long long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

ulonglong_align_2_optional::~ulonglong_align_2_optional()
{


}

ulonglong_align_2_optional::ulonglong_align_2_optional(
        const ulonglong_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ulonglong_align_2_optional::ulonglong_align_2_optional(
        ulonglong_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ulonglong_align_2_optional& ulonglong_align_2_optional::operator =(
        const ulonglong_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

ulonglong_align_2_optional& ulonglong_align_2_optional::operator =(
        ulonglong_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool ulonglong_align_2_optional::operator ==(
        const ulonglong_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool ulonglong_align_2_optional::operator !=(
        const ulonglong_align_2_optional& x) const
{
    return !(*this == x);
}

size_t ulonglong_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulonglong_align_2_optional_max_cdr_typesize;
}

size_t ulonglong_align_2_optional::getCdrSerializedSize(
        const ulonglong_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void ulonglong_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void ulonglong_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void ulonglong_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t ulonglong_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& ulonglong_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void ulonglong_align_2_optional::value(
        uint64_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint64_t ulonglong_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint64_t& ulonglong_align_2_optional::value()
{
    return m_value;
}



size_t ulonglong_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulonglong_align_2_optional_max_key_cdr_typesize;
}

bool ulonglong_align_2_optional::isKeyDefined()
{
    return false;
}

void ulonglong_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ulonglong_align_4_optional::ulonglong_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // unsigned long long m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

ulonglong_align_4_optional::~ulonglong_align_4_optional()
{


}

ulonglong_align_4_optional::ulonglong_align_4_optional(
        const ulonglong_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ulonglong_align_4_optional::ulonglong_align_4_optional(
        ulonglong_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

ulonglong_align_4_optional& ulonglong_align_4_optional::operator =(
        const ulonglong_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

ulonglong_align_4_optional& ulonglong_align_4_optional::operator =(
        ulonglong_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool ulonglong_align_4_optional::operator ==(
        const ulonglong_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool ulonglong_align_4_optional::operator !=(
        const ulonglong_align_4_optional& x) const
{
    return !(*this == x);
}

size_t ulonglong_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulonglong_align_4_optional_max_cdr_typesize;
}

size_t ulonglong_align_4_optional::getCdrSerializedSize(
        const ulonglong_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void ulonglong_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void ulonglong_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void ulonglong_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t ulonglong_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& ulonglong_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void ulonglong_align_4_optional::value(
        uint64_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint64_t ulonglong_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint64_t& ulonglong_align_4_optional::value()
{
    return m_value;
}



size_t ulonglong_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ulonglong_align_4_optional_max_key_cdr_typesize;
}

bool ulonglong_align_4_optional::isKeyDefined()
{
    return false;
}

void ulonglong_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


float_align_1_optional::float_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // float m_value
    m_value = 0.0;

    // Just to register all known types
    registeroptionalTypes();
}

float_align_1_optional::~float_align_1_optional()
{


}

float_align_1_optional::float_align_1_optional(
        const float_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

float_align_1_optional::float_align_1_optional(
        float_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

float_align_1_optional& float_align_1_optional::operator =(
        const float_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

float_align_1_optional& float_align_1_optional::operator =(
        float_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool float_align_1_optional::operator ==(
        const float_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool float_align_1_optional::operator !=(
        const float_align_1_optional& x) const
{
    return !(*this == x);
}

size_t float_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return float_align_1_optional_max_cdr_typesize;
}

size_t float_align_1_optional::getCdrSerializedSize(
        const float_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void float_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void float_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void float_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t float_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& float_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void float_align_1_optional::value(
        float _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
float float_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
float& float_align_1_optional::value()
{
    return m_value;
}



size_t float_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return float_align_1_optional_max_key_cdr_typesize;
}

bool float_align_1_optional::isKeyDefined()
{
    return false;
}

void float_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


float_align_2_optional::float_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // float m_value
    m_value = 0.0;

    // Just to register all known types
    registeroptionalTypes();
}

float_align_2_optional::~float_align_2_optional()
{


}

float_align_2_optional::float_align_2_optional(
        const float_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

float_align_2_optional::float_align_2_optional(
        float_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

float_align_2_optional& float_align_2_optional::operator =(
        const float_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

float_align_2_optional& float_align_2_optional::operator =(
        float_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool float_align_2_optional::operator ==(
        const float_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool float_align_2_optional::operator !=(
        const float_align_2_optional& x) const
{
    return !(*this == x);
}

size_t float_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return float_align_2_optional_max_cdr_typesize;
}

size_t float_align_2_optional::getCdrSerializedSize(
        const float_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void float_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void float_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void float_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t float_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& float_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void float_align_2_optional::value(
        float _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
float float_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
float& float_align_2_optional::value()
{
    return m_value;
}



size_t float_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return float_align_2_optional_max_key_cdr_typesize;
}

bool float_align_2_optional::isKeyDefined()
{
    return false;
}

void float_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


float_align_4_optional::float_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // float m_value
    m_value = 0.0;

    // Just to register all known types
    registeroptionalTypes();
}

float_align_4_optional::~float_align_4_optional()
{


}

float_align_4_optional::float_align_4_optional(
        const float_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

float_align_4_optional::float_align_4_optional(
        float_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

float_align_4_optional& float_align_4_optional::operator =(
        const float_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

float_align_4_optional& float_align_4_optional::operator =(
        float_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool float_align_4_optional::operator ==(
        const float_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool float_align_4_optional::operator !=(
        const float_align_4_optional& x) const
{
    return !(*this == x);
}

size_t float_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return float_align_4_optional_max_cdr_typesize;
}

size_t float_align_4_optional::getCdrSerializedSize(
        const float_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void float_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void float_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void float_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t float_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& float_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void float_align_4_optional::value(
        float _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
float float_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
float& float_align_4_optional::value()
{
    return m_value;
}



size_t float_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return float_align_4_optional_max_key_cdr_typesize;
}

bool float_align_4_optional::isKeyDefined()
{
    return false;
}

void float_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


double_align_1_optional::double_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // double m_value
    m_value = 0.0;

    // Just to register all known types
    registeroptionalTypes();
}

double_align_1_optional::~double_align_1_optional()
{


}

double_align_1_optional::double_align_1_optional(
        const double_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

double_align_1_optional::double_align_1_optional(
        double_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

double_align_1_optional& double_align_1_optional::operator =(
        const double_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

double_align_1_optional& double_align_1_optional::operator =(
        double_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool double_align_1_optional::operator ==(
        const double_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool double_align_1_optional::operator !=(
        const double_align_1_optional& x) const
{
    return !(*this == x);
}

size_t double_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return double_align_1_optional_max_cdr_typesize;
}

size_t double_align_1_optional::getCdrSerializedSize(
        const double_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void double_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void double_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void double_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t double_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& double_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void double_align_1_optional::value(
        double _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
double double_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
double& double_align_1_optional::value()
{
    return m_value;
}



size_t double_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return double_align_1_optional_max_key_cdr_typesize;
}

bool double_align_1_optional::isKeyDefined()
{
    return false;
}

void double_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


double_align_2_optional::double_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // double m_value
    m_value = 0.0;

    // Just to register all known types
    registeroptionalTypes();
}

double_align_2_optional::~double_align_2_optional()
{


}

double_align_2_optional::double_align_2_optional(
        const double_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

double_align_2_optional::double_align_2_optional(
        double_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

double_align_2_optional& double_align_2_optional::operator =(
        const double_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

double_align_2_optional& double_align_2_optional::operator =(
        double_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool double_align_2_optional::operator ==(
        const double_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool double_align_2_optional::operator !=(
        const double_align_2_optional& x) const
{
    return !(*this == x);
}

size_t double_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return double_align_2_optional_max_cdr_typesize;
}

size_t double_align_2_optional::getCdrSerializedSize(
        const double_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void double_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void double_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void double_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t double_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& double_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void double_align_2_optional::value(
        double _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
double double_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
double& double_align_2_optional::value()
{
    return m_value;
}



size_t double_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return double_align_2_optional_max_key_cdr_typesize;
}

bool double_align_2_optional::isKeyDefined()
{
    return false;
}

void double_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


double_align_4_optional::double_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // double m_value
    m_value = 0.0;

    // Just to register all known types
    registeroptionalTypes();
}

double_align_4_optional::~double_align_4_optional()
{


}

double_align_4_optional::double_align_4_optional(
        const double_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

double_align_4_optional::double_align_4_optional(
        double_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

double_align_4_optional& double_align_4_optional::operator =(
        const double_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

double_align_4_optional& double_align_4_optional::operator =(
        double_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool double_align_4_optional::operator ==(
        const double_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool double_align_4_optional::operator !=(
        const double_align_4_optional& x) const
{
    return !(*this == x);
}

size_t double_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return double_align_4_optional_max_cdr_typesize;
}

size_t double_align_4_optional::getCdrSerializedSize(
        const double_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void double_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void double_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void double_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t double_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& double_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void double_align_4_optional::value(
        double _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
double double_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
double& double_align_4_optional::value()
{
    return m_value;
}



size_t double_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return double_align_4_optional_max_key_cdr_typesize;
}

bool double_align_4_optional::isKeyDefined()
{
    return false;
}

void double_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


longdouble_align_1_optional::longdouble_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // long double m_value
    m_value = 0.0;

    // Just to register all known types
    registeroptionalTypes();
}

longdouble_align_1_optional::~longdouble_align_1_optional()
{


}

longdouble_align_1_optional::longdouble_align_1_optional(
        const longdouble_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

longdouble_align_1_optional::longdouble_align_1_optional(
        longdouble_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

longdouble_align_1_optional& longdouble_align_1_optional::operator =(
        const longdouble_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

longdouble_align_1_optional& longdouble_align_1_optional::operator =(
        longdouble_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool longdouble_align_1_optional::operator ==(
        const longdouble_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool longdouble_align_1_optional::operator !=(
        const longdouble_align_1_optional& x) const
{
    return !(*this == x);
}

size_t longdouble_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longdouble_align_1_optional_max_cdr_typesize;
}

size_t longdouble_align_1_optional::getCdrSerializedSize(
        const longdouble_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 16 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8); // 128 bits, but aligned as 64


    return current_alignment - initial_alignment;
}

void longdouble_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void longdouble_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void longdouble_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t longdouble_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& longdouble_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void longdouble_align_1_optional::value(
        long double _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
long double longdouble_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
long double& longdouble_align_1_optional::value()
{
    return m_value;
}



size_t longdouble_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longdouble_align_1_optional_max_key_cdr_typesize;
}

bool longdouble_align_1_optional::isKeyDefined()
{
    return false;
}

void longdouble_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


longdouble_align_2_optional::longdouble_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // long double m_value
    m_value = 0.0;

    // Just to register all known types
    registeroptionalTypes();
}

longdouble_align_2_optional::~longdouble_align_2_optional()
{


}

longdouble_align_2_optional::longdouble_align_2_optional(
        const longdouble_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

longdouble_align_2_optional::longdouble_align_2_optional(
        longdouble_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

longdouble_align_2_optional& longdouble_align_2_optional::operator =(
        const longdouble_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

longdouble_align_2_optional& longdouble_align_2_optional::operator =(
        longdouble_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool longdouble_align_2_optional::operator ==(
        const longdouble_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool longdouble_align_2_optional::operator !=(
        const longdouble_align_2_optional& x) const
{
    return !(*this == x);
}

size_t longdouble_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longdouble_align_2_optional_max_cdr_typesize;
}

size_t longdouble_align_2_optional::getCdrSerializedSize(
        const longdouble_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 16 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8); // 128 bits, but aligned as 64


    return current_alignment - initial_alignment;
}

void longdouble_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void longdouble_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void longdouble_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t longdouble_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& longdouble_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void longdouble_align_2_optional::value(
        long double _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
long double longdouble_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
long double& longdouble_align_2_optional::value()
{
    return m_value;
}



size_t longdouble_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longdouble_align_2_optional_max_key_cdr_typesize;
}

bool longdouble_align_2_optional::isKeyDefined()
{
    return false;
}

void longdouble_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


longdouble_align_4_optional::longdouble_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // long double m_value
    m_value = 0.0;

    // Just to register all known types
    registeroptionalTypes();
}

longdouble_align_4_optional::~longdouble_align_4_optional()
{


}

longdouble_align_4_optional::longdouble_align_4_optional(
        const longdouble_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

longdouble_align_4_optional::longdouble_align_4_optional(
        longdouble_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

longdouble_align_4_optional& longdouble_align_4_optional::operator =(
        const longdouble_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

longdouble_align_4_optional& longdouble_align_4_optional::operator =(
        longdouble_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool longdouble_align_4_optional::operator ==(
        const longdouble_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool longdouble_align_4_optional::operator !=(
        const longdouble_align_4_optional& x) const
{
    return !(*this == x);
}

size_t longdouble_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longdouble_align_4_optional_max_cdr_typesize;
}

size_t longdouble_align_4_optional::getCdrSerializedSize(
        const longdouble_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 16 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8); // 128 bits, but aligned as 64


    return current_alignment - initial_alignment;
}

void longdouble_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void longdouble_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void longdouble_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t longdouble_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& longdouble_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void longdouble_align_4_optional::value(
        long double _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
long double longdouble_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
long double& longdouble_align_4_optional::value()
{
    return m_value;
}



size_t longdouble_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return longdouble_align_4_optional_max_key_cdr_typesize;
}

bool longdouble_align_4_optional::isKeyDefined()
{
    return false;
}

void longdouble_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


boolean_align_1_optional::boolean_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // boolean m_value
    m_value = false;

    // Just to register all known types
    registeroptionalTypes();
}

boolean_align_1_optional::~boolean_align_1_optional()
{


}

boolean_align_1_optional::boolean_align_1_optional(
        const boolean_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

boolean_align_1_optional::boolean_align_1_optional(
        boolean_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

boolean_align_1_optional& boolean_align_1_optional::operator =(
        const boolean_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

boolean_align_1_optional& boolean_align_1_optional::operator =(
        boolean_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool boolean_align_1_optional::operator ==(
        const boolean_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool boolean_align_1_optional::operator !=(
        const boolean_align_1_optional& x) const
{
    return !(*this == x);
}

size_t boolean_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return boolean_align_1_optional_max_cdr_typesize;
}

size_t boolean_align_1_optional::getCdrSerializedSize(
        const boolean_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void boolean_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void boolean_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void boolean_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t boolean_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& boolean_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void boolean_align_1_optional::value(
        bool _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
bool boolean_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
bool& boolean_align_1_optional::value()
{
    return m_value;
}



size_t boolean_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return boolean_align_1_optional_max_key_cdr_typesize;
}

bool boolean_align_1_optional::isKeyDefined()
{
    return false;
}

void boolean_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


boolean_align_2_optional::boolean_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // boolean m_value
    m_value = false;

    // Just to register all known types
    registeroptionalTypes();
}

boolean_align_2_optional::~boolean_align_2_optional()
{


}

boolean_align_2_optional::boolean_align_2_optional(
        const boolean_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

boolean_align_2_optional::boolean_align_2_optional(
        boolean_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

boolean_align_2_optional& boolean_align_2_optional::operator =(
        const boolean_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

boolean_align_2_optional& boolean_align_2_optional::operator =(
        boolean_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool boolean_align_2_optional::operator ==(
        const boolean_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool boolean_align_2_optional::operator !=(
        const boolean_align_2_optional& x) const
{
    return !(*this == x);
}

size_t boolean_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return boolean_align_2_optional_max_cdr_typesize;
}

size_t boolean_align_2_optional::getCdrSerializedSize(
        const boolean_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void boolean_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void boolean_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void boolean_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t boolean_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& boolean_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void boolean_align_2_optional::value(
        bool _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
bool boolean_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
bool& boolean_align_2_optional::value()
{
    return m_value;
}



size_t boolean_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return boolean_align_2_optional_max_key_cdr_typesize;
}

bool boolean_align_2_optional::isKeyDefined()
{
    return false;
}

void boolean_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


boolean_align_4_optional::boolean_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // boolean m_value
    m_value = false;

    // Just to register all known types
    registeroptionalTypes();
}

boolean_align_4_optional::~boolean_align_4_optional()
{


}

boolean_align_4_optional::boolean_align_4_optional(
        const boolean_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

boolean_align_4_optional::boolean_align_4_optional(
        boolean_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

boolean_align_4_optional& boolean_align_4_optional::operator =(
        const boolean_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

boolean_align_4_optional& boolean_align_4_optional::operator =(
        boolean_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool boolean_align_4_optional::operator ==(
        const boolean_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool boolean_align_4_optional::operator !=(
        const boolean_align_4_optional& x) const
{
    return !(*this == x);
}

size_t boolean_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return boolean_align_4_optional_max_cdr_typesize;
}

size_t boolean_align_4_optional::getCdrSerializedSize(
        const boolean_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void boolean_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void boolean_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void boolean_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t boolean_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& boolean_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void boolean_align_4_optional::value(
        bool _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
bool boolean_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
bool& boolean_align_4_optional::value()
{
    return m_value;
}



size_t boolean_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return boolean_align_4_optional_max_key_cdr_typesize;
}

bool boolean_align_4_optional::isKeyDefined()
{
    return false;
}

void boolean_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


octet_align_1_optional::octet_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // octet m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

octet_align_1_optional::~octet_align_1_optional()
{


}

octet_align_1_optional::octet_align_1_optional(
        const octet_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

octet_align_1_optional::octet_align_1_optional(
        octet_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

octet_align_1_optional& octet_align_1_optional::operator =(
        const octet_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

octet_align_1_optional& octet_align_1_optional::operator =(
        octet_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool octet_align_1_optional::operator ==(
        const octet_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool octet_align_1_optional::operator !=(
        const octet_align_1_optional& x) const
{
    return !(*this == x);
}

size_t octet_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return octet_align_1_optional_max_cdr_typesize;
}

size_t octet_align_1_optional::getCdrSerializedSize(
        const octet_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void octet_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void octet_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void octet_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t octet_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& octet_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void octet_align_1_optional::value(
        uint8_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint8_t octet_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint8_t& octet_align_1_optional::value()
{
    return m_value;
}



size_t octet_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return octet_align_1_optional_max_key_cdr_typesize;
}

bool octet_align_1_optional::isKeyDefined()
{
    return false;
}

void octet_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


octet_align_2_optional::octet_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // octet m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

octet_align_2_optional::~octet_align_2_optional()
{


}

octet_align_2_optional::octet_align_2_optional(
        const octet_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

octet_align_2_optional::octet_align_2_optional(
        octet_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

octet_align_2_optional& octet_align_2_optional::operator =(
        const octet_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

octet_align_2_optional& octet_align_2_optional::operator =(
        octet_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool octet_align_2_optional::operator ==(
        const octet_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool octet_align_2_optional::operator !=(
        const octet_align_2_optional& x) const
{
    return !(*this == x);
}

size_t octet_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return octet_align_2_optional_max_cdr_typesize;
}

size_t octet_align_2_optional::getCdrSerializedSize(
        const octet_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void octet_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void octet_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void octet_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t octet_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& octet_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void octet_align_2_optional::value(
        uint8_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint8_t octet_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint8_t& octet_align_2_optional::value()
{
    return m_value;
}



size_t octet_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return octet_align_2_optional_max_key_cdr_typesize;
}

bool octet_align_2_optional::isKeyDefined()
{
    return false;
}

void octet_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


octet_align_4_optional::octet_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // octet m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

octet_align_4_optional::~octet_align_4_optional()
{


}

octet_align_4_optional::octet_align_4_optional(
        const octet_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

octet_align_4_optional::octet_align_4_optional(
        octet_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

octet_align_4_optional& octet_align_4_optional::operator =(
        const octet_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

octet_align_4_optional& octet_align_4_optional::operator =(
        octet_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool octet_align_4_optional::operator ==(
        const octet_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool octet_align_4_optional::operator !=(
        const octet_align_4_optional& x) const
{
    return !(*this == x);
}

size_t octet_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return octet_align_4_optional_max_cdr_typesize;
}

size_t octet_align_4_optional::getCdrSerializedSize(
        const octet_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void octet_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void octet_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void octet_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t octet_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& octet_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void octet_align_4_optional::value(
        uint8_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
uint8_t octet_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
uint8_t& octet_align_4_optional::value()
{
    return m_value;
}



size_t octet_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return octet_align_4_optional_max_key_cdr_typesize;
}

bool octet_align_4_optional::isKeyDefined()
{
    return false;
}

void octet_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


char_align_1_optional::char_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // char m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

char_align_1_optional::~char_align_1_optional()
{


}

char_align_1_optional::char_align_1_optional(
        const char_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

char_align_1_optional::char_align_1_optional(
        char_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

char_align_1_optional& char_align_1_optional::operator =(
        const char_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

char_align_1_optional& char_align_1_optional::operator =(
        char_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool char_align_1_optional::operator ==(
        const char_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool char_align_1_optional::operator !=(
        const char_align_1_optional& x) const
{
    return !(*this == x);
}

size_t char_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return char_align_1_optional_max_cdr_typesize;
}

size_t char_align_1_optional::getCdrSerializedSize(
        const char_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void char_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void char_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void char_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t char_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& char_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void char_align_1_optional::value(
        char _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
char char_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
char& char_align_1_optional::value()
{
    return m_value;
}



size_t char_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return char_align_1_optional_max_key_cdr_typesize;
}

bool char_align_1_optional::isKeyDefined()
{
    return false;
}

void char_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


char_align_2_optional::char_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // char m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

char_align_2_optional::~char_align_2_optional()
{


}

char_align_2_optional::char_align_2_optional(
        const char_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

char_align_2_optional::char_align_2_optional(
        char_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

char_align_2_optional& char_align_2_optional::operator =(
        const char_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

char_align_2_optional& char_align_2_optional::operator =(
        char_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool char_align_2_optional::operator ==(
        const char_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool char_align_2_optional::operator !=(
        const char_align_2_optional& x) const
{
    return !(*this == x);
}

size_t char_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return char_align_2_optional_max_cdr_typesize;
}

size_t char_align_2_optional::getCdrSerializedSize(
        const char_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void char_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void char_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void char_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t char_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& char_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void char_align_2_optional::value(
        char _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
char char_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
char& char_align_2_optional::value()
{
    return m_value;
}



size_t char_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return char_align_2_optional_max_key_cdr_typesize;
}

bool char_align_2_optional::isKeyDefined()
{
    return false;
}

void char_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


char_align_4_optional::char_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // char m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

char_align_4_optional::~char_align_4_optional()
{


}

char_align_4_optional::char_align_4_optional(
        const char_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

char_align_4_optional::char_align_4_optional(
        char_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

char_align_4_optional& char_align_4_optional::operator =(
        const char_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

char_align_4_optional& char_align_4_optional::operator =(
        char_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool char_align_4_optional::operator ==(
        const char_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool char_align_4_optional::operator !=(
        const char_align_4_optional& x) const
{
    return !(*this == x);
}

size_t char_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return char_align_4_optional_max_cdr_typesize;
}

size_t char_align_4_optional::getCdrSerializedSize(
        const char_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void char_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void char_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void char_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t char_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& char_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void char_align_4_optional::value(
        char _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
char char_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
char& char_align_4_optional::value()
{
    return m_value;
}



size_t char_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return char_align_4_optional_max_key_cdr_typesize;
}

bool char_align_4_optional::isKeyDefined()
{
    return false;
}

void char_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


wchar_align_1_optional::wchar_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // wchar m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

wchar_align_1_optional::~wchar_align_1_optional()
{


}

wchar_align_1_optional::wchar_align_1_optional(
        const wchar_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

wchar_align_1_optional::wchar_align_1_optional(
        wchar_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

wchar_align_1_optional& wchar_align_1_optional::operator =(
        const wchar_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

wchar_align_1_optional& wchar_align_1_optional::operator =(
        wchar_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool wchar_align_1_optional::operator ==(
        const wchar_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool wchar_align_1_optional::operator !=(
        const wchar_align_1_optional& x) const
{
    return !(*this == x);
}

size_t wchar_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return wchar_align_1_optional_max_cdr_typesize;
}

size_t wchar_align_1_optional::getCdrSerializedSize(
        const wchar_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void wchar_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void wchar_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void wchar_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t wchar_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& wchar_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void wchar_align_1_optional::value(
        wchar_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
wchar_t wchar_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
wchar_t& wchar_align_1_optional::value()
{
    return m_value;
}



size_t wchar_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return wchar_align_1_optional_max_key_cdr_typesize;
}

bool wchar_align_1_optional::isKeyDefined()
{
    return false;
}

void wchar_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


wchar_align_2_optional::wchar_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // wchar m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

wchar_align_2_optional::~wchar_align_2_optional()
{


}

wchar_align_2_optional::wchar_align_2_optional(
        const wchar_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

wchar_align_2_optional::wchar_align_2_optional(
        wchar_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

wchar_align_2_optional& wchar_align_2_optional::operator =(
        const wchar_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

wchar_align_2_optional& wchar_align_2_optional::operator =(
        wchar_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool wchar_align_2_optional::operator ==(
        const wchar_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool wchar_align_2_optional::operator !=(
        const wchar_align_2_optional& x) const
{
    return !(*this == x);
}

size_t wchar_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return wchar_align_2_optional_max_cdr_typesize;
}

size_t wchar_align_2_optional::getCdrSerializedSize(
        const wchar_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void wchar_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void wchar_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void wchar_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t wchar_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& wchar_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void wchar_align_2_optional::value(
        wchar_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
wchar_t wchar_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
wchar_t& wchar_align_2_optional::value()
{
    return m_value;
}



size_t wchar_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return wchar_align_2_optional_max_key_cdr_typesize;
}

bool wchar_align_2_optional::isKeyDefined()
{
    return false;
}

void wchar_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


wchar_align_4_optional::wchar_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // wchar m_value
    m_value = 0;

    // Just to register all known types
    registeroptionalTypes();
}

wchar_align_4_optional::~wchar_align_4_optional()
{


}

wchar_align_4_optional::wchar_align_4_optional(
        const wchar_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

wchar_align_4_optional::wchar_align_4_optional(
        wchar_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = x.m_value;
}

wchar_align_4_optional& wchar_align_4_optional::operator =(
        const wchar_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

wchar_align_4_optional& wchar_align_4_optional::operator =(
        wchar_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

bool wchar_align_4_optional::operator ==(
        const wchar_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool wchar_align_4_optional::operator !=(
        const wchar_align_4_optional& x) const
{
    return !(*this == x);
}

size_t wchar_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return wchar_align_4_optional_max_cdr_typesize;
}

size_t wchar_align_4_optional::getCdrSerializedSize(
        const wchar_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void wchar_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void wchar_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void wchar_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t wchar_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& wchar_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void wchar_align_4_optional::value(
        wchar_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
wchar_t wchar_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
wchar_t& wchar_align_4_optional::value()
{
    return m_value;
}



size_t wchar_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return wchar_align_4_optional_max_key_cdr_typesize;
}

bool wchar_align_4_optional::isKeyDefined()
{
    return false;
}

void wchar_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


sequence_short_optional::sequence_short_optional()
{
    // sequence<short> m_value


    // Just to register all known types
    registeroptionalTypes();
}

sequence_short_optional::~sequence_short_optional()
{
}

sequence_short_optional::sequence_short_optional(
        const sequence_short_optional& x)
{
    m_value = x.m_value;
}

sequence_short_optional::sequence_short_optional(
        sequence_short_optional&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

sequence_short_optional& sequence_short_optional::operator =(
        const sequence_short_optional& x)
{

    m_value = x.m_value;

    return *this;
}

sequence_short_optional& sequence_short_optional::operator =(
        sequence_short_optional&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool sequence_short_optional::operator ==(
        const sequence_short_optional& x) const
{

    return (m_value == x.m_value);
}

bool sequence_short_optional::operator !=(
        const sequence_short_optional& x) const
{
    return !(*this == x);
}

size_t sequence_short_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return sequence_short_optional_max_cdr_typesize;
}

size_t sequence_short_optional::getCdrSerializedSize(
        const sequence_short_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.value().size() > 0)
    {
        current_alignment += (data.value().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }



    return current_alignment - initial_alignment;
}

void sequence_short_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void sequence_short_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void sequence_short_optional::value(
        const std::vector<int16_t>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void sequence_short_optional::value(
        std::vector<int16_t>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::vector<int16_t>& sequence_short_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::vector<int16_t>& sequence_short_optional::value()
{
    return m_value;
}


size_t sequence_short_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return sequence_short_optional_max_key_cdr_typesize;
}

bool sequence_short_optional::isKeyDefined()
{
    return false;
}

void sequence_short_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


sequence_short_align_1_optional::sequence_short_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // sequence<short> m_value


    // Just to register all known types
    registeroptionalTypes();
}

sequence_short_align_1_optional::~sequence_short_align_1_optional()
{


}

sequence_short_align_1_optional::sequence_short_align_1_optional(
        const sequence_short_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

sequence_short_align_1_optional::sequence_short_align_1_optional(
        sequence_short_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

sequence_short_align_1_optional& sequence_short_align_1_optional::operator =(
        const sequence_short_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

sequence_short_align_1_optional& sequence_short_align_1_optional::operator =(
        sequence_short_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool sequence_short_align_1_optional::operator ==(
        const sequence_short_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool sequence_short_align_1_optional::operator !=(
        const sequence_short_align_1_optional& x) const
{
    return !(*this == x);
}

size_t sequence_short_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return sequence_short_align_1_optional_max_cdr_typesize;
}

size_t sequence_short_align_1_optional::getCdrSerializedSize(
        const sequence_short_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.value().size() > 0)
    {
        current_alignment += (data.value().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }




    return current_alignment - initial_alignment;
}

void sequence_short_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;

}

void sequence_short_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void sequence_short_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t sequence_short_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& sequence_short_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void sequence_short_align_1_optional::value(
        const std::vector<int16_t>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void sequence_short_align_1_optional::value(
        std::vector<int16_t>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::vector<int16_t>& sequence_short_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::vector<int16_t>& sequence_short_align_1_optional::value()
{
    return m_value;
}


size_t sequence_short_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return sequence_short_align_1_optional_max_key_cdr_typesize;
}

bool sequence_short_align_1_optional::isKeyDefined()
{
    return false;
}

void sequence_short_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


sequence_short_align_2_optional::sequence_short_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // sequence<short> m_value


    // Just to register all known types
    registeroptionalTypes();
}

sequence_short_align_2_optional::~sequence_short_align_2_optional()
{


}

sequence_short_align_2_optional::sequence_short_align_2_optional(
        const sequence_short_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

sequence_short_align_2_optional::sequence_short_align_2_optional(
        sequence_short_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

sequence_short_align_2_optional& sequence_short_align_2_optional::operator =(
        const sequence_short_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

sequence_short_align_2_optional& sequence_short_align_2_optional::operator =(
        sequence_short_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool sequence_short_align_2_optional::operator ==(
        const sequence_short_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool sequence_short_align_2_optional::operator !=(
        const sequence_short_align_2_optional& x) const
{
    return !(*this == x);
}

size_t sequence_short_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return sequence_short_align_2_optional_max_cdr_typesize;
}

size_t sequence_short_align_2_optional::getCdrSerializedSize(
        const sequence_short_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.value().size() > 0)
    {
        current_alignment += (data.value().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }




    return current_alignment - initial_alignment;
}

void sequence_short_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;

}

void sequence_short_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void sequence_short_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t sequence_short_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& sequence_short_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void sequence_short_align_2_optional::value(
        const std::vector<int16_t>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void sequence_short_align_2_optional::value(
        std::vector<int16_t>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::vector<int16_t>& sequence_short_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::vector<int16_t>& sequence_short_align_2_optional::value()
{
    return m_value;
}


size_t sequence_short_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return sequence_short_align_2_optional_max_key_cdr_typesize;
}

bool sequence_short_align_2_optional::isKeyDefined()
{
    return false;
}

void sequence_short_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


sequence_short_align_4_optional::sequence_short_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // sequence<short> m_value


    // Just to register all known types
    registeroptionalTypes();
}

sequence_short_align_4_optional::~sequence_short_align_4_optional()
{


}

sequence_short_align_4_optional::sequence_short_align_4_optional(
        const sequence_short_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

sequence_short_align_4_optional::sequence_short_align_4_optional(
        sequence_short_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

sequence_short_align_4_optional& sequence_short_align_4_optional::operator =(
        const sequence_short_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

sequence_short_align_4_optional& sequence_short_align_4_optional::operator =(
        sequence_short_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool sequence_short_align_4_optional::operator ==(
        const sequence_short_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool sequence_short_align_4_optional::operator !=(
        const sequence_short_align_4_optional& x) const
{
    return !(*this == x);
}

size_t sequence_short_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return sequence_short_align_4_optional_max_cdr_typesize;
}

size_t sequence_short_align_4_optional::getCdrSerializedSize(
        const sequence_short_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.value().size() > 0)
    {
        current_alignment += (data.value().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }




    return current_alignment - initial_alignment;
}

void sequence_short_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;

}

void sequence_short_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void sequence_short_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t sequence_short_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& sequence_short_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void sequence_short_align_4_optional::value(
        const std::vector<int16_t>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void sequence_short_align_4_optional::value(
        std::vector<int16_t>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::vector<int16_t>& sequence_short_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::vector<int16_t>& sequence_short_align_4_optional::value()
{
    return m_value;
}


size_t sequence_short_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return sequence_short_align_4_optional_max_key_cdr_typesize;
}

bool sequence_short_align_4_optional::isKeyDefined()
{
    return false;
}

void sequence_short_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


string_unbounded_optional::string_unbounded_optional()
{
    // string m_value
    m_value = "";


    // Just to register all known types
    registeroptionalTypes();
}

string_unbounded_optional::~string_unbounded_optional()
{
}

string_unbounded_optional::string_unbounded_optional(
        const string_unbounded_optional& x)
{
    m_value = x.m_value;
}

string_unbounded_optional::string_unbounded_optional(
        string_unbounded_optional&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

string_unbounded_optional& string_unbounded_optional::operator =(
        const string_unbounded_optional& x)
{

    m_value = x.m_value;

    return *this;
}

string_unbounded_optional& string_unbounded_optional::operator =(
        string_unbounded_optional&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool string_unbounded_optional::operator ==(
        const string_unbounded_optional& x) const
{

    return (m_value == x.m_value);
}

bool string_unbounded_optional::operator !=(
        const string_unbounded_optional& x) const
{
    return !(*this == x);
}

size_t string_unbounded_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_unbounded_optional_max_cdr_typesize;
}

size_t string_unbounded_optional::getCdrSerializedSize(
        const string_unbounded_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.value().size() + 1;

    return current_alignment - initial_alignment;
}

void string_unbounded_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value.c_str();
}

void string_unbounded_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void string_unbounded_optional::value(
        const std::string& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void string_unbounded_optional::value(
        std::string&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::string& string_unbounded_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::string& string_unbounded_optional::value()
{
    return m_value;
}


size_t string_unbounded_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_unbounded_optional_max_key_cdr_typesize;
}

bool string_unbounded_optional::isKeyDefined()
{
    return false;
}

void string_unbounded_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


string_unbounded_align_1_optional::string_unbounded_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // string m_value
    m_value = "";


    // Just to register all known types
    registeroptionalTypes();
}

string_unbounded_align_1_optional::~string_unbounded_align_1_optional()
{


}

string_unbounded_align_1_optional::string_unbounded_align_1_optional(
        const string_unbounded_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

string_unbounded_align_1_optional::string_unbounded_align_1_optional(
        string_unbounded_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

string_unbounded_align_1_optional& string_unbounded_align_1_optional::operator =(
        const string_unbounded_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

string_unbounded_align_1_optional& string_unbounded_align_1_optional::operator =(
        string_unbounded_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool string_unbounded_align_1_optional::operator ==(
        const string_unbounded_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool string_unbounded_align_1_optional::operator !=(
        const string_unbounded_align_1_optional& x) const
{
    return !(*this == x);
}

size_t string_unbounded_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_unbounded_align_1_optional_max_cdr_typesize;
}

size_t string_unbounded_align_1_optional::getCdrSerializedSize(
        const string_unbounded_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.value().size() + 1;


    return current_alignment - initial_alignment;
}

void string_unbounded_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value.c_str();
}

void string_unbounded_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void string_unbounded_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t string_unbounded_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& string_unbounded_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void string_unbounded_align_1_optional::value(
        const std::string& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void string_unbounded_align_1_optional::value(
        std::string&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::string& string_unbounded_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::string& string_unbounded_align_1_optional::value()
{
    return m_value;
}


size_t string_unbounded_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_unbounded_align_1_optional_max_key_cdr_typesize;
}

bool string_unbounded_align_1_optional::isKeyDefined()
{
    return false;
}

void string_unbounded_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


string_unbounded_align_2_optional::string_unbounded_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // string m_value
    m_value = "";


    // Just to register all known types
    registeroptionalTypes();
}

string_unbounded_align_2_optional::~string_unbounded_align_2_optional()
{


}

string_unbounded_align_2_optional::string_unbounded_align_2_optional(
        const string_unbounded_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

string_unbounded_align_2_optional::string_unbounded_align_2_optional(
        string_unbounded_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

string_unbounded_align_2_optional& string_unbounded_align_2_optional::operator =(
        const string_unbounded_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

string_unbounded_align_2_optional& string_unbounded_align_2_optional::operator =(
        string_unbounded_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool string_unbounded_align_2_optional::operator ==(
        const string_unbounded_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool string_unbounded_align_2_optional::operator !=(
        const string_unbounded_align_2_optional& x) const
{
    return !(*this == x);
}

size_t string_unbounded_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_unbounded_align_2_optional_max_cdr_typesize;
}

size_t string_unbounded_align_2_optional::getCdrSerializedSize(
        const string_unbounded_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.value().size() + 1;


    return current_alignment - initial_alignment;
}

void string_unbounded_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value.c_str();
}

void string_unbounded_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void string_unbounded_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t string_unbounded_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& string_unbounded_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void string_unbounded_align_2_optional::value(
        const std::string& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void string_unbounded_align_2_optional::value(
        std::string&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::string& string_unbounded_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::string& string_unbounded_align_2_optional::value()
{
    return m_value;
}


size_t string_unbounded_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_unbounded_align_2_optional_max_key_cdr_typesize;
}

bool string_unbounded_align_2_optional::isKeyDefined()
{
    return false;
}

void string_unbounded_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


string_unbounded_align_4_optional::string_unbounded_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // string m_value
    m_value = "";


    // Just to register all known types
    registeroptionalTypes();
}

string_unbounded_align_4_optional::~string_unbounded_align_4_optional()
{


}

string_unbounded_align_4_optional::string_unbounded_align_4_optional(
        const string_unbounded_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

string_unbounded_align_4_optional::string_unbounded_align_4_optional(
        string_unbounded_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

string_unbounded_align_4_optional& string_unbounded_align_4_optional::operator =(
        const string_unbounded_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

string_unbounded_align_4_optional& string_unbounded_align_4_optional::operator =(
        string_unbounded_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool string_unbounded_align_4_optional::operator ==(
        const string_unbounded_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool string_unbounded_align_4_optional::operator !=(
        const string_unbounded_align_4_optional& x) const
{
    return !(*this == x);
}

size_t string_unbounded_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_unbounded_align_4_optional_max_cdr_typesize;
}

size_t string_unbounded_align_4_optional::getCdrSerializedSize(
        const string_unbounded_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.value().size() + 1;


    return current_alignment - initial_alignment;
}

void string_unbounded_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value.c_str();
}

void string_unbounded_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void string_unbounded_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t string_unbounded_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& string_unbounded_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void string_unbounded_align_4_optional::value(
        const std::string& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void string_unbounded_align_4_optional::value(
        std::string&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::string& string_unbounded_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::string& string_unbounded_align_4_optional::value()
{
    return m_value;
}


size_t string_unbounded_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_unbounded_align_4_optional_max_key_cdr_typesize;
}

bool string_unbounded_align_4_optional::isKeyDefined()
{
    return false;
}

void string_unbounded_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


string_bounded_optional::string_bounded_optional()
{
    // string m_value
    m_value = "";


    // Just to register all known types
    registeroptionalTypes();
}

string_bounded_optional::~string_bounded_optional()
{
}

string_bounded_optional::string_bounded_optional(
        const string_bounded_optional& x)
{
    m_value = x.m_value;
}

string_bounded_optional::string_bounded_optional(
        string_bounded_optional&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

string_bounded_optional& string_bounded_optional::operator =(
        const string_bounded_optional& x)
{

    m_value = x.m_value;

    return *this;
}

string_bounded_optional& string_bounded_optional::operator =(
        string_bounded_optional&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool string_bounded_optional::operator ==(
        const string_bounded_optional& x) const
{

    return (m_value == x.m_value);
}

bool string_bounded_optional::operator !=(
        const string_bounded_optional& x) const
{
    return !(*this == x);
}

size_t string_bounded_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_bounded_optional_max_cdr_typesize;
}

size_t string_bounded_optional::getCdrSerializedSize(
        const string_bounded_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.value().size() + 1;

    return current_alignment - initial_alignment;
}

void string_bounded_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value.c_str();
}

void string_bounded_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        std::string aux;
        dcdr >> aux;
        m_value = aux.c_str();
    }}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void string_bounded_optional::value(
        const eprosima::fastrtps::fixed_string<8>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void string_bounded_optional::value(
        eprosima::fastrtps::fixed_string<8>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const eprosima::fastrtps::fixed_string<8>& string_bounded_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
eprosima::fastrtps::fixed_string<8>& string_bounded_optional::value()
{
    return m_value;
}


size_t string_bounded_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_bounded_optional_max_key_cdr_typesize;
}

bool string_bounded_optional::isKeyDefined()
{
    return false;
}

void string_bounded_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


string_bounded_align_1_optional::string_bounded_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // string m_value
    m_value = "";


    // Just to register all known types
    registeroptionalTypes();
}

string_bounded_align_1_optional::~string_bounded_align_1_optional()
{


}

string_bounded_align_1_optional::string_bounded_align_1_optional(
        const string_bounded_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

string_bounded_align_1_optional::string_bounded_align_1_optional(
        string_bounded_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

string_bounded_align_1_optional& string_bounded_align_1_optional::operator =(
        const string_bounded_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

string_bounded_align_1_optional& string_bounded_align_1_optional::operator =(
        string_bounded_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool string_bounded_align_1_optional::operator ==(
        const string_bounded_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool string_bounded_align_1_optional::operator !=(
        const string_bounded_align_1_optional& x) const
{
    return !(*this == x);
}

size_t string_bounded_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_bounded_align_1_optional_max_cdr_typesize;
}

size_t string_bounded_align_1_optional::getCdrSerializedSize(
        const string_bounded_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.value().size() + 1;


    return current_alignment - initial_alignment;
}

void string_bounded_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value.c_str();
}

void string_bounded_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    {
        std::string aux;
        dcdr >> aux;
        m_value = aux.c_str();
    }
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void string_bounded_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t string_bounded_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& string_bounded_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void string_bounded_align_1_optional::value(
        const eprosima::fastrtps::fixed_string<8>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void string_bounded_align_1_optional::value(
        eprosima::fastrtps::fixed_string<8>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const eprosima::fastrtps::fixed_string<8>& string_bounded_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
eprosima::fastrtps::fixed_string<8>& string_bounded_align_1_optional::value()
{
    return m_value;
}


size_t string_bounded_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_bounded_align_1_optional_max_key_cdr_typesize;
}

bool string_bounded_align_1_optional::isKeyDefined()
{
    return false;
}

void string_bounded_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


string_bounded_align_2_optional::string_bounded_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // string m_value
    m_value = "";


    // Just to register all known types
    registeroptionalTypes();
}

string_bounded_align_2_optional::~string_bounded_align_2_optional()
{


}

string_bounded_align_2_optional::string_bounded_align_2_optional(
        const string_bounded_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

string_bounded_align_2_optional::string_bounded_align_2_optional(
        string_bounded_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

string_bounded_align_2_optional& string_bounded_align_2_optional::operator =(
        const string_bounded_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

string_bounded_align_2_optional& string_bounded_align_2_optional::operator =(
        string_bounded_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool string_bounded_align_2_optional::operator ==(
        const string_bounded_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool string_bounded_align_2_optional::operator !=(
        const string_bounded_align_2_optional& x) const
{
    return !(*this == x);
}

size_t string_bounded_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_bounded_align_2_optional_max_cdr_typesize;
}

size_t string_bounded_align_2_optional::getCdrSerializedSize(
        const string_bounded_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.value().size() + 1;


    return current_alignment - initial_alignment;
}

void string_bounded_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value.c_str();
}

void string_bounded_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    {
        std::string aux;
        dcdr >> aux;
        m_value = aux.c_str();
    }
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void string_bounded_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t string_bounded_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& string_bounded_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void string_bounded_align_2_optional::value(
        const eprosima::fastrtps::fixed_string<8>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void string_bounded_align_2_optional::value(
        eprosima::fastrtps::fixed_string<8>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const eprosima::fastrtps::fixed_string<8>& string_bounded_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
eprosima::fastrtps::fixed_string<8>& string_bounded_align_2_optional::value()
{
    return m_value;
}


size_t string_bounded_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_bounded_align_2_optional_max_key_cdr_typesize;
}

bool string_bounded_align_2_optional::isKeyDefined()
{
    return false;
}

void string_bounded_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


string_bounded_align_4_optional::string_bounded_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // string m_value
    m_value = "";


    // Just to register all known types
    registeroptionalTypes();
}

string_bounded_align_4_optional::~string_bounded_align_4_optional()
{


}

string_bounded_align_4_optional::string_bounded_align_4_optional(
        const string_bounded_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

string_bounded_align_4_optional::string_bounded_align_4_optional(
        string_bounded_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

string_bounded_align_4_optional& string_bounded_align_4_optional::operator =(
        const string_bounded_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

string_bounded_align_4_optional& string_bounded_align_4_optional::operator =(
        string_bounded_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool string_bounded_align_4_optional::operator ==(
        const string_bounded_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool string_bounded_align_4_optional::operator !=(
        const string_bounded_align_4_optional& x) const
{
    return !(*this == x);
}

size_t string_bounded_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_bounded_align_4_optional_max_cdr_typesize;
}

size_t string_bounded_align_4_optional::getCdrSerializedSize(
        const string_bounded_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.value().size() + 1;


    return current_alignment - initial_alignment;
}

void string_bounded_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value.c_str();
}

void string_bounded_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    {
        std::string aux;
        dcdr >> aux;
        m_value = aux.c_str();
    }
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void string_bounded_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t string_bounded_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& string_bounded_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void string_bounded_align_4_optional::value(
        const eprosima::fastrtps::fixed_string<8>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void string_bounded_align_4_optional::value(
        eprosima::fastrtps::fixed_string<8>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const eprosima::fastrtps::fixed_string<8>& string_bounded_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
eprosima::fastrtps::fixed_string<8>& string_bounded_align_4_optional::value()
{
    return m_value;
}


size_t string_bounded_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return string_bounded_align_4_optional_max_key_cdr_typesize;
}

bool string_bounded_align_4_optional::isKeyDefined()
{
    return false;
}

void string_bounded_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


map_short_optional::map_short_optional()
{
    // map<long, short> m_value


    // Just to register all known types
    registeroptionalTypes();
}

map_short_optional::~map_short_optional()
{
}

map_short_optional::map_short_optional(
        const map_short_optional& x)
{
    m_value = x.m_value;
}

map_short_optional::map_short_optional(
        map_short_optional&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

map_short_optional& map_short_optional::operator =(
        const map_short_optional& x)
{

    m_value = x.m_value;

    return *this;
}

map_short_optional& map_short_optional::operator =(
        map_short_optional&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool map_short_optional::operator ==(
        const map_short_optional& x) const
{

    return (m_value == x.m_value);
}

bool map_short_optional::operator !=(
        const map_short_optional& x) const
{
    return !(*this == x);
}

size_t map_short_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return map_short_optional_max_cdr_typesize;
}

size_t map_short_optional::getCdrSerializedSize(
        const map_short_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.value())
    {
        (void)a;

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }

    return current_alignment - initial_alignment;
}

void map_short_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << static_cast<uint32_t>(m_value.size());
    for (const auto& pair : m_value)
    {
        scdr << pair.first;    scdr << pair.second;}}

void map_short_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{


        dcdr >> m_value;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void map_short_optional::value(
        const std::map<int32_t, int16_t>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void map_short_optional::value(
        std::map<int32_t, int16_t>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::map<int32_t, int16_t>& map_short_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::map<int32_t, int16_t>& map_short_optional::value()
{
    return m_value;
}


size_t map_short_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return map_short_optional_max_key_cdr_typesize;
}

bool map_short_optional::isKeyDefined()
{
    return false;
}

void map_short_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


map_short_align_1_optional::map_short_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // map<long, short> m_value


    // Just to register all known types
    registeroptionalTypes();
}

map_short_align_1_optional::~map_short_align_1_optional()
{


}

map_short_align_1_optional::map_short_align_1_optional(
        const map_short_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

map_short_align_1_optional::map_short_align_1_optional(
        map_short_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

map_short_align_1_optional& map_short_align_1_optional::operator =(
        const map_short_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

map_short_align_1_optional& map_short_align_1_optional::operator =(
        map_short_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool map_short_align_1_optional::operator ==(
        const map_short_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool map_short_align_1_optional::operator !=(
        const map_short_align_1_optional& x) const
{
    return !(*this == x);
}

size_t map_short_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return map_short_align_1_optional_max_cdr_typesize;
}

size_t map_short_align_1_optional::getCdrSerializedSize(
        const map_short_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.value())
    {
        (void)a;

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }


    return current_alignment - initial_alignment;
}

void map_short_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << static_cast<uint32_t>(m_value.size());
    for (const auto& pair : m_value)
    {
        scdr << pair.first;    scdr << pair.second;}
}

void map_short_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;

        dcdr >> m_value;

}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void map_short_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t map_short_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& map_short_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void map_short_align_1_optional::value(
        const std::map<int32_t, int16_t>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void map_short_align_1_optional::value(
        std::map<int32_t, int16_t>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::map<int32_t, int16_t>& map_short_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::map<int32_t, int16_t>& map_short_align_1_optional::value()
{
    return m_value;
}


size_t map_short_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return map_short_align_1_optional_max_key_cdr_typesize;
}

bool map_short_align_1_optional::isKeyDefined()
{
    return false;
}

void map_short_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


map_short_align_2_optional::map_short_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // map<long, short> m_value


    // Just to register all known types
    registeroptionalTypes();
}

map_short_align_2_optional::~map_short_align_2_optional()
{


}

map_short_align_2_optional::map_short_align_2_optional(
        const map_short_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

map_short_align_2_optional::map_short_align_2_optional(
        map_short_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

map_short_align_2_optional& map_short_align_2_optional::operator =(
        const map_short_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

map_short_align_2_optional& map_short_align_2_optional::operator =(
        map_short_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool map_short_align_2_optional::operator ==(
        const map_short_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool map_short_align_2_optional::operator !=(
        const map_short_align_2_optional& x) const
{
    return !(*this == x);
}

size_t map_short_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return map_short_align_2_optional_max_cdr_typesize;
}

size_t map_short_align_2_optional::getCdrSerializedSize(
        const map_short_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.value())
    {
        (void)a;

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }


    return current_alignment - initial_alignment;
}

void map_short_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << static_cast<uint32_t>(m_value.size());
    for (const auto& pair : m_value)
    {
        scdr << pair.first;    scdr << pair.second;}
}

void map_short_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;

        dcdr >> m_value;

}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void map_short_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t map_short_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& map_short_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void map_short_align_2_optional::value(
        const std::map<int32_t, int16_t>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void map_short_align_2_optional::value(
        std::map<int32_t, int16_t>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::map<int32_t, int16_t>& map_short_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::map<int32_t, int16_t>& map_short_align_2_optional::value()
{
    return m_value;
}


size_t map_short_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return map_short_align_2_optional_max_key_cdr_typesize;
}

bool map_short_align_2_optional::isKeyDefined()
{
    return false;
}

void map_short_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


map_short_align_4_optional::map_short_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // map<long, short> m_value


    // Just to register all known types
    registeroptionalTypes();
}

map_short_align_4_optional::~map_short_align_4_optional()
{


}

map_short_align_4_optional::map_short_align_4_optional(
        const map_short_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

map_short_align_4_optional::map_short_align_4_optional(
        map_short_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

map_short_align_4_optional& map_short_align_4_optional::operator =(
        const map_short_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

map_short_align_4_optional& map_short_align_4_optional::operator =(
        map_short_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool map_short_align_4_optional::operator ==(
        const map_short_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool map_short_align_4_optional::operator !=(
        const map_short_align_4_optional& x) const
{
    return !(*this == x);
}

size_t map_short_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return map_short_align_4_optional_max_cdr_typesize;
}

size_t map_short_align_4_optional::getCdrSerializedSize(
        const map_short_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.value())
    {
        (void)a;

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }


    return current_alignment - initial_alignment;
}

void map_short_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << static_cast<uint32_t>(m_value.size());
    for (const auto& pair : m_value)
    {
        scdr << pair.first;    scdr << pair.second;}
}

void map_short_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;

        dcdr >> m_value;

}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void map_short_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t map_short_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& map_short_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void map_short_align_4_optional::value(
        const std::map<int32_t, int16_t>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void map_short_align_4_optional::value(
        std::map<int32_t, int16_t>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::map<int32_t, int16_t>& map_short_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::map<int32_t, int16_t>& map_short_align_4_optional::value()
{
    return m_value;
}


size_t map_short_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return map_short_align_4_optional_max_key_cdr_typesize;
}

bool map_short_align_4_optional::isKeyDefined()
{
    return false;
}

void map_short_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


array_short_optional::array_short_optional()
{
    // short m_value
    memset(&m_value, 0, (10) * 2);


    // Just to register all known types
    registeroptionalTypes();
}

array_short_optional::~array_short_optional()
{
}

array_short_optional::array_short_optional(
        const array_short_optional& x)
{
    m_value = x.m_value;
}

array_short_optional::array_short_optional(
        array_short_optional&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

array_short_optional& array_short_optional::operator =(
        const array_short_optional& x)
{

    m_value = x.m_value;

    return *this;
}

array_short_optional& array_short_optional::operator =(
        array_short_optional&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool array_short_optional::operator ==(
        const array_short_optional& x) const
{

    return (m_value == x.m_value);
}

bool array_short_optional::operator !=(
        const array_short_optional& x) const
{
    return !(*this == x);
}

size_t array_short_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return array_short_optional_max_cdr_typesize;
}

size_t array_short_optional::getCdrSerializedSize(
        const array_short_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void array_short_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;

}

void array_short_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;

}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void array_short_optional::value(
        const std::array<int16_t, 10>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void array_short_optional::value(
        std::array<int16_t, 10>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::array<int16_t, 10>& array_short_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::array<int16_t, 10>& array_short_optional::value()
{
    return m_value;
}


size_t array_short_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return array_short_optional_max_key_cdr_typesize;
}

bool array_short_optional::isKeyDefined()
{
    return false;
}

void array_short_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


array_short_align_1_optional::array_short_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // short m_value
    memset(&m_value, 0, (10) * 2);


    // Just to register all known types
    registeroptionalTypes();
}

array_short_align_1_optional::~array_short_align_1_optional()
{


}

array_short_align_1_optional::array_short_align_1_optional(
        const array_short_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

array_short_align_1_optional::array_short_align_1_optional(
        array_short_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

array_short_align_1_optional& array_short_align_1_optional::operator =(
        const array_short_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

array_short_align_1_optional& array_short_align_1_optional::operator =(
        array_short_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool array_short_align_1_optional::operator ==(
        const array_short_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool array_short_align_1_optional::operator !=(
        const array_short_align_1_optional& x) const
{
    return !(*this == x);
}

size_t array_short_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return array_short_align_1_optional_max_cdr_typesize;
}

size_t array_short_align_1_optional::getCdrSerializedSize(
        const array_short_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += ((10) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void array_short_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;

}

void array_short_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;

}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void array_short_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t array_short_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& array_short_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void array_short_align_1_optional::value(
        const std::array<int16_t, 10>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void array_short_align_1_optional::value(
        std::array<int16_t, 10>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::array<int16_t, 10>& array_short_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::array<int16_t, 10>& array_short_align_1_optional::value()
{
    return m_value;
}


size_t array_short_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return array_short_align_1_optional_max_key_cdr_typesize;
}

bool array_short_align_1_optional::isKeyDefined()
{
    return false;
}

void array_short_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


array_short_align_2_optional::array_short_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // short m_value
    memset(&m_value, 0, (10) * 2);


    // Just to register all known types
    registeroptionalTypes();
}

array_short_align_2_optional::~array_short_align_2_optional()
{


}

array_short_align_2_optional::array_short_align_2_optional(
        const array_short_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

array_short_align_2_optional::array_short_align_2_optional(
        array_short_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

array_short_align_2_optional& array_short_align_2_optional::operator =(
        const array_short_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

array_short_align_2_optional& array_short_align_2_optional::operator =(
        array_short_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool array_short_align_2_optional::operator ==(
        const array_short_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool array_short_align_2_optional::operator !=(
        const array_short_align_2_optional& x) const
{
    return !(*this == x);
}

size_t array_short_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return array_short_align_2_optional_max_cdr_typesize;
}

size_t array_short_align_2_optional::getCdrSerializedSize(
        const array_short_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += ((10) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void array_short_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;

}

void array_short_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;

}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void array_short_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t array_short_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& array_short_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void array_short_align_2_optional::value(
        const std::array<int16_t, 10>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void array_short_align_2_optional::value(
        std::array<int16_t, 10>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::array<int16_t, 10>& array_short_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::array<int16_t, 10>& array_short_align_2_optional::value()
{
    return m_value;
}


size_t array_short_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return array_short_align_2_optional_max_key_cdr_typesize;
}

bool array_short_align_2_optional::isKeyDefined()
{
    return false;
}

void array_short_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


array_short_align_4_optional::array_short_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // short m_value
    memset(&m_value, 0, (10) * 2);


    // Just to register all known types
    registeroptionalTypes();
}

array_short_align_4_optional::~array_short_align_4_optional()
{


}

array_short_align_4_optional::array_short_align_4_optional(
        const array_short_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

array_short_align_4_optional::array_short_align_4_optional(
        array_short_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

array_short_align_4_optional& array_short_align_4_optional::operator =(
        const array_short_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

array_short_align_4_optional& array_short_align_4_optional::operator =(
        array_short_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool array_short_align_4_optional::operator ==(
        const array_short_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool array_short_align_4_optional::operator !=(
        const array_short_align_4_optional& x) const
{
    return !(*this == x);
}

size_t array_short_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return array_short_align_4_optional_max_cdr_typesize;
}

size_t array_short_align_4_optional::getCdrSerializedSize(
        const array_short_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += ((10) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void array_short_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;

}

void array_short_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;

}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void array_short_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t array_short_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& array_short_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void array_short_align_4_optional::value(
        const std::array<int16_t, 10>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void array_short_align_4_optional::value(
        std::array<int16_t, 10>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::array<int16_t, 10>& array_short_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::array<int16_t, 10>& array_short_align_4_optional::value()
{
    return m_value;
}


size_t array_short_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return array_short_align_4_optional_max_key_cdr_typesize;
}

bool array_short_align_4_optional::isKeyDefined()
{
    return false;
}

void array_short_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


struct_optional::struct_optional()
{
    // InnerStructureHelper m_value


    // Just to register all known types
    registeroptionalTypes();
}

struct_optional::~struct_optional()
{
}

struct_optional::struct_optional(
        const struct_optional& x)
{
    m_value = x.m_value;
}

struct_optional::struct_optional(
        struct_optional&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

struct_optional& struct_optional::operator =(
        const struct_optional& x)
{

    m_value = x.m_value;

    return *this;
}

struct_optional& struct_optional::operator =(
        struct_optional&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool struct_optional::operator ==(
        const struct_optional& x) const
{

    return (m_value == x.m_value);
}

bool struct_optional::operator !=(
        const struct_optional& x) const
{
    return !(*this == x);
}

size_t struct_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return struct_optional_max_cdr_typesize;
}

size_t struct_optional::getCdrSerializedSize(
        const struct_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += InnerStructureHelper::getCdrSerializedSize(data.value(), current_alignment);

    return current_alignment - initial_alignment;
}

void struct_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void struct_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void struct_optional::value(
        const InnerStructureHelper& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void struct_optional::value(
        InnerStructureHelper&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const InnerStructureHelper& struct_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
InnerStructureHelper& struct_optional::value()
{
    return m_value;
}


size_t struct_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return struct_optional_max_key_cdr_typesize;
}

bool struct_optional::isKeyDefined()
{
    return false;
}

void struct_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


struct_align_1_optional::struct_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // InnerStructureHelper m_value


    // Just to register all known types
    registeroptionalTypes();
}

struct_align_1_optional::~struct_align_1_optional()
{


}

struct_align_1_optional::struct_align_1_optional(
        const struct_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

struct_align_1_optional::struct_align_1_optional(
        struct_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

struct_align_1_optional& struct_align_1_optional::operator =(
        const struct_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

struct_align_1_optional& struct_align_1_optional::operator =(
        struct_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool struct_align_1_optional::operator ==(
        const struct_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool struct_align_1_optional::operator !=(
        const struct_align_1_optional& x) const
{
    return !(*this == x);
}

size_t struct_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return struct_align_1_optional_max_cdr_typesize;
}

size_t struct_align_1_optional::getCdrSerializedSize(
        const struct_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += InnerStructureHelper::getCdrSerializedSize(data.value(), current_alignment);

    return current_alignment - initial_alignment;
}

void struct_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void struct_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void struct_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t struct_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& struct_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void struct_align_1_optional::value(
        const InnerStructureHelper& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void struct_align_1_optional::value(
        InnerStructureHelper&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const InnerStructureHelper& struct_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
InnerStructureHelper& struct_align_1_optional::value()
{
    return m_value;
}


size_t struct_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return struct_align_1_optional_max_key_cdr_typesize;
}

bool struct_align_1_optional::isKeyDefined()
{
    return false;
}

void struct_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


struct_align_2_optional::struct_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // InnerStructureHelper m_value


    // Just to register all known types
    registeroptionalTypes();
}

struct_align_2_optional::~struct_align_2_optional()
{


}

struct_align_2_optional::struct_align_2_optional(
        const struct_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

struct_align_2_optional::struct_align_2_optional(
        struct_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

struct_align_2_optional& struct_align_2_optional::operator =(
        const struct_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

struct_align_2_optional& struct_align_2_optional::operator =(
        struct_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool struct_align_2_optional::operator ==(
        const struct_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool struct_align_2_optional::operator !=(
        const struct_align_2_optional& x) const
{
    return !(*this == x);
}

size_t struct_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return struct_align_2_optional_max_cdr_typesize;
}

size_t struct_align_2_optional::getCdrSerializedSize(
        const struct_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += InnerStructureHelper::getCdrSerializedSize(data.value(), current_alignment);

    return current_alignment - initial_alignment;
}

void struct_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void struct_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void struct_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t struct_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& struct_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void struct_align_2_optional::value(
        const InnerStructureHelper& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void struct_align_2_optional::value(
        InnerStructureHelper&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const InnerStructureHelper& struct_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
InnerStructureHelper& struct_align_2_optional::value()
{
    return m_value;
}


size_t struct_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return struct_align_2_optional_max_key_cdr_typesize;
}

bool struct_align_2_optional::isKeyDefined()
{
    return false;
}

void struct_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


struct_align_4_optional::struct_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // InnerStructureHelper m_value


    // Just to register all known types
    registeroptionalTypes();
}

struct_align_4_optional::~struct_align_4_optional()
{


}

struct_align_4_optional::struct_align_4_optional(
        const struct_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

struct_align_4_optional::struct_align_4_optional(
        struct_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

struct_align_4_optional& struct_align_4_optional::operator =(
        const struct_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

struct_align_4_optional& struct_align_4_optional::operator =(
        struct_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool struct_align_4_optional::operator ==(
        const struct_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool struct_align_4_optional::operator !=(
        const struct_align_4_optional& x) const
{
    return !(*this == x);
}

size_t struct_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return struct_align_4_optional_max_cdr_typesize;
}

size_t struct_align_4_optional::getCdrSerializedSize(
        const struct_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += InnerStructureHelper::getCdrSerializedSize(data.value(), current_alignment);

    return current_alignment - initial_alignment;
}

void struct_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void struct_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void struct_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t struct_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& struct_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void struct_align_4_optional::value(
        const InnerStructureHelper& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void struct_align_4_optional::value(
        InnerStructureHelper&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const InnerStructureHelper& struct_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
InnerStructureHelper& struct_align_4_optional::value()
{
    return m_value;
}


size_t struct_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return struct_align_4_optional_max_key_cdr_typesize;
}

bool struct_align_4_optional::isKeyDefined()
{
    return false;
}

void struct_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


InnerStructOptional::InnerStructOptional()
{
    // short m_s
    m_s = 0;
    // long m_l
    m_l = 0;

    // Just to register all known types
    registeroptionalTypes();
}

InnerStructOptional::~InnerStructOptional()
{


}

InnerStructOptional::InnerStructOptional(
        const InnerStructOptional& x)
{
    m_s = x.m_s;
    m_l = x.m_l;
}

InnerStructOptional::InnerStructOptional(
        InnerStructOptional&& x) noexcept 
{
    m_s = x.m_s;
    m_l = x.m_l;
}

InnerStructOptional& InnerStructOptional::operator =(
        const InnerStructOptional& x)
{

    m_s = x.m_s;
    m_l = x.m_l;

    return *this;
}

InnerStructOptional& InnerStructOptional::operator =(
        InnerStructOptional&& x) noexcept
{

    m_s = x.m_s;
    m_l = x.m_l;

    return *this;
}

bool InnerStructOptional::operator ==(
        const InnerStructOptional& x) const
{

    return (m_s == x.m_s && m_l == x.m_l);
}

bool InnerStructOptional::operator !=(
        const InnerStructOptional& x) const
{
    return !(*this == x);
}

size_t InnerStructOptional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return InnerStructOptional_max_cdr_typesize;
}

size_t InnerStructOptional::getCdrSerializedSize(
        const InnerStructOptional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void InnerStructOptional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_s;scdr << m_l;
}

void InnerStructOptional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_s;
    dcdr >> m_l;
}

/*!
 * @brief This function sets a value in member s
 * @param _s New value for member s
 */
void InnerStructOptional::s(
        int16_t _s)
{
    m_s = _s;
}

/*!
 * @brief This function returns the value of member s
 * @return Value of member s
 */
int16_t InnerStructOptional::s() const
{
    return m_s;
}

/*!
 * @brief This function returns a reference to member s
 * @return Reference to member s
 */
int16_t& InnerStructOptional::s()
{
    return m_s;
}

/*!
 * @brief This function sets a value in member l
 * @param _l New value for member l
 */
void InnerStructOptional::l(
        int32_t _l)
{
    m_l = _l;
}

/*!
 * @brief This function returns the value of member l
 * @return Value of member l
 */
int32_t InnerStructOptional::l() const
{
    return m_l;
}

/*!
 * @brief This function returns a reference to member l
 * @return Reference to member l
 */
int32_t& InnerStructOptional::l()
{
    return m_l;
}



size_t InnerStructOptional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return InnerStructOptional_max_key_cdr_typesize;
}

bool InnerStructOptional::isKeyDefined()
{
    return false;
}

void InnerStructOptional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


opt_struct_optional::opt_struct_optional()
{
    // InnerStructOptional m_value


    // Just to register all known types
    registeroptionalTypes();
}

opt_struct_optional::~opt_struct_optional()
{
}

opt_struct_optional::opt_struct_optional(
        const opt_struct_optional& x)
{
    m_value = x.m_value;
}

opt_struct_optional::opt_struct_optional(
        opt_struct_optional&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

opt_struct_optional& opt_struct_optional::operator =(
        const opt_struct_optional& x)
{

    m_value = x.m_value;

    return *this;
}

opt_struct_optional& opt_struct_optional::operator =(
        opt_struct_optional&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool opt_struct_optional::operator ==(
        const opt_struct_optional& x) const
{

    return (m_value == x.m_value);
}

bool opt_struct_optional::operator !=(
        const opt_struct_optional& x) const
{
    return !(*this == x);
}

size_t opt_struct_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return opt_struct_optional_max_cdr_typesize;
}

size_t opt_struct_optional::getCdrSerializedSize(
        const opt_struct_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += InnerStructOptional::getCdrSerializedSize(data.value(), current_alignment);

    return current_alignment - initial_alignment;
}

void opt_struct_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void opt_struct_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void opt_struct_optional::value(
        const InnerStructOptional& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void opt_struct_optional::value(
        InnerStructOptional&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const InnerStructOptional& opt_struct_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
InnerStructOptional& opt_struct_optional::value()
{
    return m_value;
}


size_t opt_struct_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return opt_struct_optional_max_key_cdr_typesize;
}

bool opt_struct_optional::isKeyDefined()
{
    return false;
}

void opt_struct_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


opt_struct_align_1_optional::opt_struct_align_1_optional()
{
    // octet m_align
    m_align = 0;
    // InnerStructOptional m_value


    // Just to register all known types
    registeroptionalTypes();
}

opt_struct_align_1_optional::~opt_struct_align_1_optional()
{


}

opt_struct_align_1_optional::opt_struct_align_1_optional(
        const opt_struct_align_1_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

opt_struct_align_1_optional::opt_struct_align_1_optional(
        opt_struct_align_1_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

opt_struct_align_1_optional& opt_struct_align_1_optional::operator =(
        const opt_struct_align_1_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

opt_struct_align_1_optional& opt_struct_align_1_optional::operator =(
        opt_struct_align_1_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool opt_struct_align_1_optional::operator ==(
        const opt_struct_align_1_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool opt_struct_align_1_optional::operator !=(
        const opt_struct_align_1_optional& x) const
{
    return !(*this == x);
}

size_t opt_struct_align_1_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return opt_struct_align_1_optional_max_cdr_typesize;
}

size_t opt_struct_align_1_optional::getCdrSerializedSize(
        const opt_struct_align_1_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += InnerStructOptional::getCdrSerializedSize(data.value(), current_alignment);

    return current_alignment - initial_alignment;
}

void opt_struct_align_1_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void opt_struct_align_1_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void opt_struct_align_1_optional::align(
        uint8_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint8_t opt_struct_align_1_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint8_t& opt_struct_align_1_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void opt_struct_align_1_optional::value(
        const InnerStructOptional& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void opt_struct_align_1_optional::value(
        InnerStructOptional&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const InnerStructOptional& opt_struct_align_1_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
InnerStructOptional& opt_struct_align_1_optional::value()
{
    return m_value;
}


size_t opt_struct_align_1_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return opt_struct_align_1_optional_max_key_cdr_typesize;
}

bool opt_struct_align_1_optional::isKeyDefined()
{
    return false;
}

void opt_struct_align_1_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


opt_struct_align_2_optional::opt_struct_align_2_optional()
{
    // unsigned short m_align
    m_align = 0;
    // InnerStructOptional m_value


    // Just to register all known types
    registeroptionalTypes();
}

opt_struct_align_2_optional::~opt_struct_align_2_optional()
{


}

opt_struct_align_2_optional::opt_struct_align_2_optional(
        const opt_struct_align_2_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

opt_struct_align_2_optional::opt_struct_align_2_optional(
        opt_struct_align_2_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

opt_struct_align_2_optional& opt_struct_align_2_optional::operator =(
        const opt_struct_align_2_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

opt_struct_align_2_optional& opt_struct_align_2_optional::operator =(
        opt_struct_align_2_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool opt_struct_align_2_optional::operator ==(
        const opt_struct_align_2_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool opt_struct_align_2_optional::operator !=(
        const opt_struct_align_2_optional& x) const
{
    return !(*this == x);
}

size_t opt_struct_align_2_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return opt_struct_align_2_optional_max_cdr_typesize;
}

size_t opt_struct_align_2_optional::getCdrSerializedSize(
        const opt_struct_align_2_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += InnerStructOptional::getCdrSerializedSize(data.value(), current_alignment);

    return current_alignment - initial_alignment;
}

void opt_struct_align_2_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void opt_struct_align_2_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void opt_struct_align_2_optional::align(
        uint16_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint16_t opt_struct_align_2_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint16_t& opt_struct_align_2_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void opt_struct_align_2_optional::value(
        const InnerStructOptional& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void opt_struct_align_2_optional::value(
        InnerStructOptional&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const InnerStructOptional& opt_struct_align_2_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
InnerStructOptional& opt_struct_align_2_optional::value()
{
    return m_value;
}


size_t opt_struct_align_2_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return opt_struct_align_2_optional_max_key_cdr_typesize;
}

bool opt_struct_align_2_optional::isKeyDefined()
{
    return false;
}

void opt_struct_align_2_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


opt_struct_align_4_optional::opt_struct_align_4_optional()
{
    // unsigned long m_align
    m_align = 0;
    // InnerStructOptional m_value


    // Just to register all known types
    registeroptionalTypes();
}

opt_struct_align_4_optional::~opt_struct_align_4_optional()
{


}

opt_struct_align_4_optional::opt_struct_align_4_optional(
        const opt_struct_align_4_optional& x)
{
    m_align = x.m_align;
    m_value = x.m_value;
}

opt_struct_align_4_optional::opt_struct_align_4_optional(
        opt_struct_align_4_optional&& x) noexcept 
{
    m_align = x.m_align;
    m_value = std::move(x.m_value);
}

opt_struct_align_4_optional& opt_struct_align_4_optional::operator =(
        const opt_struct_align_4_optional& x)
{

    m_align = x.m_align;
    m_value = x.m_value;

    return *this;
}

opt_struct_align_4_optional& opt_struct_align_4_optional::operator =(
        opt_struct_align_4_optional&& x) noexcept
{

    m_align = x.m_align;
    m_value = std::move(x.m_value);

    return *this;
}

bool opt_struct_align_4_optional::operator ==(
        const opt_struct_align_4_optional& x) const
{

    return (m_align == x.m_align && m_value == x.m_value);
}

bool opt_struct_align_4_optional::operator !=(
        const opt_struct_align_4_optional& x) const
{
    return !(*this == x);
}

size_t opt_struct_align_4_optional::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return opt_struct_align_4_optional_max_cdr_typesize;
}

size_t opt_struct_align_4_optional::getCdrSerializedSize(
        const opt_struct_align_4_optional& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += InnerStructOptional::getCdrSerializedSize(data.value(), current_alignment);

    return current_alignment - initial_alignment;
}

void opt_struct_align_4_optional::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_align;scdr << m_value;
}

void opt_struct_align_4_optional::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_align;
    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member align
 * @param _align New value for member align
 */
void opt_struct_align_4_optional::align(
        uint32_t _align)
{
    m_align = _align;
}

/*!
 * @brief This function returns the value of member align
 * @return Value of member align
 */
uint32_t opt_struct_align_4_optional::align() const
{
    return m_align;
}

/*!
 * @brief This function returns a reference to member align
 * @return Reference to member align
 */
uint32_t& opt_struct_align_4_optional::align()
{
    return m_align;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void opt_struct_align_4_optional::value(
        const InnerStructOptional& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void opt_struct_align_4_optional::value(
        InnerStructOptional&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const InnerStructOptional& opt_struct_align_4_optional::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
InnerStructOptional& opt_struct_align_4_optional::value()
{
    return m_value;
}


size_t opt_struct_align_4_optional::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return opt_struct_align_4_optional_max_key_cdr_typesize;
}

bool opt_struct_align_4_optional::isKeyDefined()
{
    return false;
}

void opt_struct_align_4_optional::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

