// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file optionalTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "optional.h"
#include "optionalTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

void registeroptionalTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(true),
                GetInnerEnumHelperObject(true));
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(false),
                GetInnerEnumHelperObject(false));

                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(true),
                GetInnerBitMaskHelperObject(true));
                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(false),
                GetInnerBitMaskHelperObject(false));

                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(true),
                GetInnerAliasHelperObject(true));
                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(false),
                GetInnerAliasHelperObject(false));

                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(true),
                GetInnerStructureHelperObject(true));
                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(false),
                GetInnerStructureHelperObject(false));

                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(true),
                GetInnerEmptyStructureHelperObject(true));
                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(false),
                GetInnerEmptyStructureHelperObject(false));

                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(true),
                GetInnerUnionHelperObject(true));
                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(false),
                GetInnerUnionHelperObject(false));

                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(true),
                GetInnerBitsetHelperObject(true));
                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(false),
                GetInnerBitsetHelperObject(false));

                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(true),
                GetInner_alias_bounded_string_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(false),
                GetInner_alias_bounded_string_helperObject(false));

                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(true),
                GetInner_alias_bounded_wstring_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(false),
                GetInner_alias_bounded_wstring_helperObject(false));

                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(true),
                GetInner_alias_array_helperObject(true));
                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(false),
                GetInner_alias_array_helperObject(false));

                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(true),
                GetInner_alias_sequence_helperObject(true));
                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(false),
                GetInner_alias_sequence_helperObject(false));

                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(true),
                GetInner_alias_map_helperObject(true));
                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(false),
                GetInner_alias_map_helperObject(false));

                factory->add_type_object("short_optional", Getshort_optionalIdentifier(true),
                Getshort_optionalObject(true));
                factory->add_type_object("short_optional", Getshort_optionalIdentifier(false),
                Getshort_optionalObject(false));

                factory->add_type_object("ushort_optional", Getushort_optionalIdentifier(true),
                Getushort_optionalObject(true));
                factory->add_type_object("ushort_optional", Getushort_optionalIdentifier(false),
                Getushort_optionalObject(false));

                factory->add_type_object("long_optional", Getlong_optionalIdentifier(true),
                Getlong_optionalObject(true));
                factory->add_type_object("long_optional", Getlong_optionalIdentifier(false),
                Getlong_optionalObject(false));

                factory->add_type_object("ulong_optional", Getulong_optionalIdentifier(true),
                Getulong_optionalObject(true));
                factory->add_type_object("ulong_optional", Getulong_optionalIdentifier(false),
                Getulong_optionalObject(false));

                factory->add_type_object("longlong_optional", Getlonglong_optionalIdentifier(true),
                Getlonglong_optionalObject(true));
                factory->add_type_object("longlong_optional", Getlonglong_optionalIdentifier(false),
                Getlonglong_optionalObject(false));

                factory->add_type_object("ulonglong_optional", Getulonglong_optionalIdentifier(true),
                Getulonglong_optionalObject(true));
                factory->add_type_object("ulonglong_optional", Getulonglong_optionalIdentifier(false),
                Getulonglong_optionalObject(false));

                factory->add_type_object("float_optional", Getfloat_optionalIdentifier(true),
                Getfloat_optionalObject(true));
                factory->add_type_object("float_optional", Getfloat_optionalIdentifier(false),
                Getfloat_optionalObject(false));

                factory->add_type_object("double_optional", Getdouble_optionalIdentifier(true),
                Getdouble_optionalObject(true));
                factory->add_type_object("double_optional", Getdouble_optionalIdentifier(false),
                Getdouble_optionalObject(false));

                factory->add_type_object("longdouble_optional", Getlongdouble_optionalIdentifier(true),
                Getlongdouble_optionalObject(true));
                factory->add_type_object("longdouble_optional", Getlongdouble_optionalIdentifier(false),
                Getlongdouble_optionalObject(false));

                factory->add_type_object("boolean_optional", Getboolean_optionalIdentifier(true),
                Getboolean_optionalObject(true));
                factory->add_type_object("boolean_optional", Getboolean_optionalIdentifier(false),
                Getboolean_optionalObject(false));

                factory->add_type_object("octet_optional", Getoctet_optionalIdentifier(true),
                Getoctet_optionalObject(true));
                factory->add_type_object("octet_optional", Getoctet_optionalIdentifier(false),
                Getoctet_optionalObject(false));

                factory->add_type_object("char_optional", Getchar_optionalIdentifier(true),
                Getchar_optionalObject(true));
                factory->add_type_object("char_optional", Getchar_optionalIdentifier(false),
                Getchar_optionalObject(false));

                factory->add_type_object("wchar_optional", Getwchar_optionalIdentifier(true),
                Getwchar_optionalObject(true));
                factory->add_type_object("wchar_optional", Getwchar_optionalIdentifier(false),
                Getwchar_optionalObject(false));

                factory->add_type_object("short_align_1_optional", Getshort_align_1_optionalIdentifier(true),
                Getshort_align_1_optionalObject(true));
                factory->add_type_object("short_align_1_optional", Getshort_align_1_optionalIdentifier(false),
                Getshort_align_1_optionalObject(false));

                factory->add_type_object("short_align_2_optional", Getshort_align_2_optionalIdentifier(true),
                Getshort_align_2_optionalObject(true));
                factory->add_type_object("short_align_2_optional", Getshort_align_2_optionalIdentifier(false),
                Getshort_align_2_optionalObject(false));

                factory->add_type_object("short_align_4_optional", Getshort_align_4_optionalIdentifier(true),
                Getshort_align_4_optionalObject(true));
                factory->add_type_object("short_align_4_optional", Getshort_align_4_optionalIdentifier(false),
                Getshort_align_4_optionalObject(false));

                factory->add_type_object("ushort_align_1_optional", Getushort_align_1_optionalIdentifier(true),
                Getushort_align_1_optionalObject(true));
                factory->add_type_object("ushort_align_1_optional", Getushort_align_1_optionalIdentifier(false),
                Getushort_align_1_optionalObject(false));

                factory->add_type_object("ushort_align_2_optional", Getushort_align_2_optionalIdentifier(true),
                Getushort_align_2_optionalObject(true));
                factory->add_type_object("ushort_align_2_optional", Getushort_align_2_optionalIdentifier(false),
                Getushort_align_2_optionalObject(false));

                factory->add_type_object("ushort_align_4_optional", Getushort_align_4_optionalIdentifier(true),
                Getushort_align_4_optionalObject(true));
                factory->add_type_object("ushort_align_4_optional", Getushort_align_4_optionalIdentifier(false),
                Getushort_align_4_optionalObject(false));

                factory->add_type_object("long_align_1_optional", Getlong_align_1_optionalIdentifier(true),
                Getlong_align_1_optionalObject(true));
                factory->add_type_object("long_align_1_optional", Getlong_align_1_optionalIdentifier(false),
                Getlong_align_1_optionalObject(false));

                factory->add_type_object("long_align_2_optional", Getlong_align_2_optionalIdentifier(true),
                Getlong_align_2_optionalObject(true));
                factory->add_type_object("long_align_2_optional", Getlong_align_2_optionalIdentifier(false),
                Getlong_align_2_optionalObject(false));

                factory->add_type_object("long_align_4_optional", Getlong_align_4_optionalIdentifier(true),
                Getlong_align_4_optionalObject(true));
                factory->add_type_object("long_align_4_optional", Getlong_align_4_optionalIdentifier(false),
                Getlong_align_4_optionalObject(false));

                factory->add_type_object("ulong_align_1_optional", Getulong_align_1_optionalIdentifier(true),
                Getulong_align_1_optionalObject(true));
                factory->add_type_object("ulong_align_1_optional", Getulong_align_1_optionalIdentifier(false),
                Getulong_align_1_optionalObject(false));

                factory->add_type_object("ulong_align_2_optional", Getulong_align_2_optionalIdentifier(true),
                Getulong_align_2_optionalObject(true));
                factory->add_type_object("ulong_align_2_optional", Getulong_align_2_optionalIdentifier(false),
                Getulong_align_2_optionalObject(false));

                factory->add_type_object("ulong_align_4_optional", Getulong_align_4_optionalIdentifier(true),
                Getulong_align_4_optionalObject(true));
                factory->add_type_object("ulong_align_4_optional", Getulong_align_4_optionalIdentifier(false),
                Getulong_align_4_optionalObject(false));

                factory->add_type_object("longlong_align_1_optional", Getlonglong_align_1_optionalIdentifier(true),
                Getlonglong_align_1_optionalObject(true));
                factory->add_type_object("longlong_align_1_optional", Getlonglong_align_1_optionalIdentifier(false),
                Getlonglong_align_1_optionalObject(false));

                factory->add_type_object("longlong_align_2_optional", Getlonglong_align_2_optionalIdentifier(true),
                Getlonglong_align_2_optionalObject(true));
                factory->add_type_object("longlong_align_2_optional", Getlonglong_align_2_optionalIdentifier(false),
                Getlonglong_align_2_optionalObject(false));

                factory->add_type_object("longlong_align_4_optional", Getlonglong_align_4_optionalIdentifier(true),
                Getlonglong_align_4_optionalObject(true));
                factory->add_type_object("longlong_align_4_optional", Getlonglong_align_4_optionalIdentifier(false),
                Getlonglong_align_4_optionalObject(false));

                factory->add_type_object("ulonglong_align_1_optional", Getulonglong_align_1_optionalIdentifier(true),
                Getulonglong_align_1_optionalObject(true));
                factory->add_type_object("ulonglong_align_1_optional", Getulonglong_align_1_optionalIdentifier(false),
                Getulonglong_align_1_optionalObject(false));

                factory->add_type_object("ulonglong_align_2_optional", Getulonglong_align_2_optionalIdentifier(true),
                Getulonglong_align_2_optionalObject(true));
                factory->add_type_object("ulonglong_align_2_optional", Getulonglong_align_2_optionalIdentifier(false),
                Getulonglong_align_2_optionalObject(false));

                factory->add_type_object("ulonglong_align_4_optional", Getulonglong_align_4_optionalIdentifier(true),
                Getulonglong_align_4_optionalObject(true));
                factory->add_type_object("ulonglong_align_4_optional", Getulonglong_align_4_optionalIdentifier(false),
                Getulonglong_align_4_optionalObject(false));

                factory->add_type_object("float_align_1_optional", Getfloat_align_1_optionalIdentifier(true),
                Getfloat_align_1_optionalObject(true));
                factory->add_type_object("float_align_1_optional", Getfloat_align_1_optionalIdentifier(false),
                Getfloat_align_1_optionalObject(false));

                factory->add_type_object("float_align_2_optional", Getfloat_align_2_optionalIdentifier(true),
                Getfloat_align_2_optionalObject(true));
                factory->add_type_object("float_align_2_optional", Getfloat_align_2_optionalIdentifier(false),
                Getfloat_align_2_optionalObject(false));

                factory->add_type_object("float_align_4_optional", Getfloat_align_4_optionalIdentifier(true),
                Getfloat_align_4_optionalObject(true));
                factory->add_type_object("float_align_4_optional", Getfloat_align_4_optionalIdentifier(false),
                Getfloat_align_4_optionalObject(false));

                factory->add_type_object("double_align_1_optional", Getdouble_align_1_optionalIdentifier(true),
                Getdouble_align_1_optionalObject(true));
                factory->add_type_object("double_align_1_optional", Getdouble_align_1_optionalIdentifier(false),
                Getdouble_align_1_optionalObject(false));

                factory->add_type_object("double_align_2_optional", Getdouble_align_2_optionalIdentifier(true),
                Getdouble_align_2_optionalObject(true));
                factory->add_type_object("double_align_2_optional", Getdouble_align_2_optionalIdentifier(false),
                Getdouble_align_2_optionalObject(false));

                factory->add_type_object("double_align_4_optional", Getdouble_align_4_optionalIdentifier(true),
                Getdouble_align_4_optionalObject(true));
                factory->add_type_object("double_align_4_optional", Getdouble_align_4_optionalIdentifier(false),
                Getdouble_align_4_optionalObject(false));

                factory->add_type_object("longdouble_align_1_optional", Getlongdouble_align_1_optionalIdentifier(true),
                Getlongdouble_align_1_optionalObject(true));
                factory->add_type_object("longdouble_align_1_optional", Getlongdouble_align_1_optionalIdentifier(false),
                Getlongdouble_align_1_optionalObject(false));

                factory->add_type_object("longdouble_align_2_optional", Getlongdouble_align_2_optionalIdentifier(true),
                Getlongdouble_align_2_optionalObject(true));
                factory->add_type_object("longdouble_align_2_optional", Getlongdouble_align_2_optionalIdentifier(false),
                Getlongdouble_align_2_optionalObject(false));

                factory->add_type_object("longdouble_align_4_optional", Getlongdouble_align_4_optionalIdentifier(true),
                Getlongdouble_align_4_optionalObject(true));
                factory->add_type_object("longdouble_align_4_optional", Getlongdouble_align_4_optionalIdentifier(false),
                Getlongdouble_align_4_optionalObject(false));

                factory->add_type_object("boolean_align_1_optional", Getboolean_align_1_optionalIdentifier(true),
                Getboolean_align_1_optionalObject(true));
                factory->add_type_object("boolean_align_1_optional", Getboolean_align_1_optionalIdentifier(false),
                Getboolean_align_1_optionalObject(false));

                factory->add_type_object("boolean_align_2_optional", Getboolean_align_2_optionalIdentifier(true),
                Getboolean_align_2_optionalObject(true));
                factory->add_type_object("boolean_align_2_optional", Getboolean_align_2_optionalIdentifier(false),
                Getboolean_align_2_optionalObject(false));

                factory->add_type_object("boolean_align_4_optional", Getboolean_align_4_optionalIdentifier(true),
                Getboolean_align_4_optionalObject(true));
                factory->add_type_object("boolean_align_4_optional", Getboolean_align_4_optionalIdentifier(false),
                Getboolean_align_4_optionalObject(false));

                factory->add_type_object("octet_align_1_optional", Getoctet_align_1_optionalIdentifier(true),
                Getoctet_align_1_optionalObject(true));
                factory->add_type_object("octet_align_1_optional", Getoctet_align_1_optionalIdentifier(false),
                Getoctet_align_1_optionalObject(false));

                factory->add_type_object("octet_align_2_optional", Getoctet_align_2_optionalIdentifier(true),
                Getoctet_align_2_optionalObject(true));
                factory->add_type_object("octet_align_2_optional", Getoctet_align_2_optionalIdentifier(false),
                Getoctet_align_2_optionalObject(false));

                factory->add_type_object("octet_align_4_optional", Getoctet_align_4_optionalIdentifier(true),
                Getoctet_align_4_optionalObject(true));
                factory->add_type_object("octet_align_4_optional", Getoctet_align_4_optionalIdentifier(false),
                Getoctet_align_4_optionalObject(false));

                factory->add_type_object("char_align_1_optional", Getchar_align_1_optionalIdentifier(true),
                Getchar_align_1_optionalObject(true));
                factory->add_type_object("char_align_1_optional", Getchar_align_1_optionalIdentifier(false),
                Getchar_align_1_optionalObject(false));

                factory->add_type_object("char_align_2_optional", Getchar_align_2_optionalIdentifier(true),
                Getchar_align_2_optionalObject(true));
                factory->add_type_object("char_align_2_optional", Getchar_align_2_optionalIdentifier(false),
                Getchar_align_2_optionalObject(false));

                factory->add_type_object("char_align_4_optional", Getchar_align_4_optionalIdentifier(true),
                Getchar_align_4_optionalObject(true));
                factory->add_type_object("char_align_4_optional", Getchar_align_4_optionalIdentifier(false),
                Getchar_align_4_optionalObject(false));

                factory->add_type_object("wchar_align_1_optional", Getwchar_align_1_optionalIdentifier(true),
                Getwchar_align_1_optionalObject(true));
                factory->add_type_object("wchar_align_1_optional", Getwchar_align_1_optionalIdentifier(false),
                Getwchar_align_1_optionalObject(false));

                factory->add_type_object("wchar_align_2_optional", Getwchar_align_2_optionalIdentifier(true),
                Getwchar_align_2_optionalObject(true));
                factory->add_type_object("wchar_align_2_optional", Getwchar_align_2_optionalIdentifier(false),
                Getwchar_align_2_optionalObject(false));

                factory->add_type_object("wchar_align_4_optional", Getwchar_align_4_optionalIdentifier(true),
                Getwchar_align_4_optionalObject(true));
                factory->add_type_object("wchar_align_4_optional", Getwchar_align_4_optionalIdentifier(false),
                Getwchar_align_4_optionalObject(false));

                factory->add_type_object("sequence_short_optional", Getsequence_short_optionalIdentifier(true),
                Getsequence_short_optionalObject(true));
                factory->add_type_object("sequence_short_optional", Getsequence_short_optionalIdentifier(false),
                Getsequence_short_optionalObject(false));

                factory->add_type_object("sequence_short_align_1_optional", Getsequence_short_align_1_optionalIdentifier(true),
                Getsequence_short_align_1_optionalObject(true));
                factory->add_type_object("sequence_short_align_1_optional", Getsequence_short_align_1_optionalIdentifier(false),
                Getsequence_short_align_1_optionalObject(false));

                factory->add_type_object("sequence_short_align_2_optional", Getsequence_short_align_2_optionalIdentifier(true),
                Getsequence_short_align_2_optionalObject(true));
                factory->add_type_object("sequence_short_align_2_optional", Getsequence_short_align_2_optionalIdentifier(false),
                Getsequence_short_align_2_optionalObject(false));

                factory->add_type_object("sequence_short_align_4_optional", Getsequence_short_align_4_optionalIdentifier(true),
                Getsequence_short_align_4_optionalObject(true));
                factory->add_type_object("sequence_short_align_4_optional", Getsequence_short_align_4_optionalIdentifier(false),
                Getsequence_short_align_4_optionalObject(false));

                factory->add_type_object("string_unbounded_optional", Getstring_unbounded_optionalIdentifier(true),
                Getstring_unbounded_optionalObject(true));
                factory->add_type_object("string_unbounded_optional", Getstring_unbounded_optionalIdentifier(false),
                Getstring_unbounded_optionalObject(false));

                factory->add_type_object("string_unbounded_align_1_optional", Getstring_unbounded_align_1_optionalIdentifier(true),
                Getstring_unbounded_align_1_optionalObject(true));
                factory->add_type_object("string_unbounded_align_1_optional", Getstring_unbounded_align_1_optionalIdentifier(false),
                Getstring_unbounded_align_1_optionalObject(false));

                factory->add_type_object("string_unbounded_align_2_optional", Getstring_unbounded_align_2_optionalIdentifier(true),
                Getstring_unbounded_align_2_optionalObject(true));
                factory->add_type_object("string_unbounded_align_2_optional", Getstring_unbounded_align_2_optionalIdentifier(false),
                Getstring_unbounded_align_2_optionalObject(false));

                factory->add_type_object("string_unbounded_align_4_optional", Getstring_unbounded_align_4_optionalIdentifier(true),
                Getstring_unbounded_align_4_optionalObject(true));
                factory->add_type_object("string_unbounded_align_4_optional", Getstring_unbounded_align_4_optionalIdentifier(false),
                Getstring_unbounded_align_4_optionalObject(false));

                factory->add_type_object("string_bounded_optional", Getstring_bounded_optionalIdentifier(true),
                Getstring_bounded_optionalObject(true));
                factory->add_type_object("string_bounded_optional", Getstring_bounded_optionalIdentifier(false),
                Getstring_bounded_optionalObject(false));

                factory->add_type_object("string_bounded_align_1_optional", Getstring_bounded_align_1_optionalIdentifier(true),
                Getstring_bounded_align_1_optionalObject(true));
                factory->add_type_object("string_bounded_align_1_optional", Getstring_bounded_align_1_optionalIdentifier(false),
                Getstring_bounded_align_1_optionalObject(false));

                factory->add_type_object("string_bounded_align_2_optional", Getstring_bounded_align_2_optionalIdentifier(true),
                Getstring_bounded_align_2_optionalObject(true));
                factory->add_type_object("string_bounded_align_2_optional", Getstring_bounded_align_2_optionalIdentifier(false),
                Getstring_bounded_align_2_optionalObject(false));

                factory->add_type_object("string_bounded_align_4_optional", Getstring_bounded_align_4_optionalIdentifier(true),
                Getstring_bounded_align_4_optionalObject(true));
                factory->add_type_object("string_bounded_align_4_optional", Getstring_bounded_align_4_optionalIdentifier(false),
                Getstring_bounded_align_4_optionalObject(false));

                factory->add_type_object("map_short_optional", Getmap_short_optionalIdentifier(true),
                Getmap_short_optionalObject(true));
                factory->add_type_object("map_short_optional", Getmap_short_optionalIdentifier(false),
                Getmap_short_optionalObject(false));

                factory->add_type_object("map_short_align_1_optional", Getmap_short_align_1_optionalIdentifier(true),
                Getmap_short_align_1_optionalObject(true));
                factory->add_type_object("map_short_align_1_optional", Getmap_short_align_1_optionalIdentifier(false),
                Getmap_short_align_1_optionalObject(false));

                factory->add_type_object("map_short_align_2_optional", Getmap_short_align_2_optionalIdentifier(true),
                Getmap_short_align_2_optionalObject(true));
                factory->add_type_object("map_short_align_2_optional", Getmap_short_align_2_optionalIdentifier(false),
                Getmap_short_align_2_optionalObject(false));

                factory->add_type_object("map_short_align_4_optional", Getmap_short_align_4_optionalIdentifier(true),
                Getmap_short_align_4_optionalObject(true));
                factory->add_type_object("map_short_align_4_optional", Getmap_short_align_4_optionalIdentifier(false),
                Getmap_short_align_4_optionalObject(false));

                factory->add_type_object("array_short_optional", Getarray_short_optionalIdentifier(true),
                Getarray_short_optionalObject(true));
                factory->add_type_object("array_short_optional", Getarray_short_optionalIdentifier(false),
                Getarray_short_optionalObject(false));

                factory->add_type_object("array_short_align_1_optional", Getarray_short_align_1_optionalIdentifier(true),
                Getarray_short_align_1_optionalObject(true));
                factory->add_type_object("array_short_align_1_optional", Getarray_short_align_1_optionalIdentifier(false),
                Getarray_short_align_1_optionalObject(false));

                factory->add_type_object("array_short_align_2_optional", Getarray_short_align_2_optionalIdentifier(true),
                Getarray_short_align_2_optionalObject(true));
                factory->add_type_object("array_short_align_2_optional", Getarray_short_align_2_optionalIdentifier(false),
                Getarray_short_align_2_optionalObject(false));

                factory->add_type_object("array_short_align_4_optional", Getarray_short_align_4_optionalIdentifier(true),
                Getarray_short_align_4_optionalObject(true));
                factory->add_type_object("array_short_align_4_optional", Getarray_short_align_4_optionalIdentifier(false),
                Getarray_short_align_4_optionalObject(false));

                factory->add_type_object("struct_optional", Getstruct_optionalIdentifier(true),
                Getstruct_optionalObject(true));
                factory->add_type_object("struct_optional", Getstruct_optionalIdentifier(false),
                Getstruct_optionalObject(false));

                factory->add_type_object("struct_align_1_optional", Getstruct_align_1_optionalIdentifier(true),
                Getstruct_align_1_optionalObject(true));
                factory->add_type_object("struct_align_1_optional", Getstruct_align_1_optionalIdentifier(false),
                Getstruct_align_1_optionalObject(false));

                factory->add_type_object("struct_align_2_optional", Getstruct_align_2_optionalIdentifier(true),
                Getstruct_align_2_optionalObject(true));
                factory->add_type_object("struct_align_2_optional", Getstruct_align_2_optionalIdentifier(false),
                Getstruct_align_2_optionalObject(false));

                factory->add_type_object("struct_align_4_optional", Getstruct_align_4_optionalIdentifier(true),
                Getstruct_align_4_optionalObject(true));
                factory->add_type_object("struct_align_4_optional", Getstruct_align_4_optionalIdentifier(false),
                Getstruct_align_4_optionalObject(false));

                factory->add_type_object("InnerStructOptional", GetInnerStructOptionalIdentifier(true),
                GetInnerStructOptionalObject(true));
                factory->add_type_object("InnerStructOptional", GetInnerStructOptionalIdentifier(false),
                GetInnerStructOptionalObject(false));

                factory->add_type_object("opt_struct_optional", Getopt_struct_optionalIdentifier(true),
                Getopt_struct_optionalObject(true));
                factory->add_type_object("opt_struct_optional", Getopt_struct_optionalIdentifier(false),
                Getopt_struct_optionalObject(false));

                factory->add_type_object("opt_struct_align_1_optional", Getopt_struct_align_1_optionalIdentifier(true),
                Getopt_struct_align_1_optionalObject(true));
                factory->add_type_object("opt_struct_align_1_optional", Getopt_struct_align_1_optionalIdentifier(false),
                Getopt_struct_align_1_optionalObject(false));

                factory->add_type_object("opt_struct_align_2_optional", Getopt_struct_align_2_optionalIdentifier(true),
                Getopt_struct_align_2_optionalObject(true));
                factory->add_type_object("opt_struct_align_2_optional", Getopt_struct_align_2_optionalIdentifier(false),
                Getopt_struct_align_2_optionalObject(false));

                factory->add_type_object("opt_struct_align_4_optional", Getopt_struct_align_4_optionalIdentifier(true),
                Getopt_struct_align_4_optionalObject(true));
                factory->add_type_object("opt_struct_align_4_optional", Getopt_struct_align_4_optionalIdentifier(false),
                Getopt_struct_align_4_optionalObject(false));

            });
}

const TypeIdentifier* Getshort_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("short_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getshort_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("short_optional", complete);
}

const TypeObject* Getshort_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("short_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteshort_optionalObject();
    }
    //else
    return GetMinimalshort_optionalObject();
}

const TypeObject* GetMinimalshort_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("short_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("short_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("short_optional", false);
}

const TypeObject* GetCompleteshort_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("short_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("short_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("short_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("short_optional", true);
}

const TypeIdentifier* Getushort_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ushort_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getushort_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ushort_optional", complete);
}

const TypeObject* Getushort_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ushort_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteushort_optionalObject();
    }
    //else
    return GetMinimalushort_optionalObject();
}

const TypeObject* GetMinimalushort_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ushort_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ushort_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ushort_optional", false);
}

const TypeObject* GetCompleteushort_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ushort_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ushort_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ushort_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ushort_optional", true);
}

const TypeIdentifier* Getlong_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("long_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getlong_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("long_optional", complete);
}

const TypeObject* Getlong_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("long_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletelong_optionalObject();
    }
    //else
    return GetMinimallong_optionalObject();
}

const TypeObject* GetMinimallong_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("long_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("long_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("long_optional", false);
}

const TypeObject* GetCompletelong_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("long_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("long_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("long_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("long_optional", true);
}

const TypeIdentifier* Getulong_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ulong_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getulong_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ulong_optional", complete);
}

const TypeObject* Getulong_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulong_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteulong_optionalObject();
    }
    //else
    return GetMinimalulong_optionalObject();
}

const TypeObject* GetMinimalulong_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulong_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulong_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulong_optional", false);
}

const TypeObject* GetCompleteulong_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulong_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ulong_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulong_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulong_optional", true);
}

const TypeIdentifier* Getlonglong_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("longlong_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getlonglong_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("longlong_optional", complete);
}

const TypeObject* Getlonglong_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longlong_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletelonglong_optionalObject();
    }
    //else
    return GetMinimallonglong_optionalObject();
}

const TypeObject* GetMinimallonglong_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longlong_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longlong_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longlong_optional", false);
}

const TypeObject* GetCompletelonglong_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longlong_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("longlong_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longlong_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longlong_optional", true);
}

const TypeIdentifier* Getulonglong_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ulonglong_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getulonglong_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ulonglong_optional", complete);
}

const TypeObject* Getulonglong_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulonglong_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteulonglong_optionalObject();
    }
    //else
    return GetMinimalulonglong_optionalObject();
}

const TypeObject* GetMinimalulonglong_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulonglong_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulonglong_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulonglong_optional", false);
}

const TypeObject* GetCompleteulonglong_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulonglong_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ulonglong_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulonglong_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulonglong_optional", true);
}

const TypeIdentifier* Getfloat_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("float_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getfloat_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("float_optional", complete);
}

const TypeObject* Getfloat_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("float_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletefloat_optionalObject();
    }
    //else
    return GetMinimalfloat_optionalObject();
}

const TypeObject* GetMinimalfloat_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("float_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("float_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("float_optional", false);
}

const TypeObject* GetCompletefloat_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("float_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("float_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("float_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("float_optional", true);
}

const TypeIdentifier* Getdouble_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("double_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getdouble_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("double_optional", complete);
}

const TypeObject* Getdouble_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("double_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletedouble_optionalObject();
    }
    //else
    return GetMinimaldouble_optionalObject();
}

const TypeObject* GetMinimaldouble_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("double_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("double_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("double_optional", false);
}

const TypeObject* GetCompletedouble_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("double_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("double_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("double_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("double_optional", true);
}

const TypeIdentifier* Getlongdouble_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("longdouble_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getlongdouble_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("longdouble_optional", complete);
}

const TypeObject* Getlongdouble_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longdouble_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletelongdouble_optionalObject();
    }
    //else
    return GetMinimallongdouble_optionalObject();
}

const TypeObject* GetMinimallongdouble_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longdouble_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longdouble_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longdouble_optional", false);
}

const TypeObject* GetCompletelongdouble_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longdouble_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("longdouble_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longdouble_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longdouble_optional", true);
}

const TypeIdentifier* Getboolean_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("boolean_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getboolean_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("boolean_optional", complete);
}

const TypeObject* Getboolean_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("boolean_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteboolean_optionalObject();
    }
    //else
    return GetMinimalboolean_optionalObject();
}

const TypeObject* GetMinimalboolean_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("boolean_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("boolean_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("boolean_optional", false);
}

const TypeObject* GetCompleteboolean_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("boolean_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("boolean_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("boolean_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("boolean_optional", true);
}

const TypeIdentifier* Getoctet_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("octet_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getoctet_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("octet_optional", complete);
}

const TypeObject* Getoctet_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("octet_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteoctet_optionalObject();
    }
    //else
    return GetMinimaloctet_optionalObject();
}

const TypeObject* GetMinimaloctet_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("octet_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("octet_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("octet_optional", false);
}

const TypeObject* GetCompleteoctet_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("octet_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("octet_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("octet_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("octet_optional", true);
}

const TypeIdentifier* Getchar_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("char_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getchar_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("char_optional", complete);
}

const TypeObject* Getchar_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("char_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletechar_optionalObject();
    }
    //else
    return GetMinimalchar_optionalObject();
}

const TypeObject* GetMinimalchar_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("char_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("char_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("char_optional", false);
}

const TypeObject* GetCompletechar_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("char_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("char_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("char_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("char_optional", true);
}

const TypeIdentifier* Getwchar_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("wchar_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getwchar_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("wchar_optional", complete);
}

const TypeObject* Getwchar_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("wchar_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletewchar_optionalObject();
    }
    //else
    return GetMinimalwchar_optionalObject();
}

const TypeObject* GetMinimalwchar_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("wchar_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("wchar_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("wchar_optional", false);
}

const TypeObject* GetCompletewchar_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("wchar_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("wchar_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("wchar_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("wchar_optional", true);
}

const TypeIdentifier* Getshort_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("short_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getshort_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("short_align_1_optional", complete);
}

const TypeObject* Getshort_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("short_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteshort_align_1_optionalObject();
    }
    //else
    return GetMinimalshort_align_1_optionalObject();
}

const TypeObject* GetMinimalshort_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("short_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("short_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("short_align_1_optional", false);
}

const TypeObject* GetCompleteshort_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("short_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("short_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("short_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("short_align_1_optional", true);
}

const TypeIdentifier* Getshort_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("short_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getshort_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("short_align_2_optional", complete);
}

const TypeObject* Getshort_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("short_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteshort_align_2_optionalObject();
    }
    //else
    return GetMinimalshort_align_2_optionalObject();
}

const TypeObject* GetMinimalshort_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("short_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("short_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("short_align_2_optional", false);
}

const TypeObject* GetCompleteshort_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("short_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("short_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("short_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("short_align_2_optional", true);
}

const TypeIdentifier* Getshort_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("short_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getshort_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("short_align_4_optional", complete);
}

const TypeObject* Getshort_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("short_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteshort_align_4_optionalObject();
    }
    //else
    return GetMinimalshort_align_4_optionalObject();
}

const TypeObject* GetMinimalshort_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("short_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("short_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("short_align_4_optional", false);
}

const TypeObject* GetCompleteshort_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("short_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("short_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("short_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("short_align_4_optional", true);
}

const TypeIdentifier* Getushort_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ushort_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getushort_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ushort_align_1_optional", complete);
}

const TypeObject* Getushort_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ushort_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteushort_align_1_optionalObject();
    }
    //else
    return GetMinimalushort_align_1_optionalObject();
}

const TypeObject* GetMinimalushort_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ushort_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ushort_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ushort_align_1_optional", false);
}

const TypeObject* GetCompleteushort_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ushort_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ushort_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ushort_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ushort_align_1_optional", true);
}

const TypeIdentifier* Getushort_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ushort_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getushort_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ushort_align_2_optional", complete);
}

const TypeObject* Getushort_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ushort_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteushort_align_2_optionalObject();
    }
    //else
    return GetMinimalushort_align_2_optionalObject();
}

const TypeObject* GetMinimalushort_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ushort_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ushort_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ushort_align_2_optional", false);
}

const TypeObject* GetCompleteushort_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ushort_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ushort_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ushort_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ushort_align_2_optional", true);
}

const TypeIdentifier* Getushort_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ushort_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getushort_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ushort_align_4_optional", complete);
}

const TypeObject* Getushort_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ushort_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteushort_align_4_optionalObject();
    }
    //else
    return GetMinimalushort_align_4_optionalObject();
}

const TypeObject* GetMinimalushort_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ushort_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ushort_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ushort_align_4_optional", false);
}

const TypeObject* GetCompleteushort_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ushort_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ushort_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ushort_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ushort_align_4_optional", true);
}

const TypeIdentifier* Getlong_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("long_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getlong_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("long_align_1_optional", complete);
}

const TypeObject* Getlong_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("long_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletelong_align_1_optionalObject();
    }
    //else
    return GetMinimallong_align_1_optionalObject();
}

const TypeObject* GetMinimallong_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("long_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("long_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("long_align_1_optional", false);
}

const TypeObject* GetCompletelong_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("long_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("long_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("long_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("long_align_1_optional", true);
}

const TypeIdentifier* Getlong_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("long_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getlong_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("long_align_2_optional", complete);
}

const TypeObject* Getlong_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("long_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletelong_align_2_optionalObject();
    }
    //else
    return GetMinimallong_align_2_optionalObject();
}

const TypeObject* GetMinimallong_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("long_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("long_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("long_align_2_optional", false);
}

const TypeObject* GetCompletelong_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("long_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("long_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("long_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("long_align_2_optional", true);
}

const TypeIdentifier* Getlong_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("long_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getlong_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("long_align_4_optional", complete);
}

const TypeObject* Getlong_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("long_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletelong_align_4_optionalObject();
    }
    //else
    return GetMinimallong_align_4_optionalObject();
}

const TypeObject* GetMinimallong_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("long_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("long_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("long_align_4_optional", false);
}

const TypeObject* GetCompletelong_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("long_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("long_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("long_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("long_align_4_optional", true);
}

const TypeIdentifier* Getulong_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ulong_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getulong_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ulong_align_1_optional", complete);
}

const TypeObject* Getulong_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulong_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteulong_align_1_optionalObject();
    }
    //else
    return GetMinimalulong_align_1_optionalObject();
}

const TypeObject* GetMinimalulong_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulong_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulong_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulong_align_1_optional", false);
}

const TypeObject* GetCompleteulong_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulong_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ulong_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulong_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulong_align_1_optional", true);
}

const TypeIdentifier* Getulong_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ulong_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getulong_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ulong_align_2_optional", complete);
}

const TypeObject* Getulong_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulong_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteulong_align_2_optionalObject();
    }
    //else
    return GetMinimalulong_align_2_optionalObject();
}

const TypeObject* GetMinimalulong_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulong_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulong_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulong_align_2_optional", false);
}

const TypeObject* GetCompleteulong_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulong_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ulong_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulong_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulong_align_2_optional", true);
}

const TypeIdentifier* Getulong_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ulong_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getulong_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ulong_align_4_optional", complete);
}

const TypeObject* Getulong_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulong_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteulong_align_4_optionalObject();
    }
    //else
    return GetMinimalulong_align_4_optionalObject();
}

const TypeObject* GetMinimalulong_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulong_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulong_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulong_align_4_optional", false);
}

const TypeObject* GetCompleteulong_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulong_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ulong_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulong_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulong_align_4_optional", true);
}

const TypeIdentifier* Getlonglong_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("longlong_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getlonglong_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("longlong_align_1_optional", complete);
}

const TypeObject* Getlonglong_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longlong_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletelonglong_align_1_optionalObject();
    }
    //else
    return GetMinimallonglong_align_1_optionalObject();
}

const TypeObject* GetMinimallonglong_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longlong_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longlong_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longlong_align_1_optional", false);
}

const TypeObject* GetCompletelonglong_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longlong_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("longlong_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longlong_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longlong_align_1_optional", true);
}

const TypeIdentifier* Getlonglong_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("longlong_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getlonglong_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("longlong_align_2_optional", complete);
}

const TypeObject* Getlonglong_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longlong_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletelonglong_align_2_optionalObject();
    }
    //else
    return GetMinimallonglong_align_2_optionalObject();
}

const TypeObject* GetMinimallonglong_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longlong_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longlong_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longlong_align_2_optional", false);
}

const TypeObject* GetCompletelonglong_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longlong_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("longlong_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longlong_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longlong_align_2_optional", true);
}

const TypeIdentifier* Getlonglong_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("longlong_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getlonglong_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("longlong_align_4_optional", complete);
}

const TypeObject* Getlonglong_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longlong_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletelonglong_align_4_optionalObject();
    }
    //else
    return GetMinimallonglong_align_4_optionalObject();
}

const TypeObject* GetMinimallonglong_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longlong_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longlong_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longlong_align_4_optional", false);
}

const TypeObject* GetCompletelonglong_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longlong_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("longlong_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longlong_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longlong_align_4_optional", true);
}

const TypeIdentifier* Getulonglong_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ulonglong_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getulonglong_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ulonglong_align_1_optional", complete);
}

const TypeObject* Getulonglong_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteulonglong_align_1_optionalObject();
    }
    //else
    return GetMinimalulonglong_align_1_optionalObject();
}

const TypeObject* GetMinimalulonglong_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulonglong_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_1_optional", false);
}

const TypeObject* GetCompleteulonglong_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ulonglong_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulonglong_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_1_optional", true);
}

const TypeIdentifier* Getulonglong_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ulonglong_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getulonglong_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ulonglong_align_2_optional", complete);
}

const TypeObject* Getulonglong_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteulonglong_align_2_optionalObject();
    }
    //else
    return GetMinimalulonglong_align_2_optionalObject();
}

const TypeObject* GetMinimalulonglong_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulonglong_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_2_optional", false);
}

const TypeObject* GetCompleteulonglong_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ulonglong_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulonglong_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_2_optional", true);
}

const TypeIdentifier* Getulonglong_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ulonglong_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getulonglong_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ulonglong_align_4_optional", complete);
}

const TypeObject* Getulonglong_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteulonglong_align_4_optionalObject();
    }
    //else
    return GetMinimalulonglong_align_4_optionalObject();
}

const TypeObject* GetMinimalulonglong_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulonglong_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_4_optional", false);
}

const TypeObject* GetCompleteulonglong_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ulonglong_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ulonglong_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ulonglong_align_4_optional", true);
}

const TypeIdentifier* Getfloat_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("float_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getfloat_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("float_align_1_optional", complete);
}

const TypeObject* Getfloat_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("float_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletefloat_align_1_optionalObject();
    }
    //else
    return GetMinimalfloat_align_1_optionalObject();
}

const TypeObject* GetMinimalfloat_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("float_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("float_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("float_align_1_optional", false);
}

const TypeObject* GetCompletefloat_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("float_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("float_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("float_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("float_align_1_optional", true);
}

const TypeIdentifier* Getfloat_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("float_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getfloat_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("float_align_2_optional", complete);
}

const TypeObject* Getfloat_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("float_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletefloat_align_2_optionalObject();
    }
    //else
    return GetMinimalfloat_align_2_optionalObject();
}

const TypeObject* GetMinimalfloat_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("float_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("float_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("float_align_2_optional", false);
}

const TypeObject* GetCompletefloat_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("float_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("float_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("float_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("float_align_2_optional", true);
}

const TypeIdentifier* Getfloat_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("float_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getfloat_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("float_align_4_optional", complete);
}

const TypeObject* Getfloat_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("float_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletefloat_align_4_optionalObject();
    }
    //else
    return GetMinimalfloat_align_4_optionalObject();
}

const TypeObject* GetMinimalfloat_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("float_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("float_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("float_align_4_optional", false);
}

const TypeObject* GetCompletefloat_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("float_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("float_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("float_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("float_align_4_optional", true);
}

const TypeIdentifier* Getdouble_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("double_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getdouble_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("double_align_1_optional", complete);
}

const TypeObject* Getdouble_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("double_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletedouble_align_1_optionalObject();
    }
    //else
    return GetMinimaldouble_align_1_optionalObject();
}

const TypeObject* GetMinimaldouble_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("double_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("double_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("double_align_1_optional", false);
}

const TypeObject* GetCompletedouble_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("double_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("double_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("double_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("double_align_1_optional", true);
}

const TypeIdentifier* Getdouble_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("double_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getdouble_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("double_align_2_optional", complete);
}

const TypeObject* Getdouble_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("double_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletedouble_align_2_optionalObject();
    }
    //else
    return GetMinimaldouble_align_2_optionalObject();
}

const TypeObject* GetMinimaldouble_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("double_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("double_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("double_align_2_optional", false);
}

const TypeObject* GetCompletedouble_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("double_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("double_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("double_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("double_align_2_optional", true);
}

const TypeIdentifier* Getdouble_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("double_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getdouble_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("double_align_4_optional", complete);
}

const TypeObject* Getdouble_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("double_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletedouble_align_4_optionalObject();
    }
    //else
    return GetMinimaldouble_align_4_optionalObject();
}

const TypeObject* GetMinimaldouble_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("double_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("double_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("double_align_4_optional", false);
}

const TypeObject* GetCompletedouble_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("double_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("double_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("double_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("double_align_4_optional", true);
}

const TypeIdentifier* Getlongdouble_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("longdouble_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getlongdouble_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("longdouble_align_1_optional", complete);
}

const TypeObject* Getlongdouble_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longdouble_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletelongdouble_align_1_optionalObject();
    }
    //else
    return GetMinimallongdouble_align_1_optionalObject();
}

const TypeObject* GetMinimallongdouble_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longdouble_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longdouble_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longdouble_align_1_optional", false);
}

const TypeObject* GetCompletelongdouble_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longdouble_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("longdouble_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longdouble_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longdouble_align_1_optional", true);
}

const TypeIdentifier* Getlongdouble_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("longdouble_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getlongdouble_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("longdouble_align_2_optional", complete);
}

const TypeObject* Getlongdouble_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longdouble_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletelongdouble_align_2_optionalObject();
    }
    //else
    return GetMinimallongdouble_align_2_optionalObject();
}

const TypeObject* GetMinimallongdouble_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longdouble_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longdouble_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longdouble_align_2_optional", false);
}

const TypeObject* GetCompletelongdouble_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longdouble_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("longdouble_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longdouble_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longdouble_align_2_optional", true);
}

const TypeIdentifier* Getlongdouble_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("longdouble_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getlongdouble_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("longdouble_align_4_optional", complete);
}

const TypeObject* Getlongdouble_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longdouble_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletelongdouble_align_4_optionalObject();
    }
    //else
    return GetMinimallongdouble_align_4_optionalObject();
}

const TypeObject* GetMinimallongdouble_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longdouble_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longdouble_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longdouble_align_4_optional", false);
}

const TypeObject* GetCompletelongdouble_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("longdouble_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("longdouble_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("longdouble_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("longdouble_align_4_optional", true);
}

const TypeIdentifier* Getboolean_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("boolean_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getboolean_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("boolean_align_1_optional", complete);
}

const TypeObject* Getboolean_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("boolean_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteboolean_align_1_optionalObject();
    }
    //else
    return GetMinimalboolean_align_1_optionalObject();
}

const TypeObject* GetMinimalboolean_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("boolean_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("boolean_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("boolean_align_1_optional", false);
}

const TypeObject* GetCompleteboolean_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("boolean_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("boolean_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("boolean_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("boolean_align_1_optional", true);
}

const TypeIdentifier* Getboolean_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("boolean_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getboolean_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("boolean_align_2_optional", complete);
}

const TypeObject* Getboolean_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("boolean_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteboolean_align_2_optionalObject();
    }
    //else
    return GetMinimalboolean_align_2_optionalObject();
}

const TypeObject* GetMinimalboolean_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("boolean_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("boolean_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("boolean_align_2_optional", false);
}

const TypeObject* GetCompleteboolean_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("boolean_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("boolean_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("boolean_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("boolean_align_2_optional", true);
}

const TypeIdentifier* Getboolean_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("boolean_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getboolean_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("boolean_align_4_optional", complete);
}

const TypeObject* Getboolean_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("boolean_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteboolean_align_4_optionalObject();
    }
    //else
    return GetMinimalboolean_align_4_optionalObject();
}

const TypeObject* GetMinimalboolean_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("boolean_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("boolean_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("boolean_align_4_optional", false);
}

const TypeObject* GetCompleteboolean_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("boolean_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("boolean_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("boolean_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("boolean_align_4_optional", true);
}

const TypeIdentifier* Getoctet_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("octet_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getoctet_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("octet_align_1_optional", complete);
}

const TypeObject* Getoctet_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("octet_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteoctet_align_1_optionalObject();
    }
    //else
    return GetMinimaloctet_align_1_optionalObject();
}

const TypeObject* GetMinimaloctet_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("octet_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("octet_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("octet_align_1_optional", false);
}

const TypeObject* GetCompleteoctet_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("octet_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("octet_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("octet_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("octet_align_1_optional", true);
}

const TypeIdentifier* Getoctet_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("octet_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getoctet_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("octet_align_2_optional", complete);
}

const TypeObject* Getoctet_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("octet_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteoctet_align_2_optionalObject();
    }
    //else
    return GetMinimaloctet_align_2_optionalObject();
}

const TypeObject* GetMinimaloctet_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("octet_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("octet_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("octet_align_2_optional", false);
}

const TypeObject* GetCompleteoctet_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("octet_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("octet_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("octet_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("octet_align_2_optional", true);
}

const TypeIdentifier* Getoctet_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("octet_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getoctet_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("octet_align_4_optional", complete);
}

const TypeObject* Getoctet_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("octet_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteoctet_align_4_optionalObject();
    }
    //else
    return GetMinimaloctet_align_4_optionalObject();
}

const TypeObject* GetMinimaloctet_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("octet_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("octet_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("octet_align_4_optional", false);
}

const TypeObject* GetCompleteoctet_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("octet_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("octet_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("octet_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("octet_align_4_optional", true);
}

const TypeIdentifier* Getchar_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("char_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getchar_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("char_align_1_optional", complete);
}

const TypeObject* Getchar_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("char_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletechar_align_1_optionalObject();
    }
    //else
    return GetMinimalchar_align_1_optionalObject();
}

const TypeObject* GetMinimalchar_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("char_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("char_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("char_align_1_optional", false);
}

const TypeObject* GetCompletechar_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("char_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("char_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("char_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("char_align_1_optional", true);
}

const TypeIdentifier* Getchar_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("char_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getchar_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("char_align_2_optional", complete);
}

const TypeObject* Getchar_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("char_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletechar_align_2_optionalObject();
    }
    //else
    return GetMinimalchar_align_2_optionalObject();
}

const TypeObject* GetMinimalchar_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("char_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("char_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("char_align_2_optional", false);
}

const TypeObject* GetCompletechar_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("char_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("char_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("char_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("char_align_2_optional", true);
}

const TypeIdentifier* Getchar_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("char_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getchar_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("char_align_4_optional", complete);
}

const TypeObject* Getchar_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("char_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletechar_align_4_optionalObject();
    }
    //else
    return GetMinimalchar_align_4_optionalObject();
}

const TypeObject* GetMinimalchar_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("char_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("char_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("char_align_4_optional", false);
}

const TypeObject* GetCompletechar_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("char_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("char_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("char_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("char_align_4_optional", true);
}

const TypeIdentifier* Getwchar_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("wchar_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getwchar_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("wchar_align_1_optional", complete);
}

const TypeObject* Getwchar_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("wchar_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletewchar_align_1_optionalObject();
    }
    //else
    return GetMinimalwchar_align_1_optionalObject();
}

const TypeObject* GetMinimalwchar_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("wchar_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("wchar_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("wchar_align_1_optional", false);
}

const TypeObject* GetCompletewchar_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("wchar_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("wchar_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("wchar_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("wchar_align_1_optional", true);
}

const TypeIdentifier* Getwchar_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("wchar_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getwchar_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("wchar_align_2_optional", complete);
}

const TypeObject* Getwchar_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("wchar_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletewchar_align_2_optionalObject();
    }
    //else
    return GetMinimalwchar_align_2_optionalObject();
}

const TypeObject* GetMinimalwchar_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("wchar_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("wchar_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("wchar_align_2_optional", false);
}

const TypeObject* GetCompletewchar_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("wchar_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("wchar_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("wchar_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("wchar_align_2_optional", true);
}

const TypeIdentifier* Getwchar_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("wchar_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getwchar_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("wchar_align_4_optional", complete);
}

const TypeObject* Getwchar_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("wchar_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletewchar_align_4_optionalObject();
    }
    //else
    return GetMinimalwchar_align_4_optionalObject();
}

const TypeObject* GetMinimalwchar_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("wchar_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("wchar_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("wchar_align_4_optional", false);
}

const TypeObject* GetCompletewchar_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("wchar_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("wchar_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("wchar_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("wchar_align_4_optional", true);
}

const TypeIdentifier* Getsequence_short_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("sequence_short_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getsequence_short_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("sequence_short_optional", complete);
}

const TypeObject* Getsequence_short_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("sequence_short_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletesequence_short_optionalObject();
    }
    //else
    return GetMinimalsequence_short_optionalObject();
}

const TypeObject* GetMinimalsequence_short_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("sequence_short_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 100, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("sequence_short_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("sequence_short_optional", false);
}

const TypeObject* GetCompletesequence_short_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("sequence_short_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 100, true));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("sequence_short_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("sequence_short_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("sequence_short_optional", true);
}

const TypeIdentifier* Getsequence_short_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("sequence_short_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getsequence_short_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("sequence_short_align_1_optional", complete);
}

const TypeObject* Getsequence_short_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletesequence_short_align_1_optionalObject();
    }
    //else
    return GetMinimalsequence_short_align_1_optionalObject();
}

const TypeObject* GetMinimalsequence_short_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 100, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("sequence_short_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_1_optional", false);
}

const TypeObject* GetCompletesequence_short_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 100, true));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("sequence_short_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("sequence_short_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_1_optional", true);
}

const TypeIdentifier* Getsequence_short_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("sequence_short_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getsequence_short_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("sequence_short_align_2_optional", complete);
}

const TypeObject* Getsequence_short_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletesequence_short_align_2_optionalObject();
    }
    //else
    return GetMinimalsequence_short_align_2_optionalObject();
}

const TypeObject* GetMinimalsequence_short_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 100, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("sequence_short_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_2_optional", false);
}

const TypeObject* GetCompletesequence_short_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 100, true));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("sequence_short_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("sequence_short_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_2_optional", true);
}

const TypeIdentifier* Getsequence_short_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("sequence_short_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getsequence_short_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("sequence_short_align_4_optional", complete);
}

const TypeObject* Getsequence_short_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletesequence_short_align_4_optionalObject();
    }
    //else
    return GetMinimalsequence_short_align_4_optionalObject();
}

const TypeObject* GetMinimalsequence_short_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 100, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("sequence_short_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_4_optional", false);
}

const TypeObject* GetCompletesequence_short_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 100, true));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("sequence_short_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("sequence_short_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("sequence_short_align_4_optional", true);
}

const TypeIdentifier* Getstring_unbounded_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("string_unbounded_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getstring_unbounded_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("string_unbounded_optional", complete);
}

const TypeObject* Getstring_unbounded_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_unbounded_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletestring_unbounded_optionalObject();
    }
    //else
    return GetMinimalstring_unbounded_optionalObject();
}

const TypeObject* GetMinimalstring_unbounded_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_unbounded_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_unbounded_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_unbounded_optional", false);
}

const TypeObject* GetCompletestring_unbounded_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_unbounded_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("string_unbounded_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_unbounded_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_unbounded_optional", true);
}

const TypeIdentifier* Getstring_unbounded_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("string_unbounded_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getstring_unbounded_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("string_unbounded_align_1_optional", complete);
}

const TypeObject* Getstring_unbounded_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletestring_unbounded_align_1_optionalObject();
    }
    //else
    return GetMinimalstring_unbounded_align_1_optionalObject();
}

const TypeObject* GetMinimalstring_unbounded_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_unbounded_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_1_optional", false);
}

const TypeObject* GetCompletestring_unbounded_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("string_unbounded_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_unbounded_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_1_optional", true);
}

const TypeIdentifier* Getstring_unbounded_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("string_unbounded_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getstring_unbounded_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("string_unbounded_align_2_optional", complete);
}

const TypeObject* Getstring_unbounded_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletestring_unbounded_align_2_optionalObject();
    }
    //else
    return GetMinimalstring_unbounded_align_2_optionalObject();
}

const TypeObject* GetMinimalstring_unbounded_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_unbounded_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_2_optional", false);
}

const TypeObject* GetCompletestring_unbounded_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("string_unbounded_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_unbounded_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_2_optional", true);
}

const TypeIdentifier* Getstring_unbounded_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("string_unbounded_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getstring_unbounded_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("string_unbounded_align_4_optional", complete);
}

const TypeObject* Getstring_unbounded_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletestring_unbounded_align_4_optionalObject();
    }
    //else
    return GetMinimalstring_unbounded_align_4_optionalObject();
}

const TypeObject* GetMinimalstring_unbounded_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_unbounded_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_4_optional", false);
}

const TypeObject* GetCompletestring_unbounded_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("string_unbounded_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_unbounded_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_unbounded_align_4_optional", true);
}

const TypeIdentifier* Getstring_bounded_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("string_bounded_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getstring_bounded_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("string_bounded_optional", complete);
}

const TypeObject* Getstring_bounded_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_bounded_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletestring_bounded_optionalObject();
    }
    //else
    return GetMinimalstring_bounded_optionalObject();
}

const TypeObject* GetMinimalstring_bounded_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_bounded_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(8, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_bounded_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_bounded_optional", false);
}

const TypeObject* GetCompletestring_bounded_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_bounded_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(8, false));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("string_bounded_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_bounded_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_bounded_optional", true);
}

const TypeIdentifier* Getstring_bounded_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("string_bounded_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getstring_bounded_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("string_bounded_align_1_optional", complete);
}

const TypeObject* Getstring_bounded_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletestring_bounded_align_1_optionalObject();
    }
    //else
    return GetMinimalstring_bounded_align_1_optionalObject();
}

const TypeObject* GetMinimalstring_bounded_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(8, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_bounded_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_1_optional", false);
}

const TypeObject* GetCompletestring_bounded_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(8, false));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("string_bounded_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_bounded_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_1_optional", true);
}

const TypeIdentifier* Getstring_bounded_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("string_bounded_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getstring_bounded_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("string_bounded_align_2_optional", complete);
}

const TypeObject* Getstring_bounded_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletestring_bounded_align_2_optionalObject();
    }
    //else
    return GetMinimalstring_bounded_align_2_optionalObject();
}

const TypeObject* GetMinimalstring_bounded_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(8, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_bounded_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_2_optional", false);
}

const TypeObject* GetCompletestring_bounded_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(8, false));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("string_bounded_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_bounded_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_2_optional", true);
}

const TypeIdentifier* Getstring_bounded_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("string_bounded_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getstring_bounded_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("string_bounded_align_4_optional", complete);
}

const TypeObject* Getstring_bounded_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletestring_bounded_align_4_optionalObject();
    }
    //else
    return GetMinimalstring_bounded_align_4_optionalObject();
}

const TypeObject* GetMinimalstring_bounded_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(8, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_bounded_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_4_optional", false);
}

const TypeObject* GetCompletestring_bounded_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(8, false));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("string_bounded_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("string_bounded_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("string_bounded_align_4_optional", true);
}

const TypeIdentifier* Getmap_short_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("map_short_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getmap_short_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("map_short_optional", complete);
}

const TypeObject* Getmap_short_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("map_short_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletemap_short_optionalObject();
    }
    //else
    return GetMinimalmap_short_optionalObject();
}

const TypeObject* GetMinimalmap_short_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("map_short_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int16_t", 100, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("map_short_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("map_short_optional", false);
}

const TypeObject* GetCompletemap_short_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("map_short_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int16_t", 100, true));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("map_short_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("map_short_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("map_short_optional", true);
}

const TypeIdentifier* Getmap_short_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("map_short_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getmap_short_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("map_short_align_1_optional", complete);
}

const TypeObject* Getmap_short_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("map_short_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletemap_short_align_1_optionalObject();
    }
    //else
    return GetMinimalmap_short_align_1_optionalObject();
}

const TypeObject* GetMinimalmap_short_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("map_short_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int16_t", 100, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("map_short_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("map_short_align_1_optional", false);
}

const TypeObject* GetCompletemap_short_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("map_short_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int16_t", 100, true));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("map_short_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("map_short_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("map_short_align_1_optional", true);
}

const TypeIdentifier* Getmap_short_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("map_short_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getmap_short_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("map_short_align_2_optional", complete);
}

const TypeObject* Getmap_short_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("map_short_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletemap_short_align_2_optionalObject();
    }
    //else
    return GetMinimalmap_short_align_2_optionalObject();
}

const TypeObject* GetMinimalmap_short_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("map_short_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int16_t", 100, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("map_short_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("map_short_align_2_optional", false);
}

const TypeObject* GetCompletemap_short_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("map_short_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int16_t", 100, true));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("map_short_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("map_short_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("map_short_align_2_optional", true);
}

const TypeIdentifier* Getmap_short_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("map_short_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getmap_short_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("map_short_align_4_optional", complete);
}

const TypeObject* Getmap_short_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("map_short_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletemap_short_align_4_optionalObject();
    }
    //else
    return GetMinimalmap_short_align_4_optionalObject();
}

const TypeObject* GetMinimalmap_short_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("map_short_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int16_t", 100, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("map_short_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("map_short_align_4_optional", false);
}

const TypeObject* GetCompletemap_short_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("map_short_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int16_t", 100, true));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("map_short_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("map_short_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("map_short_align_4_optional", true);
}

const TypeIdentifier* Getarray_short_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("array_short_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getarray_short_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("array_short_optional", complete);
}

const TypeObject* Getarray_short_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("array_short_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletearray_short_optionalObject();
    }
    //else
    return GetMinimalarray_short_optionalObject();
}

const TypeObject* GetMinimalarray_short_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("array_short_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10}, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("array_short_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("array_short_optional", false);
}

const TypeObject* GetCompletearray_short_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("array_short_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10}, true));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("array_short_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("array_short_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("array_short_optional", true);
}

const TypeIdentifier* Getarray_short_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("array_short_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getarray_short_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("array_short_align_1_optional", complete);
}

const TypeObject* Getarray_short_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("array_short_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletearray_short_align_1_optionalObject();
    }
    //else
    return GetMinimalarray_short_align_1_optionalObject();
}

const TypeObject* GetMinimalarray_short_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("array_short_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10}, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("array_short_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("array_short_align_1_optional", false);
}

const TypeObject* GetCompletearray_short_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("array_short_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10}, true));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("array_short_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("array_short_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("array_short_align_1_optional", true);
}

const TypeIdentifier* Getarray_short_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("array_short_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getarray_short_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("array_short_align_2_optional", complete);
}

const TypeObject* Getarray_short_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("array_short_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletearray_short_align_2_optionalObject();
    }
    //else
    return GetMinimalarray_short_align_2_optionalObject();
}

const TypeObject* GetMinimalarray_short_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("array_short_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10}, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("array_short_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("array_short_align_2_optional", false);
}

const TypeObject* GetCompletearray_short_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("array_short_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10}, true));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("array_short_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("array_short_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("array_short_align_2_optional", true);
}

const TypeIdentifier* Getarray_short_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("array_short_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getarray_short_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("array_short_align_4_optional", complete);
}

const TypeObject* Getarray_short_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("array_short_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletearray_short_align_4_optionalObject();
    }
    //else
    return GetMinimalarray_short_align_4_optionalObject();
}

const TypeObject* GetMinimalarray_short_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("array_short_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10}, false));


    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("array_short_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("array_short_align_4_optional", false);
}

const TypeObject* GetCompletearray_short_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("array_short_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10}, true));


    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("array_short_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("array_short_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("array_short_align_4_optional", true);
}

const TypeIdentifier* Getstruct_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("struct_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getstruct_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("struct_optional", complete);
}

const TypeObject* Getstruct_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("struct_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletestruct_optionalObject();
    }
    //else
    return GetMinimalstruct_optionalObject();
}

const TypeObject* GetMinimalstruct_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("struct_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*GetInnerStructureHelperIdentifier(false));
    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("struct_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("struct_optional", false);
}

const TypeObject* GetCompletestruct_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("struct_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*GetInnerStructureHelperIdentifier(true));
    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("struct_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("struct_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("struct_optional", true);
}

const TypeIdentifier* Getstruct_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("struct_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getstruct_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("struct_align_1_optional", complete);
}

const TypeObject* Getstruct_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("struct_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletestruct_align_1_optionalObject();
    }
    //else
    return GetMinimalstruct_align_1_optionalObject();
}

const TypeObject* GetMinimalstruct_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("struct_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*GetInnerStructureHelperIdentifier(false));
    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("struct_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("struct_align_1_optional", false);
}

const TypeObject* GetCompletestruct_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("struct_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*GetInnerStructureHelperIdentifier(true));
    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("struct_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("struct_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("struct_align_1_optional", true);
}

const TypeIdentifier* Getstruct_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("struct_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getstruct_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("struct_align_2_optional", complete);
}

const TypeObject* Getstruct_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("struct_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletestruct_align_2_optionalObject();
    }
    //else
    return GetMinimalstruct_align_2_optionalObject();
}

const TypeObject* GetMinimalstruct_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("struct_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*GetInnerStructureHelperIdentifier(false));
    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("struct_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("struct_align_2_optional", false);
}

const TypeObject* GetCompletestruct_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("struct_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*GetInnerStructureHelperIdentifier(true));
    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("struct_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("struct_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("struct_align_2_optional", true);
}

const TypeIdentifier* Getstruct_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("struct_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getstruct_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("struct_align_4_optional", complete);
}

const TypeObject* Getstruct_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("struct_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletestruct_align_4_optionalObject();
    }
    //else
    return GetMinimalstruct_align_4_optionalObject();
}

const TypeObject* GetMinimalstruct_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("struct_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*GetInnerStructureHelperIdentifier(false));
    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("struct_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("struct_align_4_optional", false);
}

const TypeObject* GetCompletestruct_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("struct_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*GetInnerStructureHelperIdentifier(true));
    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("struct_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("struct_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("struct_align_4_optional", true);
}

const TypeIdentifier* GetInnerStructOptionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("InnerStructOptional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInnerStructOptionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("InnerStructOptional", complete);
}

const TypeObject* GetInnerStructOptionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerStructOptional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInnerStructOptionalObject();
    }
    //else
    return GetMinimalInnerStructOptionalObject();
}

const TypeObject* GetMinimalInnerStructOptionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerStructOptional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_s;
    mst_s.common().member_id(memberId++);
    mst_s.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_s.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_s.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_s.common().member_flags().IS_OPTIONAL(false);
    mst_s.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_s.common().member_flags().IS_KEY(false);
    mst_s.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_s.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    MD5 s_hash("s");
    for(int i = 0; i < 4; ++i)
    {
        mst_s.detail().name_hash()[i] = s_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_s);

    MinimalStructMember mst_l;
    mst_l.common().member_id(memberId++);
    mst_l.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_l.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_l.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_l.common().member_flags().IS_OPTIONAL(true);
    mst_l.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_l.common().member_flags().IS_KEY(false);
    mst_l.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_l.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MD5 l_hash("l");
    for(int i = 0; i < 4; ++i)
    {
        mst_l.detail().name_hash()[i] = l_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_l);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InnerStructOptional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerStructOptional", false);
}

const TypeObject* GetCompleteInnerStructOptionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerStructOptional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_s;
    cst_s.common().member_id(memberId++);
    cst_s.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_s.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_s.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_s.common().member_flags().IS_OPTIONAL(false);
    cst_s.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_s.common().member_flags().IS_KEY(false);
    cst_s.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_s.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    cst_s.detail().name("s");

    type_object->complete().struct_type().member_seq().emplace_back(cst_s);

    CompleteStructMember cst_l;
    cst_l.common().member_id(memberId++);
    cst_l.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_l.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_l.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_l.common().member_flags().IS_OPTIONAL(true);
    cst_l.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_l.common().member_flags().IS_KEY(false);
    cst_l.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_l.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    cst_l.detail().name("l");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_l.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_l);


    // Header
    type_object->complete().struct_type().header().detail().type_name("InnerStructOptional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("InnerStructOptional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerStructOptional", true);
}

const TypeIdentifier* Getopt_struct_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("opt_struct_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getopt_struct_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("opt_struct_optional", complete);
}

const TypeObject* Getopt_struct_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("opt_struct_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteopt_struct_optionalObject();
    }
    //else
    return GetMinimalopt_struct_optionalObject();
}

const TypeObject* GetMinimalopt_struct_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("opt_struct_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*GetInnerStructOptionalIdentifier(false));
    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("opt_struct_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("opt_struct_optional", false);
}

const TypeObject* GetCompleteopt_struct_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("opt_struct_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*GetInnerStructOptionalIdentifier(true));
    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("opt_struct_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("opt_struct_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("opt_struct_optional", true);
}

const TypeIdentifier* Getopt_struct_align_1_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("opt_struct_align_1_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getopt_struct_align_1_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("opt_struct_align_1_optional", complete);
}

const TypeObject* Getopt_struct_align_1_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_1_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteopt_struct_align_1_optionalObject();
    }
    //else
    return GetMinimalopt_struct_align_1_optionalObject();
}

const TypeObject* GetMinimalopt_struct_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_1_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*GetInnerStructOptionalIdentifier(false));
    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("opt_struct_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_1_optional", false);
}

const TypeObject* GetCompleteopt_struct_align_1_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_1_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*GetInnerStructOptionalIdentifier(true));
    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("opt_struct_align_1_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("opt_struct_align_1_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_1_optional", true);
}

const TypeIdentifier* Getopt_struct_align_2_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("opt_struct_align_2_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getopt_struct_align_2_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("opt_struct_align_2_optional", complete);
}

const TypeObject* Getopt_struct_align_2_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_2_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteopt_struct_align_2_optionalObject();
    }
    //else
    return GetMinimalopt_struct_align_2_optionalObject();
}

const TypeObject* GetMinimalopt_struct_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_2_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*GetInnerStructOptionalIdentifier(false));
    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("opt_struct_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_2_optional", false);
}

const TypeObject* GetCompleteopt_struct_align_2_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_2_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*GetInnerStructOptionalIdentifier(true));
    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("opt_struct_align_2_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("opt_struct_align_2_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_2_optional", true);
}

const TypeIdentifier* Getopt_struct_align_4_optionalIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("opt_struct_align_4_optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getopt_struct_align_4_optionalObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("opt_struct_align_4_optional", complete);
}

const TypeObject* Getopt_struct_align_4_optionalObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_4_optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteopt_struct_align_4_optionalObject();
    }
    //else
    return GetMinimalopt_struct_align_4_optionalObject();
}

const TypeObject* GetMinimalopt_struct_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_4_optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_align;
    mst_align.common().member_id(memberId++);
    mst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_align.common().member_flags().IS_OPTIONAL(false);
    mst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_align.common().member_flags().IS_KEY(false);
    mst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 align_hash("align");
    for(int i = 0; i < 4; ++i)
    {
        mst_align.detail().name_hash()[i] = align_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_align);

    MinimalStructMember mst_value;
    mst_value.common().member_id(memberId++);
    mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_value.common().member_flags().IS_OPTIONAL(true);
    mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_value.common().member_flags().IS_KEY(false);
    mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_value.common().member_type_id(*GetInnerStructOptionalIdentifier(false));
    MD5 value_hash("value");
    for(int i = 0; i < 4; ++i)
    {
        mst_value.detail().name_hash()[i] = value_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("opt_struct_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_4_optional", false);
}

const TypeObject* GetCompleteopt_struct_align_4_optionalObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_4_optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_align;
    cst_align.common().member_id(memberId++);
    cst_align.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_align.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_align.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_align.common().member_flags().IS_OPTIONAL(false);
    cst_align.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_align.common().member_flags().IS_KEY(false);
    cst_align.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_align.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_align.detail().name("align");

    type_object->complete().struct_type().member_seq().emplace_back(cst_align);

    CompleteStructMember cst_value;
    cst_value.common().member_id(memberId++);
    cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_value.common().member_flags().IS_OPTIONAL(true);
    cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_value.common().member_flags().IS_KEY(false);
    cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_value.common().member_type_id(*GetInnerStructOptionalIdentifier(true));
    cst_value.detail().name("value");

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetoptionalIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("optional"));
            {
                AppliedAnnotationParameter annParam;
                MD5 message_hash("value");
                for(int i = 0; i < 4; ++i)
                {
                    annParam.paramname_hash()[i] = message_hash.digest[i];
                }
                AnnotationParameterValue paramValue;
                paramValue._d(TK_BOOLEAN);
                paramValue.from_string("true");
                annParam.value(paramValue);
                ann.param_seq().push_back(annParam);
            }
            
        cst_value.detail().ann_custom().push_back(ann);
    }

    type_object->complete().struct_type().member_seq().emplace_back(cst_value);


    // Header
    type_object->complete().struct_type().header().detail().type_name("opt_struct_align_4_optional");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("opt_struct_align_4_optional", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("opt_struct_align_4_optional", true);
}
