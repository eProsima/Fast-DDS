// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file primitivesTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "primitives.h"
#include "primitivesTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

void registerprimitivesTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("ShortStructStruct", GetShortStructStructIdentifier(true),
                GetShortStructStructObject(true));
                factory->add_type_object("ShortStructStruct", GetShortStructStructIdentifier(false),
                GetShortStructStructObject(false));

                factory->add_type_object("UShortStruct", GetUShortStructIdentifier(true),
                GetUShortStructObject(true));
                factory->add_type_object("UShortStruct", GetUShortStructIdentifier(false),
                GetUShortStructObject(false));

                factory->add_type_object("LongStruct", GetLongStructIdentifier(true),
                GetLongStructObject(true));
                factory->add_type_object("LongStruct", GetLongStructIdentifier(false),
                GetLongStructObject(false));

                factory->add_type_object("ULongStruct", GetULongStructIdentifier(true),
                GetULongStructObject(true));
                factory->add_type_object("ULongStruct", GetULongStructIdentifier(false),
                GetULongStructObject(false));

                factory->add_type_object("LongLongStruct", GetLongLongStructIdentifier(true),
                GetLongLongStructObject(true));
                factory->add_type_object("LongLongStruct", GetLongLongStructIdentifier(false),
                GetLongLongStructObject(false));

                factory->add_type_object("ULongLongStruct", GetULongLongStructIdentifier(true),
                GetULongLongStructObject(true));
                factory->add_type_object("ULongLongStruct", GetULongLongStructIdentifier(false),
                GetULongLongStructObject(false));

                factory->add_type_object("FloatStruct", GetFloatStructIdentifier(true),
                GetFloatStructObject(true));
                factory->add_type_object("FloatStruct", GetFloatStructIdentifier(false),
                GetFloatStructObject(false));

                factory->add_type_object("DoubleStruct", GetDoubleStructIdentifier(true),
                GetDoubleStructObject(true));
                factory->add_type_object("DoubleStruct", GetDoubleStructIdentifier(false),
                GetDoubleStructObject(false));

                factory->add_type_object("LongDoubleStruct", GetLongDoubleStructIdentifier(true),
                GetLongDoubleStructObject(true));
                factory->add_type_object("LongDoubleStruct", GetLongDoubleStructIdentifier(false),
                GetLongDoubleStructObject(false));

                factory->add_type_object("BooleanStruct", GetBooleanStructIdentifier(true),
                GetBooleanStructObject(true));
                factory->add_type_object("BooleanStruct", GetBooleanStructIdentifier(false),
                GetBooleanStructObject(false));

                factory->add_type_object("OctetStruct", GetOctetStructIdentifier(true),
                GetOctetStructObject(true));
                factory->add_type_object("OctetStruct", GetOctetStructIdentifier(false),
                GetOctetStructObject(false));

                factory->add_type_object("CharStruct", GetCharStructIdentifier(true),
                GetCharStructObject(true));
                factory->add_type_object("CharStruct", GetCharStructIdentifier(false),
                GetCharStructObject(false));

                factory->add_type_object("WCharStruct", GetWCharStructIdentifier(true),
                GetWCharStructObject(true));
                factory->add_type_object("WCharStruct", GetWCharStructIdentifier(false),
                GetWCharStructObject(false));

            });
}

const TypeIdentifier* GetShortStructStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ShortStructStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetShortStructStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ShortStructStruct", complete);
}

const TypeObject* GetShortStructStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ShortStructStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteShortStructStructObject();
    }
    //else
    return GetMinimalShortStructStructObject();
}

const TypeObject* GetMinimalShortStructStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ShortStructStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_short;
    mst_var_short.common().member_id(memberId++);
    mst_var_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_short.common().member_flags().IS_KEY(false);
    mst_var_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    MD5 var_short_hash("var_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_short.detail().name_hash()[i] = var_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ShortStructStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ShortStructStruct", false);
}

const TypeObject* GetCompleteShortStructStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ShortStructStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_short;
    cst_var_short.common().member_id(memberId++);
    cst_var_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_short.common().member_flags().IS_KEY(false);
    cst_var_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    cst_var_short.detail().name("var_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ShortStructStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ShortStructStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ShortStructStruct", true);
}

const TypeIdentifier* GetUShortStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UShortStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUShortStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UShortStruct", complete);
}

const TypeObject* GetUShortStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UShortStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUShortStructObject();
    }
    //else
    return GetMinimalUShortStructObject();
}

const TypeObject* GetMinimalUShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UShortStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ushort;
    mst_var_ushort.common().member_id(memberId++);
    mst_var_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ushort.common().member_flags().IS_KEY(false);
    mst_var_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 var_ushort_hash("var_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ushort.detail().name_hash()[i] = var_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UShortStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UShortStruct", false);
}

const TypeObject* GetCompleteUShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UShortStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ushort;
    cst_var_ushort.common().member_id(memberId++);
    cst_var_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ushort.common().member_flags().IS_KEY(false);
    cst_var_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_var_ushort.detail().name("var_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UShortStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UShortStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UShortStruct", true);
}

const TypeIdentifier* GetLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("LongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("LongStruct", complete);
}

const TypeObject* GetLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLongStructObject();
    }
    //else
    return GetMinimalLongStructObject();
}

const TypeObject* GetMinimalLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_long;
    mst_var_long.common().member_id(memberId++);
    mst_var_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_long.common().member_flags().IS_KEY(false);
    mst_var_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MD5 var_long_hash("var_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_long.detail().name_hash()[i] = var_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("LongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("LongStruct", false);
}

const TypeObject* GetCompleteLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_long;
    cst_var_long.common().member_id(memberId++);
    cst_var_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_long.common().member_flags().IS_KEY(false);
    cst_var_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    cst_var_long.detail().name("var_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("LongStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("LongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("LongStruct", true);
}

const TypeIdentifier* GetULongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ULongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetULongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ULongStruct", complete);
}

const TypeObject* GetULongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ULongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteULongStructObject();
    }
    //else
    return GetMinimalULongStructObject();
}

const TypeObject* GetMinimalULongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ULongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ulong;
    mst_var_ulong.common().member_id(memberId++);
    mst_var_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ulong.common().member_flags().IS_KEY(false);
    mst_var_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 var_ulong_hash("var_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ulong.detail().name_hash()[i] = var_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ULongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ULongStruct", false);
}

const TypeObject* GetCompleteULongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ULongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ulong;
    cst_var_ulong.common().member_id(memberId++);
    cst_var_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ulong.common().member_flags().IS_KEY(false);
    cst_var_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_var_ulong.detail().name("var_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ULongStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ULongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ULongStruct", true);
}

const TypeIdentifier* GetLongLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("LongLongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLongLongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("LongLongStruct", complete);
}

const TypeObject* GetLongLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongLongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLongLongStructObject();
    }
    //else
    return GetMinimalLongLongStructObject();
}

const TypeObject* GetMinimalLongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongLongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_longlong;
    mst_var_longlong.common().member_id(memberId++);
    mst_var_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_longlong.common().member_flags().IS_KEY(false);
    mst_var_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    MD5 var_longlong_hash("var_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_longlong.detail().name_hash()[i] = var_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("LongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("LongLongStruct", false);
}

const TypeObject* GetCompleteLongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongLongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_longlong;
    cst_var_longlong.common().member_id(memberId++);
    cst_var_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_longlong.common().member_flags().IS_KEY(false);
    cst_var_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    cst_var_longlong.detail().name("var_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("LongLongStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("LongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("LongLongStruct", true);
}

const TypeIdentifier* GetULongLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ULongLongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetULongLongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ULongLongStruct", complete);
}

const TypeObject* GetULongLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ULongLongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteULongLongStructObject();
    }
    //else
    return GetMinimalULongLongStructObject();
}

const TypeObject* GetMinimalULongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ULongLongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ulonglong;
    mst_var_ulonglong.common().member_id(memberId++);
    mst_var_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    MD5 var_ulonglong_hash("var_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ulonglong.detail().name_hash()[i] = var_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ULongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ULongLongStruct", false);
}

const TypeObject* GetCompleteULongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ULongLongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ulonglong;
    cst_var_ulonglong.common().member_id(memberId++);
    cst_var_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    cst_var_ulonglong.detail().name("var_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ULongLongStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ULongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ULongLongStruct", true);
}

const TypeIdentifier* GetFloatStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FloatStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFloatStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FloatStruct", complete);
}

const TypeObject* GetFloatStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FloatStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFloatStructObject();
    }
    //else
    return GetMinimalFloatStructObject();
}

const TypeObject* GetMinimalFloatStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FloatStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_float;
    mst_var_float.common().member_id(memberId++);
    mst_var_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_float.common().member_flags().IS_KEY(false);
    mst_var_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 var_float_hash("var_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_float.detail().name_hash()[i] = var_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FloatStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FloatStruct", false);
}

const TypeObject* GetCompleteFloatStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FloatStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_float;
    cst_var_float.common().member_id(memberId++);
    cst_var_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_float.common().member_flags().IS_KEY(false);
    cst_var_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_var_float.detail().name("var_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FloatStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FloatStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FloatStruct", true);
}

const TypeIdentifier* GetDoubleStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("DoubleStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetDoubleStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("DoubleStruct", complete);
}

const TypeObject* GetDoubleStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("DoubleStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteDoubleStructObject();
    }
    //else
    return GetMinimalDoubleStructObject();
}

const TypeObject* GetMinimalDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("DoubleStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_double;
    mst_var_double.common().member_id(memberId++);
    mst_var_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_double.common().member_flags().IS_KEY(false);
    mst_var_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    MD5 var_double_hash("var_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_double.detail().name_hash()[i] = var_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("DoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("DoubleStruct", false);
}

const TypeObject* GetCompleteDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("DoubleStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_double;
    cst_var_double.common().member_id(memberId++);
    cst_var_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_double.common().member_flags().IS_KEY(false);
    cst_var_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    cst_var_double.detail().name("var_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("DoubleStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("DoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("DoubleStruct", true);
}

const TypeIdentifier* GetLongDoubleStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("LongDoubleStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLongDoubleStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("LongDoubleStruct", complete);
}

const TypeObject* GetLongDoubleStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongDoubleStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLongDoubleStructObject();
    }
    //else
    return GetMinimalLongDoubleStructObject();
}

const TypeObject* GetMinimalLongDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongDoubleStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_longdouble;
    mst_var_longdouble.common().member_id(memberId++);
    mst_var_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_longdouble.common().member_flags().IS_KEY(false);
    mst_var_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    MD5 var_longdouble_hash("var_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_longdouble.detail().name_hash()[i] = var_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("LongDoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("LongDoubleStruct", false);
}

const TypeObject* GetCompleteLongDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongDoubleStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_longdouble;
    cst_var_longdouble.common().member_id(memberId++);
    cst_var_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_longdouble.common().member_flags().IS_KEY(false);
    cst_var_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    cst_var_longdouble.detail().name("var_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("LongDoubleStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("LongDoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("LongDoubleStruct", true);
}

const TypeIdentifier* GetBooleanStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("BooleanStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBooleanStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("BooleanStruct", complete);
}

const TypeObject* GetBooleanStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BooleanStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBooleanStructObject();
    }
    //else
    return GetMinimalBooleanStructObject();
}

const TypeObject* GetMinimalBooleanStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BooleanStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_boolean;
    mst_var_boolean.common().member_id(memberId++);
    mst_var_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_boolean.common().member_flags().IS_KEY(false);
    mst_var_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    MD5 var_boolean_hash("var_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_boolean.detail().name_hash()[i] = var_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BooleanStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BooleanStruct", false);
}

const TypeObject* GetCompleteBooleanStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BooleanStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_boolean;
    cst_var_boolean.common().member_id(memberId++);
    cst_var_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_boolean.common().member_flags().IS_KEY(false);
    cst_var_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    cst_var_boolean.detail().name("var_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BooleanStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BooleanStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BooleanStruct", true);
}

const TypeIdentifier* GetOctetStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("OctetStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetOctetStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("OctetStruct", complete);
}

const TypeObject* GetOctetStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("OctetStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteOctetStructObject();
    }
    //else
    return GetMinimalOctetStructObject();
}

const TypeObject* GetMinimalOctetStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("OctetStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_octet;
    mst_var_octet.common().member_id(memberId++);
    mst_var_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_octet.common().member_flags().IS_KEY(false);
    mst_var_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 var_octet_hash("var_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_octet.detail().name_hash()[i] = var_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("OctetStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("OctetStruct", false);
}

const TypeObject* GetCompleteOctetStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("OctetStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_octet;
    cst_var_octet.common().member_id(memberId++);
    cst_var_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_octet.common().member_flags().IS_KEY(false);
    cst_var_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_var_octet.detail().name("var_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("OctetStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("OctetStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("OctetStruct", true);
}

const TypeIdentifier* GetCharStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("CharStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetCharStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("CharStruct", complete);
}

const TypeObject* GetCharStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CharStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteCharStructObject();
    }
    //else
    return GetMinimalCharStructObject();
}

const TypeObject* GetMinimalCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CharStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_char8;
    mst_var_char8.common().member_id(memberId++);
    mst_var_char8.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_char8.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_char8.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_char8.common().member_flags().IS_OPTIONAL(false);
    mst_var_char8.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_char8.common().member_flags().IS_KEY(false);
    mst_var_char8.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_char8.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    MD5 var_char8_hash("var_char8");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_char8.detail().name_hash()[i] = var_char8_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_char8);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("CharStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("CharStruct", false);
}

const TypeObject* GetCompleteCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("CharStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_char8;
    cst_var_char8.common().member_id(memberId++);
    cst_var_char8.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_char8.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_char8.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_char8.common().member_flags().IS_OPTIONAL(false);
    cst_var_char8.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_char8.common().member_flags().IS_KEY(false);
    cst_var_char8.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_char8.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    cst_var_char8.detail().name("var_char8");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_char8);


    // Header
    type_object->complete().struct_type().header().detail().type_name("CharStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("CharStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("CharStruct", true);
}

const TypeIdentifier* GetWCharStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("WCharStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetWCharStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("WCharStruct", complete);
}

const TypeObject* GetWCharStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("WCharStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteWCharStructObject();
    }
    //else
    return GetMinimalWCharStructObject();
}

const TypeObject* GetMinimalWCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("WCharStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_char16;
    mst_var_char16.common().member_id(memberId++);
    mst_var_char16.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_char16.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_char16.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_char16.common().member_flags().IS_OPTIONAL(false);
    mst_var_char16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_char16.common().member_flags().IS_KEY(false);
    mst_var_char16.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_char16.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    MD5 var_char16_hash("var_char16");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_char16.detail().name_hash()[i] = var_char16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_char16);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("WCharStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("WCharStruct", false);
}

const TypeObject* GetCompleteWCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("WCharStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_char16;
    cst_var_char16.common().member_id(memberId++);
    cst_var_char16.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_char16.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_char16.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_char16.common().member_flags().IS_OPTIONAL(false);
    cst_var_char16.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_char16.common().member_flags().IS_KEY(false);
    cst_var_char16.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_char16.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    cst_var_char16.detail().name("var_char16");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_char16);


    // Header
    type_object->complete().struct_type().header().detail().type_name("WCharStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("WCharStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("WCharStruct", true);
}
