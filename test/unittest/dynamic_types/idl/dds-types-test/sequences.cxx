// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file sequences.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "sequences.h"
#include "sequencesTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define InnerStructureHelper_max_cdr_typesize 8ULL;
#define SequenceLongDouble_max_cdr_typesize 1608ULL;
#define SequenceBitset_max_cdr_typesize 804ULL;
#define SequenceStructure_max_cdr_typesize 804ULL;
#define SequenceShortArray_max_cdr_typesize 404ULL;
#define SequenceLongLong_max_cdr_typesize 808ULL;
#define SequenceAlias_max_cdr_typesize 404ULL;
#define SequenceLong_max_cdr_typesize 404ULL;
#define SequenceStringBounded_max_cdr_typesize 1603ULL;
#define SequenceMap_max_cdr_typesize 80404ULL;
#define SequenceBoolean_max_cdr_typesize 104ULL;
#define SequenceWStringBounded_max_cdr_typesize 4404ULL;
#define BoundedBigSequences_max_cdr_typesize 83854ULL;
#define SequenceString_max_cdr_typesize 26004ULL;

#define SequenceShort_max_cdr_typesize 204ULL;
#define SequenceDouble_max_cdr_typesize 808ULL;
#define InnerEmptyStructureHelper_max_cdr_typesize 0ULL;
#define BoundedSmallSequences_max_cdr_typesize 6ULL;
#define SequenceBitMask_max_cdr_typesize 404ULL;

#define SequenceUShort_max_cdr_typesize 204ULL;
#define SequenceEnum_max_cdr_typesize 404ULL;

#define SequenceOctet_max_cdr_typesize 104ULL;
#define SequenceWChar_max_cdr_typesize 404ULL;
#define SequenceSequence_max_cdr_typesize 20404ULL;



#define SequenceUnion_max_cdr_typesize 804ULL;
#define SequenceULong_max_cdr_typesize 404ULL;


#define SequenceULongLong_max_cdr_typesize 808ULL;
#define SequenceFloat_max_cdr_typesize 404ULL;
#define SequenceWString_max_cdr_typesize 102404ULL;


#define SequenceChar_max_cdr_typesize 104ULL;
#define InnerStructureHelper_max_key_cdr_typesize 0ULL;
#define SequenceLongDouble_max_key_cdr_typesize 0ULL;
#define SequenceBitset_max_key_cdr_typesize 0ULL;
#define SequenceStructure_max_key_cdr_typesize 0ULL;
#define SequenceShortArray_max_key_cdr_typesize 0ULL;
#define SequenceLongLong_max_key_cdr_typesize 0ULL;
#define SequenceAlias_max_key_cdr_typesize 0ULL;
#define SequenceLong_max_key_cdr_typesize 0ULL;
#define SequenceStringBounded_max_key_cdr_typesize 0ULL;
#define SequenceMap_max_key_cdr_typesize 0ULL;
#define SequenceBoolean_max_key_cdr_typesize 0ULL;
#define SequenceWStringBounded_max_key_cdr_typesize 0ULL;
#define BoundedBigSequences_max_key_cdr_typesize 0ULL;
#define SequenceString_max_key_cdr_typesize 0ULL;

#define SequenceShort_max_key_cdr_typesize 0ULL;
#define SequenceDouble_max_key_cdr_typesize 0ULL;
#define InnerEmptyStructureHelper_max_key_cdr_typesize 0ULL;
#define BoundedSmallSequences_max_key_cdr_typesize 0ULL;
#define SequenceBitMask_max_key_cdr_typesize 0ULL;

#define SequenceUShort_max_key_cdr_typesize 0ULL;
#define SequenceEnum_max_key_cdr_typesize 0ULL;

#define SequenceOctet_max_key_cdr_typesize 0ULL;
#define SequenceWChar_max_key_cdr_typesize 0ULL;
#define SequenceSequence_max_key_cdr_typesize 0ULL;



#define SequenceUnion_max_key_cdr_typesize 0ULL;
#define SequenceULong_max_key_cdr_typesize 0ULL;


#define SequenceULongLong_max_key_cdr_typesize 0ULL;
#define SequenceFloat_max_key_cdr_typesize 0ULL;
#define SequenceWString_max_key_cdr_typesize 0ULL;


#define SequenceChar_max_key_cdr_typesize 0ULL;

SequenceShort::SequenceShort()
{
    // sequence<short> m_var_sequence_short


    // Just to register all known types
    registersequencesTypes();
}

SequenceShort::~SequenceShort()
{
}

SequenceShort::SequenceShort(
        const SequenceShort& x)
{
    m_var_sequence_short = x.m_var_sequence_short;
}

SequenceShort::SequenceShort(
        SequenceShort&& x) noexcept 
{
    m_var_sequence_short = std::move(x.m_var_sequence_short);
}

SequenceShort& SequenceShort::operator =(
        const SequenceShort& x)
{

    m_var_sequence_short = x.m_var_sequence_short;

    return *this;
}

SequenceShort& SequenceShort::operator =(
        SequenceShort&& x) noexcept
{

    m_var_sequence_short = std::move(x.m_var_sequence_short);

    return *this;
}

bool SequenceShort::operator ==(
        const SequenceShort& x) const
{

    return (m_var_sequence_short == x.m_var_sequence_short);
}

bool SequenceShort::operator !=(
        const SequenceShort& x) const
{
    return !(*this == x);
}

size_t SequenceShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceShort_max_cdr_typesize;
}

size_t SequenceShort::getCdrSerializedSize(
        const SequenceShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_short().size() > 0)
    {
        current_alignment += (data.var_sequence_short().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }



    return current_alignment - initial_alignment;
}

void SequenceShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_short;
}

void SequenceShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_short;}

/*!
 * @brief This function copies the value in member var_sequence_short
 * @param _var_sequence_short New value to be copied in member var_sequence_short
 */
void SequenceShort::var_sequence_short(
        const std::vector<int16_t>& _var_sequence_short)
{
    m_var_sequence_short = _var_sequence_short;
}

/*!
 * @brief This function moves the value in member var_sequence_short
 * @param _var_sequence_short New value to be moved in member var_sequence_short
 */
void SequenceShort::var_sequence_short(
        std::vector<int16_t>&& _var_sequence_short)
{
    m_var_sequence_short = std::move(_var_sequence_short);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_short
 * @return Constant reference to member var_sequence_short
 */
const std::vector<int16_t>& SequenceShort::var_sequence_short() const
{
    return m_var_sequence_short;
}

/*!
 * @brief This function returns a reference to member var_sequence_short
 * @return Reference to member var_sequence_short
 */
std::vector<int16_t>& SequenceShort::var_sequence_short()
{
    return m_var_sequence_short;
}


size_t SequenceShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceShort_max_key_cdr_typesize;
}

bool SequenceShort::isKeyDefined()
{
    return false;
}

void SequenceShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceUShort::SequenceUShort()
{
    // sequence<unsigned short> m_var_sequence_ushort


    // Just to register all known types
    registersequencesTypes();
}

SequenceUShort::~SequenceUShort()
{
}

SequenceUShort::SequenceUShort(
        const SequenceUShort& x)
{
    m_var_sequence_ushort = x.m_var_sequence_ushort;
}

SequenceUShort::SequenceUShort(
        SequenceUShort&& x) noexcept 
{
    m_var_sequence_ushort = std::move(x.m_var_sequence_ushort);
}

SequenceUShort& SequenceUShort::operator =(
        const SequenceUShort& x)
{

    m_var_sequence_ushort = x.m_var_sequence_ushort;

    return *this;
}

SequenceUShort& SequenceUShort::operator =(
        SequenceUShort&& x) noexcept
{

    m_var_sequence_ushort = std::move(x.m_var_sequence_ushort);

    return *this;
}

bool SequenceUShort::operator ==(
        const SequenceUShort& x) const
{

    return (m_var_sequence_ushort == x.m_var_sequence_ushort);
}

bool SequenceUShort::operator !=(
        const SequenceUShort& x) const
{
    return !(*this == x);
}

size_t SequenceUShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceUShort_max_cdr_typesize;
}

size_t SequenceUShort::getCdrSerializedSize(
        const SequenceUShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_ushort().size() > 0)
    {
        current_alignment += (data.var_sequence_ushort().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }



    return current_alignment - initial_alignment;
}

void SequenceUShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_ushort;
}

void SequenceUShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_ushort;}

/*!
 * @brief This function copies the value in member var_sequence_ushort
 * @param _var_sequence_ushort New value to be copied in member var_sequence_ushort
 */
void SequenceUShort::var_sequence_ushort(
        const std::vector<uint16_t>& _var_sequence_ushort)
{
    m_var_sequence_ushort = _var_sequence_ushort;
}

/*!
 * @brief This function moves the value in member var_sequence_ushort
 * @param _var_sequence_ushort New value to be moved in member var_sequence_ushort
 */
void SequenceUShort::var_sequence_ushort(
        std::vector<uint16_t>&& _var_sequence_ushort)
{
    m_var_sequence_ushort = std::move(_var_sequence_ushort);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_ushort
 * @return Constant reference to member var_sequence_ushort
 */
const std::vector<uint16_t>& SequenceUShort::var_sequence_ushort() const
{
    return m_var_sequence_ushort;
}

/*!
 * @brief This function returns a reference to member var_sequence_ushort
 * @return Reference to member var_sequence_ushort
 */
std::vector<uint16_t>& SequenceUShort::var_sequence_ushort()
{
    return m_var_sequence_ushort;
}


size_t SequenceUShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceUShort_max_key_cdr_typesize;
}

bool SequenceUShort::isKeyDefined()
{
    return false;
}

void SequenceUShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceLong::SequenceLong()
{
    // sequence<long> m_var_sequence_long


    // Just to register all known types
    registersequencesTypes();
}

SequenceLong::~SequenceLong()
{
}

SequenceLong::SequenceLong(
        const SequenceLong& x)
{
    m_var_sequence_long = x.m_var_sequence_long;
}

SequenceLong::SequenceLong(
        SequenceLong&& x) noexcept 
{
    m_var_sequence_long = std::move(x.m_var_sequence_long);
}

SequenceLong& SequenceLong::operator =(
        const SequenceLong& x)
{

    m_var_sequence_long = x.m_var_sequence_long;

    return *this;
}

SequenceLong& SequenceLong::operator =(
        SequenceLong&& x) noexcept
{

    m_var_sequence_long = std::move(x.m_var_sequence_long);

    return *this;
}

bool SequenceLong::operator ==(
        const SequenceLong& x) const
{

    return (m_var_sequence_long == x.m_var_sequence_long);
}

bool SequenceLong::operator !=(
        const SequenceLong& x) const
{
    return !(*this == x);
}

size_t SequenceLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceLong_max_cdr_typesize;
}

size_t SequenceLong::getCdrSerializedSize(
        const SequenceLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_long().size() > 0)
    {
        current_alignment += (data.var_sequence_long().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    return current_alignment - initial_alignment;
}

void SequenceLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_long;
}

void SequenceLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_long;}

/*!
 * @brief This function copies the value in member var_sequence_long
 * @param _var_sequence_long New value to be copied in member var_sequence_long
 */
void SequenceLong::var_sequence_long(
        const std::vector<int32_t>& _var_sequence_long)
{
    m_var_sequence_long = _var_sequence_long;
}

/*!
 * @brief This function moves the value in member var_sequence_long
 * @param _var_sequence_long New value to be moved in member var_sequence_long
 */
void SequenceLong::var_sequence_long(
        std::vector<int32_t>&& _var_sequence_long)
{
    m_var_sequence_long = std::move(_var_sequence_long);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_long
 * @return Constant reference to member var_sequence_long
 */
const std::vector<int32_t>& SequenceLong::var_sequence_long() const
{
    return m_var_sequence_long;
}

/*!
 * @brief This function returns a reference to member var_sequence_long
 * @return Reference to member var_sequence_long
 */
std::vector<int32_t>& SequenceLong::var_sequence_long()
{
    return m_var_sequence_long;
}


size_t SequenceLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceLong_max_key_cdr_typesize;
}

bool SequenceLong::isKeyDefined()
{
    return false;
}

void SequenceLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceULong::SequenceULong()
{
    // sequence<unsigned long> m_var_sequence_ulong


    // Just to register all known types
    registersequencesTypes();
}

SequenceULong::~SequenceULong()
{
}

SequenceULong::SequenceULong(
        const SequenceULong& x)
{
    m_var_sequence_ulong = x.m_var_sequence_ulong;
}

SequenceULong::SequenceULong(
        SequenceULong&& x) noexcept 
{
    m_var_sequence_ulong = std::move(x.m_var_sequence_ulong);
}

SequenceULong& SequenceULong::operator =(
        const SequenceULong& x)
{

    m_var_sequence_ulong = x.m_var_sequence_ulong;

    return *this;
}

SequenceULong& SequenceULong::operator =(
        SequenceULong&& x) noexcept
{

    m_var_sequence_ulong = std::move(x.m_var_sequence_ulong);

    return *this;
}

bool SequenceULong::operator ==(
        const SequenceULong& x) const
{

    return (m_var_sequence_ulong == x.m_var_sequence_ulong);
}

bool SequenceULong::operator !=(
        const SequenceULong& x) const
{
    return !(*this == x);
}

size_t SequenceULong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceULong_max_cdr_typesize;
}

size_t SequenceULong::getCdrSerializedSize(
        const SequenceULong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_ulong().size() > 0)
    {
        current_alignment += (data.var_sequence_ulong().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    return current_alignment - initial_alignment;
}

void SequenceULong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_ulong;
}

void SequenceULong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_ulong;}

/*!
 * @brief This function copies the value in member var_sequence_ulong
 * @param _var_sequence_ulong New value to be copied in member var_sequence_ulong
 */
void SequenceULong::var_sequence_ulong(
        const std::vector<uint32_t>& _var_sequence_ulong)
{
    m_var_sequence_ulong = _var_sequence_ulong;
}

/*!
 * @brief This function moves the value in member var_sequence_ulong
 * @param _var_sequence_ulong New value to be moved in member var_sequence_ulong
 */
void SequenceULong::var_sequence_ulong(
        std::vector<uint32_t>&& _var_sequence_ulong)
{
    m_var_sequence_ulong = std::move(_var_sequence_ulong);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_ulong
 * @return Constant reference to member var_sequence_ulong
 */
const std::vector<uint32_t>& SequenceULong::var_sequence_ulong() const
{
    return m_var_sequence_ulong;
}

/*!
 * @brief This function returns a reference to member var_sequence_ulong
 * @return Reference to member var_sequence_ulong
 */
std::vector<uint32_t>& SequenceULong::var_sequence_ulong()
{
    return m_var_sequence_ulong;
}


size_t SequenceULong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceULong_max_key_cdr_typesize;
}

bool SequenceULong::isKeyDefined()
{
    return false;
}

void SequenceULong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceLongLong::SequenceLongLong()
{
    // sequence<long long> m_var_sequence_longlong


    // Just to register all known types
    registersequencesTypes();
}

SequenceLongLong::~SequenceLongLong()
{
}

SequenceLongLong::SequenceLongLong(
        const SequenceLongLong& x)
{
    m_var_sequence_longlong = x.m_var_sequence_longlong;
}

SequenceLongLong::SequenceLongLong(
        SequenceLongLong&& x) noexcept 
{
    m_var_sequence_longlong = std::move(x.m_var_sequence_longlong);
}

SequenceLongLong& SequenceLongLong::operator =(
        const SequenceLongLong& x)
{

    m_var_sequence_longlong = x.m_var_sequence_longlong;

    return *this;
}

SequenceLongLong& SequenceLongLong::operator =(
        SequenceLongLong&& x) noexcept
{

    m_var_sequence_longlong = std::move(x.m_var_sequence_longlong);

    return *this;
}

bool SequenceLongLong::operator ==(
        const SequenceLongLong& x) const
{

    return (m_var_sequence_longlong == x.m_var_sequence_longlong);
}

bool SequenceLongLong::operator !=(
        const SequenceLongLong& x) const
{
    return !(*this == x);
}

size_t SequenceLongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceLongLong_max_cdr_typesize;
}

size_t SequenceLongLong::getCdrSerializedSize(
        const SequenceLongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_longlong().size() > 0)
    {
        current_alignment += (data.var_sequence_longlong().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }



    return current_alignment - initial_alignment;
}

void SequenceLongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_longlong;
}

void SequenceLongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_longlong;}

/*!
 * @brief This function copies the value in member var_sequence_longlong
 * @param _var_sequence_longlong New value to be copied in member var_sequence_longlong
 */
void SequenceLongLong::var_sequence_longlong(
        const std::vector<int64_t>& _var_sequence_longlong)
{
    m_var_sequence_longlong = _var_sequence_longlong;
}

/*!
 * @brief This function moves the value in member var_sequence_longlong
 * @param _var_sequence_longlong New value to be moved in member var_sequence_longlong
 */
void SequenceLongLong::var_sequence_longlong(
        std::vector<int64_t>&& _var_sequence_longlong)
{
    m_var_sequence_longlong = std::move(_var_sequence_longlong);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_longlong
 * @return Constant reference to member var_sequence_longlong
 */
const std::vector<int64_t>& SequenceLongLong::var_sequence_longlong() const
{
    return m_var_sequence_longlong;
}

/*!
 * @brief This function returns a reference to member var_sequence_longlong
 * @return Reference to member var_sequence_longlong
 */
std::vector<int64_t>& SequenceLongLong::var_sequence_longlong()
{
    return m_var_sequence_longlong;
}


size_t SequenceLongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceLongLong_max_key_cdr_typesize;
}

bool SequenceLongLong::isKeyDefined()
{
    return false;
}

void SequenceLongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceULongLong::SequenceULongLong()
{
    // sequence<unsigned long long> m_var_sequence_ulonglong


    // Just to register all known types
    registersequencesTypes();
}

SequenceULongLong::~SequenceULongLong()
{
}

SequenceULongLong::SequenceULongLong(
        const SequenceULongLong& x)
{
    m_var_sequence_ulonglong = x.m_var_sequence_ulonglong;
}

SequenceULongLong::SequenceULongLong(
        SequenceULongLong&& x) noexcept 
{
    m_var_sequence_ulonglong = std::move(x.m_var_sequence_ulonglong);
}

SequenceULongLong& SequenceULongLong::operator =(
        const SequenceULongLong& x)
{

    m_var_sequence_ulonglong = x.m_var_sequence_ulonglong;

    return *this;
}

SequenceULongLong& SequenceULongLong::operator =(
        SequenceULongLong&& x) noexcept
{

    m_var_sequence_ulonglong = std::move(x.m_var_sequence_ulonglong);

    return *this;
}

bool SequenceULongLong::operator ==(
        const SequenceULongLong& x) const
{

    return (m_var_sequence_ulonglong == x.m_var_sequence_ulonglong);
}

bool SequenceULongLong::operator !=(
        const SequenceULongLong& x) const
{
    return !(*this == x);
}

size_t SequenceULongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceULongLong_max_cdr_typesize;
}

size_t SequenceULongLong::getCdrSerializedSize(
        const SequenceULongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_ulonglong().size() > 0)
    {
        current_alignment += (data.var_sequence_ulonglong().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }



    return current_alignment - initial_alignment;
}

void SequenceULongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_ulonglong;
}

void SequenceULongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_ulonglong;}

/*!
 * @brief This function copies the value in member var_sequence_ulonglong
 * @param _var_sequence_ulonglong New value to be copied in member var_sequence_ulonglong
 */
void SequenceULongLong::var_sequence_ulonglong(
        const std::vector<uint64_t>& _var_sequence_ulonglong)
{
    m_var_sequence_ulonglong = _var_sequence_ulonglong;
}

/*!
 * @brief This function moves the value in member var_sequence_ulonglong
 * @param _var_sequence_ulonglong New value to be moved in member var_sequence_ulonglong
 */
void SequenceULongLong::var_sequence_ulonglong(
        std::vector<uint64_t>&& _var_sequence_ulonglong)
{
    m_var_sequence_ulonglong = std::move(_var_sequence_ulonglong);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_ulonglong
 * @return Constant reference to member var_sequence_ulonglong
 */
const std::vector<uint64_t>& SequenceULongLong::var_sequence_ulonglong() const
{
    return m_var_sequence_ulonglong;
}

/*!
 * @brief This function returns a reference to member var_sequence_ulonglong
 * @return Reference to member var_sequence_ulonglong
 */
std::vector<uint64_t>& SequenceULongLong::var_sequence_ulonglong()
{
    return m_var_sequence_ulonglong;
}


size_t SequenceULongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceULongLong_max_key_cdr_typesize;
}

bool SequenceULongLong::isKeyDefined()
{
    return false;
}

void SequenceULongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceFloat::SequenceFloat()
{
    // sequence<float> m_var_sequence_float


    // Just to register all known types
    registersequencesTypes();
}

SequenceFloat::~SequenceFloat()
{
}

SequenceFloat::SequenceFloat(
        const SequenceFloat& x)
{
    m_var_sequence_float = x.m_var_sequence_float;
}

SequenceFloat::SequenceFloat(
        SequenceFloat&& x) noexcept 
{
    m_var_sequence_float = std::move(x.m_var_sequence_float);
}

SequenceFloat& SequenceFloat::operator =(
        const SequenceFloat& x)
{

    m_var_sequence_float = x.m_var_sequence_float;

    return *this;
}

SequenceFloat& SequenceFloat::operator =(
        SequenceFloat&& x) noexcept
{

    m_var_sequence_float = std::move(x.m_var_sequence_float);

    return *this;
}

bool SequenceFloat::operator ==(
        const SequenceFloat& x) const
{

    return (m_var_sequence_float == x.m_var_sequence_float);
}

bool SequenceFloat::operator !=(
        const SequenceFloat& x) const
{
    return !(*this == x);
}

size_t SequenceFloat::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceFloat_max_cdr_typesize;
}

size_t SequenceFloat::getCdrSerializedSize(
        const SequenceFloat& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_float().size() > 0)
    {
        current_alignment += (data.var_sequence_float().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    return current_alignment - initial_alignment;
}

void SequenceFloat::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_float;
}

void SequenceFloat::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_float;}

/*!
 * @brief This function copies the value in member var_sequence_float
 * @param _var_sequence_float New value to be copied in member var_sequence_float
 */
void SequenceFloat::var_sequence_float(
        const std::vector<float>& _var_sequence_float)
{
    m_var_sequence_float = _var_sequence_float;
}

/*!
 * @brief This function moves the value in member var_sequence_float
 * @param _var_sequence_float New value to be moved in member var_sequence_float
 */
void SequenceFloat::var_sequence_float(
        std::vector<float>&& _var_sequence_float)
{
    m_var_sequence_float = std::move(_var_sequence_float);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_float
 * @return Constant reference to member var_sequence_float
 */
const std::vector<float>& SequenceFloat::var_sequence_float() const
{
    return m_var_sequence_float;
}

/*!
 * @brief This function returns a reference to member var_sequence_float
 * @return Reference to member var_sequence_float
 */
std::vector<float>& SequenceFloat::var_sequence_float()
{
    return m_var_sequence_float;
}


size_t SequenceFloat::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceFloat_max_key_cdr_typesize;
}

bool SequenceFloat::isKeyDefined()
{
    return false;
}

void SequenceFloat::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceDouble::SequenceDouble()
{
    // sequence<double> m_var_sequence_double


    // Just to register all known types
    registersequencesTypes();
}

SequenceDouble::~SequenceDouble()
{
}

SequenceDouble::SequenceDouble(
        const SequenceDouble& x)
{
    m_var_sequence_double = x.m_var_sequence_double;
}

SequenceDouble::SequenceDouble(
        SequenceDouble&& x) noexcept 
{
    m_var_sequence_double = std::move(x.m_var_sequence_double);
}

SequenceDouble& SequenceDouble::operator =(
        const SequenceDouble& x)
{

    m_var_sequence_double = x.m_var_sequence_double;

    return *this;
}

SequenceDouble& SequenceDouble::operator =(
        SequenceDouble&& x) noexcept
{

    m_var_sequence_double = std::move(x.m_var_sequence_double);

    return *this;
}

bool SequenceDouble::operator ==(
        const SequenceDouble& x) const
{

    return (m_var_sequence_double == x.m_var_sequence_double);
}

bool SequenceDouble::operator !=(
        const SequenceDouble& x) const
{
    return !(*this == x);
}

size_t SequenceDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceDouble_max_cdr_typesize;
}

size_t SequenceDouble::getCdrSerializedSize(
        const SequenceDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_double().size() > 0)
    {
        current_alignment += (data.var_sequence_double().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }



    return current_alignment - initial_alignment;
}

void SequenceDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_double;
}

void SequenceDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_double;}

/*!
 * @brief This function copies the value in member var_sequence_double
 * @param _var_sequence_double New value to be copied in member var_sequence_double
 */
void SequenceDouble::var_sequence_double(
        const std::vector<double>& _var_sequence_double)
{
    m_var_sequence_double = _var_sequence_double;
}

/*!
 * @brief This function moves the value in member var_sequence_double
 * @param _var_sequence_double New value to be moved in member var_sequence_double
 */
void SequenceDouble::var_sequence_double(
        std::vector<double>&& _var_sequence_double)
{
    m_var_sequence_double = std::move(_var_sequence_double);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_double
 * @return Constant reference to member var_sequence_double
 */
const std::vector<double>& SequenceDouble::var_sequence_double() const
{
    return m_var_sequence_double;
}

/*!
 * @brief This function returns a reference to member var_sequence_double
 * @return Reference to member var_sequence_double
 */
std::vector<double>& SequenceDouble::var_sequence_double()
{
    return m_var_sequence_double;
}


size_t SequenceDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceDouble_max_key_cdr_typesize;
}

bool SequenceDouble::isKeyDefined()
{
    return false;
}

void SequenceDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceLongDouble::SequenceLongDouble()
{
    // sequence<long double> m_var_sequence_longdouble


    // Just to register all known types
    registersequencesTypes();
}

SequenceLongDouble::~SequenceLongDouble()
{
}

SequenceLongDouble::SequenceLongDouble(
        const SequenceLongDouble& x)
{
    m_var_sequence_longdouble = x.m_var_sequence_longdouble;
}

SequenceLongDouble::SequenceLongDouble(
        SequenceLongDouble&& x) noexcept 
{
    m_var_sequence_longdouble = std::move(x.m_var_sequence_longdouble);
}

SequenceLongDouble& SequenceLongDouble::operator =(
        const SequenceLongDouble& x)
{

    m_var_sequence_longdouble = x.m_var_sequence_longdouble;

    return *this;
}

SequenceLongDouble& SequenceLongDouble::operator =(
        SequenceLongDouble&& x) noexcept
{

    m_var_sequence_longdouble = std::move(x.m_var_sequence_longdouble);

    return *this;
}

bool SequenceLongDouble::operator ==(
        const SequenceLongDouble& x) const
{

    return (m_var_sequence_longdouble == x.m_var_sequence_longdouble);
}

bool SequenceLongDouble::operator !=(
        const SequenceLongDouble& x) const
{
    return !(*this == x);
}

size_t SequenceLongDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceLongDouble_max_cdr_typesize;
}

size_t SequenceLongDouble::getCdrSerializedSize(
        const SequenceLongDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_longdouble().size() > 0)
    {
        current_alignment += (data.var_sequence_longdouble().size() * 16) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8); // 128 bits, but aligned as 64
    }



    return current_alignment - initial_alignment;
}

void SequenceLongDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_longdouble;
}

void SequenceLongDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_longdouble;}

/*!
 * @brief This function copies the value in member var_sequence_longdouble
 * @param _var_sequence_longdouble New value to be copied in member var_sequence_longdouble
 */
void SequenceLongDouble::var_sequence_longdouble(
        const std::vector<long double>& _var_sequence_longdouble)
{
    m_var_sequence_longdouble = _var_sequence_longdouble;
}

/*!
 * @brief This function moves the value in member var_sequence_longdouble
 * @param _var_sequence_longdouble New value to be moved in member var_sequence_longdouble
 */
void SequenceLongDouble::var_sequence_longdouble(
        std::vector<long double>&& _var_sequence_longdouble)
{
    m_var_sequence_longdouble = std::move(_var_sequence_longdouble);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_longdouble
 * @return Constant reference to member var_sequence_longdouble
 */
const std::vector<long double>& SequenceLongDouble::var_sequence_longdouble() const
{
    return m_var_sequence_longdouble;
}

/*!
 * @brief This function returns a reference to member var_sequence_longdouble
 * @return Reference to member var_sequence_longdouble
 */
std::vector<long double>& SequenceLongDouble::var_sequence_longdouble()
{
    return m_var_sequence_longdouble;
}


size_t SequenceLongDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceLongDouble_max_key_cdr_typesize;
}

bool SequenceLongDouble::isKeyDefined()
{
    return false;
}

void SequenceLongDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceBoolean::SequenceBoolean()
{
    // sequence<boolean> m_var_sequence_boolean


    // Just to register all known types
    registersequencesTypes();
}

SequenceBoolean::~SequenceBoolean()
{
}

SequenceBoolean::SequenceBoolean(
        const SequenceBoolean& x)
{
    m_var_sequence_boolean = x.m_var_sequence_boolean;
}

SequenceBoolean::SequenceBoolean(
        SequenceBoolean&& x) noexcept 
{
    m_var_sequence_boolean = std::move(x.m_var_sequence_boolean);
}

SequenceBoolean& SequenceBoolean::operator =(
        const SequenceBoolean& x)
{

    m_var_sequence_boolean = x.m_var_sequence_boolean;

    return *this;
}

SequenceBoolean& SequenceBoolean::operator =(
        SequenceBoolean&& x) noexcept
{

    m_var_sequence_boolean = std::move(x.m_var_sequence_boolean);

    return *this;
}

bool SequenceBoolean::operator ==(
        const SequenceBoolean& x) const
{

    return (m_var_sequence_boolean == x.m_var_sequence_boolean);
}

bool SequenceBoolean::operator !=(
        const SequenceBoolean& x) const
{
    return !(*this == x);
}

size_t SequenceBoolean::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceBoolean_max_cdr_typesize;
}

size_t SequenceBoolean::getCdrSerializedSize(
        const SequenceBoolean& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_boolean().size() > 0)
    {
        current_alignment += (data.var_sequence_boolean().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }



    return current_alignment - initial_alignment;
}

void SequenceBoolean::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_boolean;
}

void SequenceBoolean::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_boolean;}

/*!
 * @brief This function copies the value in member var_sequence_boolean
 * @param _var_sequence_boolean New value to be copied in member var_sequence_boolean
 */
void SequenceBoolean::var_sequence_boolean(
        const std::vector<bool>& _var_sequence_boolean)
{
    m_var_sequence_boolean = _var_sequence_boolean;
}

/*!
 * @brief This function moves the value in member var_sequence_boolean
 * @param _var_sequence_boolean New value to be moved in member var_sequence_boolean
 */
void SequenceBoolean::var_sequence_boolean(
        std::vector<bool>&& _var_sequence_boolean)
{
    m_var_sequence_boolean = std::move(_var_sequence_boolean);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_boolean
 * @return Constant reference to member var_sequence_boolean
 */
const std::vector<bool>& SequenceBoolean::var_sequence_boolean() const
{
    return m_var_sequence_boolean;
}

/*!
 * @brief This function returns a reference to member var_sequence_boolean
 * @return Reference to member var_sequence_boolean
 */
std::vector<bool>& SequenceBoolean::var_sequence_boolean()
{
    return m_var_sequence_boolean;
}


size_t SequenceBoolean::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceBoolean_max_key_cdr_typesize;
}

bool SequenceBoolean::isKeyDefined()
{
    return false;
}

void SequenceBoolean::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceOctet::SequenceOctet()
{
    // sequence<octet> m_var_sequence_octet


    // Just to register all known types
    registersequencesTypes();
}

SequenceOctet::~SequenceOctet()
{
}

SequenceOctet::SequenceOctet(
        const SequenceOctet& x)
{
    m_var_sequence_octet = x.m_var_sequence_octet;
}

SequenceOctet::SequenceOctet(
        SequenceOctet&& x) noexcept 
{
    m_var_sequence_octet = std::move(x.m_var_sequence_octet);
}

SequenceOctet& SequenceOctet::operator =(
        const SequenceOctet& x)
{

    m_var_sequence_octet = x.m_var_sequence_octet;

    return *this;
}

SequenceOctet& SequenceOctet::operator =(
        SequenceOctet&& x) noexcept
{

    m_var_sequence_octet = std::move(x.m_var_sequence_octet);

    return *this;
}

bool SequenceOctet::operator ==(
        const SequenceOctet& x) const
{

    return (m_var_sequence_octet == x.m_var_sequence_octet);
}

bool SequenceOctet::operator !=(
        const SequenceOctet& x) const
{
    return !(*this == x);
}

size_t SequenceOctet::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceOctet_max_cdr_typesize;
}

size_t SequenceOctet::getCdrSerializedSize(
        const SequenceOctet& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_octet().size() > 0)
    {
        current_alignment += (data.var_sequence_octet().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }



    return current_alignment - initial_alignment;
}

void SequenceOctet::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_octet;
}

void SequenceOctet::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_octet;}

/*!
 * @brief This function copies the value in member var_sequence_octet
 * @param _var_sequence_octet New value to be copied in member var_sequence_octet
 */
void SequenceOctet::var_sequence_octet(
        const std::vector<uint8_t>& _var_sequence_octet)
{
    m_var_sequence_octet = _var_sequence_octet;
}

/*!
 * @brief This function moves the value in member var_sequence_octet
 * @param _var_sequence_octet New value to be moved in member var_sequence_octet
 */
void SequenceOctet::var_sequence_octet(
        std::vector<uint8_t>&& _var_sequence_octet)
{
    m_var_sequence_octet = std::move(_var_sequence_octet);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_octet
 * @return Constant reference to member var_sequence_octet
 */
const std::vector<uint8_t>& SequenceOctet::var_sequence_octet() const
{
    return m_var_sequence_octet;
}

/*!
 * @brief This function returns a reference to member var_sequence_octet
 * @return Reference to member var_sequence_octet
 */
std::vector<uint8_t>& SequenceOctet::var_sequence_octet()
{
    return m_var_sequence_octet;
}


size_t SequenceOctet::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceOctet_max_key_cdr_typesize;
}

bool SequenceOctet::isKeyDefined()
{
    return false;
}

void SequenceOctet::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceChar::SequenceChar()
{
    // sequence<char> m_var_sequence_char


    // Just to register all known types
    registersequencesTypes();
}

SequenceChar::~SequenceChar()
{
}

SequenceChar::SequenceChar(
        const SequenceChar& x)
{
    m_var_sequence_char = x.m_var_sequence_char;
}

SequenceChar::SequenceChar(
        SequenceChar&& x) noexcept 
{
    m_var_sequence_char = std::move(x.m_var_sequence_char);
}

SequenceChar& SequenceChar::operator =(
        const SequenceChar& x)
{

    m_var_sequence_char = x.m_var_sequence_char;

    return *this;
}

SequenceChar& SequenceChar::operator =(
        SequenceChar&& x) noexcept
{

    m_var_sequence_char = std::move(x.m_var_sequence_char);

    return *this;
}

bool SequenceChar::operator ==(
        const SequenceChar& x) const
{

    return (m_var_sequence_char == x.m_var_sequence_char);
}

bool SequenceChar::operator !=(
        const SequenceChar& x) const
{
    return !(*this == x);
}

size_t SequenceChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceChar_max_cdr_typesize;
}

size_t SequenceChar::getCdrSerializedSize(
        const SequenceChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_char().size() > 0)
    {
        current_alignment += (data.var_sequence_char().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }



    return current_alignment - initial_alignment;
}

void SequenceChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_char;
}

void SequenceChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_char;}

/*!
 * @brief This function copies the value in member var_sequence_char
 * @param _var_sequence_char New value to be copied in member var_sequence_char
 */
void SequenceChar::var_sequence_char(
        const std::vector<char>& _var_sequence_char)
{
    m_var_sequence_char = _var_sequence_char;
}

/*!
 * @brief This function moves the value in member var_sequence_char
 * @param _var_sequence_char New value to be moved in member var_sequence_char
 */
void SequenceChar::var_sequence_char(
        std::vector<char>&& _var_sequence_char)
{
    m_var_sequence_char = std::move(_var_sequence_char);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_char
 * @return Constant reference to member var_sequence_char
 */
const std::vector<char>& SequenceChar::var_sequence_char() const
{
    return m_var_sequence_char;
}

/*!
 * @brief This function returns a reference to member var_sequence_char
 * @return Reference to member var_sequence_char
 */
std::vector<char>& SequenceChar::var_sequence_char()
{
    return m_var_sequence_char;
}


size_t SequenceChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceChar_max_key_cdr_typesize;
}

bool SequenceChar::isKeyDefined()
{
    return false;
}

void SequenceChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceWChar::SequenceWChar()
{
    // sequence<wchar> m_var_sequence_wchar


    // Just to register all known types
    registersequencesTypes();
}

SequenceWChar::~SequenceWChar()
{
}

SequenceWChar::SequenceWChar(
        const SequenceWChar& x)
{
    m_var_sequence_wchar = x.m_var_sequence_wchar;
}

SequenceWChar::SequenceWChar(
        SequenceWChar&& x) noexcept 
{
    m_var_sequence_wchar = std::move(x.m_var_sequence_wchar);
}

SequenceWChar& SequenceWChar::operator =(
        const SequenceWChar& x)
{

    m_var_sequence_wchar = x.m_var_sequence_wchar;

    return *this;
}

SequenceWChar& SequenceWChar::operator =(
        SequenceWChar&& x) noexcept
{

    m_var_sequence_wchar = std::move(x.m_var_sequence_wchar);

    return *this;
}

bool SequenceWChar::operator ==(
        const SequenceWChar& x) const
{

    return (m_var_sequence_wchar == x.m_var_sequence_wchar);
}

bool SequenceWChar::operator !=(
        const SequenceWChar& x) const
{
    return !(*this == x);
}

size_t SequenceWChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceWChar_max_cdr_typesize;
}

size_t SequenceWChar::getCdrSerializedSize(
        const SequenceWChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_wchar().size() > 0)
    {
        current_alignment += (data.var_sequence_wchar().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    return current_alignment - initial_alignment;
}

void SequenceWChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_wchar;
}

void SequenceWChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_wchar;}

/*!
 * @brief This function copies the value in member var_sequence_wchar
 * @param _var_sequence_wchar New value to be copied in member var_sequence_wchar
 */
void SequenceWChar::var_sequence_wchar(
        const std::vector<wchar_t>& _var_sequence_wchar)
{
    m_var_sequence_wchar = _var_sequence_wchar;
}

/*!
 * @brief This function moves the value in member var_sequence_wchar
 * @param _var_sequence_wchar New value to be moved in member var_sequence_wchar
 */
void SequenceWChar::var_sequence_wchar(
        std::vector<wchar_t>&& _var_sequence_wchar)
{
    m_var_sequence_wchar = std::move(_var_sequence_wchar);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_wchar
 * @return Constant reference to member var_sequence_wchar
 */
const std::vector<wchar_t>& SequenceWChar::var_sequence_wchar() const
{
    return m_var_sequence_wchar;
}

/*!
 * @brief This function returns a reference to member var_sequence_wchar
 * @return Reference to member var_sequence_wchar
 */
std::vector<wchar_t>& SequenceWChar::var_sequence_wchar()
{
    return m_var_sequence_wchar;
}


size_t SequenceWChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceWChar_max_key_cdr_typesize;
}

bool SequenceWChar::isKeyDefined()
{
    return false;
}

void SequenceWChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceString::SequenceString()
{
    // sequence<string> m_var_sequence_string


    // Just to register all known types
    registersequencesTypes();
}

SequenceString::~SequenceString()
{
}

SequenceString::SequenceString(
        const SequenceString& x)
{
    m_var_sequence_string = x.m_var_sequence_string;
}

SequenceString::SequenceString(
        SequenceString&& x) noexcept 
{
    m_var_sequence_string = std::move(x.m_var_sequence_string);
}

SequenceString& SequenceString::operator =(
        const SequenceString& x)
{

    m_var_sequence_string = x.m_var_sequence_string;

    return *this;
}

SequenceString& SequenceString::operator =(
        SequenceString&& x) noexcept
{

    m_var_sequence_string = std::move(x.m_var_sequence_string);

    return *this;
}

bool SequenceString::operator ==(
        const SequenceString& x) const
{

    return (m_var_sequence_string == x.m_var_sequence_string);
}

bool SequenceString::operator !=(
        const SequenceString& x) const
{
    return !(*this == x);
}

size_t SequenceString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceString_max_cdr_typesize;
}

size_t SequenceString::getCdrSerializedSize(
        const SequenceString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < data.var_sequence_string().size(); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) +
            data.var_sequence_string().at(a).size() + 1;
    }

    return current_alignment - initial_alignment;
}

void SequenceString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_string;}

void SequenceString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_string;}

/*!
 * @brief This function copies the value in member var_sequence_string
 * @param _var_sequence_string New value to be copied in member var_sequence_string
 */
void SequenceString::var_sequence_string(
        const std::vector<std::string>& _var_sequence_string)
{
    m_var_sequence_string = _var_sequence_string;
}

/*!
 * @brief This function moves the value in member var_sequence_string
 * @param _var_sequence_string New value to be moved in member var_sequence_string
 */
void SequenceString::var_sequence_string(
        std::vector<std::string>&& _var_sequence_string)
{
    m_var_sequence_string = std::move(_var_sequence_string);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_string
 * @return Constant reference to member var_sequence_string
 */
const std::vector<std::string>& SequenceString::var_sequence_string() const
{
    return m_var_sequence_string;
}

/*!
 * @brief This function returns a reference to member var_sequence_string
 * @return Reference to member var_sequence_string
 */
std::vector<std::string>& SequenceString::var_sequence_string()
{
    return m_var_sequence_string;
}


size_t SequenceString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceString_max_key_cdr_typesize;
}

bool SequenceString::isKeyDefined()
{
    return false;
}

void SequenceString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceWString::SequenceWString()
{
    // sequence<wstring> m_var_sequence_wstring


    // Just to register all known types
    registersequencesTypes();
}

SequenceWString::~SequenceWString()
{
}

SequenceWString::SequenceWString(
        const SequenceWString& x)
{
    m_var_sequence_wstring = x.m_var_sequence_wstring;
}

SequenceWString::SequenceWString(
        SequenceWString&& x) noexcept 
{
    m_var_sequence_wstring = std::move(x.m_var_sequence_wstring);
}

SequenceWString& SequenceWString::operator =(
        const SequenceWString& x)
{

    m_var_sequence_wstring = x.m_var_sequence_wstring;

    return *this;
}

SequenceWString& SequenceWString::operator =(
        SequenceWString&& x) noexcept
{

    m_var_sequence_wstring = std::move(x.m_var_sequence_wstring);

    return *this;
}

bool SequenceWString::operator ==(
        const SequenceWString& x) const
{

    return (m_var_sequence_wstring == x.m_var_sequence_wstring);
}

bool SequenceWString::operator !=(
        const SequenceWString& x) const
{
    return !(*this == x);
}

size_t SequenceWString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceWString_max_cdr_typesize;
}

size_t SequenceWString::getCdrSerializedSize(
        const SequenceWString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < data.var_sequence_wstring().size(); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.var_sequence_wstring().at(a).size() * 4);
    }

    return current_alignment - initial_alignment;
}

void SequenceWString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_wstring;
}

void SequenceWString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_wstring;}

/*!
 * @brief This function copies the value in member var_sequence_wstring
 * @param _var_sequence_wstring New value to be copied in member var_sequence_wstring
 */
void SequenceWString::var_sequence_wstring(
        const std::vector<std::wstring>& _var_sequence_wstring)
{
    m_var_sequence_wstring = _var_sequence_wstring;
}

/*!
 * @brief This function moves the value in member var_sequence_wstring
 * @param _var_sequence_wstring New value to be moved in member var_sequence_wstring
 */
void SequenceWString::var_sequence_wstring(
        std::vector<std::wstring>&& _var_sequence_wstring)
{
    m_var_sequence_wstring = std::move(_var_sequence_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_wstring
 * @return Constant reference to member var_sequence_wstring
 */
const std::vector<std::wstring>& SequenceWString::var_sequence_wstring() const
{
    return m_var_sequence_wstring;
}

/*!
 * @brief This function returns a reference to member var_sequence_wstring
 * @return Reference to member var_sequence_wstring
 */
std::vector<std::wstring>& SequenceWString::var_sequence_wstring()
{
    return m_var_sequence_wstring;
}


size_t SequenceWString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceWString_max_key_cdr_typesize;
}

bool SequenceWString::isKeyDefined()
{
    return false;
}

void SequenceWString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceStringBounded::SequenceStringBounded()
{
    // sequence<Inner_alias_bounded_string_helper> m_var_sequence_bounded_string


    // Just to register all known types
    registersequencesTypes();
}

SequenceStringBounded::~SequenceStringBounded()
{
}

SequenceStringBounded::SequenceStringBounded(
        const SequenceStringBounded& x)
{
    m_var_sequence_bounded_string = x.m_var_sequence_bounded_string;
}

SequenceStringBounded::SequenceStringBounded(
        SequenceStringBounded&& x) noexcept 
{
    m_var_sequence_bounded_string = std::move(x.m_var_sequence_bounded_string);
}

SequenceStringBounded& SequenceStringBounded::operator =(
        const SequenceStringBounded& x)
{

    m_var_sequence_bounded_string = x.m_var_sequence_bounded_string;

    return *this;
}

SequenceStringBounded& SequenceStringBounded::operator =(
        SequenceStringBounded&& x) noexcept
{

    m_var_sequence_bounded_string = std::move(x.m_var_sequence_bounded_string);

    return *this;
}

bool SequenceStringBounded::operator ==(
        const SequenceStringBounded& x) const
{

    return (m_var_sequence_bounded_string == x.m_var_sequence_bounded_string);
}

bool SequenceStringBounded::operator !=(
        const SequenceStringBounded& x) const
{
    return !(*this == x);
}

size_t SequenceStringBounded::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceStringBounded_max_cdr_typesize;
}

size_t SequenceStringBounded::getCdrSerializedSize(
        const SequenceStringBounded& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < data.var_sequence_bounded_string().size(); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) +
            data.var_sequence_bounded_string().at(a).size() + 1;
    }

    return current_alignment - initial_alignment;
}

void SequenceStringBounded::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    {
        scdr << static_cast<uint32_t>(m_var_sequence_bounded_string.size());    for (const auto& item : m_var_sequence_bounded_string)
        {
            scdr << item.c_str();
        }
    }}

void SequenceStringBounded::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint32_t sequence_size = 0;
        dcdr >> sequence_size;
        m_var_sequence_bounded_string.resize(sequence_size);    for (auto& item : m_var_sequence_bounded_string)
        {
            std::string s;
            dcdr >> s;
            item = s.c_str();
        }
    }}

/*!
 * @brief This function copies the value in member var_sequence_bounded_string
 * @param _var_sequence_bounded_string New value to be copied in member var_sequence_bounded_string
 */
void SequenceStringBounded::var_sequence_bounded_string(
        const std::vector<Inner_alias_bounded_string_helper>& _var_sequence_bounded_string)
{
    m_var_sequence_bounded_string = _var_sequence_bounded_string;
}

/*!
 * @brief This function moves the value in member var_sequence_bounded_string
 * @param _var_sequence_bounded_string New value to be moved in member var_sequence_bounded_string
 */
void SequenceStringBounded::var_sequence_bounded_string(
        std::vector<Inner_alias_bounded_string_helper>&& _var_sequence_bounded_string)
{
    m_var_sequence_bounded_string = std::move(_var_sequence_bounded_string);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_bounded_string
 * @return Constant reference to member var_sequence_bounded_string
 */
const std::vector<Inner_alias_bounded_string_helper>& SequenceStringBounded::var_sequence_bounded_string() const
{
    return m_var_sequence_bounded_string;
}

/*!
 * @brief This function returns a reference to member var_sequence_bounded_string
 * @return Reference to member var_sequence_bounded_string
 */
std::vector<Inner_alias_bounded_string_helper>& SequenceStringBounded::var_sequence_bounded_string()
{
    return m_var_sequence_bounded_string;
}


size_t SequenceStringBounded::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceStringBounded_max_key_cdr_typesize;
}

bool SequenceStringBounded::isKeyDefined()
{
    return false;
}

void SequenceStringBounded::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceWStringBounded::SequenceWStringBounded()
{
    // sequence<Inner_alias_bounded_wstring_helper> m_var_sequence_bounded_wstring


    // Just to register all known types
    registersequencesTypes();
}

SequenceWStringBounded::~SequenceWStringBounded()
{
}

SequenceWStringBounded::SequenceWStringBounded(
        const SequenceWStringBounded& x)
{
    m_var_sequence_bounded_wstring = x.m_var_sequence_bounded_wstring;
}

SequenceWStringBounded::SequenceWStringBounded(
        SequenceWStringBounded&& x) noexcept 
{
    m_var_sequence_bounded_wstring = std::move(x.m_var_sequence_bounded_wstring);
}

SequenceWStringBounded& SequenceWStringBounded::operator =(
        const SequenceWStringBounded& x)
{

    m_var_sequence_bounded_wstring = x.m_var_sequence_bounded_wstring;

    return *this;
}

SequenceWStringBounded& SequenceWStringBounded::operator =(
        SequenceWStringBounded&& x) noexcept
{

    m_var_sequence_bounded_wstring = std::move(x.m_var_sequence_bounded_wstring);

    return *this;
}

bool SequenceWStringBounded::operator ==(
        const SequenceWStringBounded& x) const
{

    return (m_var_sequence_bounded_wstring == x.m_var_sequence_bounded_wstring);
}

bool SequenceWStringBounded::operator !=(
        const SequenceWStringBounded& x) const
{
    return !(*this == x);
}

size_t SequenceWStringBounded::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceWStringBounded_max_cdr_typesize;
}

size_t SequenceWStringBounded::getCdrSerializedSize(
        const SequenceWStringBounded& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < data.var_sequence_bounded_wstring().size(); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.var_sequence_bounded_wstring().at(a).size() * 4);
    }

    return current_alignment - initial_alignment;
}

void SequenceWStringBounded::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_bounded_wstring;
}

void SequenceWStringBounded::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_bounded_wstring;}

/*!
 * @brief This function copies the value in member var_sequence_bounded_wstring
 * @param _var_sequence_bounded_wstring New value to be copied in member var_sequence_bounded_wstring
 */
void SequenceWStringBounded::var_sequence_bounded_wstring(
        const std::vector<Inner_alias_bounded_wstring_helper>& _var_sequence_bounded_wstring)
{
    m_var_sequence_bounded_wstring = _var_sequence_bounded_wstring;
}

/*!
 * @brief This function moves the value in member var_sequence_bounded_wstring
 * @param _var_sequence_bounded_wstring New value to be moved in member var_sequence_bounded_wstring
 */
void SequenceWStringBounded::var_sequence_bounded_wstring(
        std::vector<Inner_alias_bounded_wstring_helper>&& _var_sequence_bounded_wstring)
{
    m_var_sequence_bounded_wstring = std::move(_var_sequence_bounded_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_bounded_wstring
 * @return Constant reference to member var_sequence_bounded_wstring
 */
const std::vector<Inner_alias_bounded_wstring_helper>& SequenceWStringBounded::var_sequence_bounded_wstring() const
{
    return m_var_sequence_bounded_wstring;
}

/*!
 * @brief This function returns a reference to member var_sequence_bounded_wstring
 * @return Reference to member var_sequence_bounded_wstring
 */
std::vector<Inner_alias_bounded_wstring_helper>& SequenceWStringBounded::var_sequence_bounded_wstring()
{
    return m_var_sequence_bounded_wstring;
}


size_t SequenceWStringBounded::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceWStringBounded_max_key_cdr_typesize;
}

bool SequenceWStringBounded::isKeyDefined()
{
    return false;
}

void SequenceWStringBounded::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceEnum::SequenceEnum()
{
    // sequence<InnerEnumHelper> m_var_sequence_enum


    // Just to register all known types
    registersequencesTypes();
}

SequenceEnum::~SequenceEnum()
{
}

SequenceEnum::SequenceEnum(
        const SequenceEnum& x)
{
    m_var_sequence_enum = x.m_var_sequence_enum;
}

SequenceEnum::SequenceEnum(
        SequenceEnum&& x) noexcept 
{
    m_var_sequence_enum = std::move(x.m_var_sequence_enum);
}

SequenceEnum& SequenceEnum::operator =(
        const SequenceEnum& x)
{

    m_var_sequence_enum = x.m_var_sequence_enum;

    return *this;
}

SequenceEnum& SequenceEnum::operator =(
        SequenceEnum&& x) noexcept
{

    m_var_sequence_enum = std::move(x.m_var_sequence_enum);

    return *this;
}

bool SequenceEnum::operator ==(
        const SequenceEnum& x) const
{

    return (m_var_sequence_enum == x.m_var_sequence_enum);
}

bool SequenceEnum::operator !=(
        const SequenceEnum& x) const
{
    return !(*this == x);
}

size_t SequenceEnum::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceEnum_max_cdr_typesize;
}

size_t SequenceEnum::getCdrSerializedSize(
        const SequenceEnum& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_enum().size() > 0)
    {
        current_alignment += (data.var_sequence_enum().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    return current_alignment - initial_alignment;
}

void SequenceEnum::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << static_cast<uint32_t>(m_var_sequence_enum.size());
    scdr.serializeArray(reinterpret_cast<const uint32_t*>(m_var_sequence_enum.data()), m_var_sequence_enum.size());

}

void SequenceEnum::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint32_t seq_length = 0;
        dcdr >> seq_length;
        m_var_sequence_enum.resize(seq_length);
        dcdr.deserializeArray(reinterpret_cast<uint32_t*>(m_var_sequence_enum.data()), seq_length);
    }
}

/*!
 * @brief This function copies the value in member var_sequence_enum
 * @param _var_sequence_enum New value to be copied in member var_sequence_enum
 */
void SequenceEnum::var_sequence_enum(
        const std::vector<InnerEnumHelper>& _var_sequence_enum)
{
    m_var_sequence_enum = _var_sequence_enum;
}

/*!
 * @brief This function moves the value in member var_sequence_enum
 * @param _var_sequence_enum New value to be moved in member var_sequence_enum
 */
void SequenceEnum::var_sequence_enum(
        std::vector<InnerEnumHelper>&& _var_sequence_enum)
{
    m_var_sequence_enum = std::move(_var_sequence_enum);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_enum
 * @return Constant reference to member var_sequence_enum
 */
const std::vector<InnerEnumHelper>& SequenceEnum::var_sequence_enum() const
{
    return m_var_sequence_enum;
}

/*!
 * @brief This function returns a reference to member var_sequence_enum
 * @return Reference to member var_sequence_enum
 */
std::vector<InnerEnumHelper>& SequenceEnum::var_sequence_enum()
{
    return m_var_sequence_enum;
}


size_t SequenceEnum::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceEnum_max_key_cdr_typesize;
}

bool SequenceEnum::isKeyDefined()
{
    return false;
}

void SequenceEnum::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceBitMask::SequenceBitMask()
{
    // sequence<InnerBitMaskHelper> m_var_sequence_bitmask


    // Just to register all known types
    registersequencesTypes();
}

SequenceBitMask::~SequenceBitMask()
{
}

SequenceBitMask::SequenceBitMask(
        const SequenceBitMask& x)
{
    m_var_sequence_bitmask = x.m_var_sequence_bitmask;
}

SequenceBitMask::SequenceBitMask(
        SequenceBitMask&& x) noexcept 
{
    m_var_sequence_bitmask = std::move(x.m_var_sequence_bitmask);
}

SequenceBitMask& SequenceBitMask::operator =(
        const SequenceBitMask& x)
{

    m_var_sequence_bitmask = x.m_var_sequence_bitmask;

    return *this;
}

SequenceBitMask& SequenceBitMask::operator =(
        SequenceBitMask&& x) noexcept
{

    m_var_sequence_bitmask = std::move(x.m_var_sequence_bitmask);

    return *this;
}

bool SequenceBitMask::operator ==(
        const SequenceBitMask& x) const
{

    return (m_var_sequence_bitmask == x.m_var_sequence_bitmask);
}

bool SequenceBitMask::operator !=(
        const SequenceBitMask& x) const
{
    return !(*this == x);
}

size_t SequenceBitMask::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceBitMask_max_cdr_typesize;
}

size_t SequenceBitMask::getCdrSerializedSize(
        const SequenceBitMask& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_bitmask().size() > 0)
    {
        current_alignment += (data.var_sequence_bitmask().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    return current_alignment - initial_alignment;
}

void SequenceBitMask::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << static_cast<uint32_t>(m_var_sequence_bitmask.size());
    scdr.serializeArray(reinterpret_cast<const uint32_t*>(m_var_sequence_bitmask.data()), m_var_sequence_bitmask.size());
}

void SequenceBitMask::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint32_t seq_length = 0;
        dcdr >> seq_length;
        m_var_sequence_bitmask.resize(seq_length);
        dcdr.deserializeArray(reinterpret_cast<uint32_t*>(m_var_sequence_bitmask.data()), seq_length);
    }
}

/*!
 * @brief This function copies the value in member var_sequence_bitmask
 * @param _var_sequence_bitmask New value to be copied in member var_sequence_bitmask
 */
void SequenceBitMask::var_sequence_bitmask(
        const std::vector<InnerBitMaskHelper>& _var_sequence_bitmask)
{
    m_var_sequence_bitmask = _var_sequence_bitmask;
}

/*!
 * @brief This function moves the value in member var_sequence_bitmask
 * @param _var_sequence_bitmask New value to be moved in member var_sequence_bitmask
 */
void SequenceBitMask::var_sequence_bitmask(
        std::vector<InnerBitMaskHelper>&& _var_sequence_bitmask)
{
    m_var_sequence_bitmask = std::move(_var_sequence_bitmask);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_bitmask
 * @return Constant reference to member var_sequence_bitmask
 */
const std::vector<InnerBitMaskHelper>& SequenceBitMask::var_sequence_bitmask() const
{
    return m_var_sequence_bitmask;
}

/*!
 * @brief This function returns a reference to member var_sequence_bitmask
 * @return Reference to member var_sequence_bitmask
 */
std::vector<InnerBitMaskHelper>& SequenceBitMask::var_sequence_bitmask()
{
    return m_var_sequence_bitmask;
}


size_t SequenceBitMask::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceBitMask_max_key_cdr_typesize;
}

bool SequenceBitMask::isKeyDefined()
{
    return false;
}

void SequenceBitMask::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceAlias::SequenceAlias()
{
    // sequence<InnerAliasHelper> m_var_sequence_alias


    // Just to register all known types
    registersequencesTypes();
}

SequenceAlias::~SequenceAlias()
{
}

SequenceAlias::SequenceAlias(
        const SequenceAlias& x)
{
    m_var_sequence_alias = x.m_var_sequence_alias;
}

SequenceAlias::SequenceAlias(
        SequenceAlias&& x) noexcept 
{
    m_var_sequence_alias = std::move(x.m_var_sequence_alias);
}

SequenceAlias& SequenceAlias::operator =(
        const SequenceAlias& x)
{

    m_var_sequence_alias = x.m_var_sequence_alias;

    return *this;
}

SequenceAlias& SequenceAlias::operator =(
        SequenceAlias&& x) noexcept
{

    m_var_sequence_alias = std::move(x.m_var_sequence_alias);

    return *this;
}

bool SequenceAlias::operator ==(
        const SequenceAlias& x) const
{

    return (m_var_sequence_alias == x.m_var_sequence_alias);
}

bool SequenceAlias::operator !=(
        const SequenceAlias& x) const
{
    return !(*this == x);
}

size_t SequenceAlias::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceAlias_max_cdr_typesize;
}

size_t SequenceAlias::getCdrSerializedSize(
        const SequenceAlias& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_alias().size() > 0)
    {
        current_alignment += (data.var_sequence_alias().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    return current_alignment - initial_alignment;
}

void SequenceAlias::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_alias;
}

void SequenceAlias::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_alias;}

/*!
 * @brief This function copies the value in member var_sequence_alias
 * @param _var_sequence_alias New value to be copied in member var_sequence_alias
 */
void SequenceAlias::var_sequence_alias(
        const std::vector<InnerAliasHelper>& _var_sequence_alias)
{
    m_var_sequence_alias = _var_sequence_alias;
}

/*!
 * @brief This function moves the value in member var_sequence_alias
 * @param _var_sequence_alias New value to be moved in member var_sequence_alias
 */
void SequenceAlias::var_sequence_alias(
        std::vector<InnerAliasHelper>&& _var_sequence_alias)
{
    m_var_sequence_alias = std::move(_var_sequence_alias);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_alias
 * @return Constant reference to member var_sequence_alias
 */
const std::vector<InnerAliasHelper>& SequenceAlias::var_sequence_alias() const
{
    return m_var_sequence_alias;
}

/*!
 * @brief This function returns a reference to member var_sequence_alias
 * @return Reference to member var_sequence_alias
 */
std::vector<InnerAliasHelper>& SequenceAlias::var_sequence_alias()
{
    return m_var_sequence_alias;
}


size_t SequenceAlias::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceAlias_max_key_cdr_typesize;
}

bool SequenceAlias::isKeyDefined()
{
    return false;
}

void SequenceAlias::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceShortArray::SequenceShortArray()
{
    // sequence<Inner_alias_array_helper> m_var_sequence_short_array


    // Just to register all known types
    registersequencesTypes();
}

SequenceShortArray::~SequenceShortArray()
{
}

SequenceShortArray::SequenceShortArray(
        const SequenceShortArray& x)
{
    m_var_sequence_short_array = x.m_var_sequence_short_array;
}

SequenceShortArray::SequenceShortArray(
        SequenceShortArray&& x) noexcept 
{
    m_var_sequence_short_array = std::move(x.m_var_sequence_short_array);
}

SequenceShortArray& SequenceShortArray::operator =(
        const SequenceShortArray& x)
{

    m_var_sequence_short_array = x.m_var_sequence_short_array;

    return *this;
}

SequenceShortArray& SequenceShortArray::operator =(
        SequenceShortArray&& x) noexcept
{

    m_var_sequence_short_array = std::move(x.m_var_sequence_short_array);

    return *this;
}

bool SequenceShortArray::operator ==(
        const SequenceShortArray& x) const
{

    return (m_var_sequence_short_array == x.m_var_sequence_short_array);
}

bool SequenceShortArray::operator !=(
        const SequenceShortArray& x) const
{
    return !(*this == x);
}

size_t SequenceShortArray::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceShortArray_max_cdr_typesize;
}

size_t SequenceShortArray::getCdrSerializedSize(
        const SequenceShortArray& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.var_sequence_short_array().size(); ++a)
    {
        current_alignment += ((2) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }

    return current_alignment - initial_alignment;
}

void SequenceShortArray::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_short_array;
}

void SequenceShortArray::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_short_array;}

/*!
 * @brief This function copies the value in member var_sequence_short_array
 * @param _var_sequence_short_array New value to be copied in member var_sequence_short_array
 */
void SequenceShortArray::var_sequence_short_array(
        const std::vector<Inner_alias_array_helper>& _var_sequence_short_array)
{
    m_var_sequence_short_array = _var_sequence_short_array;
}

/*!
 * @brief This function moves the value in member var_sequence_short_array
 * @param _var_sequence_short_array New value to be moved in member var_sequence_short_array
 */
void SequenceShortArray::var_sequence_short_array(
        std::vector<Inner_alias_array_helper>&& _var_sequence_short_array)
{
    m_var_sequence_short_array = std::move(_var_sequence_short_array);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_short_array
 * @return Constant reference to member var_sequence_short_array
 */
const std::vector<Inner_alias_array_helper>& SequenceShortArray::var_sequence_short_array() const
{
    return m_var_sequence_short_array;
}

/*!
 * @brief This function returns a reference to member var_sequence_short_array
 * @return Reference to member var_sequence_short_array
 */
std::vector<Inner_alias_array_helper>& SequenceShortArray::var_sequence_short_array()
{
    return m_var_sequence_short_array;
}


size_t SequenceShortArray::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceShortArray_max_key_cdr_typesize;
}

bool SequenceShortArray::isKeyDefined()
{
    return false;
}

void SequenceShortArray::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceSequence::SequenceSequence()
{
    // sequence<Inner_alias_sequence_helper> m_var_sequence_sequence


    // Just to register all known types
    registersequencesTypes();
}

SequenceSequence::~SequenceSequence()
{
}

SequenceSequence::SequenceSequence(
        const SequenceSequence& x)
{
    m_var_sequence_sequence = x.m_var_sequence_sequence;
}

SequenceSequence::SequenceSequence(
        SequenceSequence&& x) noexcept 
{
    m_var_sequence_sequence = std::move(x.m_var_sequence_sequence);
}

SequenceSequence& SequenceSequence::operator =(
        const SequenceSequence& x)
{

    m_var_sequence_sequence = x.m_var_sequence_sequence;

    return *this;
}

SequenceSequence& SequenceSequence::operator =(
        SequenceSequence&& x) noexcept
{

    m_var_sequence_sequence = std::move(x.m_var_sequence_sequence);

    return *this;
}

bool SequenceSequence::operator ==(
        const SequenceSequence& x) const
{

    return (m_var_sequence_sequence == x.m_var_sequence_sequence);
}

bool SequenceSequence::operator !=(
        const SequenceSequence& x) const
{
    return !(*this == x);
}

size_t SequenceSequence::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceSequence_max_cdr_typesize;
}

size_t SequenceSequence::getCdrSerializedSize(
        const SequenceSequence& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.var_sequence_sequence().size(); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        if (data.var_sequence_sequence().at(a).size() > 0)
        {
            current_alignment += (data.var_sequence_sequence().at(a).size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
        }



    }

    return current_alignment - initial_alignment;
}

void SequenceSequence::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_sequence;
}

void SequenceSequence::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_sequence;}

/*!
 * @brief This function copies the value in member var_sequence_sequence
 * @param _var_sequence_sequence New value to be copied in member var_sequence_sequence
 */
void SequenceSequence::var_sequence_sequence(
        const std::vector<Inner_alias_sequence_helper>& _var_sequence_sequence)
{
    m_var_sequence_sequence = _var_sequence_sequence;
}

/*!
 * @brief This function moves the value in member var_sequence_sequence
 * @param _var_sequence_sequence New value to be moved in member var_sequence_sequence
 */
void SequenceSequence::var_sequence_sequence(
        std::vector<Inner_alias_sequence_helper>&& _var_sequence_sequence)
{
    m_var_sequence_sequence = std::move(_var_sequence_sequence);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_sequence
 * @return Constant reference to member var_sequence_sequence
 */
const std::vector<Inner_alias_sequence_helper>& SequenceSequence::var_sequence_sequence() const
{
    return m_var_sequence_sequence;
}

/*!
 * @brief This function returns a reference to member var_sequence_sequence
 * @return Reference to member var_sequence_sequence
 */
std::vector<Inner_alias_sequence_helper>& SequenceSequence::var_sequence_sequence()
{
    return m_var_sequence_sequence;
}


size_t SequenceSequence::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceSequence_max_key_cdr_typesize;
}

bool SequenceSequence::isKeyDefined()
{
    return false;
}

void SequenceSequence::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceMap::SequenceMap()
{
    // sequence<Inner_alias_map_helper> m_var_sequence_map


    // Just to register all known types
    registersequencesTypes();
}

SequenceMap::~SequenceMap()
{
}

SequenceMap::SequenceMap(
        const SequenceMap& x)
{
    m_var_sequence_map = x.m_var_sequence_map;
}

SequenceMap::SequenceMap(
        SequenceMap&& x) noexcept 
{
    m_var_sequence_map = std::move(x.m_var_sequence_map);
}

SequenceMap& SequenceMap::operator =(
        const SequenceMap& x)
{

    m_var_sequence_map = x.m_var_sequence_map;

    return *this;
}

SequenceMap& SequenceMap::operator =(
        SequenceMap&& x) noexcept
{

    m_var_sequence_map = std::move(x.m_var_sequence_map);

    return *this;
}

bool SequenceMap::operator ==(
        const SequenceMap& x) const
{

    return (m_var_sequence_map == x.m_var_sequence_map);
}

bool SequenceMap::operator !=(
        const SequenceMap& x) const
{
    return !(*this == x);
}

size_t SequenceMap::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceMap_max_cdr_typesize;
}

size_t SequenceMap::getCdrSerializedSize(
        const SequenceMap& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.var_sequence_map().size(); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for(auto b : data.var_sequence_map().at(a))
        {
            (void)b;

                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        }

    }

    return current_alignment - initial_alignment;
}

void SequenceMap::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_map;
}

void SequenceMap::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_map;}

/*!
 * @brief This function copies the value in member var_sequence_map
 * @param _var_sequence_map New value to be copied in member var_sequence_map
 */
void SequenceMap::var_sequence_map(
        const std::vector<Inner_alias_map_helper>& _var_sequence_map)
{
    m_var_sequence_map = _var_sequence_map;
}

/*!
 * @brief This function moves the value in member var_sequence_map
 * @param _var_sequence_map New value to be moved in member var_sequence_map
 */
void SequenceMap::var_sequence_map(
        std::vector<Inner_alias_map_helper>&& _var_sequence_map)
{
    m_var_sequence_map = std::move(_var_sequence_map);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_map
 * @return Constant reference to member var_sequence_map
 */
const std::vector<Inner_alias_map_helper>& SequenceMap::var_sequence_map() const
{
    return m_var_sequence_map;
}

/*!
 * @brief This function returns a reference to member var_sequence_map
 * @return Reference to member var_sequence_map
 */
std::vector<Inner_alias_map_helper>& SequenceMap::var_sequence_map()
{
    return m_var_sequence_map;
}


size_t SequenceMap::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceMap_max_key_cdr_typesize;
}

bool SequenceMap::isKeyDefined()
{
    return false;
}

void SequenceMap::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceUnion::SequenceUnion()
{
    // sequence<InnerUnionHelper> m_var_sequence_union


    // Just to register all known types
    registersequencesTypes();
}

SequenceUnion::~SequenceUnion()
{
}

SequenceUnion::SequenceUnion(
        const SequenceUnion& x)
{
    m_var_sequence_union = x.m_var_sequence_union;
}

SequenceUnion::SequenceUnion(
        SequenceUnion&& x) noexcept 
{
    m_var_sequence_union = std::move(x.m_var_sequence_union);
}

SequenceUnion& SequenceUnion::operator =(
        const SequenceUnion& x)
{

    m_var_sequence_union = x.m_var_sequence_union;

    return *this;
}

SequenceUnion& SequenceUnion::operator =(
        SequenceUnion&& x) noexcept
{

    m_var_sequence_union = std::move(x.m_var_sequence_union);

    return *this;
}

bool SequenceUnion::operator ==(
        const SequenceUnion& x) const
{

    return (m_var_sequence_union == x.m_var_sequence_union);
}

bool SequenceUnion::operator !=(
        const SequenceUnion& x) const
{
    return !(*this == x);
}

size_t SequenceUnion::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceUnion_max_cdr_typesize;
}

size_t SequenceUnion::getCdrSerializedSize(
        const SequenceUnion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.var_sequence_union().size(); ++a)
    {
        current_alignment += InnerUnionHelper::getCdrSerializedSize(data.var_sequence_union().at(a), current_alignment);}

    return current_alignment - initial_alignment;
}

void SequenceUnion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_union;
}

void SequenceUnion::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_union;}

/*!
 * @brief This function copies the value in member var_sequence_union
 * @param _var_sequence_union New value to be copied in member var_sequence_union
 */
void SequenceUnion::var_sequence_union(
        const std::vector<InnerUnionHelper>& _var_sequence_union)
{
    m_var_sequence_union = _var_sequence_union;
}

/*!
 * @brief This function moves the value in member var_sequence_union
 * @param _var_sequence_union New value to be moved in member var_sequence_union
 */
void SequenceUnion::var_sequence_union(
        std::vector<InnerUnionHelper>&& _var_sequence_union)
{
    m_var_sequence_union = std::move(_var_sequence_union);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_union
 * @return Constant reference to member var_sequence_union
 */
const std::vector<InnerUnionHelper>& SequenceUnion::var_sequence_union() const
{
    return m_var_sequence_union;
}

/*!
 * @brief This function returns a reference to member var_sequence_union
 * @return Reference to member var_sequence_union
 */
std::vector<InnerUnionHelper>& SequenceUnion::var_sequence_union()
{
    return m_var_sequence_union;
}


size_t SequenceUnion::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceUnion_max_key_cdr_typesize;
}

bool SequenceUnion::isKeyDefined()
{
    return false;
}

void SequenceUnion::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceStructure::SequenceStructure()
{
    // sequence<InnerStructureHelper> m_var_sequence_structure


    // Just to register all known types
    registersequencesTypes();
}

SequenceStructure::~SequenceStructure()
{
}

SequenceStructure::SequenceStructure(
        const SequenceStructure& x)
{
    m_var_sequence_structure = x.m_var_sequence_structure;
}

SequenceStructure::SequenceStructure(
        SequenceStructure&& x) noexcept 
{
    m_var_sequence_structure = std::move(x.m_var_sequence_structure);
}

SequenceStructure& SequenceStructure::operator =(
        const SequenceStructure& x)
{

    m_var_sequence_structure = x.m_var_sequence_structure;

    return *this;
}

SequenceStructure& SequenceStructure::operator =(
        SequenceStructure&& x) noexcept
{

    m_var_sequence_structure = std::move(x.m_var_sequence_structure);

    return *this;
}

bool SequenceStructure::operator ==(
        const SequenceStructure& x) const
{

    return (m_var_sequence_structure == x.m_var_sequence_structure);
}

bool SequenceStructure::operator !=(
        const SequenceStructure& x) const
{
    return !(*this == x);
}

size_t SequenceStructure::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceStructure_max_cdr_typesize;
}

size_t SequenceStructure::getCdrSerializedSize(
        const SequenceStructure& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.var_sequence_structure().size(); ++a)
    {
        current_alignment += InnerStructureHelper::getCdrSerializedSize(data.var_sequence_structure().at(a), current_alignment);}

    return current_alignment - initial_alignment;
}

void SequenceStructure::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_structure;
}

void SequenceStructure::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_structure;}

/*!
 * @brief This function copies the value in member var_sequence_structure
 * @param _var_sequence_structure New value to be copied in member var_sequence_structure
 */
void SequenceStructure::var_sequence_structure(
        const std::vector<InnerStructureHelper>& _var_sequence_structure)
{
    m_var_sequence_structure = _var_sequence_structure;
}

/*!
 * @brief This function moves the value in member var_sequence_structure
 * @param _var_sequence_structure New value to be moved in member var_sequence_structure
 */
void SequenceStructure::var_sequence_structure(
        std::vector<InnerStructureHelper>&& _var_sequence_structure)
{
    m_var_sequence_structure = std::move(_var_sequence_structure);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_structure
 * @return Constant reference to member var_sequence_structure
 */
const std::vector<InnerStructureHelper>& SequenceStructure::var_sequence_structure() const
{
    return m_var_sequence_structure;
}

/*!
 * @brief This function returns a reference to member var_sequence_structure
 * @return Reference to member var_sequence_structure
 */
std::vector<InnerStructureHelper>& SequenceStructure::var_sequence_structure()
{
    return m_var_sequence_structure;
}


size_t SequenceStructure::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceStructure_max_key_cdr_typesize;
}

bool SequenceStructure::isKeyDefined()
{
    return false;
}

void SequenceStructure::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceBitset::SequenceBitset()
{
    // sequence<InnerBitsetHelper> m_var_sequence_bitset


    // Just to register all known types
    registersequencesTypes();
}

SequenceBitset::~SequenceBitset()
{
}

SequenceBitset::SequenceBitset(
        const SequenceBitset& x)
{
    m_var_sequence_bitset = x.m_var_sequence_bitset;
}

SequenceBitset::SequenceBitset(
        SequenceBitset&& x) noexcept 
{
    m_var_sequence_bitset = std::move(x.m_var_sequence_bitset);
}

SequenceBitset& SequenceBitset::operator =(
        const SequenceBitset& x)
{

    m_var_sequence_bitset = x.m_var_sequence_bitset;

    return *this;
}

SequenceBitset& SequenceBitset::operator =(
        SequenceBitset&& x) noexcept
{

    m_var_sequence_bitset = std::move(x.m_var_sequence_bitset);

    return *this;
}

bool SequenceBitset::operator ==(
        const SequenceBitset& x) const
{

    return (m_var_sequence_bitset == x.m_var_sequence_bitset);
}

bool SequenceBitset::operator !=(
        const SequenceBitset& x) const
{
    return !(*this == x);
}

size_t SequenceBitset::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceBitset_max_cdr_typesize;
}

size_t SequenceBitset::getCdrSerializedSize(
        const SequenceBitset& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.var_sequence_bitset().size(); ++a)
    {
        current_alignment += InnerBitsetHelper::getCdrSerializedSize(data.var_sequence_bitset().at(a), current_alignment);}

    return current_alignment - initial_alignment;
}

void SequenceBitset::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_bitset;
}

void SequenceBitset::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_bitset;}

/*!
 * @brief This function copies the value in member var_sequence_bitset
 * @param _var_sequence_bitset New value to be copied in member var_sequence_bitset
 */
void SequenceBitset::var_sequence_bitset(
        const std::vector<InnerBitsetHelper>& _var_sequence_bitset)
{
    m_var_sequence_bitset = _var_sequence_bitset;
}

/*!
 * @brief This function moves the value in member var_sequence_bitset
 * @param _var_sequence_bitset New value to be moved in member var_sequence_bitset
 */
void SequenceBitset::var_sequence_bitset(
        std::vector<InnerBitsetHelper>&& _var_sequence_bitset)
{
    m_var_sequence_bitset = std::move(_var_sequence_bitset);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_bitset
 * @return Constant reference to member var_sequence_bitset
 */
const std::vector<InnerBitsetHelper>& SequenceBitset::var_sequence_bitset() const
{
    return m_var_sequence_bitset;
}

/*!
 * @brief This function returns a reference to member var_sequence_bitset
 * @return Reference to member var_sequence_bitset
 */
std::vector<InnerBitsetHelper>& SequenceBitset::var_sequence_bitset()
{
    return m_var_sequence_bitset;
}


size_t SequenceBitset::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceBitset_max_key_cdr_typesize;
}

bool SequenceBitset::isKeyDefined()
{
    return false;
}

void SequenceBitset::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


BoundedSmallSequences::BoundedSmallSequences()
{
    // sequence<short, 1> m_var_sequence_small


    // Just to register all known types
    registersequencesTypes();
}

BoundedSmallSequences::~BoundedSmallSequences()
{
}

BoundedSmallSequences::BoundedSmallSequences(
        const BoundedSmallSequences& x)
{
    m_var_sequence_small = x.m_var_sequence_small;
}

BoundedSmallSequences::BoundedSmallSequences(
        BoundedSmallSequences&& x) noexcept 
{
    m_var_sequence_small = std::move(x.m_var_sequence_small);
}

BoundedSmallSequences& BoundedSmallSequences::operator =(
        const BoundedSmallSequences& x)
{

    m_var_sequence_small = x.m_var_sequence_small;

    return *this;
}

BoundedSmallSequences& BoundedSmallSequences::operator =(
        BoundedSmallSequences&& x) noexcept
{

    m_var_sequence_small = std::move(x.m_var_sequence_small);

    return *this;
}

bool BoundedSmallSequences::operator ==(
        const BoundedSmallSequences& x) const
{

    return (m_var_sequence_small == x.m_var_sequence_small);
}

bool BoundedSmallSequences::operator !=(
        const BoundedSmallSequences& x) const
{
    return !(*this == x);
}

size_t BoundedSmallSequences::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BoundedSmallSequences_max_cdr_typesize;
}

size_t BoundedSmallSequences::getCdrSerializedSize(
        const BoundedSmallSequences& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_small().size() > 0)
    {
        current_alignment += (data.var_sequence_small().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }



    return current_alignment - initial_alignment;
}

void BoundedSmallSequences::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_small;
}

void BoundedSmallSequences::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_small;}

/*!
 * @brief This function copies the value in member var_sequence_small
 * @param _var_sequence_small New value to be copied in member var_sequence_small
 */
void BoundedSmallSequences::var_sequence_small(
        const std::vector<int16_t>& _var_sequence_small)
{
    m_var_sequence_small = _var_sequence_small;
}

/*!
 * @brief This function moves the value in member var_sequence_small
 * @param _var_sequence_small New value to be moved in member var_sequence_small
 */
void BoundedSmallSequences::var_sequence_small(
        std::vector<int16_t>&& _var_sequence_small)
{
    m_var_sequence_small = std::move(_var_sequence_small);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_small
 * @return Constant reference to member var_sequence_small
 */
const std::vector<int16_t>& BoundedSmallSequences::var_sequence_small() const
{
    return m_var_sequence_small;
}

/*!
 * @brief This function returns a reference to member var_sequence_small
 * @return Reference to member var_sequence_small
 */
std::vector<int16_t>& BoundedSmallSequences::var_sequence_small()
{
    return m_var_sequence_small;
}


size_t BoundedSmallSequences::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BoundedSmallSequences_max_key_cdr_typesize;
}

bool BoundedSmallSequences::isKeyDefined()
{
    return false;
}

void BoundedSmallSequences::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


BoundedBigSequences::BoundedBigSequences()
{
    // sequence<short, 41925> m_var_sequence_big


    // Just to register all known types
    registersequencesTypes();
}

BoundedBigSequences::~BoundedBigSequences()
{
}

BoundedBigSequences::BoundedBigSequences(
        const BoundedBigSequences& x)
{
    m_var_sequence_big = x.m_var_sequence_big;
}

BoundedBigSequences::BoundedBigSequences(
        BoundedBigSequences&& x) noexcept 
{
    m_var_sequence_big = std::move(x.m_var_sequence_big);
}

BoundedBigSequences& BoundedBigSequences::operator =(
        const BoundedBigSequences& x)
{

    m_var_sequence_big = x.m_var_sequence_big;

    return *this;
}

BoundedBigSequences& BoundedBigSequences::operator =(
        BoundedBigSequences&& x) noexcept
{

    m_var_sequence_big = std::move(x.m_var_sequence_big);

    return *this;
}

bool BoundedBigSequences::operator ==(
        const BoundedBigSequences& x) const
{

    return (m_var_sequence_big == x.m_var_sequence_big);
}

bool BoundedBigSequences::operator !=(
        const BoundedBigSequences& x) const
{
    return !(*this == x);
}

size_t BoundedBigSequences::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BoundedBigSequences_max_cdr_typesize;
}

size_t BoundedBigSequences::getCdrSerializedSize(
        const BoundedBigSequences& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence_big().size() > 0)
    {
        current_alignment += (data.var_sequence_big().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }



    return current_alignment - initial_alignment;
}

void BoundedBigSequences::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence_big;
}

void BoundedBigSequences::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence_big;}

/*!
 * @brief This function copies the value in member var_sequence_big
 * @param _var_sequence_big New value to be copied in member var_sequence_big
 */
void BoundedBigSequences::var_sequence_big(
        const std::vector<int16_t>& _var_sequence_big)
{
    m_var_sequence_big = _var_sequence_big;
}

/*!
 * @brief This function moves the value in member var_sequence_big
 * @param _var_sequence_big New value to be moved in member var_sequence_big
 */
void BoundedBigSequences::var_sequence_big(
        std::vector<int16_t>&& _var_sequence_big)
{
    m_var_sequence_big = std::move(_var_sequence_big);
}

/*!
 * @brief This function returns a constant reference to member var_sequence_big
 * @return Constant reference to member var_sequence_big
 */
const std::vector<int16_t>& BoundedBigSequences::var_sequence_big() const
{
    return m_var_sequence_big;
}

/*!
 * @brief This function returns a reference to member var_sequence_big
 * @return Reference to member var_sequence_big
 */
std::vector<int16_t>& BoundedBigSequences::var_sequence_big()
{
    return m_var_sequence_big;
}


size_t BoundedBigSequences::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BoundedBigSequences_max_key_cdr_typesize;
}

bool BoundedBigSequences::isKeyDefined()
{
    return false;
}

void BoundedBigSequences::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

