// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file sequencesTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "sequences.h"
#include "sequencesTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

void registersequencesTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(true),
                GetInnerEnumHelperObject(true));
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(false),
                GetInnerEnumHelperObject(false));

                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(true),
                GetInnerBitMaskHelperObject(true));
                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(false),
                GetInnerBitMaskHelperObject(false));

                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(true),
                GetInnerAliasHelperObject(true));
                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(false),
                GetInnerAliasHelperObject(false));

                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(true),
                GetInnerStructureHelperObject(true));
                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(false),
                GetInnerStructureHelperObject(false));

                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(true),
                GetInnerEmptyStructureHelperObject(true));
                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(false),
                GetInnerEmptyStructureHelperObject(false));

                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(true),
                GetInnerUnionHelperObject(true));
                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(false),
                GetInnerUnionHelperObject(false));

                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(true),
                GetInnerBitsetHelperObject(true));
                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(false),
                GetInnerBitsetHelperObject(false));

                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(true),
                GetInner_alias_bounded_string_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(false),
                GetInner_alias_bounded_string_helperObject(false));

                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(true),
                GetInner_alias_bounded_wstring_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(false),
                GetInner_alias_bounded_wstring_helperObject(false));

                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(true),
                GetInner_alias_array_helperObject(true));
                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(false),
                GetInner_alias_array_helperObject(false));

                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(true),
                GetInner_alias_sequence_helperObject(true));
                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(false),
                GetInner_alias_sequence_helperObject(false));

                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(true),
                GetInner_alias_map_helperObject(true));
                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(false),
                GetInner_alias_map_helperObject(false));

                factory->add_type_object("SequenceShort", GetSequenceShortIdentifier(true),
                GetSequenceShortObject(true));
                factory->add_type_object("SequenceShort", GetSequenceShortIdentifier(false),
                GetSequenceShortObject(false));

                factory->add_type_object("SequenceUShort", GetSequenceUShortIdentifier(true),
                GetSequenceUShortObject(true));
                factory->add_type_object("SequenceUShort", GetSequenceUShortIdentifier(false),
                GetSequenceUShortObject(false));

                factory->add_type_object("SequenceLong", GetSequenceLongIdentifier(true),
                GetSequenceLongObject(true));
                factory->add_type_object("SequenceLong", GetSequenceLongIdentifier(false),
                GetSequenceLongObject(false));

                factory->add_type_object("SequenceULong", GetSequenceULongIdentifier(true),
                GetSequenceULongObject(true));
                factory->add_type_object("SequenceULong", GetSequenceULongIdentifier(false),
                GetSequenceULongObject(false));

                factory->add_type_object("SequenceLongLong", GetSequenceLongLongIdentifier(true),
                GetSequenceLongLongObject(true));
                factory->add_type_object("SequenceLongLong", GetSequenceLongLongIdentifier(false),
                GetSequenceLongLongObject(false));

                factory->add_type_object("SequenceULongLong", GetSequenceULongLongIdentifier(true),
                GetSequenceULongLongObject(true));
                factory->add_type_object("SequenceULongLong", GetSequenceULongLongIdentifier(false),
                GetSequenceULongLongObject(false));

                factory->add_type_object("SequenceFloat", GetSequenceFloatIdentifier(true),
                GetSequenceFloatObject(true));
                factory->add_type_object("SequenceFloat", GetSequenceFloatIdentifier(false),
                GetSequenceFloatObject(false));

                factory->add_type_object("SequenceDouble", GetSequenceDoubleIdentifier(true),
                GetSequenceDoubleObject(true));
                factory->add_type_object("SequenceDouble", GetSequenceDoubleIdentifier(false),
                GetSequenceDoubleObject(false));

                factory->add_type_object("SequenceLongDouble", GetSequenceLongDoubleIdentifier(true),
                GetSequenceLongDoubleObject(true));
                factory->add_type_object("SequenceLongDouble", GetSequenceLongDoubleIdentifier(false),
                GetSequenceLongDoubleObject(false));

                factory->add_type_object("SequenceBoolean", GetSequenceBooleanIdentifier(true),
                GetSequenceBooleanObject(true));
                factory->add_type_object("SequenceBoolean", GetSequenceBooleanIdentifier(false),
                GetSequenceBooleanObject(false));

                factory->add_type_object("SequenceOctet", GetSequenceOctetIdentifier(true),
                GetSequenceOctetObject(true));
                factory->add_type_object("SequenceOctet", GetSequenceOctetIdentifier(false),
                GetSequenceOctetObject(false));

                factory->add_type_object("SequenceChar", GetSequenceCharIdentifier(true),
                GetSequenceCharObject(true));
                factory->add_type_object("SequenceChar", GetSequenceCharIdentifier(false),
                GetSequenceCharObject(false));

                factory->add_type_object("SequenceWChar", GetSequenceWCharIdentifier(true),
                GetSequenceWCharObject(true));
                factory->add_type_object("SequenceWChar", GetSequenceWCharIdentifier(false),
                GetSequenceWCharObject(false));

                factory->add_type_object("SequenceString", GetSequenceStringIdentifier(true),
                GetSequenceStringObject(true));
                factory->add_type_object("SequenceString", GetSequenceStringIdentifier(false),
                GetSequenceStringObject(false));

                factory->add_type_object("SequenceWString", GetSequenceWStringIdentifier(true),
                GetSequenceWStringObject(true));
                factory->add_type_object("SequenceWString", GetSequenceWStringIdentifier(false),
                GetSequenceWStringObject(false));

                factory->add_type_object("SequenceStringBounded", GetSequenceStringBoundedIdentifier(true),
                GetSequenceStringBoundedObject(true));
                factory->add_type_object("SequenceStringBounded", GetSequenceStringBoundedIdentifier(false),
                GetSequenceStringBoundedObject(false));

                factory->add_type_object("SequenceWStringBounded", GetSequenceWStringBoundedIdentifier(true),
                GetSequenceWStringBoundedObject(true));
                factory->add_type_object("SequenceWStringBounded", GetSequenceWStringBoundedIdentifier(false),
                GetSequenceWStringBoundedObject(false));

                factory->add_type_object("SequenceEnum", GetSequenceEnumIdentifier(true),
                GetSequenceEnumObject(true));
                factory->add_type_object("SequenceEnum", GetSequenceEnumIdentifier(false),
                GetSequenceEnumObject(false));

                factory->add_type_object("SequenceBitMask", GetSequenceBitMaskIdentifier(true),
                GetSequenceBitMaskObject(true));
                factory->add_type_object("SequenceBitMask", GetSequenceBitMaskIdentifier(false),
                GetSequenceBitMaskObject(false));

                factory->add_type_object("SequenceAlias", GetSequenceAliasIdentifier(true),
                GetSequenceAliasObject(true));
                factory->add_type_object("SequenceAlias", GetSequenceAliasIdentifier(false),
                GetSequenceAliasObject(false));

                factory->add_type_object("SequenceShortArray", GetSequenceShortArrayIdentifier(true),
                GetSequenceShortArrayObject(true));
                factory->add_type_object("SequenceShortArray", GetSequenceShortArrayIdentifier(false),
                GetSequenceShortArrayObject(false));

                factory->add_type_object("SequenceSequence", GetSequenceSequenceIdentifier(true),
                GetSequenceSequenceObject(true));
                factory->add_type_object("SequenceSequence", GetSequenceSequenceIdentifier(false),
                GetSequenceSequenceObject(false));

                factory->add_type_object("SequenceMap", GetSequenceMapIdentifier(true),
                GetSequenceMapObject(true));
                factory->add_type_object("SequenceMap", GetSequenceMapIdentifier(false),
                GetSequenceMapObject(false));

                factory->add_type_object("SequenceUnion", GetSequenceUnionIdentifier(true),
                GetSequenceUnionObject(true));
                factory->add_type_object("SequenceUnion", GetSequenceUnionIdentifier(false),
                GetSequenceUnionObject(false));

                factory->add_type_object("SequenceStructure", GetSequenceStructureIdentifier(true),
                GetSequenceStructureObject(true));
                factory->add_type_object("SequenceStructure", GetSequenceStructureIdentifier(false),
                GetSequenceStructureObject(false));

                factory->add_type_object("SequenceBitset", GetSequenceBitsetIdentifier(true),
                GetSequenceBitsetObject(true));
                factory->add_type_object("SequenceBitset", GetSequenceBitsetIdentifier(false),
                GetSequenceBitsetObject(false));

                factory->add_type_object("BoundedSmallSequences", GetBoundedSmallSequencesIdentifier(true),
                GetBoundedSmallSequencesObject(true));
                factory->add_type_object("BoundedSmallSequences", GetBoundedSmallSequencesIdentifier(false),
                GetBoundedSmallSequencesObject(false));

                factory->add_type_object("BoundedBigSequences", GetBoundedBigSequencesIdentifier(true),
                GetBoundedBigSequencesObject(true));
                factory->add_type_object("BoundedBigSequences", GetBoundedBigSequencesIdentifier(false),
                GetBoundedBigSequencesObject(false));

            });
}

const TypeIdentifier* GetSequenceShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceShort", complete);
}

const TypeObject* GetSequenceShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceShortObject();
    }
    //else
    return GetMinimalSequenceShortObject();
}

const TypeObject* GetMinimalSequenceShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_short;
    mst_var_sequence_short.common().member_id(memberId++);
    mst_var_sequence_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_short.common().member_flags().IS_KEY(false);
    mst_var_sequence_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 100, false));


    MD5 var_sequence_short_hash("var_sequence_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_short.detail().name_hash()[i] = var_sequence_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceShort", false);
}

const TypeObject* GetCompleteSequenceShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_short;
    cst_var_sequence_short.common().member_id(memberId++);
    cst_var_sequence_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_short.common().member_flags().IS_KEY(false);
    cst_var_sequence_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 100, true));


    cst_var_sequence_short.detail().name("var_sequence_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceShort", true);
}

const TypeIdentifier* GetSequenceUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceUShort", complete);
}

const TypeObject* GetSequenceUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceUShortObject();
    }
    //else
    return GetMinimalSequenceUShortObject();
}

const TypeObject* GetMinimalSequenceUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_ushort;
    mst_var_sequence_ushort.common().member_id(memberId++);
    mst_var_sequence_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_ushort.common().member_flags().IS_KEY(false);
    mst_var_sequence_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint16_t", 100, false));


    MD5 var_sequence_ushort_hash("var_sequence_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_ushort.detail().name_hash()[i] = var_sequence_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceUShort", false);
}

const TypeObject* GetCompleteSequenceUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_ushort;
    cst_var_sequence_ushort.common().member_id(memberId++);
    cst_var_sequence_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_ushort.common().member_flags().IS_KEY(false);
    cst_var_sequence_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint16_t", 100, true));


    cst_var_sequence_ushort.detail().name("var_sequence_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceUShort", true);
}

const TypeIdentifier* GetSequenceLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceLong", complete);
}

const TypeObject* GetSequenceLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceLongObject();
    }
    //else
    return GetMinimalSequenceLongObject();
}

const TypeObject* GetMinimalSequenceLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_long;
    mst_var_sequence_long.common().member_id(memberId++);
    mst_var_sequence_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_long.common().member_flags().IS_KEY(false);
    mst_var_sequence_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int32_t", 100, false));


    MD5 var_sequence_long_hash("var_sequence_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_long.detail().name_hash()[i] = var_sequence_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceLong", false);
}

const TypeObject* GetCompleteSequenceLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_long;
    cst_var_sequence_long.common().member_id(memberId++);
    cst_var_sequence_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_long.common().member_flags().IS_KEY(false);
    cst_var_sequence_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int32_t", 100, true));


    cst_var_sequence_long.detail().name("var_sequence_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceLong", true);
}

const TypeIdentifier* GetSequenceULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceULong", complete);
}

const TypeObject* GetSequenceULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceULongObject();
    }
    //else
    return GetMinimalSequenceULongObject();
}

const TypeObject* GetMinimalSequenceULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_ulong;
    mst_var_sequence_ulong.common().member_id(memberId++);
    mst_var_sequence_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_ulong.common().member_flags().IS_KEY(false);
    mst_var_sequence_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint32_t", 100, false));


    MD5 var_sequence_ulong_hash("var_sequence_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_ulong.detail().name_hash()[i] = var_sequence_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceULong", false);
}

const TypeObject* GetCompleteSequenceULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_ulong;
    cst_var_sequence_ulong.common().member_id(memberId++);
    cst_var_sequence_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_ulong.common().member_flags().IS_KEY(false);
    cst_var_sequence_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint32_t", 100, true));


    cst_var_sequence_ulong.detail().name("var_sequence_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceULong", true);
}

const TypeIdentifier* GetSequenceLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceLongLong", complete);
}

const TypeObject* GetSequenceLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceLongLongObject();
    }
    //else
    return GetMinimalSequenceLongLongObject();
}

const TypeObject* GetMinimalSequenceLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_longlong;
    mst_var_sequence_longlong.common().member_id(memberId++);
    mst_var_sequence_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_longlong.common().member_flags().IS_KEY(false);
    mst_var_sequence_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int64_t", 100, false));


    MD5 var_sequence_longlong_hash("var_sequence_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_longlong.detail().name_hash()[i] = var_sequence_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceLongLong", false);
}

const TypeObject* GetCompleteSequenceLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_longlong;
    cst_var_sequence_longlong.common().member_id(memberId++);
    cst_var_sequence_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_longlong.common().member_flags().IS_KEY(false);
    cst_var_sequence_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int64_t", 100, true));


    cst_var_sequence_longlong.detail().name("var_sequence_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceLongLong", true);
}

const TypeIdentifier* GetSequenceULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceULongLong", complete);
}

const TypeObject* GetSequenceULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceULongLongObject();
    }
    //else
    return GetMinimalSequenceULongLongObject();
}

const TypeObject* GetMinimalSequenceULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_ulonglong;
    mst_var_sequence_ulonglong.common().member_id(memberId++);
    mst_var_sequence_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_sequence_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint64_t", 100, false));


    MD5 var_sequence_ulonglong_hash("var_sequence_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_ulonglong.detail().name_hash()[i] = var_sequence_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceULongLong", false);
}

const TypeObject* GetCompleteSequenceULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_ulonglong;
    cst_var_sequence_ulonglong.common().member_id(memberId++);
    cst_var_sequence_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_sequence_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint64_t", 100, true));


    cst_var_sequence_ulonglong.detail().name("var_sequence_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceULongLong", true);
}

const TypeIdentifier* GetSequenceFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceFloat", complete);
}

const TypeObject* GetSequenceFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceFloatObject();
    }
    //else
    return GetMinimalSequenceFloatObject();
}

const TypeObject* GetMinimalSequenceFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_float;
    mst_var_sequence_float.common().member_id(memberId++);
    mst_var_sequence_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_float.common().member_flags().IS_KEY(false);
    mst_var_sequence_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("float", 100, false));


    MD5 var_sequence_float_hash("var_sequence_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_float.detail().name_hash()[i] = var_sequence_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceFloat", false);
}

const TypeObject* GetCompleteSequenceFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_float;
    cst_var_sequence_float.common().member_id(memberId++);
    cst_var_sequence_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_float.common().member_flags().IS_KEY(false);
    cst_var_sequence_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("float", 100, true));


    cst_var_sequence_float.detail().name("var_sequence_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceFloat", true);
}

const TypeIdentifier* GetSequenceDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceDouble", complete);
}

const TypeObject* GetSequenceDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceDoubleObject();
    }
    //else
    return GetMinimalSequenceDoubleObject();
}

const TypeObject* GetMinimalSequenceDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_double;
    mst_var_sequence_double.common().member_id(memberId++);
    mst_var_sequence_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_double.common().member_flags().IS_KEY(false);
    mst_var_sequence_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("double", 100, false));


    MD5 var_sequence_double_hash("var_sequence_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_double.detail().name_hash()[i] = var_sequence_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceDouble", false);
}

const TypeObject* GetCompleteSequenceDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_double;
    cst_var_sequence_double.common().member_id(memberId++);
    cst_var_sequence_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_double.common().member_flags().IS_KEY(false);
    cst_var_sequence_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("double", 100, true));


    cst_var_sequence_double.detail().name("var_sequence_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceDouble", true);
}

const TypeIdentifier* GetSequenceLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceLongDouble", complete);
}

const TypeObject* GetSequenceLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceLongDoubleObject();
    }
    //else
    return GetMinimalSequenceLongDoubleObject();
}

const TypeObject* GetMinimalSequenceLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_longdouble;
    mst_var_sequence_longdouble.common().member_id(memberId++);
    mst_var_sequence_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_longdouble.common().member_flags().IS_KEY(false);
    mst_var_sequence_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("longdouble", 100, false));


    MD5 var_sequence_longdouble_hash("var_sequence_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_longdouble.detail().name_hash()[i] = var_sequence_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceLongDouble", false);
}

const TypeObject* GetCompleteSequenceLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_longdouble;
    cst_var_sequence_longdouble.common().member_id(memberId++);
    cst_var_sequence_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_longdouble.common().member_flags().IS_KEY(false);
    cst_var_sequence_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("longdouble", 100, true));


    cst_var_sequence_longdouble.detail().name("var_sequence_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceLongDouble", true);
}

const TypeIdentifier* GetSequenceBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceBoolean", complete);
}

const TypeObject* GetSequenceBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceBooleanObject();
    }
    //else
    return GetMinimalSequenceBooleanObject();
}

const TypeObject* GetMinimalSequenceBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_boolean;
    mst_var_sequence_boolean.common().member_id(memberId++);
    mst_var_sequence_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_boolean.common().member_flags().IS_KEY(false);
    mst_var_sequence_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("bool", 100, false));


    MD5 var_sequence_boolean_hash("var_sequence_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_boolean.detail().name_hash()[i] = var_sequence_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceBoolean", false);
}

const TypeObject* GetCompleteSequenceBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_boolean;
    cst_var_sequence_boolean.common().member_id(memberId++);
    cst_var_sequence_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_boolean.common().member_flags().IS_KEY(false);
    cst_var_sequence_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("bool", 100, true));


    cst_var_sequence_boolean.detail().name("var_sequence_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceBoolean", true);
}

const TypeIdentifier* GetSequenceOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceOctet", complete);
}

const TypeObject* GetSequenceOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceOctetObject();
    }
    //else
    return GetMinimalSequenceOctetObject();
}

const TypeObject* GetMinimalSequenceOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_octet;
    mst_var_sequence_octet.common().member_id(memberId++);
    mst_var_sequence_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_octet.common().member_flags().IS_KEY(false);
    mst_var_sequence_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100, false));


    MD5 var_sequence_octet_hash("var_sequence_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_octet.detail().name_hash()[i] = var_sequence_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceOctet", false);
}

const TypeObject* GetCompleteSequenceOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_octet;
    cst_var_sequence_octet.common().member_id(memberId++);
    cst_var_sequence_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_octet.common().member_flags().IS_KEY(false);
    cst_var_sequence_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100, true));


    cst_var_sequence_octet.detail().name("var_sequence_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceOctet", true);
}

const TypeIdentifier* GetSequenceCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceChar", complete);
}

const TypeObject* GetSequenceCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceCharObject();
    }
    //else
    return GetMinimalSequenceCharObject();
}

const TypeObject* GetMinimalSequenceCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_char;
    mst_var_sequence_char.common().member_id(memberId++);
    mst_var_sequence_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_char.common().member_flags().IS_KEY(false);
    mst_var_sequence_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("char", 100, false));


    MD5 var_sequence_char_hash("var_sequence_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_char.detail().name_hash()[i] = var_sequence_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceChar", false);
}

const TypeObject* GetCompleteSequenceCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_char;
    cst_var_sequence_char.common().member_id(memberId++);
    cst_var_sequence_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_char.common().member_flags().IS_KEY(false);
    cst_var_sequence_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_char.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("char", 100, true));


    cst_var_sequence_char.detail().name("var_sequence_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceChar", true);
}

const TypeIdentifier* GetSequenceWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceWChar", complete);
}

const TypeObject* GetSequenceWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceWCharObject();
    }
    //else
    return GetMinimalSequenceWCharObject();
}

const TypeObject* GetMinimalSequenceWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_wchar;
    mst_var_sequence_wchar.common().member_id(memberId++);
    mst_var_sequence_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_wchar.common().member_flags().IS_KEY(false);
    mst_var_sequence_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("wchar_t", 100, false));


    MD5 var_sequence_wchar_hash("var_sequence_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_wchar.detail().name_hash()[i] = var_sequence_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceWChar", false);
}

const TypeObject* GetCompleteSequenceWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_wchar;
    cst_var_sequence_wchar.common().member_id(memberId++);
    cst_var_sequence_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_wchar.common().member_flags().IS_KEY(false);
    cst_var_sequence_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_wchar.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("wchar_t", 100, true));


    cst_var_sequence_wchar.detail().name("var_sequence_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceWChar", true);
}

const TypeIdentifier* GetSequenceStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceString", complete);
}

const TypeObject* GetSequenceStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceStringObject();
    }
    //else
    return GetMinimalSequenceStringObject();
}

const TypeObject* GetMinimalSequenceStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_string;
    mst_var_sequence_string.common().member_id(memberId++);
    mst_var_sequence_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_string.common().member_flags().IS_KEY(false);
    mst_var_sequence_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(TypeNamesGenerator::get_string_type_name(255, false), 100, false));


    MD5 var_sequence_string_hash("var_sequence_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_string.detail().name_hash()[i] = var_sequence_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceString", false);
}

const TypeObject* GetCompleteSequenceStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_string;
    cst_var_sequence_string.common().member_id(memberId++);
    cst_var_sequence_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_string.common().member_flags().IS_KEY(false);
    cst_var_sequence_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(TypeNamesGenerator::get_string_type_name(255, false), 100, true));


    cst_var_sequence_string.detail().name("var_sequence_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceString", true);
}

const TypeIdentifier* GetSequenceWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceWString", complete);
}

const TypeObject* GetSequenceWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceWStringObject();
    }
    //else
    return GetMinimalSequenceWStringObject();
}

const TypeObject* GetMinimalSequenceWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_wstring;
    mst_var_sequence_wstring.common().member_id(memberId++);
    mst_var_sequence_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_wstring.common().member_flags().IS_KEY(false);
    mst_var_sequence_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(TypeNamesGenerator::get_string_type_name(255, true), 100, false));


    MD5 var_sequence_wstring_hash("var_sequence_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_wstring.detail().name_hash()[i] = var_sequence_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceWString", false);
}

const TypeObject* GetCompleteSequenceWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_wstring;
    cst_var_sequence_wstring.common().member_id(memberId++);
    cst_var_sequence_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_wstring.common().member_flags().IS_KEY(false);
    cst_var_sequence_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier(TypeNamesGenerator::get_string_type_name(255, true), 100, true));


    cst_var_sequence_wstring.detail().name("var_sequence_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceWString", true);
}

const TypeIdentifier* GetSequenceStringBoundedIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceStringBounded", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceStringBoundedObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceStringBounded", complete);
}

const TypeObject* GetSequenceStringBoundedObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceStringBounded", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceStringBoundedObject();
    }
    //else
    return GetMinimalSequenceStringBoundedObject();
}

const TypeObject* GetMinimalSequenceStringBoundedObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceStringBounded", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_bounded_string;
    mst_var_sequence_bounded_string.common().member_id(memberId++);
    mst_var_sequence_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_bounded_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_bounded_string.common().member_flags().IS_KEY(false);
    mst_var_sequence_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_bounded_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("Inner_alias_bounded_string_helper", 100, false));


    MD5 var_sequence_bounded_string_hash("var_sequence_bounded_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_bounded_string.detail().name_hash()[i] = var_sequence_bounded_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_bounded_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceStringBounded", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceStringBounded", false);
}

const TypeObject* GetCompleteSequenceStringBoundedObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceStringBounded", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_bounded_string;
    cst_var_sequence_bounded_string.common().member_id(memberId++);
    cst_var_sequence_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_bounded_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_bounded_string.common().member_flags().IS_KEY(false);
    cst_var_sequence_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_bounded_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("Inner_alias_bounded_string_helper", 100, true));


    cst_var_sequence_bounded_string.detail().name("var_sequence_bounded_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_bounded_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceStringBounded");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceStringBounded", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceStringBounded", true);
}

const TypeIdentifier* GetSequenceWStringBoundedIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceWStringBounded", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceWStringBoundedObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceWStringBounded", complete);
}

const TypeObject* GetSequenceWStringBoundedObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceWStringBounded", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceWStringBoundedObject();
    }
    //else
    return GetMinimalSequenceWStringBoundedObject();
}

const TypeObject* GetMinimalSequenceWStringBoundedObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceWStringBounded", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_bounded_wstring;
    mst_var_sequence_bounded_wstring.common().member_id(memberId++);
    mst_var_sequence_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_bounded_wstring.common().member_flags().IS_KEY(false);
    mst_var_sequence_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_bounded_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("Inner_alias_bounded_wstring_helper", 100, false));


    MD5 var_sequence_bounded_wstring_hash("var_sequence_bounded_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_bounded_wstring.detail().name_hash()[i] = var_sequence_bounded_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_bounded_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceWStringBounded", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceWStringBounded", false);
}

const TypeObject* GetCompleteSequenceWStringBoundedObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceWStringBounded", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_bounded_wstring;
    cst_var_sequence_bounded_wstring.common().member_id(memberId++);
    cst_var_sequence_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_bounded_wstring.common().member_flags().IS_KEY(false);
    cst_var_sequence_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_bounded_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("Inner_alias_bounded_wstring_helper", 100, true));


    cst_var_sequence_bounded_wstring.detail().name("var_sequence_bounded_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_bounded_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceWStringBounded");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceWStringBounded", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceWStringBounded", true);
}

const TypeIdentifier* GetSequenceEnumIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceEnum", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceEnumObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceEnum", complete);
}

const TypeObject* GetSequenceEnumObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceEnum", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceEnumObject();
    }
    //else
    return GetMinimalSequenceEnumObject();
}

const TypeObject* GetMinimalSequenceEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceEnum", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_enum;
    mst_var_sequence_enum.common().member_id(memberId++);
    mst_var_sequence_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_enum.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_enum.common().member_flags().IS_KEY(false);
    mst_var_sequence_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_enum.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("InnerEnumHelper", 100, false));


    MD5 var_sequence_enum_hash("var_sequence_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_enum.detail().name_hash()[i] = var_sequence_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_enum);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceEnum", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceEnum", false);
}

const TypeObject* GetCompleteSequenceEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceEnum", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_enum;
    cst_var_sequence_enum.common().member_id(memberId++);
    cst_var_sequence_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_enum.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_enum.common().member_flags().IS_KEY(false);
    cst_var_sequence_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_enum.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("InnerEnumHelper", 100, true));


    cst_var_sequence_enum.detail().name("var_sequence_enum");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_enum);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceEnum");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceEnum", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceEnum", true);
}

const TypeIdentifier* GetSequenceBitMaskIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceBitMask", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceBitMaskObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceBitMask", complete);
}

const TypeObject* GetSequenceBitMaskObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceBitMask", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceBitMaskObject();
    }
    //else
    return GetMinimalSequenceBitMaskObject();
}

const TypeObject* GetMinimalSequenceBitMaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceBitMask", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_bitmask;
    mst_var_sequence_bitmask.common().member_id(memberId++);
    mst_var_sequence_bitmask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_bitmask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_bitmask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_bitmask.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_bitmask.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_bitmask.common().member_flags().IS_KEY(false);
    mst_var_sequence_bitmask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_bitmask.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("InnerBitMaskHelper", 100, false));


    MD5 var_sequence_bitmask_hash("var_sequence_bitmask");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_bitmask.detail().name_hash()[i] = var_sequence_bitmask_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_bitmask);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceBitMask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceBitMask", false);
}

const TypeObject* GetCompleteSequenceBitMaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceBitMask", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_bitmask;
    cst_var_sequence_bitmask.common().member_id(memberId++);
    cst_var_sequence_bitmask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_bitmask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_bitmask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_bitmask.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_bitmask.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_bitmask.common().member_flags().IS_KEY(false);
    cst_var_sequence_bitmask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_bitmask.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("InnerBitMaskHelper", 100, true));


    cst_var_sequence_bitmask.detail().name("var_sequence_bitmask");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_bitmask);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceBitMask");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceBitMask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceBitMask", true);
}

const TypeIdentifier* GetSequenceAliasIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceAlias", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceAliasObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceAlias", complete);
}

const TypeObject* GetSequenceAliasObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceAlias", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceAliasObject();
    }
    //else
    return GetMinimalSequenceAliasObject();
}

const TypeObject* GetMinimalSequenceAliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceAlias", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_alias;
    mst_var_sequence_alias.common().member_id(memberId++);
    mst_var_sequence_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_alias.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_alias.common().member_flags().IS_KEY(false);
    mst_var_sequence_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_alias.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("InnerAliasHelper", 100, false));


    MD5 var_sequence_alias_hash("var_sequence_alias");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_alias.detail().name_hash()[i] = var_sequence_alias_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_alias);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceAlias", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceAlias", false);
}

const TypeObject* GetCompleteSequenceAliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceAlias", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_alias;
    cst_var_sequence_alias.common().member_id(memberId++);
    cst_var_sequence_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_alias.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_alias.common().member_flags().IS_KEY(false);
    cst_var_sequence_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_alias.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("InnerAliasHelper", 100, true));


    cst_var_sequence_alias.detail().name("var_sequence_alias");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_alias);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceAlias");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceAlias", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceAlias", true);
}

const TypeIdentifier* GetSequenceShortArrayIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceShortArray", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceShortArrayObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceShortArray", complete);
}

const TypeObject* GetSequenceShortArrayObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceShortArray", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceShortArrayObject();
    }
    //else
    return GetMinimalSequenceShortArrayObject();
}

const TypeObject* GetMinimalSequenceShortArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceShortArray", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_short_array;
    mst_var_sequence_short_array.common().member_id(memberId++);
    mst_var_sequence_short_array.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_short_array.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_short_array.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_short_array.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_short_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_short_array.common().member_flags().IS_KEY(false);
    mst_var_sequence_short_array.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_short_array.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("Inner_alias_array_helper", 100, false));


    MD5 var_sequence_short_array_hash("var_sequence_short_array");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_short_array.detail().name_hash()[i] = var_sequence_short_array_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_short_array);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceShortArray", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceShortArray", false);
}

const TypeObject* GetCompleteSequenceShortArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceShortArray", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_short_array;
    cst_var_sequence_short_array.common().member_id(memberId++);
    cst_var_sequence_short_array.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_short_array.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_short_array.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_short_array.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_short_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_short_array.common().member_flags().IS_KEY(false);
    cst_var_sequence_short_array.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_short_array.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("Inner_alias_array_helper", 100, true));


    cst_var_sequence_short_array.detail().name("var_sequence_short_array");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_short_array);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceShortArray");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceShortArray", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceShortArray", true);
}

const TypeIdentifier* GetSequenceSequenceIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceSequence", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceSequenceObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceSequence", complete);
}

const TypeObject* GetSequenceSequenceObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceSequence", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceSequenceObject();
    }
    //else
    return GetMinimalSequenceSequenceObject();
}

const TypeObject* GetMinimalSequenceSequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceSequence", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_sequence;
    mst_var_sequence_sequence.common().member_id(memberId++);
    mst_var_sequence_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_sequence.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_sequence.common().member_flags().IS_KEY(false);
    mst_var_sequence_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_sequence.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("Inner_alias_sequence_helper", 100, false));


    MD5 var_sequence_sequence_hash("var_sequence_sequence");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_sequence.detail().name_hash()[i] = var_sequence_sequence_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_sequence);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceSequence", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceSequence", false);
}

const TypeObject* GetCompleteSequenceSequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceSequence", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_sequence;
    cst_var_sequence_sequence.common().member_id(memberId++);
    cst_var_sequence_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_sequence.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_sequence.common().member_flags().IS_KEY(false);
    cst_var_sequence_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_sequence.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("Inner_alias_sequence_helper", 100, true));


    cst_var_sequence_sequence.detail().name("var_sequence_sequence");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_sequence);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceSequence");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceSequence", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceSequence", true);
}

const TypeIdentifier* GetSequenceMapIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceMap", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceMapObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceMap", complete);
}

const TypeObject* GetSequenceMapObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceMap", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceMapObject();
    }
    //else
    return GetMinimalSequenceMapObject();
}

const TypeObject* GetMinimalSequenceMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceMap", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_map;
    mst_var_sequence_map.common().member_id(memberId++);
    mst_var_sequence_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_map.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_map.common().member_flags().IS_KEY(false);
    mst_var_sequence_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("Inner_alias_map_helper", 100, false));


    MD5 var_sequence_map_hash("var_sequence_map");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_map.detail().name_hash()[i] = var_sequence_map_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_map);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceMap", false);
}

const TypeObject* GetCompleteSequenceMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceMap", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_map;
    cst_var_sequence_map.common().member_id(memberId++);
    cst_var_sequence_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_map.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_map.common().member_flags().IS_KEY(false);
    cst_var_sequence_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("Inner_alias_map_helper", 100, true));


    cst_var_sequence_map.detail().name("var_sequence_map");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_map);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceMap");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceMap", true);
}

const TypeIdentifier* GetSequenceUnionIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceUnion", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceUnionObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceUnion", complete);
}

const TypeObject* GetSequenceUnionObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceUnion", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceUnionObject();
    }
    //else
    return GetMinimalSequenceUnionObject();
}

const TypeObject* GetMinimalSequenceUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceUnion", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_union;
    mst_var_sequence_union.common().member_id(memberId++);
    mst_var_sequence_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_union.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_union.common().member_flags().IS_KEY(false);
    mst_var_sequence_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_union.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("InnerUnionHelper", 100, false));


    MD5 var_sequence_union_hash("var_sequence_union");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_union.detail().name_hash()[i] = var_sequence_union_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_union);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceUnion", false);
}

const TypeObject* GetCompleteSequenceUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceUnion", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_union;
    cst_var_sequence_union.common().member_id(memberId++);
    cst_var_sequence_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_union.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_union.common().member_flags().IS_KEY(false);
    cst_var_sequence_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_union.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("InnerUnionHelper", 100, true));


    cst_var_sequence_union.detail().name("var_sequence_union");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_union);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceUnion");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceUnion", true);
}

const TypeIdentifier* GetSequenceStructureIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceStructure", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceStructureObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceStructure", complete);
}

const TypeObject* GetSequenceStructureObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceStructure", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceStructureObject();
    }
    //else
    return GetMinimalSequenceStructureObject();
}

const TypeObject* GetMinimalSequenceStructureObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceStructure", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_structure;
    mst_var_sequence_structure.common().member_id(memberId++);
    mst_var_sequence_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_structure.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_structure.common().member_flags().IS_KEY(false);
    mst_var_sequence_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_structure.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("InnerStructureHelper", 100, false));


    MD5 var_sequence_structure_hash("var_sequence_structure");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_structure.detail().name_hash()[i] = var_sequence_structure_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_structure);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceStructure", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceStructure", false);
}

const TypeObject* GetCompleteSequenceStructureObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceStructure", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_structure;
    cst_var_sequence_structure.common().member_id(memberId++);
    cst_var_sequence_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_structure.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_structure.common().member_flags().IS_KEY(false);
    cst_var_sequence_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_structure.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("InnerStructureHelper", 100, true));


    cst_var_sequence_structure.detail().name("var_sequence_structure");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_structure);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceStructure");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceStructure", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceStructure", true);
}

const TypeIdentifier* GetSequenceBitsetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceBitset", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceBitsetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceBitset", complete);
}

const TypeObject* GetSequenceBitsetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceBitset", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceBitsetObject();
    }
    //else
    return GetMinimalSequenceBitsetObject();
}

const TypeObject* GetMinimalSequenceBitsetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceBitset", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_bitset;
    mst_var_sequence_bitset.common().member_id(memberId++);
    mst_var_sequence_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_bitset.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_bitset.common().member_flags().IS_KEY(false);
    mst_var_sequence_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_bitset.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("InnerBitsetHelper", 100, false));


    MD5 var_sequence_bitset_hash("var_sequence_bitset");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_bitset.detail().name_hash()[i] = var_sequence_bitset_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_bitset);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceBitset", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceBitset", false);
}

const TypeObject* GetCompleteSequenceBitsetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceBitset", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_bitset;
    cst_var_sequence_bitset.common().member_id(memberId++);
    cst_var_sequence_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_bitset.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_bitset.common().member_flags().IS_KEY(false);
    cst_var_sequence_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_bitset.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("InnerBitsetHelper", 100, true));


    cst_var_sequence_bitset.detail().name("var_sequence_bitset");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_bitset);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceBitset");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceBitset", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceBitset", true);
}

const TypeIdentifier* GetBoundedSmallSequencesIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("BoundedSmallSequences", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBoundedSmallSequencesObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("BoundedSmallSequences", complete);
}

const TypeObject* GetBoundedSmallSequencesObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedSmallSequences", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBoundedSmallSequencesObject();
    }
    //else
    return GetMinimalBoundedSmallSequencesObject();
}

const TypeObject* GetMinimalBoundedSmallSequencesObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedSmallSequences", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_small;
    mst_var_sequence_small.common().member_id(memberId++);
    mst_var_sequence_small.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_small.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_small.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_small.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_small.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_small.common().member_flags().IS_KEY(false);
    mst_var_sequence_small.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_small.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 1, false));


    MD5 var_sequence_small_hash("var_sequence_small");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_small.detail().name_hash()[i] = var_sequence_small_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_small);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedSmallSequences", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedSmallSequences", false);
}

const TypeObject* GetCompleteBoundedSmallSequencesObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedSmallSequences", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_small;
    cst_var_sequence_small.common().member_id(memberId++);
    cst_var_sequence_small.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_small.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_small.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_small.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_small.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_small.common().member_flags().IS_KEY(false);
    cst_var_sequence_small.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_small.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 1, true));


    cst_var_sequence_small.detail().name("var_sequence_small");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_small);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BoundedSmallSequences");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedSmallSequences", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedSmallSequences", true);
}

const TypeIdentifier* GetBoundedBigSequencesIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("BoundedBigSequences", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBoundedBigSequencesObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("BoundedBigSequences", complete);
}

const TypeObject* GetBoundedBigSequencesObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedBigSequences", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBoundedBigSequencesObject();
    }
    //else
    return GetMinimalBoundedBigSequencesObject();
}

const TypeObject* GetMinimalBoundedBigSequencesObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedBigSequences", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence_big;
    mst_var_sequence_big.common().member_id(memberId++);
    mst_var_sequence_big.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence_big.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence_big.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence_big.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence_big.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence_big.common().member_flags().IS_KEY(false);
    mst_var_sequence_big.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence_big.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 41925, false));


    MD5 var_sequence_big_hash("var_sequence_big");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence_big.detail().name_hash()[i] = var_sequence_big_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence_big);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedBigSequences", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedBigSequences", false);
}

const TypeObject* GetCompleteBoundedBigSequencesObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedBigSequences", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence_big;
    cst_var_sequence_big.common().member_id(memberId++);
    cst_var_sequence_big.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence_big.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence_big.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence_big.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence_big.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence_big.common().member_flags().IS_KEY(false);
    cst_var_sequence_big.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence_big.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 41925, true));


    cst_var_sequence_big.detail().name("var_sequence_big");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence_big);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BoundedBigSequences");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedBigSequences", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedBigSequences", true);
}
