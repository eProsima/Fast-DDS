// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file structures.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "structures.h"
#include "structuresTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define InnerStructureHelper_max_cdr_typesize 8ULL;
#define StructChar8_max_cdr_typesize 1ULL;
#define StructBoolean_max_cdr_typesize 1ULL;
#define StructBoundedString_max_cdr_typesize 15ULL;
#define StructChar16_max_cdr_typesize 4ULL;
#define StructOctet_max_cdr_typesize 1ULL;
#define StructShort_max_cdr_typesize 2ULL;
#define StructAlias_max_cdr_typesize 4ULL;
#define StructSequence_max_cdr_typesize 404ULL;
#define StructBoundedWString_max_cdr_typesize 44ULL;
#define StructStructure_max_cdr_typesize 8ULL;
#define StructEnum_max_cdr_typesize 4ULL;
#define StructEmpty_max_cdr_typesize 0ULL;
#define StructBitMask_max_cdr_typesize 4ULL;
#define StructLong_max_cdr_typesize 4ULL;
#define Structures_max_cdr_typesize 2620ULL;
#define StructUnsignedLong_max_cdr_typesize 4ULL;
#define StructDouble_max_cdr_typesize 8ULL;
#define StructShortArray_max_cdr_typesize 20ULL;

#define InnerEmptyStructureHelper_max_cdr_typesize 0ULL;
#define StructLongDouble_max_cdr_typesize 16ULL;
#define StructWString_max_cdr_typesize 1024ULL;
#define StructMap_max_cdr_typesize 804ULL;

#define StructUnsignedShort_max_cdr_typesize 2ULL;

#define StructLongLong_max_cdr_typesize 8ULL;
#define StructString_max_cdr_typesize 260ULL;
#define StructBitset_max_cdr_typesize 8ULL;


#define StructUnion_max_cdr_typesize 8ULL;

#define StructUnsignedLongLong_max_cdr_typesize 8ULL;




#define StructFloat_max_cdr_typesize 4ULL;
#define InnerStructureHelper_max_key_cdr_typesize 0ULL;
#define StructChar8_max_key_cdr_typesize 0ULL;
#define StructBoolean_max_key_cdr_typesize 0ULL;
#define StructBoundedString_max_key_cdr_typesize 0ULL;
#define StructChar16_max_key_cdr_typesize 0ULL;
#define StructOctet_max_key_cdr_typesize 0ULL;
#define StructShort_max_key_cdr_typesize 0ULL;
#define StructAlias_max_key_cdr_typesize 0ULL;
#define StructSequence_max_key_cdr_typesize 0ULL;
#define StructBoundedWString_max_key_cdr_typesize 0ULL;
#define StructStructure_max_key_cdr_typesize 0ULL;
#define StructEnum_max_key_cdr_typesize 0ULL;
#define StructEmpty_max_key_cdr_typesize 0ULL;
#define StructBitMask_max_key_cdr_typesize 0ULL;
#define StructLong_max_key_cdr_typesize 0ULL;
#define Structures_max_key_cdr_typesize 0ULL;
#define StructUnsignedLong_max_key_cdr_typesize 0ULL;
#define StructDouble_max_key_cdr_typesize 0ULL;
#define StructShortArray_max_key_cdr_typesize 0ULL;

#define InnerEmptyStructureHelper_max_key_cdr_typesize 0ULL;
#define StructLongDouble_max_key_cdr_typesize 0ULL;
#define StructWString_max_key_cdr_typesize 0ULL;
#define StructMap_max_key_cdr_typesize 0ULL;

#define StructUnsignedShort_max_key_cdr_typesize 0ULL;

#define StructLongLong_max_key_cdr_typesize 0ULL;
#define StructString_max_key_cdr_typesize 0ULL;
#define StructBitset_max_key_cdr_typesize 0ULL;


#define StructUnion_max_key_cdr_typesize 0ULL;

#define StructUnsignedLongLong_max_key_cdr_typesize 0ULL;




#define StructFloat_max_key_cdr_typesize 0ULL;

StructShort::StructShort()
{
    // short m_var_short
    m_var_short = 0;

    // Just to register all known types
    registerstructuresTypes();
}

StructShort::~StructShort()
{
}

StructShort::StructShort(
        const StructShort& x)
{
    m_var_short = x.m_var_short;
}

StructShort::StructShort(
        StructShort&& x) noexcept 
{
    m_var_short = x.m_var_short;
}

StructShort& StructShort::operator =(
        const StructShort& x)
{

    m_var_short = x.m_var_short;

    return *this;
}

StructShort& StructShort::operator =(
        StructShort&& x) noexcept
{

    m_var_short = x.m_var_short;

    return *this;
}

bool StructShort::operator ==(
        const StructShort& x) const
{

    return (m_var_short == x.m_var_short);
}

bool StructShort::operator !=(
        const StructShort& x) const
{
    return !(*this == x);
}

size_t StructShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructShort_max_cdr_typesize;
}

size_t StructShort::getCdrSerializedSize(
        const StructShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void StructShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_short;
}

void StructShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_short;
}

/*!
 * @brief This function sets a value in member var_short
 * @param _var_short New value for member var_short
 */
void StructShort::var_short(
        int16_t _var_short)
{
    m_var_short = _var_short;
}

/*!
 * @brief This function returns the value of member var_short
 * @return Value of member var_short
 */
int16_t StructShort::var_short() const
{
    return m_var_short;
}

/*!
 * @brief This function returns a reference to member var_short
 * @return Reference to member var_short
 */
int16_t& StructShort::var_short()
{
    return m_var_short;
}



size_t StructShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructShort_max_key_cdr_typesize;
}

bool StructShort::isKeyDefined()
{
    return false;
}

void StructShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructUnsignedShort::StructUnsignedShort()
{
    // unsigned short m_var_ushort
    m_var_ushort = 0;

    // Just to register all known types
    registerstructuresTypes();
}

StructUnsignedShort::~StructUnsignedShort()
{
}

StructUnsignedShort::StructUnsignedShort(
        const StructUnsignedShort& x)
{
    m_var_ushort = x.m_var_ushort;
}

StructUnsignedShort::StructUnsignedShort(
        StructUnsignedShort&& x) noexcept 
{
    m_var_ushort = x.m_var_ushort;
}

StructUnsignedShort& StructUnsignedShort::operator =(
        const StructUnsignedShort& x)
{

    m_var_ushort = x.m_var_ushort;

    return *this;
}

StructUnsignedShort& StructUnsignedShort::operator =(
        StructUnsignedShort&& x) noexcept
{

    m_var_ushort = x.m_var_ushort;

    return *this;
}

bool StructUnsignedShort::operator ==(
        const StructUnsignedShort& x) const
{

    return (m_var_ushort == x.m_var_ushort);
}

bool StructUnsignedShort::operator !=(
        const StructUnsignedShort& x) const
{
    return !(*this == x);
}

size_t StructUnsignedShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructUnsignedShort_max_cdr_typesize;
}

size_t StructUnsignedShort::getCdrSerializedSize(
        const StructUnsignedShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void StructUnsignedShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ushort;
}

void StructUnsignedShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ushort;
}

/*!
 * @brief This function sets a value in member var_ushort
 * @param _var_ushort New value for member var_ushort
 */
void StructUnsignedShort::var_ushort(
        uint16_t _var_ushort)
{
    m_var_ushort = _var_ushort;
}

/*!
 * @brief This function returns the value of member var_ushort
 * @return Value of member var_ushort
 */
uint16_t StructUnsignedShort::var_ushort() const
{
    return m_var_ushort;
}

/*!
 * @brief This function returns a reference to member var_ushort
 * @return Reference to member var_ushort
 */
uint16_t& StructUnsignedShort::var_ushort()
{
    return m_var_ushort;
}



size_t StructUnsignedShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructUnsignedShort_max_key_cdr_typesize;
}

bool StructUnsignedShort::isKeyDefined()
{
    return false;
}

void StructUnsignedShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructLong::StructLong()
{
    // long m_var_long
    m_var_long = 0;

    // Just to register all known types
    registerstructuresTypes();
}

StructLong::~StructLong()
{
}

StructLong::StructLong(
        const StructLong& x)
{
    m_var_long = x.m_var_long;
}

StructLong::StructLong(
        StructLong&& x) noexcept 
{
    m_var_long = x.m_var_long;
}

StructLong& StructLong::operator =(
        const StructLong& x)
{

    m_var_long = x.m_var_long;

    return *this;
}

StructLong& StructLong::operator =(
        StructLong&& x) noexcept
{

    m_var_long = x.m_var_long;

    return *this;
}

bool StructLong::operator ==(
        const StructLong& x) const
{

    return (m_var_long == x.m_var_long);
}

bool StructLong::operator !=(
        const StructLong& x) const
{
    return !(*this == x);
}

size_t StructLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructLong_max_cdr_typesize;
}

size_t StructLong::getCdrSerializedSize(
        const StructLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void StructLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_long;
}

void StructLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_long;
}

/*!
 * @brief This function sets a value in member var_long
 * @param _var_long New value for member var_long
 */
void StructLong::var_long(
        int32_t _var_long)
{
    m_var_long = _var_long;
}

/*!
 * @brief This function returns the value of member var_long
 * @return Value of member var_long
 */
int32_t StructLong::var_long() const
{
    return m_var_long;
}

/*!
 * @brief This function returns a reference to member var_long
 * @return Reference to member var_long
 */
int32_t& StructLong::var_long()
{
    return m_var_long;
}



size_t StructLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructLong_max_key_cdr_typesize;
}

bool StructLong::isKeyDefined()
{
    return false;
}

void StructLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructUnsignedLong::StructUnsignedLong()
{
    // unsigned long m_var_ulong
    m_var_ulong = 0;

    // Just to register all known types
    registerstructuresTypes();
}

StructUnsignedLong::~StructUnsignedLong()
{
}

StructUnsignedLong::StructUnsignedLong(
        const StructUnsignedLong& x)
{
    m_var_ulong = x.m_var_ulong;
}

StructUnsignedLong::StructUnsignedLong(
        StructUnsignedLong&& x) noexcept 
{
    m_var_ulong = x.m_var_ulong;
}

StructUnsignedLong& StructUnsignedLong::operator =(
        const StructUnsignedLong& x)
{

    m_var_ulong = x.m_var_ulong;

    return *this;
}

StructUnsignedLong& StructUnsignedLong::operator =(
        StructUnsignedLong&& x) noexcept
{

    m_var_ulong = x.m_var_ulong;

    return *this;
}

bool StructUnsignedLong::operator ==(
        const StructUnsignedLong& x) const
{

    return (m_var_ulong == x.m_var_ulong);
}

bool StructUnsignedLong::operator !=(
        const StructUnsignedLong& x) const
{
    return !(*this == x);
}

size_t StructUnsignedLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructUnsignedLong_max_cdr_typesize;
}

size_t StructUnsignedLong::getCdrSerializedSize(
        const StructUnsignedLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void StructUnsignedLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ulong;
}

void StructUnsignedLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ulong;
}

/*!
 * @brief This function sets a value in member var_ulong
 * @param _var_ulong New value for member var_ulong
 */
void StructUnsignedLong::var_ulong(
        uint32_t _var_ulong)
{
    m_var_ulong = _var_ulong;
}

/*!
 * @brief This function returns the value of member var_ulong
 * @return Value of member var_ulong
 */
uint32_t StructUnsignedLong::var_ulong() const
{
    return m_var_ulong;
}

/*!
 * @brief This function returns a reference to member var_ulong
 * @return Reference to member var_ulong
 */
uint32_t& StructUnsignedLong::var_ulong()
{
    return m_var_ulong;
}



size_t StructUnsignedLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructUnsignedLong_max_key_cdr_typesize;
}

bool StructUnsignedLong::isKeyDefined()
{
    return false;
}

void StructUnsignedLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructLongLong::StructLongLong()
{
    // long long m_var_longlong
    m_var_longlong = 0;

    // Just to register all known types
    registerstructuresTypes();
}

StructLongLong::~StructLongLong()
{
}

StructLongLong::StructLongLong(
        const StructLongLong& x)
{
    m_var_longlong = x.m_var_longlong;
}

StructLongLong::StructLongLong(
        StructLongLong&& x) noexcept 
{
    m_var_longlong = x.m_var_longlong;
}

StructLongLong& StructLongLong::operator =(
        const StructLongLong& x)
{

    m_var_longlong = x.m_var_longlong;

    return *this;
}

StructLongLong& StructLongLong::operator =(
        StructLongLong&& x) noexcept
{

    m_var_longlong = x.m_var_longlong;

    return *this;
}

bool StructLongLong::operator ==(
        const StructLongLong& x) const
{

    return (m_var_longlong == x.m_var_longlong);
}

bool StructLongLong::operator !=(
        const StructLongLong& x) const
{
    return !(*this == x);
}

size_t StructLongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructLongLong_max_cdr_typesize;
}

size_t StructLongLong::getCdrSerializedSize(
        const StructLongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void StructLongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_longlong;
}

void StructLongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_longlong;
}

/*!
 * @brief This function sets a value in member var_longlong
 * @param _var_longlong New value for member var_longlong
 */
void StructLongLong::var_longlong(
        int64_t _var_longlong)
{
    m_var_longlong = _var_longlong;
}

/*!
 * @brief This function returns the value of member var_longlong
 * @return Value of member var_longlong
 */
int64_t StructLongLong::var_longlong() const
{
    return m_var_longlong;
}

/*!
 * @brief This function returns a reference to member var_longlong
 * @return Reference to member var_longlong
 */
int64_t& StructLongLong::var_longlong()
{
    return m_var_longlong;
}



size_t StructLongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructLongLong_max_key_cdr_typesize;
}

bool StructLongLong::isKeyDefined()
{
    return false;
}

void StructLongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructUnsignedLongLong::StructUnsignedLongLong()
{
    // unsigned long long m_var_ulonglong
    m_var_ulonglong = 0;

    // Just to register all known types
    registerstructuresTypes();
}

StructUnsignedLongLong::~StructUnsignedLongLong()
{
}

StructUnsignedLongLong::StructUnsignedLongLong(
        const StructUnsignedLongLong& x)
{
    m_var_ulonglong = x.m_var_ulonglong;
}

StructUnsignedLongLong::StructUnsignedLongLong(
        StructUnsignedLongLong&& x) noexcept 
{
    m_var_ulonglong = x.m_var_ulonglong;
}

StructUnsignedLongLong& StructUnsignedLongLong::operator =(
        const StructUnsignedLongLong& x)
{

    m_var_ulonglong = x.m_var_ulonglong;

    return *this;
}

StructUnsignedLongLong& StructUnsignedLongLong::operator =(
        StructUnsignedLongLong&& x) noexcept
{

    m_var_ulonglong = x.m_var_ulonglong;

    return *this;
}

bool StructUnsignedLongLong::operator ==(
        const StructUnsignedLongLong& x) const
{

    return (m_var_ulonglong == x.m_var_ulonglong);
}

bool StructUnsignedLongLong::operator !=(
        const StructUnsignedLongLong& x) const
{
    return !(*this == x);
}

size_t StructUnsignedLongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructUnsignedLongLong_max_cdr_typesize;
}

size_t StructUnsignedLongLong::getCdrSerializedSize(
        const StructUnsignedLongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void StructUnsignedLongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ulonglong;
}

void StructUnsignedLongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ulonglong;
}

/*!
 * @brief This function sets a value in member var_ulonglong
 * @param _var_ulonglong New value for member var_ulonglong
 */
void StructUnsignedLongLong::var_ulonglong(
        uint64_t _var_ulonglong)
{
    m_var_ulonglong = _var_ulonglong;
}

/*!
 * @brief This function returns the value of member var_ulonglong
 * @return Value of member var_ulonglong
 */
uint64_t StructUnsignedLongLong::var_ulonglong() const
{
    return m_var_ulonglong;
}

/*!
 * @brief This function returns a reference to member var_ulonglong
 * @return Reference to member var_ulonglong
 */
uint64_t& StructUnsignedLongLong::var_ulonglong()
{
    return m_var_ulonglong;
}



size_t StructUnsignedLongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructUnsignedLongLong_max_key_cdr_typesize;
}

bool StructUnsignedLongLong::isKeyDefined()
{
    return false;
}

void StructUnsignedLongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructFloat::StructFloat()
{
    // float m_var_float
    m_var_float = 0.0;

    // Just to register all known types
    registerstructuresTypes();
}

StructFloat::~StructFloat()
{
}

StructFloat::StructFloat(
        const StructFloat& x)
{
    m_var_float = x.m_var_float;
}

StructFloat::StructFloat(
        StructFloat&& x) noexcept 
{
    m_var_float = x.m_var_float;
}

StructFloat& StructFloat::operator =(
        const StructFloat& x)
{

    m_var_float = x.m_var_float;

    return *this;
}

StructFloat& StructFloat::operator =(
        StructFloat&& x) noexcept
{

    m_var_float = x.m_var_float;

    return *this;
}

bool StructFloat::operator ==(
        const StructFloat& x) const
{

    return (m_var_float == x.m_var_float);
}

bool StructFloat::operator !=(
        const StructFloat& x) const
{
    return !(*this == x);
}

size_t StructFloat::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructFloat_max_cdr_typesize;
}

size_t StructFloat::getCdrSerializedSize(
        const StructFloat& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void StructFloat::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_float;
}

void StructFloat::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_float;
}

/*!
 * @brief This function sets a value in member var_float
 * @param _var_float New value for member var_float
 */
void StructFloat::var_float(
        float _var_float)
{
    m_var_float = _var_float;
}

/*!
 * @brief This function returns the value of member var_float
 * @return Value of member var_float
 */
float StructFloat::var_float() const
{
    return m_var_float;
}

/*!
 * @brief This function returns a reference to member var_float
 * @return Reference to member var_float
 */
float& StructFloat::var_float()
{
    return m_var_float;
}



size_t StructFloat::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructFloat_max_key_cdr_typesize;
}

bool StructFloat::isKeyDefined()
{
    return false;
}

void StructFloat::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructDouble::StructDouble()
{
    // double m_var_double
    m_var_double = 0.0;

    // Just to register all known types
    registerstructuresTypes();
}

StructDouble::~StructDouble()
{
}

StructDouble::StructDouble(
        const StructDouble& x)
{
    m_var_double = x.m_var_double;
}

StructDouble::StructDouble(
        StructDouble&& x) noexcept 
{
    m_var_double = x.m_var_double;
}

StructDouble& StructDouble::operator =(
        const StructDouble& x)
{

    m_var_double = x.m_var_double;

    return *this;
}

StructDouble& StructDouble::operator =(
        StructDouble&& x) noexcept
{

    m_var_double = x.m_var_double;

    return *this;
}

bool StructDouble::operator ==(
        const StructDouble& x) const
{

    return (m_var_double == x.m_var_double);
}

bool StructDouble::operator !=(
        const StructDouble& x) const
{
    return !(*this == x);
}

size_t StructDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructDouble_max_cdr_typesize;
}

size_t StructDouble::getCdrSerializedSize(
        const StructDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void StructDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_double;
}

void StructDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_double;
}

/*!
 * @brief This function sets a value in member var_double
 * @param _var_double New value for member var_double
 */
void StructDouble::var_double(
        double _var_double)
{
    m_var_double = _var_double;
}

/*!
 * @brief This function returns the value of member var_double
 * @return Value of member var_double
 */
double StructDouble::var_double() const
{
    return m_var_double;
}

/*!
 * @brief This function returns a reference to member var_double
 * @return Reference to member var_double
 */
double& StructDouble::var_double()
{
    return m_var_double;
}



size_t StructDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructDouble_max_key_cdr_typesize;
}

bool StructDouble::isKeyDefined()
{
    return false;
}

void StructDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructLongDouble::StructLongDouble()
{
    // long double m_var_longdouble
    m_var_longdouble = 0.0;

    // Just to register all known types
    registerstructuresTypes();
}

StructLongDouble::~StructLongDouble()
{
}

StructLongDouble::StructLongDouble(
        const StructLongDouble& x)
{
    m_var_longdouble = x.m_var_longdouble;
}

StructLongDouble::StructLongDouble(
        StructLongDouble&& x) noexcept 
{
    m_var_longdouble = x.m_var_longdouble;
}

StructLongDouble& StructLongDouble::operator =(
        const StructLongDouble& x)
{

    m_var_longdouble = x.m_var_longdouble;

    return *this;
}

StructLongDouble& StructLongDouble::operator =(
        StructLongDouble&& x) noexcept
{

    m_var_longdouble = x.m_var_longdouble;

    return *this;
}

bool StructLongDouble::operator ==(
        const StructLongDouble& x) const
{

    return (m_var_longdouble == x.m_var_longdouble);
}

bool StructLongDouble::operator !=(
        const StructLongDouble& x) const
{
    return !(*this == x);
}

size_t StructLongDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructLongDouble_max_cdr_typesize;
}

size_t StructLongDouble::getCdrSerializedSize(
        const StructLongDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 16 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8); // 128 bits, but aligned as 64


    return current_alignment - initial_alignment;
}

void StructLongDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_longdouble;
}

void StructLongDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_longdouble;
}

/*!
 * @brief This function sets a value in member var_longdouble
 * @param _var_longdouble New value for member var_longdouble
 */
void StructLongDouble::var_longdouble(
        long double _var_longdouble)
{
    m_var_longdouble = _var_longdouble;
}

/*!
 * @brief This function returns the value of member var_longdouble
 * @return Value of member var_longdouble
 */
long double StructLongDouble::var_longdouble() const
{
    return m_var_longdouble;
}

/*!
 * @brief This function returns a reference to member var_longdouble
 * @return Reference to member var_longdouble
 */
long double& StructLongDouble::var_longdouble()
{
    return m_var_longdouble;
}



size_t StructLongDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructLongDouble_max_key_cdr_typesize;
}

bool StructLongDouble::isKeyDefined()
{
    return false;
}

void StructLongDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructBoolean::StructBoolean()
{
    // boolean m_var_boolean
    m_var_boolean = false;

    // Just to register all known types
    registerstructuresTypes();
}

StructBoolean::~StructBoolean()
{
}

StructBoolean::StructBoolean(
        const StructBoolean& x)
{
    m_var_boolean = x.m_var_boolean;
}

StructBoolean::StructBoolean(
        StructBoolean&& x) noexcept 
{
    m_var_boolean = x.m_var_boolean;
}

StructBoolean& StructBoolean::operator =(
        const StructBoolean& x)
{

    m_var_boolean = x.m_var_boolean;

    return *this;
}

StructBoolean& StructBoolean::operator =(
        StructBoolean&& x) noexcept
{

    m_var_boolean = x.m_var_boolean;

    return *this;
}

bool StructBoolean::operator ==(
        const StructBoolean& x) const
{

    return (m_var_boolean == x.m_var_boolean);
}

bool StructBoolean::operator !=(
        const StructBoolean& x) const
{
    return !(*this == x);
}

size_t StructBoolean::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructBoolean_max_cdr_typesize;
}

size_t StructBoolean::getCdrSerializedSize(
        const StructBoolean& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void StructBoolean::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_boolean;
}

void StructBoolean::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_boolean;
}

/*!
 * @brief This function sets a value in member var_boolean
 * @param _var_boolean New value for member var_boolean
 */
void StructBoolean::var_boolean(
        bool _var_boolean)
{
    m_var_boolean = _var_boolean;
}

/*!
 * @brief This function returns the value of member var_boolean
 * @return Value of member var_boolean
 */
bool StructBoolean::var_boolean() const
{
    return m_var_boolean;
}

/*!
 * @brief This function returns a reference to member var_boolean
 * @return Reference to member var_boolean
 */
bool& StructBoolean::var_boolean()
{
    return m_var_boolean;
}



size_t StructBoolean::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructBoolean_max_key_cdr_typesize;
}

bool StructBoolean::isKeyDefined()
{
    return false;
}

void StructBoolean::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructOctet::StructOctet()
{
    // octet m_var_octet
    m_var_octet = 0;

    // Just to register all known types
    registerstructuresTypes();
}

StructOctet::~StructOctet()
{
}

StructOctet::StructOctet(
        const StructOctet& x)
{
    m_var_octet = x.m_var_octet;
}

StructOctet::StructOctet(
        StructOctet&& x) noexcept 
{
    m_var_octet = x.m_var_octet;
}

StructOctet& StructOctet::operator =(
        const StructOctet& x)
{

    m_var_octet = x.m_var_octet;

    return *this;
}

StructOctet& StructOctet::operator =(
        StructOctet&& x) noexcept
{

    m_var_octet = x.m_var_octet;

    return *this;
}

bool StructOctet::operator ==(
        const StructOctet& x) const
{

    return (m_var_octet == x.m_var_octet);
}

bool StructOctet::operator !=(
        const StructOctet& x) const
{
    return !(*this == x);
}

size_t StructOctet::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructOctet_max_cdr_typesize;
}

size_t StructOctet::getCdrSerializedSize(
        const StructOctet& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void StructOctet::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_octet;
}

void StructOctet::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_octet;
}

/*!
 * @brief This function sets a value in member var_octet
 * @param _var_octet New value for member var_octet
 */
void StructOctet::var_octet(
        uint8_t _var_octet)
{
    m_var_octet = _var_octet;
}

/*!
 * @brief This function returns the value of member var_octet
 * @return Value of member var_octet
 */
uint8_t StructOctet::var_octet() const
{
    return m_var_octet;
}

/*!
 * @brief This function returns a reference to member var_octet
 * @return Reference to member var_octet
 */
uint8_t& StructOctet::var_octet()
{
    return m_var_octet;
}



size_t StructOctet::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructOctet_max_key_cdr_typesize;
}

bool StructOctet::isKeyDefined()
{
    return false;
}

void StructOctet::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructChar8::StructChar8()
{
    // char m_var_char8
    m_var_char8 = 0;

    // Just to register all known types
    registerstructuresTypes();
}

StructChar8::~StructChar8()
{
}

StructChar8::StructChar8(
        const StructChar8& x)
{
    m_var_char8 = x.m_var_char8;
}

StructChar8::StructChar8(
        StructChar8&& x) noexcept 
{
    m_var_char8 = x.m_var_char8;
}

StructChar8& StructChar8::operator =(
        const StructChar8& x)
{

    m_var_char8 = x.m_var_char8;

    return *this;
}

StructChar8& StructChar8::operator =(
        StructChar8&& x) noexcept
{

    m_var_char8 = x.m_var_char8;

    return *this;
}

bool StructChar8::operator ==(
        const StructChar8& x) const
{

    return (m_var_char8 == x.m_var_char8);
}

bool StructChar8::operator !=(
        const StructChar8& x) const
{
    return !(*this == x);
}

size_t StructChar8::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructChar8_max_cdr_typesize;
}

size_t StructChar8::getCdrSerializedSize(
        const StructChar8& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void StructChar8::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_char8;
}

void StructChar8::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_char8;
}

/*!
 * @brief This function sets a value in member var_char8
 * @param _var_char8 New value for member var_char8
 */
void StructChar8::var_char8(
        char _var_char8)
{
    m_var_char8 = _var_char8;
}

/*!
 * @brief This function returns the value of member var_char8
 * @return Value of member var_char8
 */
char StructChar8::var_char8() const
{
    return m_var_char8;
}

/*!
 * @brief This function returns a reference to member var_char8
 * @return Reference to member var_char8
 */
char& StructChar8::var_char8()
{
    return m_var_char8;
}



size_t StructChar8::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructChar8_max_key_cdr_typesize;
}

bool StructChar8::isKeyDefined()
{
    return false;
}

void StructChar8::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructChar16::StructChar16()
{
    // wchar m_var_char16
    m_var_char16 = 0;

    // Just to register all known types
    registerstructuresTypes();
}

StructChar16::~StructChar16()
{
}

StructChar16::StructChar16(
        const StructChar16& x)
{
    m_var_char16 = x.m_var_char16;
}

StructChar16::StructChar16(
        StructChar16&& x) noexcept 
{
    m_var_char16 = x.m_var_char16;
}

StructChar16& StructChar16::operator =(
        const StructChar16& x)
{

    m_var_char16 = x.m_var_char16;

    return *this;
}

StructChar16& StructChar16::operator =(
        StructChar16&& x) noexcept
{

    m_var_char16 = x.m_var_char16;

    return *this;
}

bool StructChar16::operator ==(
        const StructChar16& x) const
{

    return (m_var_char16 == x.m_var_char16);
}

bool StructChar16::operator !=(
        const StructChar16& x) const
{
    return !(*this == x);
}

size_t StructChar16::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructChar16_max_cdr_typesize;
}

size_t StructChar16::getCdrSerializedSize(
        const StructChar16& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void StructChar16::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_char16;
}

void StructChar16::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_char16;
}

/*!
 * @brief This function sets a value in member var_char16
 * @param _var_char16 New value for member var_char16
 */
void StructChar16::var_char16(
        wchar_t _var_char16)
{
    m_var_char16 = _var_char16;
}

/*!
 * @brief This function returns the value of member var_char16
 * @return Value of member var_char16
 */
wchar_t StructChar16::var_char16() const
{
    return m_var_char16;
}

/*!
 * @brief This function returns a reference to member var_char16
 * @return Reference to member var_char16
 */
wchar_t& StructChar16::var_char16()
{
    return m_var_char16;
}



size_t StructChar16::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructChar16_max_key_cdr_typesize;
}

bool StructChar16::isKeyDefined()
{
    return false;
}

void StructChar16::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructString::StructString()
{
    // string m_var_string
    m_var_string = "";


    // Just to register all known types
    registerstructuresTypes();
}

StructString::~StructString()
{
}

StructString::StructString(
        const StructString& x)
{
    m_var_string = x.m_var_string;
}

StructString::StructString(
        StructString&& x) noexcept 
{
    m_var_string = std::move(x.m_var_string);
}

StructString& StructString::operator =(
        const StructString& x)
{

    m_var_string = x.m_var_string;

    return *this;
}

StructString& StructString::operator =(
        StructString&& x) noexcept
{

    m_var_string = std::move(x.m_var_string);

    return *this;
}

bool StructString::operator ==(
        const StructString& x) const
{

    return (m_var_string == x.m_var_string);
}

bool StructString::operator !=(
        const StructString& x) const
{
    return !(*this == x);
}

size_t StructString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructString_max_cdr_typesize;
}

size_t StructString::getCdrSerializedSize(
        const StructString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_string().size() + 1;

    return current_alignment - initial_alignment;
}

void StructString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_string.c_str();
}

void StructString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_string;}

/*!
 * @brief This function copies the value in member var_string
 * @param _var_string New value to be copied in member var_string
 */
void StructString::var_string(
        const std::string& _var_string)
{
    m_var_string = _var_string;
}

/*!
 * @brief This function moves the value in member var_string
 * @param _var_string New value to be moved in member var_string
 */
void StructString::var_string(
        std::string&& _var_string)
{
    m_var_string = std::move(_var_string);
}

/*!
 * @brief This function returns a constant reference to member var_string
 * @return Constant reference to member var_string
 */
const std::string& StructString::var_string() const
{
    return m_var_string;
}

/*!
 * @brief This function returns a reference to member var_string
 * @return Reference to member var_string
 */
std::string& StructString::var_string()
{
    return m_var_string;
}


size_t StructString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructString_max_key_cdr_typesize;
}

bool StructString::isKeyDefined()
{
    return false;
}

void StructString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructWString::StructWString()
{
    // wstring m_var_wstring
    m_var_wstring = L"";


    // Just to register all known types
    registerstructuresTypes();
}

StructWString::~StructWString()
{
}

StructWString::StructWString(
        const StructWString& x)
{
    m_var_wstring = x.m_var_wstring;
}

StructWString::StructWString(
        StructWString&& x) noexcept 
{
    m_var_wstring = std::move(x.m_var_wstring);
}

StructWString& StructWString::operator =(
        const StructWString& x)
{

    m_var_wstring = x.m_var_wstring;

    return *this;
}

StructWString& StructWString::operator =(
        StructWString&& x) noexcept
{

    m_var_wstring = std::move(x.m_var_wstring);

    return *this;
}

bool StructWString::operator ==(
        const StructWString& x) const
{

    return (m_var_wstring == x.m_var_wstring);
}

bool StructWString::operator !=(
        const StructWString& x) const
{
    return !(*this == x);
}

size_t StructWString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructWString_max_cdr_typesize;
}

size_t StructWString::getCdrSerializedSize(
        const StructWString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.var_wstring().size()) * 4; // 32 bits

    return current_alignment - initial_alignment;
}

void StructWString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_wstring;
}

void StructWString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_wstring;
}

/*!
 * @brief This function copies the value in member var_wstring
 * @param _var_wstring New value to be copied in member var_wstring
 */
void StructWString::var_wstring(
        const std::wstring& _var_wstring)
{
    m_var_wstring = _var_wstring;
}

/*!
 * @brief This function moves the value in member var_wstring
 * @param _var_wstring New value to be moved in member var_wstring
 */
void StructWString::var_wstring(
        std::wstring&& _var_wstring)
{
    m_var_wstring = std::move(_var_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_wstring
 * @return Constant reference to member var_wstring
 */
const std::wstring& StructWString::var_wstring() const
{
    return m_var_wstring;
}

/*!
 * @brief This function returns a reference to member var_wstring
 * @return Reference to member var_wstring
 */
std::wstring& StructWString::var_wstring()
{
    return m_var_wstring;
}


size_t StructWString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructWString_max_key_cdr_typesize;
}

bool StructWString::isKeyDefined()
{
    return false;
}

void StructWString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructBoundedString::StructBoundedString()
{
    // Inner_alias_bounded_string_helper m_var_bounded_string
    m_var_bounded_string = "";


    // Just to register all known types
    registerstructuresTypes();
}

StructBoundedString::~StructBoundedString()
{
}

StructBoundedString::StructBoundedString(
        const StructBoundedString& x)
{
    m_var_bounded_string = x.m_var_bounded_string;
}

StructBoundedString::StructBoundedString(
        StructBoundedString&& x) noexcept 
{
    m_var_bounded_string = std::move(x.m_var_bounded_string);
}

StructBoundedString& StructBoundedString::operator =(
        const StructBoundedString& x)
{

    m_var_bounded_string = x.m_var_bounded_string;

    return *this;
}

StructBoundedString& StructBoundedString::operator =(
        StructBoundedString&& x) noexcept
{

    m_var_bounded_string = std::move(x.m_var_bounded_string);

    return *this;
}

bool StructBoundedString::operator ==(
        const StructBoundedString& x) const
{

    return (m_var_bounded_string == x.m_var_bounded_string);
}

bool StructBoundedString::operator !=(
        const StructBoundedString& x) const
{
    return !(*this == x);
}

size_t StructBoundedString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructBoundedString_max_cdr_typesize;
}

size_t StructBoundedString::getCdrSerializedSize(
        const StructBoundedString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_bounded_string().size() + 1;

    return current_alignment - initial_alignment;
}

void StructBoundedString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_bounded_string.c_str();
}

void StructBoundedString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        std::string aux;
        dcdr >> aux;
        m_var_bounded_string = aux.c_str();
    }}

/*!
 * @brief This function copies the value in member var_bounded_string
 * @param _var_bounded_string New value to be copied in member var_bounded_string
 */
void StructBoundedString::var_bounded_string(
        const Inner_alias_bounded_string_helper& _var_bounded_string)
{
    m_var_bounded_string = _var_bounded_string;
}

/*!
 * @brief This function moves the value in member var_bounded_string
 * @param _var_bounded_string New value to be moved in member var_bounded_string
 */
void StructBoundedString::var_bounded_string(
        Inner_alias_bounded_string_helper&& _var_bounded_string)
{
    m_var_bounded_string = std::move(_var_bounded_string);
}

/*!
 * @brief This function returns a constant reference to member var_bounded_string
 * @return Constant reference to member var_bounded_string
 */
const Inner_alias_bounded_string_helper& StructBoundedString::var_bounded_string() const
{
    return m_var_bounded_string;
}

/*!
 * @brief This function returns a reference to member var_bounded_string
 * @return Reference to member var_bounded_string
 */
Inner_alias_bounded_string_helper& StructBoundedString::var_bounded_string()
{
    return m_var_bounded_string;
}


size_t StructBoundedString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructBoundedString_max_key_cdr_typesize;
}

bool StructBoundedString::isKeyDefined()
{
    return false;
}

void StructBoundedString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructBoundedWString::StructBoundedWString()
{
    // Inner_alias_bounded_wstring_helper m_var_bounded_wstring
    m_var_bounded_wstring = L"";


    // Just to register all known types
    registerstructuresTypes();
}

StructBoundedWString::~StructBoundedWString()
{
}

StructBoundedWString::StructBoundedWString(
        const StructBoundedWString& x)
{
    m_var_bounded_wstring = x.m_var_bounded_wstring;
}

StructBoundedWString::StructBoundedWString(
        StructBoundedWString&& x) noexcept 
{
    m_var_bounded_wstring = std::move(x.m_var_bounded_wstring);
}

StructBoundedWString& StructBoundedWString::operator =(
        const StructBoundedWString& x)
{

    m_var_bounded_wstring = x.m_var_bounded_wstring;

    return *this;
}

StructBoundedWString& StructBoundedWString::operator =(
        StructBoundedWString&& x) noexcept
{

    m_var_bounded_wstring = std::move(x.m_var_bounded_wstring);

    return *this;
}

bool StructBoundedWString::operator ==(
        const StructBoundedWString& x) const
{

    return (m_var_bounded_wstring == x.m_var_bounded_wstring);
}

bool StructBoundedWString::operator !=(
        const StructBoundedWString& x) const
{
    return !(*this == x);
}

size_t StructBoundedWString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructBoundedWString_max_cdr_typesize;
}

size_t StructBoundedWString::getCdrSerializedSize(
        const StructBoundedWString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.var_bounded_wstring().size()) * 4; // 32 bits

    return current_alignment - initial_alignment;
}

void StructBoundedWString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_bounded_wstring;
}

void StructBoundedWString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_bounded_wstring;
}

/*!
 * @brief This function copies the value in member var_bounded_wstring
 * @param _var_bounded_wstring New value to be copied in member var_bounded_wstring
 */
void StructBoundedWString::var_bounded_wstring(
        const Inner_alias_bounded_wstring_helper& _var_bounded_wstring)
{
    m_var_bounded_wstring = _var_bounded_wstring;
}

/*!
 * @brief This function moves the value in member var_bounded_wstring
 * @param _var_bounded_wstring New value to be moved in member var_bounded_wstring
 */
void StructBoundedWString::var_bounded_wstring(
        Inner_alias_bounded_wstring_helper&& _var_bounded_wstring)
{
    m_var_bounded_wstring = std::move(_var_bounded_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_bounded_wstring
 * @return Constant reference to member var_bounded_wstring
 */
const Inner_alias_bounded_wstring_helper& StructBoundedWString::var_bounded_wstring() const
{
    return m_var_bounded_wstring;
}

/*!
 * @brief This function returns a reference to member var_bounded_wstring
 * @return Reference to member var_bounded_wstring
 */
Inner_alias_bounded_wstring_helper& StructBoundedWString::var_bounded_wstring()
{
    return m_var_bounded_wstring;
}


size_t StructBoundedWString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructBoundedWString_max_key_cdr_typesize;
}

bool StructBoundedWString::isKeyDefined()
{
    return false;
}

void StructBoundedWString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructEnum::StructEnum()
{
    // InnerEnumHelper m_var_enum
    m_var_enum = ::ENUM_VALUE_1;

    // Just to register all known types
    registerstructuresTypes();
}

StructEnum::~StructEnum()
{
}

StructEnum::StructEnum(
        const StructEnum& x)
{
    m_var_enum = x.m_var_enum;
}

StructEnum::StructEnum(
        StructEnum&& x) noexcept 
{
    m_var_enum = x.m_var_enum;
}

StructEnum& StructEnum::operator =(
        const StructEnum& x)
{

    m_var_enum = x.m_var_enum;

    return *this;
}

StructEnum& StructEnum::operator =(
        StructEnum&& x) noexcept
{

    m_var_enum = x.m_var_enum;

    return *this;
}

bool StructEnum::operator ==(
        const StructEnum& x) const
{

    return (m_var_enum == x.m_var_enum);
}

bool StructEnum::operator !=(
        const StructEnum& x) const
{
    return !(*this == x);
}

size_t StructEnum::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructEnum_max_cdr_typesize;
}

size_t StructEnum::getCdrSerializedSize(
        const StructEnum& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void StructEnum::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint32_t)m_var_enum;
}

void StructEnum::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_var_enum = (InnerEnumHelper)enum_value;
    }

}

/*!
 * @brief This function sets a value in member var_enum
 * @param _var_enum New value for member var_enum
 */
void StructEnum::var_enum(
        InnerEnumHelper _var_enum)
{
    m_var_enum = _var_enum;
}

/*!
 * @brief This function returns the value of member var_enum
 * @return Value of member var_enum
 */
InnerEnumHelper StructEnum::var_enum() const
{
    return m_var_enum;
}

/*!
 * @brief This function returns a reference to member var_enum
 * @return Reference to member var_enum
 */
InnerEnumHelper& StructEnum::var_enum()
{
    return m_var_enum;
}



size_t StructEnum::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructEnum_max_key_cdr_typesize;
}

bool StructEnum::isKeyDefined()
{
    return false;
}

void StructEnum::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructBitMask::StructBitMask()
{
    // InnerBitMaskHelper m_var_bitmask
    m_var_bitmask = static_cast<InnerBitMaskHelper>(0);

    // Just to register all known types
    registerstructuresTypes();
}

StructBitMask::~StructBitMask()
{
}

StructBitMask::StructBitMask(
        const StructBitMask& x)
{
    m_var_bitmask = x.m_var_bitmask;
}

StructBitMask::StructBitMask(
        StructBitMask&& x) noexcept 
{
    m_var_bitmask = x.m_var_bitmask;
}

StructBitMask& StructBitMask::operator =(
        const StructBitMask& x)
{

    m_var_bitmask = x.m_var_bitmask;

    return *this;
}

StructBitMask& StructBitMask::operator =(
        StructBitMask&& x) noexcept
{

    m_var_bitmask = x.m_var_bitmask;

    return *this;
}

bool StructBitMask::operator ==(
        const StructBitMask& x) const
{

    return (m_var_bitmask == x.m_var_bitmask);
}

bool StructBitMask::operator !=(
        const StructBitMask& x) const
{
    return !(*this == x);
}

size_t StructBitMask::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructBitMask_max_cdr_typesize;
}

size_t StructBitMask::getCdrSerializedSize(
        const StructBitMask& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void StructBitMask::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint32_t)m_var_bitmask;
}

void StructBitMask::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint32_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_var_bitmask = (InnerBitMaskHelper)bitmask_value;
    }

}

/*!
 * @brief This function sets a value in member var_bitmask
 * @param _var_bitmask New value for member var_bitmask
 */
void StructBitMask::var_bitmask(
        InnerBitMaskHelper _var_bitmask)
{
    m_var_bitmask = _var_bitmask;
}

/*!
 * @brief This function returns the value of member var_bitmask
 * @return Value of member var_bitmask
 */
InnerBitMaskHelper StructBitMask::var_bitmask() const
{
    return m_var_bitmask;
}

/*!
 * @brief This function returns a reference to member var_bitmask
 * @return Reference to member var_bitmask
 */
InnerBitMaskHelper& StructBitMask::var_bitmask()
{
    return m_var_bitmask;
}



size_t StructBitMask::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructBitMask_max_key_cdr_typesize;
}

bool StructBitMask::isKeyDefined()
{
    return false;
}

void StructBitMask::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructAlias::StructAlias()
{
    // InnerAliasHelper m_var_alias
    m_var_alias = 0;

    // Just to register all known types
    registerstructuresTypes();
}

StructAlias::~StructAlias()
{
}

StructAlias::StructAlias(
        const StructAlias& x)
{
    m_var_alias = x.m_var_alias;
}

StructAlias::StructAlias(
        StructAlias&& x) noexcept 
{
    m_var_alias = x.m_var_alias;
}

StructAlias& StructAlias::operator =(
        const StructAlias& x)
{

    m_var_alias = x.m_var_alias;

    return *this;
}

StructAlias& StructAlias::operator =(
        StructAlias&& x) noexcept
{

    m_var_alias = x.m_var_alias;

    return *this;
}

bool StructAlias::operator ==(
        const StructAlias& x) const
{

    return (m_var_alias == x.m_var_alias);
}

bool StructAlias::operator !=(
        const StructAlias& x) const
{
    return !(*this == x);
}

size_t StructAlias::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructAlias_max_cdr_typesize;
}

size_t StructAlias::getCdrSerializedSize(
        const StructAlias& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void StructAlias::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_alias;
}

void StructAlias::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_alias;
}

/*!
 * @brief This function sets a value in member var_alias
 * @param _var_alias New value for member var_alias
 */
void StructAlias::var_alias(
        InnerAliasHelper _var_alias)
{
    m_var_alias = _var_alias;
}

/*!
 * @brief This function returns the value of member var_alias
 * @return Value of member var_alias
 */
InnerAliasHelper StructAlias::var_alias() const
{
    return m_var_alias;
}

/*!
 * @brief This function returns a reference to member var_alias
 * @return Reference to member var_alias
 */
InnerAliasHelper& StructAlias::var_alias()
{
    return m_var_alias;
}



size_t StructAlias::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructAlias_max_key_cdr_typesize;
}

bool StructAlias::isKeyDefined()
{
    return false;
}

void StructAlias::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructShortArray::StructShortArray()
{
    // short m_var_array_short
    memset(&m_var_array_short, 0, (10) * 2);


    // Just to register all known types
    registerstructuresTypes();
}

StructShortArray::~StructShortArray()
{
}

StructShortArray::StructShortArray(
        const StructShortArray& x)
{
    m_var_array_short = x.m_var_array_short;
}

StructShortArray::StructShortArray(
        StructShortArray&& x) noexcept 
{
    m_var_array_short = std::move(x.m_var_array_short);
}

StructShortArray& StructShortArray::operator =(
        const StructShortArray& x)
{

    m_var_array_short = x.m_var_array_short;

    return *this;
}

StructShortArray& StructShortArray::operator =(
        StructShortArray&& x) noexcept
{

    m_var_array_short = std::move(x.m_var_array_short);

    return *this;
}

bool StructShortArray::operator ==(
        const StructShortArray& x) const
{

    return (m_var_array_short == x.m_var_array_short);
}

bool StructShortArray::operator !=(
        const StructShortArray& x) const
{
    return !(*this == x);
}

size_t StructShortArray::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructShortArray_max_cdr_typesize;
}

size_t StructShortArray::getCdrSerializedSize(
        const StructShortArray& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void StructShortArray::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_short;

}

void StructShortArray::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_short;

}

/*!
 * @brief This function copies the value in member var_array_short
 * @param _var_array_short New value to be copied in member var_array_short
 */
void StructShortArray::var_array_short(
        const std::array<int16_t, 10>& _var_array_short)
{
    m_var_array_short = _var_array_short;
}

/*!
 * @brief This function moves the value in member var_array_short
 * @param _var_array_short New value to be moved in member var_array_short
 */
void StructShortArray::var_array_short(
        std::array<int16_t, 10>&& _var_array_short)
{
    m_var_array_short = std::move(_var_array_short);
}

/*!
 * @brief This function returns a constant reference to member var_array_short
 * @return Constant reference to member var_array_short
 */
const std::array<int16_t, 10>& StructShortArray::var_array_short() const
{
    return m_var_array_short;
}

/*!
 * @brief This function returns a reference to member var_array_short
 * @return Reference to member var_array_short
 */
std::array<int16_t, 10>& StructShortArray::var_array_short()
{
    return m_var_array_short;
}


size_t StructShortArray::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructShortArray_max_key_cdr_typesize;
}

bool StructShortArray::isKeyDefined()
{
    return false;
}

void StructShortArray::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructSequence::StructSequence()
{
    // sequence<long> m_var_sequence


    // Just to register all known types
    registerstructuresTypes();
}

StructSequence::~StructSequence()
{
}

StructSequence::StructSequence(
        const StructSequence& x)
{
    m_var_sequence = x.m_var_sequence;
}

StructSequence::StructSequence(
        StructSequence&& x) noexcept 
{
    m_var_sequence = std::move(x.m_var_sequence);
}

StructSequence& StructSequence::operator =(
        const StructSequence& x)
{

    m_var_sequence = x.m_var_sequence;

    return *this;
}

StructSequence& StructSequence::operator =(
        StructSequence&& x) noexcept
{

    m_var_sequence = std::move(x.m_var_sequence);

    return *this;
}

bool StructSequence::operator ==(
        const StructSequence& x) const
{

    return (m_var_sequence == x.m_var_sequence);
}

bool StructSequence::operator !=(
        const StructSequence& x) const
{
    return !(*this == x);
}

size_t StructSequence::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructSequence_max_cdr_typesize;
}

size_t StructSequence::getCdrSerializedSize(
        const StructSequence& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence().size() > 0)
    {
        current_alignment += (data.var_sequence().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    return current_alignment - initial_alignment;
}

void StructSequence::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence;
}

void StructSequence::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence;}

/*!
 * @brief This function copies the value in member var_sequence
 * @param _var_sequence New value to be copied in member var_sequence
 */
void StructSequence::var_sequence(
        const std::vector<int32_t>& _var_sequence)
{
    m_var_sequence = _var_sequence;
}

/*!
 * @brief This function moves the value in member var_sequence
 * @param _var_sequence New value to be moved in member var_sequence
 */
void StructSequence::var_sequence(
        std::vector<int32_t>&& _var_sequence)
{
    m_var_sequence = std::move(_var_sequence);
}

/*!
 * @brief This function returns a constant reference to member var_sequence
 * @return Constant reference to member var_sequence
 */
const std::vector<int32_t>& StructSequence::var_sequence() const
{
    return m_var_sequence;
}

/*!
 * @brief This function returns a reference to member var_sequence
 * @return Reference to member var_sequence
 */
std::vector<int32_t>& StructSequence::var_sequence()
{
    return m_var_sequence;
}


size_t StructSequence::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructSequence_max_key_cdr_typesize;
}

bool StructSequence::isKeyDefined()
{
    return false;
}

void StructSequence::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructMap::StructMap()
{
    // map<long, long> m_var_map


    // Just to register all known types
    registerstructuresTypes();
}

StructMap::~StructMap()
{
}

StructMap::StructMap(
        const StructMap& x)
{
    m_var_map = x.m_var_map;
}

StructMap::StructMap(
        StructMap&& x) noexcept 
{
    m_var_map = std::move(x.m_var_map);
}

StructMap& StructMap::operator =(
        const StructMap& x)
{

    m_var_map = x.m_var_map;

    return *this;
}

StructMap& StructMap::operator =(
        StructMap&& x) noexcept
{

    m_var_map = std::move(x.m_var_map);

    return *this;
}

bool StructMap::operator ==(
        const StructMap& x) const
{

    return (m_var_map == x.m_var_map);
}

bool StructMap::operator !=(
        const StructMap& x) const
{
    return !(*this == x);
}

size_t StructMap::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructMap_max_cdr_typesize;
}

size_t StructMap::getCdrSerializedSize(
        const StructMap& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.var_map())
    {
        (void)a;

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }

    return current_alignment - initial_alignment;
}

void StructMap::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << static_cast<uint32_t>(m_var_map.size());
    for (const auto& pair : m_var_map)
    {
        scdr << pair.first;    scdr << pair.second;}}

void StructMap::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{


        dcdr >> m_var_map;
}

/*!
 * @brief This function copies the value in member var_map
 * @param _var_map New value to be copied in member var_map
 */
void StructMap::var_map(
        const std::map<int32_t, int32_t>& _var_map)
{
    m_var_map = _var_map;
}

/*!
 * @brief This function moves the value in member var_map
 * @param _var_map New value to be moved in member var_map
 */
void StructMap::var_map(
        std::map<int32_t, int32_t>&& _var_map)
{
    m_var_map = std::move(_var_map);
}

/*!
 * @brief This function returns a constant reference to member var_map
 * @return Constant reference to member var_map
 */
const std::map<int32_t, int32_t>& StructMap::var_map() const
{
    return m_var_map;
}

/*!
 * @brief This function returns a reference to member var_map
 * @return Reference to member var_map
 */
std::map<int32_t, int32_t>& StructMap::var_map()
{
    return m_var_map;
}


size_t StructMap::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructMap_max_key_cdr_typesize;
}

bool StructMap::isKeyDefined()
{
    return false;
}

void StructMap::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructUnion::StructUnion()
{
    // InnerUnionHelper m_var_union


    // Just to register all known types
    registerstructuresTypes();
}

StructUnion::~StructUnion()
{
}

StructUnion::StructUnion(
        const StructUnion& x)
{
    m_var_union = x.m_var_union;
}

StructUnion::StructUnion(
        StructUnion&& x) noexcept 
{
    m_var_union = std::move(x.m_var_union);
}

StructUnion& StructUnion::operator =(
        const StructUnion& x)
{

    m_var_union = x.m_var_union;

    return *this;
}

StructUnion& StructUnion::operator =(
        StructUnion&& x) noexcept
{

    m_var_union = std::move(x.m_var_union);

    return *this;
}

bool StructUnion::operator ==(
        const StructUnion& x) const
{

    return (m_var_union == x.m_var_union);
}

bool StructUnion::operator !=(
        const StructUnion& x) const
{
    return !(*this == x);
}

size_t StructUnion::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructUnion_max_cdr_typesize;
}

size_t StructUnion::getCdrSerializedSize(
        const StructUnion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += InnerUnionHelper::getCdrSerializedSize(data.var_union(), current_alignment);

    return current_alignment - initial_alignment;
}

void StructUnion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union;
}

void StructUnion::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union;
}

/*!
 * @brief This function copies the value in member var_union
 * @param _var_union New value to be copied in member var_union
 */
void StructUnion::var_union(
        const InnerUnionHelper& _var_union)
{
    m_var_union = _var_union;
}

/*!
 * @brief This function moves the value in member var_union
 * @param _var_union New value to be moved in member var_union
 */
void StructUnion::var_union(
        InnerUnionHelper&& _var_union)
{
    m_var_union = std::move(_var_union);
}

/*!
 * @brief This function returns a constant reference to member var_union
 * @return Constant reference to member var_union
 */
const InnerUnionHelper& StructUnion::var_union() const
{
    return m_var_union;
}

/*!
 * @brief This function returns a reference to member var_union
 * @return Reference to member var_union
 */
InnerUnionHelper& StructUnion::var_union()
{
    return m_var_union;
}


size_t StructUnion::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructUnion_max_key_cdr_typesize;
}

bool StructUnion::isKeyDefined()
{
    return false;
}

void StructUnion::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructStructure::StructStructure()
{
    // InnerStructureHelper m_var_structure


    // Just to register all known types
    registerstructuresTypes();
}

StructStructure::~StructStructure()
{
}

StructStructure::StructStructure(
        const StructStructure& x)
{
    m_var_structure = x.m_var_structure;
}

StructStructure::StructStructure(
        StructStructure&& x) noexcept 
{
    m_var_structure = std::move(x.m_var_structure);
}

StructStructure& StructStructure::operator =(
        const StructStructure& x)
{

    m_var_structure = x.m_var_structure;

    return *this;
}

StructStructure& StructStructure::operator =(
        StructStructure&& x) noexcept
{

    m_var_structure = std::move(x.m_var_structure);

    return *this;
}

bool StructStructure::operator ==(
        const StructStructure& x) const
{

    return (m_var_structure == x.m_var_structure);
}

bool StructStructure::operator !=(
        const StructStructure& x) const
{
    return !(*this == x);
}

size_t StructStructure::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructStructure_max_cdr_typesize;
}

size_t StructStructure::getCdrSerializedSize(
        const StructStructure& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += InnerStructureHelper::getCdrSerializedSize(data.var_structure(), current_alignment);

    return current_alignment - initial_alignment;
}

void StructStructure::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_structure;
}

void StructStructure::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_structure;
}

/*!
 * @brief This function copies the value in member var_structure
 * @param _var_structure New value to be copied in member var_structure
 */
void StructStructure::var_structure(
        const InnerStructureHelper& _var_structure)
{
    m_var_structure = _var_structure;
}

/*!
 * @brief This function moves the value in member var_structure
 * @param _var_structure New value to be moved in member var_structure
 */
void StructStructure::var_structure(
        InnerStructureHelper&& _var_structure)
{
    m_var_structure = std::move(_var_structure);
}

/*!
 * @brief This function returns a constant reference to member var_structure
 * @return Constant reference to member var_structure
 */
const InnerStructureHelper& StructStructure::var_structure() const
{
    return m_var_structure;
}

/*!
 * @brief This function returns a reference to member var_structure
 * @return Reference to member var_structure
 */
InnerStructureHelper& StructStructure::var_structure()
{
    return m_var_structure;
}


size_t StructStructure::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructStructure_max_key_cdr_typesize;
}

bool StructStructure::isKeyDefined()
{
    return false;
}

void StructStructure::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructBitset::StructBitset()
{
    // InnerBitsetHelper m_var_bitset


    // Just to register all known types
    registerstructuresTypes();
}

StructBitset::~StructBitset()
{
}

StructBitset::StructBitset(
        const StructBitset& x)
{
    m_var_bitset = x.m_var_bitset;
}

StructBitset::StructBitset(
        StructBitset&& x) noexcept 
{
    m_var_bitset = std::move(x.m_var_bitset);
}

StructBitset& StructBitset::operator =(
        const StructBitset& x)
{

    m_var_bitset = x.m_var_bitset;

    return *this;
}

StructBitset& StructBitset::operator =(
        StructBitset&& x) noexcept
{

    m_var_bitset = std::move(x.m_var_bitset);

    return *this;
}

bool StructBitset::operator ==(
        const StructBitset& x) const
{

    return (m_var_bitset == x.m_var_bitset);
}

bool StructBitset::operator !=(
        const StructBitset& x) const
{
    return !(*this == x);
}

size_t StructBitset::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructBitset_max_cdr_typesize;
}

size_t StructBitset::getCdrSerializedSize(
        const StructBitset& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += InnerBitsetHelper::getCdrSerializedSize(data.var_bitset(), current_alignment);

    return current_alignment - initial_alignment;
}

void StructBitset::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_bitset;
}

void StructBitset::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_bitset;
}

/*!
 * @brief This function copies the value in member var_bitset
 * @param _var_bitset New value to be copied in member var_bitset
 */
void StructBitset::var_bitset(
        const InnerBitsetHelper& _var_bitset)
{
    m_var_bitset = _var_bitset;
}

/*!
 * @brief This function moves the value in member var_bitset
 * @param _var_bitset New value to be moved in member var_bitset
 */
void StructBitset::var_bitset(
        InnerBitsetHelper&& _var_bitset)
{
    m_var_bitset = std::move(_var_bitset);
}

/*!
 * @brief This function returns a constant reference to member var_bitset
 * @return Constant reference to member var_bitset
 */
const InnerBitsetHelper& StructBitset::var_bitset() const
{
    return m_var_bitset;
}

/*!
 * @brief This function returns a reference to member var_bitset
 * @return Reference to member var_bitset
 */
InnerBitsetHelper& StructBitset::var_bitset()
{
    return m_var_bitset;
}


size_t StructBitset::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructBitset_max_key_cdr_typesize;
}

bool StructBitset::isKeyDefined()
{
    return false;
}

void StructBitset::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructEmpty::StructEmpty()
{

    // Just to register all known types
    registerstructuresTypes();
}

StructEmpty::~StructEmpty()
{
}

StructEmpty::StructEmpty(
        const StructEmpty& x)
{
}

StructEmpty::StructEmpty(
        StructEmpty&& x) noexcept 
{
}

StructEmpty& StructEmpty::operator =(
        const StructEmpty& x)
{


    return *this;
}

StructEmpty& StructEmpty::operator =(
        StructEmpty&& x) noexcept
{


    return *this;
}

bool StructEmpty::operator ==(
        const StructEmpty& x) const
{

    return true;
}

bool StructEmpty::operator !=(
        const StructEmpty& x) const
{
    return !(*this == x);
}

size_t StructEmpty::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructEmpty_max_cdr_typesize;
}

size_t StructEmpty::getCdrSerializedSize(
        const StructEmpty& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    return current_alignment - initial_alignment;
}

void StructEmpty::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

}

void StructEmpty::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

}



size_t StructEmpty::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructEmpty_max_key_cdr_typesize;
}

bool StructEmpty::isKeyDefined()
{
    return false;
}

void StructEmpty::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


Structures::Structures()
{
    // StructShort m_var_StructShort

    // StructUnsignedShort m_var_StructUnsignedShort

    // StructLong m_var_StructLong

    // StructUnsignedLong m_var_StructUnsignedLong

    // StructLongLong m_var_StructLongLong

    // StructUnsignedLongLong m_var_StructUnsignedLongLong

    // StructFloat m_var_StructFloat

    // StructDouble m_var_StructDouble

    // StructLongDouble m_var_StructLongDouble

    // StructBoolean m_var_StructBoolean

    // StructOctet m_var_StructOctet

    // StructChar8 m_var_StructChar8

    // StructChar16 m_var_StructChar16

    // StructString m_var_StructString

    // StructWString m_var_StructWString

    // StructEnum m_var_StructEnum

    // StructBitMask m_var_StructBitMask

    // StructAlias m_var_StructAlias

    // StructShortArray m_var_StructShortArray

    // StructSequence m_var_StructSequence

    // StructMap m_var_StructMap

    // StructUnion m_var_StructUnion

    // StructStructure m_var_StructStructure

    // StructBitset m_var_StructBitset

    // StructEmpty m_var_StructEmpty


    // Just to register all known types
    registerstructuresTypes();
}

Structures::~Structures()
{

























}

Structures::Structures(
        const Structures& x)
{
    m_var_StructShort = x.m_var_StructShort;
    m_var_StructUnsignedShort = x.m_var_StructUnsignedShort;
    m_var_StructLong = x.m_var_StructLong;
    m_var_StructUnsignedLong = x.m_var_StructUnsignedLong;
    m_var_StructLongLong = x.m_var_StructLongLong;
    m_var_StructUnsignedLongLong = x.m_var_StructUnsignedLongLong;
    m_var_StructFloat = x.m_var_StructFloat;
    m_var_StructDouble = x.m_var_StructDouble;
    m_var_StructLongDouble = x.m_var_StructLongDouble;
    m_var_StructBoolean = x.m_var_StructBoolean;
    m_var_StructOctet = x.m_var_StructOctet;
    m_var_StructChar8 = x.m_var_StructChar8;
    m_var_StructChar16 = x.m_var_StructChar16;
    m_var_StructString = x.m_var_StructString;
    m_var_StructWString = x.m_var_StructWString;
    m_var_StructEnum = x.m_var_StructEnum;
    m_var_StructBitMask = x.m_var_StructBitMask;
    m_var_StructAlias = x.m_var_StructAlias;
    m_var_StructShortArray = x.m_var_StructShortArray;
    m_var_StructSequence = x.m_var_StructSequence;
    m_var_StructMap = x.m_var_StructMap;
    m_var_StructUnion = x.m_var_StructUnion;
    m_var_StructStructure = x.m_var_StructStructure;
    m_var_StructBitset = x.m_var_StructBitset;
    m_var_StructEmpty = x.m_var_StructEmpty;
}

Structures::Structures(
        Structures&& x) noexcept 
{
    m_var_StructShort = std::move(x.m_var_StructShort);
    m_var_StructUnsignedShort = std::move(x.m_var_StructUnsignedShort);
    m_var_StructLong = std::move(x.m_var_StructLong);
    m_var_StructUnsignedLong = std::move(x.m_var_StructUnsignedLong);
    m_var_StructLongLong = std::move(x.m_var_StructLongLong);
    m_var_StructUnsignedLongLong = std::move(x.m_var_StructUnsignedLongLong);
    m_var_StructFloat = std::move(x.m_var_StructFloat);
    m_var_StructDouble = std::move(x.m_var_StructDouble);
    m_var_StructLongDouble = std::move(x.m_var_StructLongDouble);
    m_var_StructBoolean = std::move(x.m_var_StructBoolean);
    m_var_StructOctet = std::move(x.m_var_StructOctet);
    m_var_StructChar8 = std::move(x.m_var_StructChar8);
    m_var_StructChar16 = std::move(x.m_var_StructChar16);
    m_var_StructString = std::move(x.m_var_StructString);
    m_var_StructWString = std::move(x.m_var_StructWString);
    m_var_StructEnum = std::move(x.m_var_StructEnum);
    m_var_StructBitMask = std::move(x.m_var_StructBitMask);
    m_var_StructAlias = std::move(x.m_var_StructAlias);
    m_var_StructShortArray = std::move(x.m_var_StructShortArray);
    m_var_StructSequence = std::move(x.m_var_StructSequence);
    m_var_StructMap = std::move(x.m_var_StructMap);
    m_var_StructUnion = std::move(x.m_var_StructUnion);
    m_var_StructStructure = std::move(x.m_var_StructStructure);
    m_var_StructBitset = std::move(x.m_var_StructBitset);
    m_var_StructEmpty = std::move(x.m_var_StructEmpty);
}

Structures& Structures::operator =(
        const Structures& x)
{

    m_var_StructShort = x.m_var_StructShort;
    m_var_StructUnsignedShort = x.m_var_StructUnsignedShort;
    m_var_StructLong = x.m_var_StructLong;
    m_var_StructUnsignedLong = x.m_var_StructUnsignedLong;
    m_var_StructLongLong = x.m_var_StructLongLong;
    m_var_StructUnsignedLongLong = x.m_var_StructUnsignedLongLong;
    m_var_StructFloat = x.m_var_StructFloat;
    m_var_StructDouble = x.m_var_StructDouble;
    m_var_StructLongDouble = x.m_var_StructLongDouble;
    m_var_StructBoolean = x.m_var_StructBoolean;
    m_var_StructOctet = x.m_var_StructOctet;
    m_var_StructChar8 = x.m_var_StructChar8;
    m_var_StructChar16 = x.m_var_StructChar16;
    m_var_StructString = x.m_var_StructString;
    m_var_StructWString = x.m_var_StructWString;
    m_var_StructEnum = x.m_var_StructEnum;
    m_var_StructBitMask = x.m_var_StructBitMask;
    m_var_StructAlias = x.m_var_StructAlias;
    m_var_StructShortArray = x.m_var_StructShortArray;
    m_var_StructSequence = x.m_var_StructSequence;
    m_var_StructMap = x.m_var_StructMap;
    m_var_StructUnion = x.m_var_StructUnion;
    m_var_StructStructure = x.m_var_StructStructure;
    m_var_StructBitset = x.m_var_StructBitset;
    m_var_StructEmpty = x.m_var_StructEmpty;

    return *this;
}

Structures& Structures::operator =(
        Structures&& x) noexcept
{

    m_var_StructShort = std::move(x.m_var_StructShort);
    m_var_StructUnsignedShort = std::move(x.m_var_StructUnsignedShort);
    m_var_StructLong = std::move(x.m_var_StructLong);
    m_var_StructUnsignedLong = std::move(x.m_var_StructUnsignedLong);
    m_var_StructLongLong = std::move(x.m_var_StructLongLong);
    m_var_StructUnsignedLongLong = std::move(x.m_var_StructUnsignedLongLong);
    m_var_StructFloat = std::move(x.m_var_StructFloat);
    m_var_StructDouble = std::move(x.m_var_StructDouble);
    m_var_StructLongDouble = std::move(x.m_var_StructLongDouble);
    m_var_StructBoolean = std::move(x.m_var_StructBoolean);
    m_var_StructOctet = std::move(x.m_var_StructOctet);
    m_var_StructChar8 = std::move(x.m_var_StructChar8);
    m_var_StructChar16 = std::move(x.m_var_StructChar16);
    m_var_StructString = std::move(x.m_var_StructString);
    m_var_StructWString = std::move(x.m_var_StructWString);
    m_var_StructEnum = std::move(x.m_var_StructEnum);
    m_var_StructBitMask = std::move(x.m_var_StructBitMask);
    m_var_StructAlias = std::move(x.m_var_StructAlias);
    m_var_StructShortArray = std::move(x.m_var_StructShortArray);
    m_var_StructSequence = std::move(x.m_var_StructSequence);
    m_var_StructMap = std::move(x.m_var_StructMap);
    m_var_StructUnion = std::move(x.m_var_StructUnion);
    m_var_StructStructure = std::move(x.m_var_StructStructure);
    m_var_StructBitset = std::move(x.m_var_StructBitset);
    m_var_StructEmpty = std::move(x.m_var_StructEmpty);

    return *this;
}

bool Structures::operator ==(
        const Structures& x) const
{

    return (m_var_StructShort == x.m_var_StructShort && m_var_StructUnsignedShort == x.m_var_StructUnsignedShort && m_var_StructLong == x.m_var_StructLong && m_var_StructUnsignedLong == x.m_var_StructUnsignedLong && m_var_StructLongLong == x.m_var_StructLongLong && m_var_StructUnsignedLongLong == x.m_var_StructUnsignedLongLong && m_var_StructFloat == x.m_var_StructFloat && m_var_StructDouble == x.m_var_StructDouble && m_var_StructLongDouble == x.m_var_StructLongDouble && m_var_StructBoolean == x.m_var_StructBoolean && m_var_StructOctet == x.m_var_StructOctet && m_var_StructChar8 == x.m_var_StructChar8 && m_var_StructChar16 == x.m_var_StructChar16 && m_var_StructString == x.m_var_StructString && m_var_StructWString == x.m_var_StructWString && m_var_StructEnum == x.m_var_StructEnum && m_var_StructBitMask == x.m_var_StructBitMask && m_var_StructAlias == x.m_var_StructAlias && m_var_StructShortArray == x.m_var_StructShortArray && m_var_StructSequence == x.m_var_StructSequence && m_var_StructMap == x.m_var_StructMap && m_var_StructUnion == x.m_var_StructUnion && m_var_StructStructure == x.m_var_StructStructure && m_var_StructBitset == x.m_var_StructBitset && m_var_StructEmpty == x.m_var_StructEmpty);
}

bool Structures::operator !=(
        const Structures& x) const
{
    return !(*this == x);
}

size_t Structures::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Structures_max_cdr_typesize;
}

size_t Structures::getCdrSerializedSize(
        const Structures& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += StructShort::getCdrSerializedSize(data.var_StructShort(), current_alignment);
    current_alignment += StructUnsignedShort::getCdrSerializedSize(data.var_StructUnsignedShort(), current_alignment);
    current_alignment += StructLong::getCdrSerializedSize(data.var_StructLong(), current_alignment);
    current_alignment += StructUnsignedLong::getCdrSerializedSize(data.var_StructUnsignedLong(), current_alignment);
    current_alignment += StructLongLong::getCdrSerializedSize(data.var_StructLongLong(), current_alignment);
    current_alignment += StructUnsignedLongLong::getCdrSerializedSize(data.var_StructUnsignedLongLong(), current_alignment);
    current_alignment += StructFloat::getCdrSerializedSize(data.var_StructFloat(), current_alignment);
    current_alignment += StructDouble::getCdrSerializedSize(data.var_StructDouble(), current_alignment);
    current_alignment += StructLongDouble::getCdrSerializedSize(data.var_StructLongDouble(), current_alignment);
    current_alignment += StructBoolean::getCdrSerializedSize(data.var_StructBoolean(), current_alignment);
    current_alignment += StructOctet::getCdrSerializedSize(data.var_StructOctet(), current_alignment);
    current_alignment += StructChar8::getCdrSerializedSize(data.var_StructChar8(), current_alignment);
    current_alignment += StructChar16::getCdrSerializedSize(data.var_StructChar16(), current_alignment);
    current_alignment += StructString::getCdrSerializedSize(data.var_StructString(), current_alignment);
    current_alignment += StructWString::getCdrSerializedSize(data.var_StructWString(), current_alignment);
    current_alignment += StructEnum::getCdrSerializedSize(data.var_StructEnum(), current_alignment);
    current_alignment += StructBitMask::getCdrSerializedSize(data.var_StructBitMask(), current_alignment);
    current_alignment += StructAlias::getCdrSerializedSize(data.var_StructAlias(), current_alignment);
    current_alignment += StructShortArray::getCdrSerializedSize(data.var_StructShortArray(), current_alignment);
    current_alignment += StructSequence::getCdrSerializedSize(data.var_StructSequence(), current_alignment);
    current_alignment += StructMap::getCdrSerializedSize(data.var_StructMap(), current_alignment);
    current_alignment += StructUnion::getCdrSerializedSize(data.var_StructUnion(), current_alignment);
    current_alignment += StructStructure::getCdrSerializedSize(data.var_StructStructure(), current_alignment);
    current_alignment += StructBitset::getCdrSerializedSize(data.var_StructBitset(), current_alignment);
    current_alignment += StructEmpty::getCdrSerializedSize(data.var_StructEmpty(), current_alignment);

    return current_alignment - initial_alignment;
}

void Structures::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_StructShort;scdr << m_var_StructUnsignedShort;scdr << m_var_StructLong;scdr << m_var_StructUnsignedLong;scdr << m_var_StructLongLong;scdr << m_var_StructUnsignedLongLong;scdr << m_var_StructFloat;scdr << m_var_StructDouble;scdr << m_var_StructLongDouble;scdr << m_var_StructBoolean;scdr << m_var_StructOctet;scdr << m_var_StructChar8;scdr << m_var_StructChar16;scdr << m_var_StructString;scdr << m_var_StructWString;scdr << m_var_StructEnum;scdr << m_var_StructBitMask;scdr << m_var_StructAlias;scdr << m_var_StructShortArray;scdr << m_var_StructSequence;scdr << m_var_StructMap;scdr << m_var_StructUnion;scdr << m_var_StructStructure;scdr << m_var_StructBitset;scdr << m_var_StructEmpty;
}

void Structures::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_StructShort;
    dcdr >> m_var_StructUnsignedShort;
    dcdr >> m_var_StructLong;
    dcdr >> m_var_StructUnsignedLong;
    dcdr >> m_var_StructLongLong;
    dcdr >> m_var_StructUnsignedLongLong;
    dcdr >> m_var_StructFloat;
    dcdr >> m_var_StructDouble;
    dcdr >> m_var_StructLongDouble;
    dcdr >> m_var_StructBoolean;
    dcdr >> m_var_StructOctet;
    dcdr >> m_var_StructChar8;
    dcdr >> m_var_StructChar16;
    dcdr >> m_var_StructString;
    dcdr >> m_var_StructWString;
    dcdr >> m_var_StructEnum;
    dcdr >> m_var_StructBitMask;
    dcdr >> m_var_StructAlias;
    dcdr >> m_var_StructShortArray;
    dcdr >> m_var_StructSequence;
    dcdr >> m_var_StructMap;
    dcdr >> m_var_StructUnion;
    dcdr >> m_var_StructStructure;
    dcdr >> m_var_StructBitset;
    dcdr >> m_var_StructEmpty;
}

/*!
 * @brief This function copies the value in member var_StructShort
 * @param _var_StructShort New value to be copied in member var_StructShort
 */
void Structures::var_StructShort(
        const StructShort& _var_StructShort)
{
    m_var_StructShort = _var_StructShort;
}

/*!
 * @brief This function moves the value in member var_StructShort
 * @param _var_StructShort New value to be moved in member var_StructShort
 */
void Structures::var_StructShort(
        StructShort&& _var_StructShort)
{
    m_var_StructShort = std::move(_var_StructShort);
}

/*!
 * @brief This function returns a constant reference to member var_StructShort
 * @return Constant reference to member var_StructShort
 */
const StructShort& Structures::var_StructShort() const
{
    return m_var_StructShort;
}

/*!
 * @brief This function returns a reference to member var_StructShort
 * @return Reference to member var_StructShort
 */
StructShort& Structures::var_StructShort()
{
    return m_var_StructShort;
}
/*!
 * @brief This function copies the value in member var_StructUnsignedShort
 * @param _var_StructUnsignedShort New value to be copied in member var_StructUnsignedShort
 */
void Structures::var_StructUnsignedShort(
        const StructUnsignedShort& _var_StructUnsignedShort)
{
    m_var_StructUnsignedShort = _var_StructUnsignedShort;
}

/*!
 * @brief This function moves the value in member var_StructUnsignedShort
 * @param _var_StructUnsignedShort New value to be moved in member var_StructUnsignedShort
 */
void Structures::var_StructUnsignedShort(
        StructUnsignedShort&& _var_StructUnsignedShort)
{
    m_var_StructUnsignedShort = std::move(_var_StructUnsignedShort);
}

/*!
 * @brief This function returns a constant reference to member var_StructUnsignedShort
 * @return Constant reference to member var_StructUnsignedShort
 */
const StructUnsignedShort& Structures::var_StructUnsignedShort() const
{
    return m_var_StructUnsignedShort;
}

/*!
 * @brief This function returns a reference to member var_StructUnsignedShort
 * @return Reference to member var_StructUnsignedShort
 */
StructUnsignedShort& Structures::var_StructUnsignedShort()
{
    return m_var_StructUnsignedShort;
}
/*!
 * @brief This function copies the value in member var_StructLong
 * @param _var_StructLong New value to be copied in member var_StructLong
 */
void Structures::var_StructLong(
        const StructLong& _var_StructLong)
{
    m_var_StructLong = _var_StructLong;
}

/*!
 * @brief This function moves the value in member var_StructLong
 * @param _var_StructLong New value to be moved in member var_StructLong
 */
void Structures::var_StructLong(
        StructLong&& _var_StructLong)
{
    m_var_StructLong = std::move(_var_StructLong);
}

/*!
 * @brief This function returns a constant reference to member var_StructLong
 * @return Constant reference to member var_StructLong
 */
const StructLong& Structures::var_StructLong() const
{
    return m_var_StructLong;
}

/*!
 * @brief This function returns a reference to member var_StructLong
 * @return Reference to member var_StructLong
 */
StructLong& Structures::var_StructLong()
{
    return m_var_StructLong;
}
/*!
 * @brief This function copies the value in member var_StructUnsignedLong
 * @param _var_StructUnsignedLong New value to be copied in member var_StructUnsignedLong
 */
void Structures::var_StructUnsignedLong(
        const StructUnsignedLong& _var_StructUnsignedLong)
{
    m_var_StructUnsignedLong = _var_StructUnsignedLong;
}

/*!
 * @brief This function moves the value in member var_StructUnsignedLong
 * @param _var_StructUnsignedLong New value to be moved in member var_StructUnsignedLong
 */
void Structures::var_StructUnsignedLong(
        StructUnsignedLong&& _var_StructUnsignedLong)
{
    m_var_StructUnsignedLong = std::move(_var_StructUnsignedLong);
}

/*!
 * @brief This function returns a constant reference to member var_StructUnsignedLong
 * @return Constant reference to member var_StructUnsignedLong
 */
const StructUnsignedLong& Structures::var_StructUnsignedLong() const
{
    return m_var_StructUnsignedLong;
}

/*!
 * @brief This function returns a reference to member var_StructUnsignedLong
 * @return Reference to member var_StructUnsignedLong
 */
StructUnsignedLong& Structures::var_StructUnsignedLong()
{
    return m_var_StructUnsignedLong;
}
/*!
 * @brief This function copies the value in member var_StructLongLong
 * @param _var_StructLongLong New value to be copied in member var_StructLongLong
 */
void Structures::var_StructLongLong(
        const StructLongLong& _var_StructLongLong)
{
    m_var_StructLongLong = _var_StructLongLong;
}

/*!
 * @brief This function moves the value in member var_StructLongLong
 * @param _var_StructLongLong New value to be moved in member var_StructLongLong
 */
void Structures::var_StructLongLong(
        StructLongLong&& _var_StructLongLong)
{
    m_var_StructLongLong = std::move(_var_StructLongLong);
}

/*!
 * @brief This function returns a constant reference to member var_StructLongLong
 * @return Constant reference to member var_StructLongLong
 */
const StructLongLong& Structures::var_StructLongLong() const
{
    return m_var_StructLongLong;
}

/*!
 * @brief This function returns a reference to member var_StructLongLong
 * @return Reference to member var_StructLongLong
 */
StructLongLong& Structures::var_StructLongLong()
{
    return m_var_StructLongLong;
}
/*!
 * @brief This function copies the value in member var_StructUnsignedLongLong
 * @param _var_StructUnsignedLongLong New value to be copied in member var_StructUnsignedLongLong
 */
void Structures::var_StructUnsignedLongLong(
        const StructUnsignedLongLong& _var_StructUnsignedLongLong)
{
    m_var_StructUnsignedLongLong = _var_StructUnsignedLongLong;
}

/*!
 * @brief This function moves the value in member var_StructUnsignedLongLong
 * @param _var_StructUnsignedLongLong New value to be moved in member var_StructUnsignedLongLong
 */
void Structures::var_StructUnsignedLongLong(
        StructUnsignedLongLong&& _var_StructUnsignedLongLong)
{
    m_var_StructUnsignedLongLong = std::move(_var_StructUnsignedLongLong);
}

/*!
 * @brief This function returns a constant reference to member var_StructUnsignedLongLong
 * @return Constant reference to member var_StructUnsignedLongLong
 */
const StructUnsignedLongLong& Structures::var_StructUnsignedLongLong() const
{
    return m_var_StructUnsignedLongLong;
}

/*!
 * @brief This function returns a reference to member var_StructUnsignedLongLong
 * @return Reference to member var_StructUnsignedLongLong
 */
StructUnsignedLongLong& Structures::var_StructUnsignedLongLong()
{
    return m_var_StructUnsignedLongLong;
}
/*!
 * @brief This function copies the value in member var_StructFloat
 * @param _var_StructFloat New value to be copied in member var_StructFloat
 */
void Structures::var_StructFloat(
        const StructFloat& _var_StructFloat)
{
    m_var_StructFloat = _var_StructFloat;
}

/*!
 * @brief This function moves the value in member var_StructFloat
 * @param _var_StructFloat New value to be moved in member var_StructFloat
 */
void Structures::var_StructFloat(
        StructFloat&& _var_StructFloat)
{
    m_var_StructFloat = std::move(_var_StructFloat);
}

/*!
 * @brief This function returns a constant reference to member var_StructFloat
 * @return Constant reference to member var_StructFloat
 */
const StructFloat& Structures::var_StructFloat() const
{
    return m_var_StructFloat;
}

/*!
 * @brief This function returns a reference to member var_StructFloat
 * @return Reference to member var_StructFloat
 */
StructFloat& Structures::var_StructFloat()
{
    return m_var_StructFloat;
}
/*!
 * @brief This function copies the value in member var_StructDouble
 * @param _var_StructDouble New value to be copied in member var_StructDouble
 */
void Structures::var_StructDouble(
        const StructDouble& _var_StructDouble)
{
    m_var_StructDouble = _var_StructDouble;
}

/*!
 * @brief This function moves the value in member var_StructDouble
 * @param _var_StructDouble New value to be moved in member var_StructDouble
 */
void Structures::var_StructDouble(
        StructDouble&& _var_StructDouble)
{
    m_var_StructDouble = std::move(_var_StructDouble);
}

/*!
 * @brief This function returns a constant reference to member var_StructDouble
 * @return Constant reference to member var_StructDouble
 */
const StructDouble& Structures::var_StructDouble() const
{
    return m_var_StructDouble;
}

/*!
 * @brief This function returns a reference to member var_StructDouble
 * @return Reference to member var_StructDouble
 */
StructDouble& Structures::var_StructDouble()
{
    return m_var_StructDouble;
}
/*!
 * @brief This function copies the value in member var_StructLongDouble
 * @param _var_StructLongDouble New value to be copied in member var_StructLongDouble
 */
void Structures::var_StructLongDouble(
        const StructLongDouble& _var_StructLongDouble)
{
    m_var_StructLongDouble = _var_StructLongDouble;
}

/*!
 * @brief This function moves the value in member var_StructLongDouble
 * @param _var_StructLongDouble New value to be moved in member var_StructLongDouble
 */
void Structures::var_StructLongDouble(
        StructLongDouble&& _var_StructLongDouble)
{
    m_var_StructLongDouble = std::move(_var_StructLongDouble);
}

/*!
 * @brief This function returns a constant reference to member var_StructLongDouble
 * @return Constant reference to member var_StructLongDouble
 */
const StructLongDouble& Structures::var_StructLongDouble() const
{
    return m_var_StructLongDouble;
}

/*!
 * @brief This function returns a reference to member var_StructLongDouble
 * @return Reference to member var_StructLongDouble
 */
StructLongDouble& Structures::var_StructLongDouble()
{
    return m_var_StructLongDouble;
}
/*!
 * @brief This function copies the value in member var_StructBoolean
 * @param _var_StructBoolean New value to be copied in member var_StructBoolean
 */
void Structures::var_StructBoolean(
        const StructBoolean& _var_StructBoolean)
{
    m_var_StructBoolean = _var_StructBoolean;
}

/*!
 * @brief This function moves the value in member var_StructBoolean
 * @param _var_StructBoolean New value to be moved in member var_StructBoolean
 */
void Structures::var_StructBoolean(
        StructBoolean&& _var_StructBoolean)
{
    m_var_StructBoolean = std::move(_var_StructBoolean);
}

/*!
 * @brief This function returns a constant reference to member var_StructBoolean
 * @return Constant reference to member var_StructBoolean
 */
const StructBoolean& Structures::var_StructBoolean() const
{
    return m_var_StructBoolean;
}

/*!
 * @brief This function returns a reference to member var_StructBoolean
 * @return Reference to member var_StructBoolean
 */
StructBoolean& Structures::var_StructBoolean()
{
    return m_var_StructBoolean;
}
/*!
 * @brief This function copies the value in member var_StructOctet
 * @param _var_StructOctet New value to be copied in member var_StructOctet
 */
void Structures::var_StructOctet(
        const StructOctet& _var_StructOctet)
{
    m_var_StructOctet = _var_StructOctet;
}

/*!
 * @brief This function moves the value in member var_StructOctet
 * @param _var_StructOctet New value to be moved in member var_StructOctet
 */
void Structures::var_StructOctet(
        StructOctet&& _var_StructOctet)
{
    m_var_StructOctet = std::move(_var_StructOctet);
}

/*!
 * @brief This function returns a constant reference to member var_StructOctet
 * @return Constant reference to member var_StructOctet
 */
const StructOctet& Structures::var_StructOctet() const
{
    return m_var_StructOctet;
}

/*!
 * @brief This function returns a reference to member var_StructOctet
 * @return Reference to member var_StructOctet
 */
StructOctet& Structures::var_StructOctet()
{
    return m_var_StructOctet;
}
/*!
 * @brief This function copies the value in member var_StructChar8
 * @param _var_StructChar8 New value to be copied in member var_StructChar8
 */
void Structures::var_StructChar8(
        const StructChar8& _var_StructChar8)
{
    m_var_StructChar8 = _var_StructChar8;
}

/*!
 * @brief This function moves the value in member var_StructChar8
 * @param _var_StructChar8 New value to be moved in member var_StructChar8
 */
void Structures::var_StructChar8(
        StructChar8&& _var_StructChar8)
{
    m_var_StructChar8 = std::move(_var_StructChar8);
}

/*!
 * @brief This function returns a constant reference to member var_StructChar8
 * @return Constant reference to member var_StructChar8
 */
const StructChar8& Structures::var_StructChar8() const
{
    return m_var_StructChar8;
}

/*!
 * @brief This function returns a reference to member var_StructChar8
 * @return Reference to member var_StructChar8
 */
StructChar8& Structures::var_StructChar8()
{
    return m_var_StructChar8;
}
/*!
 * @brief This function copies the value in member var_StructChar16
 * @param _var_StructChar16 New value to be copied in member var_StructChar16
 */
void Structures::var_StructChar16(
        const StructChar16& _var_StructChar16)
{
    m_var_StructChar16 = _var_StructChar16;
}

/*!
 * @brief This function moves the value in member var_StructChar16
 * @param _var_StructChar16 New value to be moved in member var_StructChar16
 */
void Structures::var_StructChar16(
        StructChar16&& _var_StructChar16)
{
    m_var_StructChar16 = std::move(_var_StructChar16);
}

/*!
 * @brief This function returns a constant reference to member var_StructChar16
 * @return Constant reference to member var_StructChar16
 */
const StructChar16& Structures::var_StructChar16() const
{
    return m_var_StructChar16;
}

/*!
 * @brief This function returns a reference to member var_StructChar16
 * @return Reference to member var_StructChar16
 */
StructChar16& Structures::var_StructChar16()
{
    return m_var_StructChar16;
}
/*!
 * @brief This function copies the value in member var_StructString
 * @param _var_StructString New value to be copied in member var_StructString
 */
void Structures::var_StructString(
        const StructString& _var_StructString)
{
    m_var_StructString = _var_StructString;
}

/*!
 * @brief This function moves the value in member var_StructString
 * @param _var_StructString New value to be moved in member var_StructString
 */
void Structures::var_StructString(
        StructString&& _var_StructString)
{
    m_var_StructString = std::move(_var_StructString);
}

/*!
 * @brief This function returns a constant reference to member var_StructString
 * @return Constant reference to member var_StructString
 */
const StructString& Structures::var_StructString() const
{
    return m_var_StructString;
}

/*!
 * @brief This function returns a reference to member var_StructString
 * @return Reference to member var_StructString
 */
StructString& Structures::var_StructString()
{
    return m_var_StructString;
}
/*!
 * @brief This function copies the value in member var_StructWString
 * @param _var_StructWString New value to be copied in member var_StructWString
 */
void Structures::var_StructWString(
        const StructWString& _var_StructWString)
{
    m_var_StructWString = _var_StructWString;
}

/*!
 * @brief This function moves the value in member var_StructWString
 * @param _var_StructWString New value to be moved in member var_StructWString
 */
void Structures::var_StructWString(
        StructWString&& _var_StructWString)
{
    m_var_StructWString = std::move(_var_StructWString);
}

/*!
 * @brief This function returns a constant reference to member var_StructWString
 * @return Constant reference to member var_StructWString
 */
const StructWString& Structures::var_StructWString() const
{
    return m_var_StructWString;
}

/*!
 * @brief This function returns a reference to member var_StructWString
 * @return Reference to member var_StructWString
 */
StructWString& Structures::var_StructWString()
{
    return m_var_StructWString;
}
/*!
 * @brief This function copies the value in member var_StructEnum
 * @param _var_StructEnum New value to be copied in member var_StructEnum
 */
void Structures::var_StructEnum(
        const StructEnum& _var_StructEnum)
{
    m_var_StructEnum = _var_StructEnum;
}

/*!
 * @brief This function moves the value in member var_StructEnum
 * @param _var_StructEnum New value to be moved in member var_StructEnum
 */
void Structures::var_StructEnum(
        StructEnum&& _var_StructEnum)
{
    m_var_StructEnum = std::move(_var_StructEnum);
}

/*!
 * @brief This function returns a constant reference to member var_StructEnum
 * @return Constant reference to member var_StructEnum
 */
const StructEnum& Structures::var_StructEnum() const
{
    return m_var_StructEnum;
}

/*!
 * @brief This function returns a reference to member var_StructEnum
 * @return Reference to member var_StructEnum
 */
StructEnum& Structures::var_StructEnum()
{
    return m_var_StructEnum;
}
/*!
 * @brief This function copies the value in member var_StructBitMask
 * @param _var_StructBitMask New value to be copied in member var_StructBitMask
 */
void Structures::var_StructBitMask(
        const StructBitMask& _var_StructBitMask)
{
    m_var_StructBitMask = _var_StructBitMask;
}

/*!
 * @brief This function moves the value in member var_StructBitMask
 * @param _var_StructBitMask New value to be moved in member var_StructBitMask
 */
void Structures::var_StructBitMask(
        StructBitMask&& _var_StructBitMask)
{
    m_var_StructBitMask = std::move(_var_StructBitMask);
}

/*!
 * @brief This function returns a constant reference to member var_StructBitMask
 * @return Constant reference to member var_StructBitMask
 */
const StructBitMask& Structures::var_StructBitMask() const
{
    return m_var_StructBitMask;
}

/*!
 * @brief This function returns a reference to member var_StructBitMask
 * @return Reference to member var_StructBitMask
 */
StructBitMask& Structures::var_StructBitMask()
{
    return m_var_StructBitMask;
}
/*!
 * @brief This function copies the value in member var_StructAlias
 * @param _var_StructAlias New value to be copied in member var_StructAlias
 */
void Structures::var_StructAlias(
        const StructAlias& _var_StructAlias)
{
    m_var_StructAlias = _var_StructAlias;
}

/*!
 * @brief This function moves the value in member var_StructAlias
 * @param _var_StructAlias New value to be moved in member var_StructAlias
 */
void Structures::var_StructAlias(
        StructAlias&& _var_StructAlias)
{
    m_var_StructAlias = std::move(_var_StructAlias);
}

/*!
 * @brief This function returns a constant reference to member var_StructAlias
 * @return Constant reference to member var_StructAlias
 */
const StructAlias& Structures::var_StructAlias() const
{
    return m_var_StructAlias;
}

/*!
 * @brief This function returns a reference to member var_StructAlias
 * @return Reference to member var_StructAlias
 */
StructAlias& Structures::var_StructAlias()
{
    return m_var_StructAlias;
}
/*!
 * @brief This function copies the value in member var_StructShortArray
 * @param _var_StructShortArray New value to be copied in member var_StructShortArray
 */
void Structures::var_StructShortArray(
        const StructShortArray& _var_StructShortArray)
{
    m_var_StructShortArray = _var_StructShortArray;
}

/*!
 * @brief This function moves the value in member var_StructShortArray
 * @param _var_StructShortArray New value to be moved in member var_StructShortArray
 */
void Structures::var_StructShortArray(
        StructShortArray&& _var_StructShortArray)
{
    m_var_StructShortArray = std::move(_var_StructShortArray);
}

/*!
 * @brief This function returns a constant reference to member var_StructShortArray
 * @return Constant reference to member var_StructShortArray
 */
const StructShortArray& Structures::var_StructShortArray() const
{
    return m_var_StructShortArray;
}

/*!
 * @brief This function returns a reference to member var_StructShortArray
 * @return Reference to member var_StructShortArray
 */
StructShortArray& Structures::var_StructShortArray()
{
    return m_var_StructShortArray;
}
/*!
 * @brief This function copies the value in member var_StructSequence
 * @param _var_StructSequence New value to be copied in member var_StructSequence
 */
void Structures::var_StructSequence(
        const StructSequence& _var_StructSequence)
{
    m_var_StructSequence = _var_StructSequence;
}

/*!
 * @brief This function moves the value in member var_StructSequence
 * @param _var_StructSequence New value to be moved in member var_StructSequence
 */
void Structures::var_StructSequence(
        StructSequence&& _var_StructSequence)
{
    m_var_StructSequence = std::move(_var_StructSequence);
}

/*!
 * @brief This function returns a constant reference to member var_StructSequence
 * @return Constant reference to member var_StructSequence
 */
const StructSequence& Structures::var_StructSequence() const
{
    return m_var_StructSequence;
}

/*!
 * @brief This function returns a reference to member var_StructSequence
 * @return Reference to member var_StructSequence
 */
StructSequence& Structures::var_StructSequence()
{
    return m_var_StructSequence;
}
/*!
 * @brief This function copies the value in member var_StructMap
 * @param _var_StructMap New value to be copied in member var_StructMap
 */
void Structures::var_StructMap(
        const StructMap& _var_StructMap)
{
    m_var_StructMap = _var_StructMap;
}

/*!
 * @brief This function moves the value in member var_StructMap
 * @param _var_StructMap New value to be moved in member var_StructMap
 */
void Structures::var_StructMap(
        StructMap&& _var_StructMap)
{
    m_var_StructMap = std::move(_var_StructMap);
}

/*!
 * @brief This function returns a constant reference to member var_StructMap
 * @return Constant reference to member var_StructMap
 */
const StructMap& Structures::var_StructMap() const
{
    return m_var_StructMap;
}

/*!
 * @brief This function returns a reference to member var_StructMap
 * @return Reference to member var_StructMap
 */
StructMap& Structures::var_StructMap()
{
    return m_var_StructMap;
}
/*!
 * @brief This function copies the value in member var_StructUnion
 * @param _var_StructUnion New value to be copied in member var_StructUnion
 */
void Structures::var_StructUnion(
        const StructUnion& _var_StructUnion)
{
    m_var_StructUnion = _var_StructUnion;
}

/*!
 * @brief This function moves the value in member var_StructUnion
 * @param _var_StructUnion New value to be moved in member var_StructUnion
 */
void Structures::var_StructUnion(
        StructUnion&& _var_StructUnion)
{
    m_var_StructUnion = std::move(_var_StructUnion);
}

/*!
 * @brief This function returns a constant reference to member var_StructUnion
 * @return Constant reference to member var_StructUnion
 */
const StructUnion& Structures::var_StructUnion() const
{
    return m_var_StructUnion;
}

/*!
 * @brief This function returns a reference to member var_StructUnion
 * @return Reference to member var_StructUnion
 */
StructUnion& Structures::var_StructUnion()
{
    return m_var_StructUnion;
}
/*!
 * @brief This function copies the value in member var_StructStructure
 * @param _var_StructStructure New value to be copied in member var_StructStructure
 */
void Structures::var_StructStructure(
        const StructStructure& _var_StructStructure)
{
    m_var_StructStructure = _var_StructStructure;
}

/*!
 * @brief This function moves the value in member var_StructStructure
 * @param _var_StructStructure New value to be moved in member var_StructStructure
 */
void Structures::var_StructStructure(
        StructStructure&& _var_StructStructure)
{
    m_var_StructStructure = std::move(_var_StructStructure);
}

/*!
 * @brief This function returns a constant reference to member var_StructStructure
 * @return Constant reference to member var_StructStructure
 */
const StructStructure& Structures::var_StructStructure() const
{
    return m_var_StructStructure;
}

/*!
 * @brief This function returns a reference to member var_StructStructure
 * @return Reference to member var_StructStructure
 */
StructStructure& Structures::var_StructStructure()
{
    return m_var_StructStructure;
}
/*!
 * @brief This function copies the value in member var_StructBitset
 * @param _var_StructBitset New value to be copied in member var_StructBitset
 */
void Structures::var_StructBitset(
        const StructBitset& _var_StructBitset)
{
    m_var_StructBitset = _var_StructBitset;
}

/*!
 * @brief This function moves the value in member var_StructBitset
 * @param _var_StructBitset New value to be moved in member var_StructBitset
 */
void Structures::var_StructBitset(
        StructBitset&& _var_StructBitset)
{
    m_var_StructBitset = std::move(_var_StructBitset);
}

/*!
 * @brief This function returns a constant reference to member var_StructBitset
 * @return Constant reference to member var_StructBitset
 */
const StructBitset& Structures::var_StructBitset() const
{
    return m_var_StructBitset;
}

/*!
 * @brief This function returns a reference to member var_StructBitset
 * @return Reference to member var_StructBitset
 */
StructBitset& Structures::var_StructBitset()
{
    return m_var_StructBitset;
}
/*!
 * @brief This function copies the value in member var_StructEmpty
 * @param _var_StructEmpty New value to be copied in member var_StructEmpty
 */
void Structures::var_StructEmpty(
        const StructEmpty& _var_StructEmpty)
{
    m_var_StructEmpty = _var_StructEmpty;
}

/*!
 * @brief This function moves the value in member var_StructEmpty
 * @param _var_StructEmpty New value to be moved in member var_StructEmpty
 */
void Structures::var_StructEmpty(
        StructEmpty&& _var_StructEmpty)
{
    m_var_StructEmpty = std::move(_var_StructEmpty);
}

/*!
 * @brief This function returns a constant reference to member var_StructEmpty
 * @return Constant reference to member var_StructEmpty
 */
const StructEmpty& Structures::var_StructEmpty() const
{
    return m_var_StructEmpty;
}

/*!
 * @brief This function returns a reference to member var_StructEmpty
 * @return Reference to member var_StructEmpty
 */
StructEmpty& Structures::var_StructEmpty()
{
    return m_var_StructEmpty;
}


size_t Structures::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Structures_max_key_cdr_typesize;
}

bool Structures::isKeyDefined()
{
    return false;
}

void Structures::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

