// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file structures.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "structures.h"
#include "structuresTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define InnerStructureHelper_max_cdr_typesize 8ULL;
#define OctetStruct_max_cdr_typesize 1ULL;
#define LongStruct_max_cdr_typesize 4ULL;
#define Char16Struct_max_cdr_typesize 4ULL;
#define EnumStruct_max_cdr_typesize 4ULL;
#define BitMaskStruct_max_cdr_typesize 4ULL;
#define StructureStruct_max_cdr_typesize 8ULL;
#define BitsetStruct_max_cdr_typesize 8ULL;
#define Char8Struct_max_cdr_typesize 1ULL;
#define DoubleStruct_max_cdr_typesize 8ULL;
#define BooleanStruct_max_cdr_typesize 1ULL;
#define UnsignedShortStruct_max_cdr_typesize 2ULL;
#define UnsignedLongStruct_max_cdr_typesize 4ULL;
#define WStringStruct_max_cdr_typesize 1024ULL;
#define SequenceStruct_max_cdr_typesize 404ULL;
#define Structures_max_cdr_typesize 2620ULL;
#define BoundedStringStruct_max_cdr_typesize 15ULL;
#define ShortArrayStruct_max_cdr_typesize 20ULL;

#define FloatStruct_max_cdr_typesize 4ULL;
#define LongDoubleStruct_max_cdr_typesize 16ULL;
#define InnerEmptyStructureHelper_max_cdr_typesize 0ULL;

#define ShortStruct_max_cdr_typesize 2ULL;
#define MapStruct_max_cdr_typesize 804ULL;

#define AliasStruct_max_cdr_typesize 4ULL;


#define BoundedWStringStruct_max_cdr_typesize 44ULL;
#define EmptyStructure_max_cdr_typesize 0ULL;

#define LongLongStruct_max_cdr_typesize 8ULL;
#define StringStruct_max_cdr_typesize 260ULL;
#define UnsignedLongLongStruct_max_cdr_typesize 8ULL;
#define UnionStruct_max_cdr_typesize 8ULL;




#define InnerStructureHelper_max_key_cdr_typesize 0ULL;
#define OctetStruct_max_key_cdr_typesize 0ULL;
#define LongStruct_max_key_cdr_typesize 0ULL;
#define Char16Struct_max_key_cdr_typesize 0ULL;
#define EnumStruct_max_key_cdr_typesize 0ULL;
#define BitMaskStruct_max_key_cdr_typesize 0ULL;
#define StructureStruct_max_key_cdr_typesize 0ULL;
#define BitsetStruct_max_key_cdr_typesize 0ULL;
#define Char8Struct_max_key_cdr_typesize 0ULL;
#define DoubleStruct_max_key_cdr_typesize 0ULL;
#define BooleanStruct_max_key_cdr_typesize 0ULL;
#define UnsignedShortStruct_max_key_cdr_typesize 0ULL;
#define UnsignedLongStruct_max_key_cdr_typesize 0ULL;
#define WStringStruct_max_key_cdr_typesize 0ULL;
#define SequenceStruct_max_key_cdr_typesize 0ULL;
#define Structures_max_key_cdr_typesize 0ULL;
#define BoundedStringStruct_max_key_cdr_typesize 0ULL;
#define ShortArrayStruct_max_key_cdr_typesize 0ULL;

#define FloatStruct_max_key_cdr_typesize 0ULL;
#define LongDoubleStruct_max_key_cdr_typesize 0ULL;
#define InnerEmptyStructureHelper_max_key_cdr_typesize 0ULL;

#define ShortStruct_max_key_cdr_typesize 0ULL;
#define MapStruct_max_key_cdr_typesize 0ULL;

#define AliasStruct_max_key_cdr_typesize 0ULL;


#define BoundedWStringStruct_max_key_cdr_typesize 0ULL;
#define EmptyStructure_max_key_cdr_typesize 0ULL;

#define LongLongStruct_max_key_cdr_typesize 0ULL;
#define StringStruct_max_key_cdr_typesize 0ULL;
#define UnsignedLongLongStruct_max_key_cdr_typesize 0ULL;
#define UnionStruct_max_key_cdr_typesize 0ULL;











ShortStruct::ShortStruct()
{
    // short m_var_short
    m_var_short = 0;

    // Just to register all known types
    registerstructuresTypes();
}

ShortStruct::~ShortStruct()
{
}

ShortStruct::ShortStruct(
        const ShortStruct& x)
{
    m_var_short = x.m_var_short;
}

ShortStruct::ShortStruct(
        ShortStruct&& x) noexcept 
{
    m_var_short = x.m_var_short;
}

ShortStruct& ShortStruct::operator =(
        const ShortStruct& x)
{

    m_var_short = x.m_var_short;

    return *this;
}

ShortStruct& ShortStruct::operator =(
        ShortStruct&& x) noexcept
{

    m_var_short = x.m_var_short;

    return *this;
}

bool ShortStruct::operator ==(
        const ShortStruct& x) const
{

    return (m_var_short == x.m_var_short);
}

bool ShortStruct::operator !=(
        const ShortStruct& x) const
{
    return !(*this == x);
}

size_t ShortStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ShortStruct_max_cdr_typesize;
}

size_t ShortStruct::getCdrSerializedSize(
        const ShortStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void ShortStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_short;
}

void ShortStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_short;
}

/*!
 * @brief This function sets a value in member var_short
 * @param _var_short New value for member var_short
 */
void ShortStruct::var_short(
        int16_t _var_short)
{
    m_var_short = _var_short;
}

/*!
 * @brief This function returns the value of member var_short
 * @return Value of member var_short
 */
int16_t ShortStruct::var_short() const
{
    return m_var_short;
}

/*!
 * @brief This function returns a reference to member var_short
 * @return Reference to member var_short
 */
int16_t& ShortStruct::var_short()
{
    return m_var_short;
}



size_t ShortStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ShortStruct_max_key_cdr_typesize;
}

bool ShortStruct::isKeyDefined()
{
    return false;
}

void ShortStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnsignedShortStruct::UnsignedShortStruct()
{
    // unsigned short m_var_ushort
    m_var_ushort = 0;

    // Just to register all known types
    registerstructuresTypes();
}

UnsignedShortStruct::~UnsignedShortStruct()
{
}

UnsignedShortStruct::UnsignedShortStruct(
        const UnsignedShortStruct& x)
{
    m_var_ushort = x.m_var_ushort;
}

UnsignedShortStruct::UnsignedShortStruct(
        UnsignedShortStruct&& x) noexcept 
{
    m_var_ushort = x.m_var_ushort;
}

UnsignedShortStruct& UnsignedShortStruct::operator =(
        const UnsignedShortStruct& x)
{

    m_var_ushort = x.m_var_ushort;

    return *this;
}

UnsignedShortStruct& UnsignedShortStruct::operator =(
        UnsignedShortStruct&& x) noexcept
{

    m_var_ushort = x.m_var_ushort;

    return *this;
}

bool UnsignedShortStruct::operator ==(
        const UnsignedShortStruct& x) const
{

    return (m_var_ushort == x.m_var_ushort);
}

bool UnsignedShortStruct::operator !=(
        const UnsignedShortStruct& x) const
{
    return !(*this == x);
}

size_t UnsignedShortStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnsignedShortStruct_max_cdr_typesize;
}

size_t UnsignedShortStruct::getCdrSerializedSize(
        const UnsignedShortStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void UnsignedShortStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ushort;
}

void UnsignedShortStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ushort;
}

/*!
 * @brief This function sets a value in member var_ushort
 * @param _var_ushort New value for member var_ushort
 */
void UnsignedShortStruct::var_ushort(
        uint16_t _var_ushort)
{
    m_var_ushort = _var_ushort;
}

/*!
 * @brief This function returns the value of member var_ushort
 * @return Value of member var_ushort
 */
uint16_t UnsignedShortStruct::var_ushort() const
{
    return m_var_ushort;
}

/*!
 * @brief This function returns a reference to member var_ushort
 * @return Reference to member var_ushort
 */
uint16_t& UnsignedShortStruct::var_ushort()
{
    return m_var_ushort;
}



size_t UnsignedShortStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnsignedShortStruct_max_key_cdr_typesize;
}

bool UnsignedShortStruct::isKeyDefined()
{
    return false;
}

void UnsignedShortStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


LongStruct::LongStruct()
{
    // long m_var_long
    m_var_long = 0;

    // Just to register all known types
    registerstructuresTypes();
}

LongStruct::~LongStruct()
{
}

LongStruct::LongStruct(
        const LongStruct& x)
{
    m_var_long = x.m_var_long;
}

LongStruct::LongStruct(
        LongStruct&& x) noexcept 
{
    m_var_long = x.m_var_long;
}

LongStruct& LongStruct::operator =(
        const LongStruct& x)
{

    m_var_long = x.m_var_long;

    return *this;
}

LongStruct& LongStruct::operator =(
        LongStruct&& x) noexcept
{

    m_var_long = x.m_var_long;

    return *this;
}

bool LongStruct::operator ==(
        const LongStruct& x) const
{

    return (m_var_long == x.m_var_long);
}

bool LongStruct::operator !=(
        const LongStruct& x) const
{
    return !(*this == x);
}

size_t LongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LongStruct_max_cdr_typesize;
}

size_t LongStruct::getCdrSerializedSize(
        const LongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void LongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_long;
}

void LongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_long;
}

/*!
 * @brief This function sets a value in member var_long
 * @param _var_long New value for member var_long
 */
void LongStruct::var_long(
        int32_t _var_long)
{
    m_var_long = _var_long;
}

/*!
 * @brief This function returns the value of member var_long
 * @return Value of member var_long
 */
int32_t LongStruct::var_long() const
{
    return m_var_long;
}

/*!
 * @brief This function returns a reference to member var_long
 * @return Reference to member var_long
 */
int32_t& LongStruct::var_long()
{
    return m_var_long;
}



size_t LongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LongStruct_max_key_cdr_typesize;
}

bool LongStruct::isKeyDefined()
{
    return false;
}

void LongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnsignedLongStruct::UnsignedLongStruct()
{
    // unsigned long m_var_ulong
    m_var_ulong = 0;

    // Just to register all known types
    registerstructuresTypes();
}

UnsignedLongStruct::~UnsignedLongStruct()
{
}

UnsignedLongStruct::UnsignedLongStruct(
        const UnsignedLongStruct& x)
{
    m_var_ulong = x.m_var_ulong;
}

UnsignedLongStruct::UnsignedLongStruct(
        UnsignedLongStruct&& x) noexcept 
{
    m_var_ulong = x.m_var_ulong;
}

UnsignedLongStruct& UnsignedLongStruct::operator =(
        const UnsignedLongStruct& x)
{

    m_var_ulong = x.m_var_ulong;

    return *this;
}

UnsignedLongStruct& UnsignedLongStruct::operator =(
        UnsignedLongStruct&& x) noexcept
{

    m_var_ulong = x.m_var_ulong;

    return *this;
}

bool UnsignedLongStruct::operator ==(
        const UnsignedLongStruct& x) const
{

    return (m_var_ulong == x.m_var_ulong);
}

bool UnsignedLongStruct::operator !=(
        const UnsignedLongStruct& x) const
{
    return !(*this == x);
}

size_t UnsignedLongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnsignedLongStruct_max_cdr_typesize;
}

size_t UnsignedLongStruct::getCdrSerializedSize(
        const UnsignedLongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void UnsignedLongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ulong;
}

void UnsignedLongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ulong;
}

/*!
 * @brief This function sets a value in member var_ulong
 * @param _var_ulong New value for member var_ulong
 */
void UnsignedLongStruct::var_ulong(
        uint32_t _var_ulong)
{
    m_var_ulong = _var_ulong;
}

/*!
 * @brief This function returns the value of member var_ulong
 * @return Value of member var_ulong
 */
uint32_t UnsignedLongStruct::var_ulong() const
{
    return m_var_ulong;
}

/*!
 * @brief This function returns a reference to member var_ulong
 * @return Reference to member var_ulong
 */
uint32_t& UnsignedLongStruct::var_ulong()
{
    return m_var_ulong;
}



size_t UnsignedLongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnsignedLongStruct_max_key_cdr_typesize;
}

bool UnsignedLongStruct::isKeyDefined()
{
    return false;
}

void UnsignedLongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


LongLongStruct::LongLongStruct()
{
    // long long m_var_longlong
    m_var_longlong = 0;

    // Just to register all known types
    registerstructuresTypes();
}

LongLongStruct::~LongLongStruct()
{
}

LongLongStruct::LongLongStruct(
        const LongLongStruct& x)
{
    m_var_longlong = x.m_var_longlong;
}

LongLongStruct::LongLongStruct(
        LongLongStruct&& x) noexcept 
{
    m_var_longlong = x.m_var_longlong;
}

LongLongStruct& LongLongStruct::operator =(
        const LongLongStruct& x)
{

    m_var_longlong = x.m_var_longlong;

    return *this;
}

LongLongStruct& LongLongStruct::operator =(
        LongLongStruct&& x) noexcept
{

    m_var_longlong = x.m_var_longlong;

    return *this;
}

bool LongLongStruct::operator ==(
        const LongLongStruct& x) const
{

    return (m_var_longlong == x.m_var_longlong);
}

bool LongLongStruct::operator !=(
        const LongLongStruct& x) const
{
    return !(*this == x);
}

size_t LongLongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LongLongStruct_max_cdr_typesize;
}

size_t LongLongStruct::getCdrSerializedSize(
        const LongLongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void LongLongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_longlong;
}

void LongLongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_longlong;
}

/*!
 * @brief This function sets a value in member var_longlong
 * @param _var_longlong New value for member var_longlong
 */
void LongLongStruct::var_longlong(
        int64_t _var_longlong)
{
    m_var_longlong = _var_longlong;
}

/*!
 * @brief This function returns the value of member var_longlong
 * @return Value of member var_longlong
 */
int64_t LongLongStruct::var_longlong() const
{
    return m_var_longlong;
}

/*!
 * @brief This function returns a reference to member var_longlong
 * @return Reference to member var_longlong
 */
int64_t& LongLongStruct::var_longlong()
{
    return m_var_longlong;
}



size_t LongLongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LongLongStruct_max_key_cdr_typesize;
}

bool LongLongStruct::isKeyDefined()
{
    return false;
}

void LongLongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnsignedLongLongStruct::UnsignedLongLongStruct()
{
    // unsigned long long m_var_ulonglong
    m_var_ulonglong = 0;

    // Just to register all known types
    registerstructuresTypes();
}

UnsignedLongLongStruct::~UnsignedLongLongStruct()
{
}

UnsignedLongLongStruct::UnsignedLongLongStruct(
        const UnsignedLongLongStruct& x)
{
    m_var_ulonglong = x.m_var_ulonglong;
}

UnsignedLongLongStruct::UnsignedLongLongStruct(
        UnsignedLongLongStruct&& x) noexcept 
{
    m_var_ulonglong = x.m_var_ulonglong;
}

UnsignedLongLongStruct& UnsignedLongLongStruct::operator =(
        const UnsignedLongLongStruct& x)
{

    m_var_ulonglong = x.m_var_ulonglong;

    return *this;
}

UnsignedLongLongStruct& UnsignedLongLongStruct::operator =(
        UnsignedLongLongStruct&& x) noexcept
{

    m_var_ulonglong = x.m_var_ulonglong;

    return *this;
}

bool UnsignedLongLongStruct::operator ==(
        const UnsignedLongLongStruct& x) const
{

    return (m_var_ulonglong == x.m_var_ulonglong);
}

bool UnsignedLongLongStruct::operator !=(
        const UnsignedLongLongStruct& x) const
{
    return !(*this == x);
}

size_t UnsignedLongLongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnsignedLongLongStruct_max_cdr_typesize;
}

size_t UnsignedLongLongStruct::getCdrSerializedSize(
        const UnsignedLongLongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void UnsignedLongLongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ulonglong;
}

void UnsignedLongLongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ulonglong;
}

/*!
 * @brief This function sets a value in member var_ulonglong
 * @param _var_ulonglong New value for member var_ulonglong
 */
void UnsignedLongLongStruct::var_ulonglong(
        uint64_t _var_ulonglong)
{
    m_var_ulonglong = _var_ulonglong;
}

/*!
 * @brief This function returns the value of member var_ulonglong
 * @return Value of member var_ulonglong
 */
uint64_t UnsignedLongLongStruct::var_ulonglong() const
{
    return m_var_ulonglong;
}

/*!
 * @brief This function returns a reference to member var_ulonglong
 * @return Reference to member var_ulonglong
 */
uint64_t& UnsignedLongLongStruct::var_ulonglong()
{
    return m_var_ulonglong;
}



size_t UnsignedLongLongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnsignedLongLongStruct_max_key_cdr_typesize;
}

bool UnsignedLongLongStruct::isKeyDefined()
{
    return false;
}

void UnsignedLongLongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


FloatStruct::FloatStruct()
{
    // float m_var_float
    m_var_float = 0.0;

    // Just to register all known types
    registerstructuresTypes();
}

FloatStruct::~FloatStruct()
{
}

FloatStruct::FloatStruct(
        const FloatStruct& x)
{
    m_var_float = x.m_var_float;
}

FloatStruct::FloatStruct(
        FloatStruct&& x) noexcept 
{
    m_var_float = x.m_var_float;
}

FloatStruct& FloatStruct::operator =(
        const FloatStruct& x)
{

    m_var_float = x.m_var_float;

    return *this;
}

FloatStruct& FloatStruct::operator =(
        FloatStruct&& x) noexcept
{

    m_var_float = x.m_var_float;

    return *this;
}

bool FloatStruct::operator ==(
        const FloatStruct& x) const
{

    return (m_var_float == x.m_var_float);
}

bool FloatStruct::operator !=(
        const FloatStruct& x) const
{
    return !(*this == x);
}

size_t FloatStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FloatStruct_max_cdr_typesize;
}

size_t FloatStruct::getCdrSerializedSize(
        const FloatStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void FloatStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_float;
}

void FloatStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_float;
}

/*!
 * @brief This function sets a value in member var_float
 * @param _var_float New value for member var_float
 */
void FloatStruct::var_float(
        float _var_float)
{
    m_var_float = _var_float;
}

/*!
 * @brief This function returns the value of member var_float
 * @return Value of member var_float
 */
float FloatStruct::var_float() const
{
    return m_var_float;
}

/*!
 * @brief This function returns a reference to member var_float
 * @return Reference to member var_float
 */
float& FloatStruct::var_float()
{
    return m_var_float;
}



size_t FloatStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FloatStruct_max_key_cdr_typesize;
}

bool FloatStruct::isKeyDefined()
{
    return false;
}

void FloatStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


DoubleStruct::DoubleStruct()
{
    // double m_var_double
    m_var_double = 0.0;

    // Just to register all known types
    registerstructuresTypes();
}

DoubleStruct::~DoubleStruct()
{
}

DoubleStruct::DoubleStruct(
        const DoubleStruct& x)
{
    m_var_double = x.m_var_double;
}

DoubleStruct::DoubleStruct(
        DoubleStruct&& x) noexcept 
{
    m_var_double = x.m_var_double;
}

DoubleStruct& DoubleStruct::operator =(
        const DoubleStruct& x)
{

    m_var_double = x.m_var_double;

    return *this;
}

DoubleStruct& DoubleStruct::operator =(
        DoubleStruct&& x) noexcept
{

    m_var_double = x.m_var_double;

    return *this;
}

bool DoubleStruct::operator ==(
        const DoubleStruct& x) const
{

    return (m_var_double == x.m_var_double);
}

bool DoubleStruct::operator !=(
        const DoubleStruct& x) const
{
    return !(*this == x);
}

size_t DoubleStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return DoubleStruct_max_cdr_typesize;
}

size_t DoubleStruct::getCdrSerializedSize(
        const DoubleStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void DoubleStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_double;
}

void DoubleStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_double;
}

/*!
 * @brief This function sets a value in member var_double
 * @param _var_double New value for member var_double
 */
void DoubleStruct::var_double(
        double _var_double)
{
    m_var_double = _var_double;
}

/*!
 * @brief This function returns the value of member var_double
 * @return Value of member var_double
 */
double DoubleStruct::var_double() const
{
    return m_var_double;
}

/*!
 * @brief This function returns a reference to member var_double
 * @return Reference to member var_double
 */
double& DoubleStruct::var_double()
{
    return m_var_double;
}



size_t DoubleStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return DoubleStruct_max_key_cdr_typesize;
}

bool DoubleStruct::isKeyDefined()
{
    return false;
}

void DoubleStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


LongDoubleStruct::LongDoubleStruct()
{
    // long double m_var_longdouble
    m_var_longdouble = 0.0;

    // Just to register all known types
    registerstructuresTypes();
}

LongDoubleStruct::~LongDoubleStruct()
{
}

LongDoubleStruct::LongDoubleStruct(
        const LongDoubleStruct& x)
{
    m_var_longdouble = x.m_var_longdouble;
}

LongDoubleStruct::LongDoubleStruct(
        LongDoubleStruct&& x) noexcept 
{
    m_var_longdouble = x.m_var_longdouble;
}

LongDoubleStruct& LongDoubleStruct::operator =(
        const LongDoubleStruct& x)
{

    m_var_longdouble = x.m_var_longdouble;

    return *this;
}

LongDoubleStruct& LongDoubleStruct::operator =(
        LongDoubleStruct&& x) noexcept
{

    m_var_longdouble = x.m_var_longdouble;

    return *this;
}

bool LongDoubleStruct::operator ==(
        const LongDoubleStruct& x) const
{

    return (m_var_longdouble == x.m_var_longdouble);
}

bool LongDoubleStruct::operator !=(
        const LongDoubleStruct& x) const
{
    return !(*this == x);
}

size_t LongDoubleStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LongDoubleStruct_max_cdr_typesize;
}

size_t LongDoubleStruct::getCdrSerializedSize(
        const LongDoubleStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 16 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8); // 128 bits, but aligned as 64


    return current_alignment - initial_alignment;
}

void LongDoubleStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_longdouble;
}

void LongDoubleStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_longdouble;
}

/*!
 * @brief This function sets a value in member var_longdouble
 * @param _var_longdouble New value for member var_longdouble
 */
void LongDoubleStruct::var_longdouble(
        long double _var_longdouble)
{
    m_var_longdouble = _var_longdouble;
}

/*!
 * @brief This function returns the value of member var_longdouble
 * @return Value of member var_longdouble
 */
long double LongDoubleStruct::var_longdouble() const
{
    return m_var_longdouble;
}

/*!
 * @brief This function returns a reference to member var_longdouble
 * @return Reference to member var_longdouble
 */
long double& LongDoubleStruct::var_longdouble()
{
    return m_var_longdouble;
}



size_t LongDoubleStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LongDoubleStruct_max_key_cdr_typesize;
}

bool LongDoubleStruct::isKeyDefined()
{
    return false;
}

void LongDoubleStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


BooleanStruct::BooleanStruct()
{
    // boolean m_var_boolean
    m_var_boolean = false;

    // Just to register all known types
    registerstructuresTypes();
}

BooleanStruct::~BooleanStruct()
{
}

BooleanStruct::BooleanStruct(
        const BooleanStruct& x)
{
    m_var_boolean = x.m_var_boolean;
}

BooleanStruct::BooleanStruct(
        BooleanStruct&& x) noexcept 
{
    m_var_boolean = x.m_var_boolean;
}

BooleanStruct& BooleanStruct::operator =(
        const BooleanStruct& x)
{

    m_var_boolean = x.m_var_boolean;

    return *this;
}

BooleanStruct& BooleanStruct::operator =(
        BooleanStruct&& x) noexcept
{

    m_var_boolean = x.m_var_boolean;

    return *this;
}

bool BooleanStruct::operator ==(
        const BooleanStruct& x) const
{

    return (m_var_boolean == x.m_var_boolean);
}

bool BooleanStruct::operator !=(
        const BooleanStruct& x) const
{
    return !(*this == x);
}

size_t BooleanStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BooleanStruct_max_cdr_typesize;
}

size_t BooleanStruct::getCdrSerializedSize(
        const BooleanStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void BooleanStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_boolean;
}

void BooleanStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_boolean;
}

/*!
 * @brief This function sets a value in member var_boolean
 * @param _var_boolean New value for member var_boolean
 */
void BooleanStruct::var_boolean(
        bool _var_boolean)
{
    m_var_boolean = _var_boolean;
}

/*!
 * @brief This function returns the value of member var_boolean
 * @return Value of member var_boolean
 */
bool BooleanStruct::var_boolean() const
{
    return m_var_boolean;
}

/*!
 * @brief This function returns a reference to member var_boolean
 * @return Reference to member var_boolean
 */
bool& BooleanStruct::var_boolean()
{
    return m_var_boolean;
}



size_t BooleanStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BooleanStruct_max_key_cdr_typesize;
}

bool BooleanStruct::isKeyDefined()
{
    return false;
}

void BooleanStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


OctetStruct::OctetStruct()
{
    // octet m_var_octet
    m_var_octet = 0;

    // Just to register all known types
    registerstructuresTypes();
}

OctetStruct::~OctetStruct()
{
}

OctetStruct::OctetStruct(
        const OctetStruct& x)
{
    m_var_octet = x.m_var_octet;
}

OctetStruct::OctetStruct(
        OctetStruct&& x) noexcept 
{
    m_var_octet = x.m_var_octet;
}

OctetStruct& OctetStruct::operator =(
        const OctetStruct& x)
{

    m_var_octet = x.m_var_octet;

    return *this;
}

OctetStruct& OctetStruct::operator =(
        OctetStruct&& x) noexcept
{

    m_var_octet = x.m_var_octet;

    return *this;
}

bool OctetStruct::operator ==(
        const OctetStruct& x) const
{

    return (m_var_octet == x.m_var_octet);
}

bool OctetStruct::operator !=(
        const OctetStruct& x) const
{
    return !(*this == x);
}

size_t OctetStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return OctetStruct_max_cdr_typesize;
}

size_t OctetStruct::getCdrSerializedSize(
        const OctetStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void OctetStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_octet;
}

void OctetStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_octet;
}

/*!
 * @brief This function sets a value in member var_octet
 * @param _var_octet New value for member var_octet
 */
void OctetStruct::var_octet(
        uint8_t _var_octet)
{
    m_var_octet = _var_octet;
}

/*!
 * @brief This function returns the value of member var_octet
 * @return Value of member var_octet
 */
uint8_t OctetStruct::var_octet() const
{
    return m_var_octet;
}

/*!
 * @brief This function returns a reference to member var_octet
 * @return Reference to member var_octet
 */
uint8_t& OctetStruct::var_octet()
{
    return m_var_octet;
}



size_t OctetStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return OctetStruct_max_key_cdr_typesize;
}

bool OctetStruct::isKeyDefined()
{
    return false;
}

void OctetStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


Char8Struct::Char8Struct()
{
    // char m_var_char8
    m_var_char8 = 0;

    // Just to register all known types
    registerstructuresTypes();
}

Char8Struct::~Char8Struct()
{
}

Char8Struct::Char8Struct(
        const Char8Struct& x)
{
    m_var_char8 = x.m_var_char8;
}

Char8Struct::Char8Struct(
        Char8Struct&& x) noexcept 
{
    m_var_char8 = x.m_var_char8;
}

Char8Struct& Char8Struct::operator =(
        const Char8Struct& x)
{

    m_var_char8 = x.m_var_char8;

    return *this;
}

Char8Struct& Char8Struct::operator =(
        Char8Struct&& x) noexcept
{

    m_var_char8 = x.m_var_char8;

    return *this;
}

bool Char8Struct::operator ==(
        const Char8Struct& x) const
{

    return (m_var_char8 == x.m_var_char8);
}

bool Char8Struct::operator !=(
        const Char8Struct& x) const
{
    return !(*this == x);
}

size_t Char8Struct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Char8Struct_max_cdr_typesize;
}

size_t Char8Struct::getCdrSerializedSize(
        const Char8Struct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void Char8Struct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_char8;
}

void Char8Struct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_char8;
}

/*!
 * @brief This function sets a value in member var_char8
 * @param _var_char8 New value for member var_char8
 */
void Char8Struct::var_char8(
        char _var_char8)
{
    m_var_char8 = _var_char8;
}

/*!
 * @brief This function returns the value of member var_char8
 * @return Value of member var_char8
 */
char Char8Struct::var_char8() const
{
    return m_var_char8;
}

/*!
 * @brief This function returns a reference to member var_char8
 * @return Reference to member var_char8
 */
char& Char8Struct::var_char8()
{
    return m_var_char8;
}



size_t Char8Struct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Char8Struct_max_key_cdr_typesize;
}

bool Char8Struct::isKeyDefined()
{
    return false;
}

void Char8Struct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


Char16Struct::Char16Struct()
{
    // wchar m_var_char16
    m_var_char16 = 0;

    // Just to register all known types
    registerstructuresTypes();
}

Char16Struct::~Char16Struct()
{
}

Char16Struct::Char16Struct(
        const Char16Struct& x)
{
    m_var_char16 = x.m_var_char16;
}

Char16Struct::Char16Struct(
        Char16Struct&& x) noexcept 
{
    m_var_char16 = x.m_var_char16;
}

Char16Struct& Char16Struct::operator =(
        const Char16Struct& x)
{

    m_var_char16 = x.m_var_char16;

    return *this;
}

Char16Struct& Char16Struct::operator =(
        Char16Struct&& x) noexcept
{

    m_var_char16 = x.m_var_char16;

    return *this;
}

bool Char16Struct::operator ==(
        const Char16Struct& x) const
{

    return (m_var_char16 == x.m_var_char16);
}

bool Char16Struct::operator !=(
        const Char16Struct& x) const
{
    return !(*this == x);
}

size_t Char16Struct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Char16Struct_max_cdr_typesize;
}

size_t Char16Struct::getCdrSerializedSize(
        const Char16Struct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void Char16Struct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_char16;
}

void Char16Struct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_char16;
}

/*!
 * @brief This function sets a value in member var_char16
 * @param _var_char16 New value for member var_char16
 */
void Char16Struct::var_char16(
        wchar_t _var_char16)
{
    m_var_char16 = _var_char16;
}

/*!
 * @brief This function returns the value of member var_char16
 * @return Value of member var_char16
 */
wchar_t Char16Struct::var_char16() const
{
    return m_var_char16;
}

/*!
 * @brief This function returns a reference to member var_char16
 * @return Reference to member var_char16
 */
wchar_t& Char16Struct::var_char16()
{
    return m_var_char16;
}



size_t Char16Struct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Char16Struct_max_key_cdr_typesize;
}

bool Char16Struct::isKeyDefined()
{
    return false;
}

void Char16Struct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StringStruct::StringStruct()
{
    // string m_var_string
    m_var_string = "";


    // Just to register all known types
    registerstructuresTypes();
}

StringStruct::~StringStruct()
{
}

StringStruct::StringStruct(
        const StringStruct& x)
{
    m_var_string = x.m_var_string;
}

StringStruct::StringStruct(
        StringStruct&& x) noexcept 
{
    m_var_string = std::move(x.m_var_string);
}

StringStruct& StringStruct::operator =(
        const StringStruct& x)
{

    m_var_string = x.m_var_string;

    return *this;
}

StringStruct& StringStruct::operator =(
        StringStruct&& x) noexcept
{

    m_var_string = std::move(x.m_var_string);

    return *this;
}

bool StringStruct::operator ==(
        const StringStruct& x) const
{

    return (m_var_string == x.m_var_string);
}

bool StringStruct::operator !=(
        const StringStruct& x) const
{
    return !(*this == x);
}

size_t StringStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StringStruct_max_cdr_typesize;
}

size_t StringStruct::getCdrSerializedSize(
        const StringStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_string().size() + 1;

    return current_alignment - initial_alignment;
}

void StringStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_string.c_str();
}

void StringStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_string;}

/*!
 * @brief This function copies the value in member var_string
 * @param _var_string New value to be copied in member var_string
 */
void StringStruct::var_string(
        const std::string& _var_string)
{
    m_var_string = _var_string;
}

/*!
 * @brief This function moves the value in member var_string
 * @param _var_string New value to be moved in member var_string
 */
void StringStruct::var_string(
        std::string&& _var_string)
{
    m_var_string = std::move(_var_string);
}

/*!
 * @brief This function returns a constant reference to member var_string
 * @return Constant reference to member var_string
 */
const std::string& StringStruct::var_string() const
{
    return m_var_string;
}

/*!
 * @brief This function returns a reference to member var_string
 * @return Reference to member var_string
 */
std::string& StringStruct::var_string()
{
    return m_var_string;
}


size_t StringStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StringStruct_max_key_cdr_typesize;
}

bool StringStruct::isKeyDefined()
{
    return false;
}

void StringStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


WStringStruct::WStringStruct()
{
    // wstring m_var_wstring
    m_var_wstring = L"";


    // Just to register all known types
    registerstructuresTypes();
}

WStringStruct::~WStringStruct()
{
}

WStringStruct::WStringStruct(
        const WStringStruct& x)
{
    m_var_wstring = x.m_var_wstring;
}

WStringStruct::WStringStruct(
        WStringStruct&& x) noexcept 
{
    m_var_wstring = std::move(x.m_var_wstring);
}

WStringStruct& WStringStruct::operator =(
        const WStringStruct& x)
{

    m_var_wstring = x.m_var_wstring;

    return *this;
}

WStringStruct& WStringStruct::operator =(
        WStringStruct&& x) noexcept
{

    m_var_wstring = std::move(x.m_var_wstring);

    return *this;
}

bool WStringStruct::operator ==(
        const WStringStruct& x) const
{

    return (m_var_wstring == x.m_var_wstring);
}

bool WStringStruct::operator !=(
        const WStringStruct& x) const
{
    return !(*this == x);
}

size_t WStringStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return WStringStruct_max_cdr_typesize;
}

size_t WStringStruct::getCdrSerializedSize(
        const WStringStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.var_wstring().size()) * 4; // 32 bits

    return current_alignment - initial_alignment;
}

void WStringStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_wstring;
}

void WStringStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_wstring;
}

/*!
 * @brief This function copies the value in member var_wstring
 * @param _var_wstring New value to be copied in member var_wstring
 */
void WStringStruct::var_wstring(
        const std::wstring& _var_wstring)
{
    m_var_wstring = _var_wstring;
}

/*!
 * @brief This function moves the value in member var_wstring
 * @param _var_wstring New value to be moved in member var_wstring
 */
void WStringStruct::var_wstring(
        std::wstring&& _var_wstring)
{
    m_var_wstring = std::move(_var_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_wstring
 * @return Constant reference to member var_wstring
 */
const std::wstring& WStringStruct::var_wstring() const
{
    return m_var_wstring;
}

/*!
 * @brief This function returns a reference to member var_wstring
 * @return Reference to member var_wstring
 */
std::wstring& WStringStruct::var_wstring()
{
    return m_var_wstring;
}


size_t WStringStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return WStringStruct_max_key_cdr_typesize;
}

bool WStringStruct::isKeyDefined()
{
    return false;
}

void WStringStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


BoundedStringStruct::BoundedStringStruct()
{
    // Inner_alias_bounded_string_helper m_var_bounded_string
    m_var_bounded_string = "";


    // Just to register all known types
    registerstructuresTypes();
}

BoundedStringStruct::~BoundedStringStruct()
{
}

BoundedStringStruct::BoundedStringStruct(
        const BoundedStringStruct& x)
{
    m_var_bounded_string = x.m_var_bounded_string;
}

BoundedStringStruct::BoundedStringStruct(
        BoundedStringStruct&& x) noexcept 
{
    m_var_bounded_string = std::move(x.m_var_bounded_string);
}

BoundedStringStruct& BoundedStringStruct::operator =(
        const BoundedStringStruct& x)
{

    m_var_bounded_string = x.m_var_bounded_string;

    return *this;
}

BoundedStringStruct& BoundedStringStruct::operator =(
        BoundedStringStruct&& x) noexcept
{

    m_var_bounded_string = std::move(x.m_var_bounded_string);

    return *this;
}

bool BoundedStringStruct::operator ==(
        const BoundedStringStruct& x) const
{

    return (m_var_bounded_string == x.m_var_bounded_string);
}

bool BoundedStringStruct::operator !=(
        const BoundedStringStruct& x) const
{
    return !(*this == x);
}

size_t BoundedStringStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BoundedStringStruct_max_cdr_typesize;
}

size_t BoundedStringStruct::getCdrSerializedSize(
        const BoundedStringStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_bounded_string().size() + 1;

    return current_alignment - initial_alignment;
}

void BoundedStringStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_bounded_string.c_str();
}

void BoundedStringStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        std::string aux;
        dcdr >> aux;
        m_var_bounded_string = aux.c_str();
    }}

/*!
 * @brief This function copies the value in member var_bounded_string
 * @param _var_bounded_string New value to be copied in member var_bounded_string
 */
void BoundedStringStruct::var_bounded_string(
        const Inner_alias_bounded_string_helper& _var_bounded_string)
{
    m_var_bounded_string = _var_bounded_string;
}

/*!
 * @brief This function moves the value in member var_bounded_string
 * @param _var_bounded_string New value to be moved in member var_bounded_string
 */
void BoundedStringStruct::var_bounded_string(
        Inner_alias_bounded_string_helper&& _var_bounded_string)
{
    m_var_bounded_string = std::move(_var_bounded_string);
}

/*!
 * @brief This function returns a constant reference to member var_bounded_string
 * @return Constant reference to member var_bounded_string
 */
const Inner_alias_bounded_string_helper& BoundedStringStruct::var_bounded_string() const
{
    return m_var_bounded_string;
}

/*!
 * @brief This function returns a reference to member var_bounded_string
 * @return Reference to member var_bounded_string
 */
Inner_alias_bounded_string_helper& BoundedStringStruct::var_bounded_string()
{
    return m_var_bounded_string;
}


size_t BoundedStringStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BoundedStringStruct_max_key_cdr_typesize;
}

bool BoundedStringStruct::isKeyDefined()
{
    return false;
}

void BoundedStringStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


BoundedWStringStruct::BoundedWStringStruct()
{
    // Inner_alias_bounded_wstring_helper m_var_bounded_wstring
    m_var_bounded_wstring = L"";


    // Just to register all known types
    registerstructuresTypes();
}

BoundedWStringStruct::~BoundedWStringStruct()
{
}

BoundedWStringStruct::BoundedWStringStruct(
        const BoundedWStringStruct& x)
{
    m_var_bounded_wstring = x.m_var_bounded_wstring;
}

BoundedWStringStruct::BoundedWStringStruct(
        BoundedWStringStruct&& x) noexcept 
{
    m_var_bounded_wstring = std::move(x.m_var_bounded_wstring);
}

BoundedWStringStruct& BoundedWStringStruct::operator =(
        const BoundedWStringStruct& x)
{

    m_var_bounded_wstring = x.m_var_bounded_wstring;

    return *this;
}

BoundedWStringStruct& BoundedWStringStruct::operator =(
        BoundedWStringStruct&& x) noexcept
{

    m_var_bounded_wstring = std::move(x.m_var_bounded_wstring);

    return *this;
}

bool BoundedWStringStruct::operator ==(
        const BoundedWStringStruct& x) const
{

    return (m_var_bounded_wstring == x.m_var_bounded_wstring);
}

bool BoundedWStringStruct::operator !=(
        const BoundedWStringStruct& x) const
{
    return !(*this == x);
}

size_t BoundedWStringStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BoundedWStringStruct_max_cdr_typesize;
}

size_t BoundedWStringStruct::getCdrSerializedSize(
        const BoundedWStringStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.var_bounded_wstring().size()) * 4; // 32 bits

    return current_alignment - initial_alignment;
}

void BoundedWStringStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_bounded_wstring;
}

void BoundedWStringStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_bounded_wstring;
}

/*!
 * @brief This function copies the value in member var_bounded_wstring
 * @param _var_bounded_wstring New value to be copied in member var_bounded_wstring
 */
void BoundedWStringStruct::var_bounded_wstring(
        const Inner_alias_bounded_wstring_helper& _var_bounded_wstring)
{
    m_var_bounded_wstring = _var_bounded_wstring;
}

/*!
 * @brief This function moves the value in member var_bounded_wstring
 * @param _var_bounded_wstring New value to be moved in member var_bounded_wstring
 */
void BoundedWStringStruct::var_bounded_wstring(
        Inner_alias_bounded_wstring_helper&& _var_bounded_wstring)
{
    m_var_bounded_wstring = std::move(_var_bounded_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_bounded_wstring
 * @return Constant reference to member var_bounded_wstring
 */
const Inner_alias_bounded_wstring_helper& BoundedWStringStruct::var_bounded_wstring() const
{
    return m_var_bounded_wstring;
}

/*!
 * @brief This function returns a reference to member var_bounded_wstring
 * @return Reference to member var_bounded_wstring
 */
Inner_alias_bounded_wstring_helper& BoundedWStringStruct::var_bounded_wstring()
{
    return m_var_bounded_wstring;
}


size_t BoundedWStringStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BoundedWStringStruct_max_key_cdr_typesize;
}

bool BoundedWStringStruct::isKeyDefined()
{
    return false;
}

void BoundedWStringStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


EnumStruct::EnumStruct()
{
    // InnerEnumHelper m_var_enum
    m_var_enum = ::ENUM_VALUE_1;

    // Just to register all known types
    registerstructuresTypes();
}

EnumStruct::~EnumStruct()
{
}

EnumStruct::EnumStruct(
        const EnumStruct& x)
{
    m_var_enum = x.m_var_enum;
}

EnumStruct::EnumStruct(
        EnumStruct&& x) noexcept 
{
    m_var_enum = x.m_var_enum;
}

EnumStruct& EnumStruct::operator =(
        const EnumStruct& x)
{

    m_var_enum = x.m_var_enum;

    return *this;
}

EnumStruct& EnumStruct::operator =(
        EnumStruct&& x) noexcept
{

    m_var_enum = x.m_var_enum;

    return *this;
}

bool EnumStruct::operator ==(
        const EnumStruct& x) const
{

    return (m_var_enum == x.m_var_enum);
}

bool EnumStruct::operator !=(
        const EnumStruct& x) const
{
    return !(*this == x);
}

size_t EnumStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return EnumStruct_max_cdr_typesize;
}

size_t EnumStruct::getCdrSerializedSize(
        const EnumStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void EnumStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint32_t)m_var_enum;
}

void EnumStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_var_enum = (InnerEnumHelper)enum_value;
    }

}

/*!
 * @brief This function sets a value in member var_enum
 * @param _var_enum New value for member var_enum
 */
void EnumStruct::var_enum(
        InnerEnumHelper _var_enum)
{
    m_var_enum = _var_enum;
}

/*!
 * @brief This function returns the value of member var_enum
 * @return Value of member var_enum
 */
InnerEnumHelper EnumStruct::var_enum() const
{
    return m_var_enum;
}

/*!
 * @brief This function returns a reference to member var_enum
 * @return Reference to member var_enum
 */
InnerEnumHelper& EnumStruct::var_enum()
{
    return m_var_enum;
}



size_t EnumStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return EnumStruct_max_key_cdr_typesize;
}

bool EnumStruct::isKeyDefined()
{
    return false;
}

void EnumStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


BitMaskStruct::BitMaskStruct()
{
    // InnerBitMaskHelper m_var_bitmask
    m_var_bitmask = static_cast<InnerBitMaskHelper>(0);

    // Just to register all known types
    registerstructuresTypes();
}

BitMaskStruct::~BitMaskStruct()
{
}

BitMaskStruct::BitMaskStruct(
        const BitMaskStruct& x)
{
    m_var_bitmask = x.m_var_bitmask;
}

BitMaskStruct::BitMaskStruct(
        BitMaskStruct&& x) noexcept 
{
    m_var_bitmask = x.m_var_bitmask;
}

BitMaskStruct& BitMaskStruct::operator =(
        const BitMaskStruct& x)
{

    m_var_bitmask = x.m_var_bitmask;

    return *this;
}

BitMaskStruct& BitMaskStruct::operator =(
        BitMaskStruct&& x) noexcept
{

    m_var_bitmask = x.m_var_bitmask;

    return *this;
}

bool BitMaskStruct::operator ==(
        const BitMaskStruct& x) const
{

    return (m_var_bitmask == x.m_var_bitmask);
}

bool BitMaskStruct::operator !=(
        const BitMaskStruct& x) const
{
    return !(*this == x);
}

size_t BitMaskStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BitMaskStruct_max_cdr_typesize;
}

size_t BitMaskStruct::getCdrSerializedSize(
        const BitMaskStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void BitMaskStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint32_t)m_var_bitmask;
}

void BitMaskStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint32_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_var_bitmask = (InnerBitMaskHelper)bitmask_value;
    }

}

/*!
 * @brief This function sets a value in member var_bitmask
 * @param _var_bitmask New value for member var_bitmask
 */
void BitMaskStruct::var_bitmask(
        InnerBitMaskHelper _var_bitmask)
{
    m_var_bitmask = _var_bitmask;
}

/*!
 * @brief This function returns the value of member var_bitmask
 * @return Value of member var_bitmask
 */
InnerBitMaskHelper BitMaskStruct::var_bitmask() const
{
    return m_var_bitmask;
}

/*!
 * @brief This function returns a reference to member var_bitmask
 * @return Reference to member var_bitmask
 */
InnerBitMaskHelper& BitMaskStruct::var_bitmask()
{
    return m_var_bitmask;
}



size_t BitMaskStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BitMaskStruct_max_key_cdr_typesize;
}

bool BitMaskStruct::isKeyDefined()
{
    return false;
}

void BitMaskStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasStruct::AliasStruct()
{
    // InnerAliasHelper m_var_alias
    m_var_alias = 0;

    // Just to register all known types
    registerstructuresTypes();
}

AliasStruct::~AliasStruct()
{
}

AliasStruct::AliasStruct(
        const AliasStruct& x)
{
    m_var_alias = x.m_var_alias;
}

AliasStruct::AliasStruct(
        AliasStruct&& x) noexcept 
{
    m_var_alias = x.m_var_alias;
}

AliasStruct& AliasStruct::operator =(
        const AliasStruct& x)
{

    m_var_alias = x.m_var_alias;

    return *this;
}

AliasStruct& AliasStruct::operator =(
        AliasStruct&& x) noexcept
{

    m_var_alias = x.m_var_alias;

    return *this;
}

bool AliasStruct::operator ==(
        const AliasStruct& x) const
{

    return (m_var_alias == x.m_var_alias);
}

bool AliasStruct::operator !=(
        const AliasStruct& x) const
{
    return !(*this == x);
}

size_t AliasStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasStruct_max_cdr_typesize;
}

size_t AliasStruct::getCdrSerializedSize(
        const AliasStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void AliasStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_alias;
}

void AliasStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_alias;
}

/*!
 * @brief This function sets a value in member var_alias
 * @param _var_alias New value for member var_alias
 */
void AliasStruct::var_alias(
        InnerAliasHelper _var_alias)
{
    m_var_alias = _var_alias;
}

/*!
 * @brief This function returns the value of member var_alias
 * @return Value of member var_alias
 */
InnerAliasHelper AliasStruct::var_alias() const
{
    return m_var_alias;
}

/*!
 * @brief This function returns a reference to member var_alias
 * @return Reference to member var_alias
 */
InnerAliasHelper& AliasStruct::var_alias()
{
    return m_var_alias;
}



size_t AliasStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasStruct_max_key_cdr_typesize;
}

bool AliasStruct::isKeyDefined()
{
    return false;
}

void AliasStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ShortArrayStruct::ShortArrayStruct()
{
    // short m_var_array_short
    memset(&m_var_array_short, 0, (10) * 2);


    // Just to register all known types
    registerstructuresTypes();
}

ShortArrayStruct::~ShortArrayStruct()
{
}

ShortArrayStruct::ShortArrayStruct(
        const ShortArrayStruct& x)
{
    m_var_array_short = x.m_var_array_short;
}

ShortArrayStruct::ShortArrayStruct(
        ShortArrayStruct&& x) noexcept 
{
    m_var_array_short = std::move(x.m_var_array_short);
}

ShortArrayStruct& ShortArrayStruct::operator =(
        const ShortArrayStruct& x)
{

    m_var_array_short = x.m_var_array_short;

    return *this;
}

ShortArrayStruct& ShortArrayStruct::operator =(
        ShortArrayStruct&& x) noexcept
{

    m_var_array_short = std::move(x.m_var_array_short);

    return *this;
}

bool ShortArrayStruct::operator ==(
        const ShortArrayStruct& x) const
{

    return (m_var_array_short == x.m_var_array_short);
}

bool ShortArrayStruct::operator !=(
        const ShortArrayStruct& x) const
{
    return !(*this == x);
}

size_t ShortArrayStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ShortArrayStruct_max_cdr_typesize;
}

size_t ShortArrayStruct::getCdrSerializedSize(
        const ShortArrayStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void ShortArrayStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_short;

}

void ShortArrayStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_short;

}

/*!
 * @brief This function copies the value in member var_array_short
 * @param _var_array_short New value to be copied in member var_array_short
 */
void ShortArrayStruct::var_array_short(
        const std::array<int16_t, 10>& _var_array_short)
{
    m_var_array_short = _var_array_short;
}

/*!
 * @brief This function moves the value in member var_array_short
 * @param _var_array_short New value to be moved in member var_array_short
 */
void ShortArrayStruct::var_array_short(
        std::array<int16_t, 10>&& _var_array_short)
{
    m_var_array_short = std::move(_var_array_short);
}

/*!
 * @brief This function returns a constant reference to member var_array_short
 * @return Constant reference to member var_array_short
 */
const std::array<int16_t, 10>& ShortArrayStruct::var_array_short() const
{
    return m_var_array_short;
}

/*!
 * @brief This function returns a reference to member var_array_short
 * @return Reference to member var_array_short
 */
std::array<int16_t, 10>& ShortArrayStruct::var_array_short()
{
    return m_var_array_short;
}


size_t ShortArrayStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ShortArrayStruct_max_key_cdr_typesize;
}

bool ShortArrayStruct::isKeyDefined()
{
    return false;
}

void ShortArrayStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


SequenceStruct::SequenceStruct()
{
    // sequence<long> m_var_sequence


    // Just to register all known types
    registerstructuresTypes();
}

SequenceStruct::~SequenceStruct()
{
}

SequenceStruct::SequenceStruct(
        const SequenceStruct& x)
{
    m_var_sequence = x.m_var_sequence;
}

SequenceStruct::SequenceStruct(
        SequenceStruct&& x) noexcept 
{
    m_var_sequence = std::move(x.m_var_sequence);
}

SequenceStruct& SequenceStruct::operator =(
        const SequenceStruct& x)
{

    m_var_sequence = x.m_var_sequence;

    return *this;
}

SequenceStruct& SequenceStruct::operator =(
        SequenceStruct&& x) noexcept
{

    m_var_sequence = std::move(x.m_var_sequence);

    return *this;
}

bool SequenceStruct::operator ==(
        const SequenceStruct& x) const
{

    return (m_var_sequence == x.m_var_sequence);
}

bool SequenceStruct::operator !=(
        const SequenceStruct& x) const
{
    return !(*this == x);
}

size_t SequenceStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceStruct_max_cdr_typesize;
}

size_t SequenceStruct::getCdrSerializedSize(
        const SequenceStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var_sequence().size() > 0)
    {
        current_alignment += (data.var_sequence().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    return current_alignment - initial_alignment;
}

void SequenceStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_sequence;
}

void SequenceStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_sequence;}

/*!
 * @brief This function copies the value in member var_sequence
 * @param _var_sequence New value to be copied in member var_sequence
 */
void SequenceStruct::var_sequence(
        const std::vector<int32_t>& _var_sequence)
{
    m_var_sequence = _var_sequence;
}

/*!
 * @brief This function moves the value in member var_sequence
 * @param _var_sequence New value to be moved in member var_sequence
 */
void SequenceStruct::var_sequence(
        std::vector<int32_t>&& _var_sequence)
{
    m_var_sequence = std::move(_var_sequence);
}

/*!
 * @brief This function returns a constant reference to member var_sequence
 * @return Constant reference to member var_sequence
 */
const std::vector<int32_t>& SequenceStruct::var_sequence() const
{
    return m_var_sequence;
}

/*!
 * @brief This function returns a reference to member var_sequence
 * @return Reference to member var_sequence
 */
std::vector<int32_t>& SequenceStruct::var_sequence()
{
    return m_var_sequence;
}


size_t SequenceStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceStruct_max_key_cdr_typesize;
}

bool SequenceStruct::isKeyDefined()
{
    return false;
}

void SequenceStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


MapStruct::MapStruct()
{
    // map<long, long> m_var_map


    // Just to register all known types
    registerstructuresTypes();
}

MapStruct::~MapStruct()
{
}

MapStruct::MapStruct(
        const MapStruct& x)
{
    m_var_map = x.m_var_map;
}

MapStruct::MapStruct(
        MapStruct&& x) noexcept 
{
    m_var_map = std::move(x.m_var_map);
}

MapStruct& MapStruct::operator =(
        const MapStruct& x)
{

    m_var_map = x.m_var_map;

    return *this;
}

MapStruct& MapStruct::operator =(
        MapStruct&& x) noexcept
{

    m_var_map = std::move(x.m_var_map);

    return *this;
}

bool MapStruct::operator ==(
        const MapStruct& x) const
{

    return (m_var_map == x.m_var_map);
}

bool MapStruct::operator !=(
        const MapStruct& x) const
{
    return !(*this == x);
}

size_t MapStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapStruct_max_cdr_typesize;
}

size_t MapStruct::getCdrSerializedSize(
        const MapStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.var_map())
    {
        (void)a;

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }

    return current_alignment - initial_alignment;
}

void MapStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << static_cast<uint32_t>(m_var_map.size());
    for (const auto& pair : m_var_map)
    {
        scdr << pair.first;    scdr << pair.second;}}

void MapStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{


        dcdr >> m_var_map;
}

/*!
 * @brief This function copies the value in member var_map
 * @param _var_map New value to be copied in member var_map
 */
void MapStruct::var_map(
        const std::map<int32_t, int32_t>& _var_map)
{
    m_var_map = _var_map;
}

/*!
 * @brief This function moves the value in member var_map
 * @param _var_map New value to be moved in member var_map
 */
void MapStruct::var_map(
        std::map<int32_t, int32_t>&& _var_map)
{
    m_var_map = std::move(_var_map);
}

/*!
 * @brief This function returns a constant reference to member var_map
 * @return Constant reference to member var_map
 */
const std::map<int32_t, int32_t>& MapStruct::var_map() const
{
    return m_var_map;
}

/*!
 * @brief This function returns a reference to member var_map
 * @return Reference to member var_map
 */
std::map<int32_t, int32_t>& MapStruct::var_map()
{
    return m_var_map;
}


size_t MapStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapStruct_max_key_cdr_typesize;
}

bool MapStruct::isKeyDefined()
{
    return false;
}

void MapStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionStruct::UnionStruct()
{
    // InnerUnionHelper m_var_union


    // Just to register all known types
    registerstructuresTypes();
}

UnionStruct::~UnionStruct()
{
}

UnionStruct::UnionStruct(
        const UnionStruct& x)
{
    m_var_union = x.m_var_union;
}

UnionStruct::UnionStruct(
        UnionStruct&& x) noexcept 
{
    m_var_union = std::move(x.m_var_union);
}

UnionStruct& UnionStruct::operator =(
        const UnionStruct& x)
{

    m_var_union = x.m_var_union;

    return *this;
}

UnionStruct& UnionStruct::operator =(
        UnionStruct&& x) noexcept
{

    m_var_union = std::move(x.m_var_union);

    return *this;
}

bool UnionStruct::operator ==(
        const UnionStruct& x) const
{

    return (m_var_union == x.m_var_union);
}

bool UnionStruct::operator !=(
        const UnionStruct& x) const
{
    return !(*this == x);
}

size_t UnionStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionStruct_max_cdr_typesize;
}

size_t UnionStruct::getCdrSerializedSize(
        const UnionStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += InnerUnionHelper::getCdrSerializedSize(data.var_union(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union;
}

void UnionStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union;
}

/*!
 * @brief This function copies the value in member var_union
 * @param _var_union New value to be copied in member var_union
 */
void UnionStruct::var_union(
        const InnerUnionHelper& _var_union)
{
    m_var_union = _var_union;
}

/*!
 * @brief This function moves the value in member var_union
 * @param _var_union New value to be moved in member var_union
 */
void UnionStruct::var_union(
        InnerUnionHelper&& _var_union)
{
    m_var_union = std::move(_var_union);
}

/*!
 * @brief This function returns a constant reference to member var_union
 * @return Constant reference to member var_union
 */
const InnerUnionHelper& UnionStruct::var_union() const
{
    return m_var_union;
}

/*!
 * @brief This function returns a reference to member var_union
 * @return Reference to member var_union
 */
InnerUnionHelper& UnionStruct::var_union()
{
    return m_var_union;
}


size_t UnionStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionStruct_max_key_cdr_typesize;
}

bool UnionStruct::isKeyDefined()
{
    return false;
}

void UnionStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


StructureStruct::StructureStruct()
{
    // InnerStructureHelper m_var_structure


    // Just to register all known types
    registerstructuresTypes();
}

StructureStruct::~StructureStruct()
{
}

StructureStruct::StructureStruct(
        const StructureStruct& x)
{
    m_var_structure = x.m_var_structure;
}

StructureStruct::StructureStruct(
        StructureStruct&& x) noexcept 
{
    m_var_structure = std::move(x.m_var_structure);
}

StructureStruct& StructureStruct::operator =(
        const StructureStruct& x)
{

    m_var_structure = x.m_var_structure;

    return *this;
}

StructureStruct& StructureStruct::operator =(
        StructureStruct&& x) noexcept
{

    m_var_structure = std::move(x.m_var_structure);

    return *this;
}

bool StructureStruct::operator ==(
        const StructureStruct& x) const
{

    return (m_var_structure == x.m_var_structure);
}

bool StructureStruct::operator !=(
        const StructureStruct& x) const
{
    return !(*this == x);
}

size_t StructureStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructureStruct_max_cdr_typesize;
}

size_t StructureStruct::getCdrSerializedSize(
        const StructureStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += InnerStructureHelper::getCdrSerializedSize(data.var_structure(), current_alignment);

    return current_alignment - initial_alignment;
}

void StructureStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_structure;
}

void StructureStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_structure;
}

/*!
 * @brief This function copies the value in member var_structure
 * @param _var_structure New value to be copied in member var_structure
 */
void StructureStruct::var_structure(
        const InnerStructureHelper& _var_structure)
{
    m_var_structure = _var_structure;
}

/*!
 * @brief This function moves the value in member var_structure
 * @param _var_structure New value to be moved in member var_structure
 */
void StructureStruct::var_structure(
        InnerStructureHelper&& _var_structure)
{
    m_var_structure = std::move(_var_structure);
}

/*!
 * @brief This function returns a constant reference to member var_structure
 * @return Constant reference to member var_structure
 */
const InnerStructureHelper& StructureStruct::var_structure() const
{
    return m_var_structure;
}

/*!
 * @brief This function returns a reference to member var_structure
 * @return Reference to member var_structure
 */
InnerStructureHelper& StructureStruct::var_structure()
{
    return m_var_structure;
}


size_t StructureStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StructureStruct_max_key_cdr_typesize;
}

bool StructureStruct::isKeyDefined()
{
    return false;
}

void StructureStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


BitsetStruct::BitsetStruct()
{
    // InnerBitsetHelper m_var_bitset


    // Just to register all known types
    registerstructuresTypes();
}

BitsetStruct::~BitsetStruct()
{
}

BitsetStruct::BitsetStruct(
        const BitsetStruct& x)
{
    m_var_bitset = x.m_var_bitset;
}

BitsetStruct::BitsetStruct(
        BitsetStruct&& x) noexcept 
{
    m_var_bitset = std::move(x.m_var_bitset);
}

BitsetStruct& BitsetStruct::operator =(
        const BitsetStruct& x)
{

    m_var_bitset = x.m_var_bitset;

    return *this;
}

BitsetStruct& BitsetStruct::operator =(
        BitsetStruct&& x) noexcept
{

    m_var_bitset = std::move(x.m_var_bitset);

    return *this;
}

bool BitsetStruct::operator ==(
        const BitsetStruct& x) const
{

    return (m_var_bitset == x.m_var_bitset);
}

bool BitsetStruct::operator !=(
        const BitsetStruct& x) const
{
    return !(*this == x);
}

size_t BitsetStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BitsetStruct_max_cdr_typesize;
}

size_t BitsetStruct::getCdrSerializedSize(
        const BitsetStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += InnerBitsetHelper::getCdrSerializedSize(data.var_bitset(), current_alignment);

    return current_alignment - initial_alignment;
}

void BitsetStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_bitset;
}

void BitsetStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_bitset;
}

/*!
 * @brief This function copies the value in member var_bitset
 * @param _var_bitset New value to be copied in member var_bitset
 */
void BitsetStruct::var_bitset(
        const InnerBitsetHelper& _var_bitset)
{
    m_var_bitset = _var_bitset;
}

/*!
 * @brief This function moves the value in member var_bitset
 * @param _var_bitset New value to be moved in member var_bitset
 */
void BitsetStruct::var_bitset(
        InnerBitsetHelper&& _var_bitset)
{
    m_var_bitset = std::move(_var_bitset);
}

/*!
 * @brief This function returns a constant reference to member var_bitset
 * @return Constant reference to member var_bitset
 */
const InnerBitsetHelper& BitsetStruct::var_bitset() const
{
    return m_var_bitset;
}

/*!
 * @brief This function returns a reference to member var_bitset
 * @return Reference to member var_bitset
 */
InnerBitsetHelper& BitsetStruct::var_bitset()
{
    return m_var_bitset;
}


size_t BitsetStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BitsetStruct_max_key_cdr_typesize;
}

bool BitsetStruct::isKeyDefined()
{
    return false;
}

void BitsetStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


EmptyStructure::EmptyStructure()
{

    // Just to register all known types
    registerstructuresTypes();
}

EmptyStructure::~EmptyStructure()
{
}

EmptyStructure::EmptyStructure(
        const EmptyStructure& x)
{
}

EmptyStructure::EmptyStructure(
        EmptyStructure&& x) noexcept 
{
}

EmptyStructure& EmptyStructure::operator =(
        const EmptyStructure& x)
{


    return *this;
}

EmptyStructure& EmptyStructure::operator =(
        EmptyStructure&& x) noexcept
{


    return *this;
}

bool EmptyStructure::operator ==(
        const EmptyStructure& x) const
{

    return true;
}

bool EmptyStructure::operator !=(
        const EmptyStructure& x) const
{
    return !(*this == x);
}

size_t EmptyStructure::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return EmptyStructure_max_cdr_typesize;
}

size_t EmptyStructure::getCdrSerializedSize(
        const EmptyStructure& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    return current_alignment - initial_alignment;
}

void EmptyStructure::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

}

void EmptyStructure::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

}



size_t EmptyStructure::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return EmptyStructure_max_key_cdr_typesize;
}

bool EmptyStructure::isKeyDefined()
{
    return false;
}

void EmptyStructure::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


Structures::Structures()
{
    // ShortStruct m_var_ShortStruct

    // UnsignedShortStruct m_var_UnsignedShortStruct

    // LongStruct m_var_LongStruct

    // UnsignedLongStruct m_var_UnsignedLongStruct

    // LongLongStruct m_var_LongLongStruct

    // UnsignedLongLongStruct m_var_UnsignedLongLongStruct

    // FloatStruct m_var_FloatStruct

    // DoubleStruct m_var_DoubleStruct

    // LongDoubleStruct m_var_LongDoubleStruct

    // BooleanStruct m_var_BooleanStruct

    // OctetStruct m_var_OctetStruct

    // Char8Struct m_var_Char8Struct

    // Char16Struct m_var_Char16Struct

    // StringStruct m_var_StringStruct

    // WStringStruct m_var_WStringStruct

    // EnumStruct m_var_EnumStruct

    // BitMaskStruct m_var_BitMaskStruct

    // AliasStruct m_var_AliasStruct

    // ShortArrayStruct m_var_ShortArrayStruct

    // SequenceStruct m_var_SequenceStruct

    // MapStruct m_var_MapStruct

    // UnionStruct m_var_UnionStruct

    // StructureStruct m_var_StructureStruct

    // BitsetStruct m_var_BitsetStruct

    // EmptyStructure m_var_EmptyStructure


    // Just to register all known types
    registerstructuresTypes();
}

Structures::~Structures()
{

























}

Structures::Structures(
        const Structures& x)
{
    m_var_ShortStruct = x.m_var_ShortStruct;
    m_var_UnsignedShortStruct = x.m_var_UnsignedShortStruct;
    m_var_LongStruct = x.m_var_LongStruct;
    m_var_UnsignedLongStruct = x.m_var_UnsignedLongStruct;
    m_var_LongLongStruct = x.m_var_LongLongStruct;
    m_var_UnsignedLongLongStruct = x.m_var_UnsignedLongLongStruct;
    m_var_FloatStruct = x.m_var_FloatStruct;
    m_var_DoubleStruct = x.m_var_DoubleStruct;
    m_var_LongDoubleStruct = x.m_var_LongDoubleStruct;
    m_var_BooleanStruct = x.m_var_BooleanStruct;
    m_var_OctetStruct = x.m_var_OctetStruct;
    m_var_Char8Struct = x.m_var_Char8Struct;
    m_var_Char16Struct = x.m_var_Char16Struct;
    m_var_StringStruct = x.m_var_StringStruct;
    m_var_WStringStruct = x.m_var_WStringStruct;
    m_var_EnumStruct = x.m_var_EnumStruct;
    m_var_BitMaskStruct = x.m_var_BitMaskStruct;
    m_var_AliasStruct = x.m_var_AliasStruct;
    m_var_ShortArrayStruct = x.m_var_ShortArrayStruct;
    m_var_SequenceStruct = x.m_var_SequenceStruct;
    m_var_MapStruct = x.m_var_MapStruct;
    m_var_UnionStruct = x.m_var_UnionStruct;
    m_var_StructureStruct = x.m_var_StructureStruct;
    m_var_BitsetStruct = x.m_var_BitsetStruct;
    m_var_EmptyStructure = x.m_var_EmptyStructure;
}

Structures::Structures(
        Structures&& x) noexcept 
{
    m_var_ShortStruct = std::move(x.m_var_ShortStruct);
    m_var_UnsignedShortStruct = std::move(x.m_var_UnsignedShortStruct);
    m_var_LongStruct = std::move(x.m_var_LongStruct);
    m_var_UnsignedLongStruct = std::move(x.m_var_UnsignedLongStruct);
    m_var_LongLongStruct = std::move(x.m_var_LongLongStruct);
    m_var_UnsignedLongLongStruct = std::move(x.m_var_UnsignedLongLongStruct);
    m_var_FloatStruct = std::move(x.m_var_FloatStruct);
    m_var_DoubleStruct = std::move(x.m_var_DoubleStruct);
    m_var_LongDoubleStruct = std::move(x.m_var_LongDoubleStruct);
    m_var_BooleanStruct = std::move(x.m_var_BooleanStruct);
    m_var_OctetStruct = std::move(x.m_var_OctetStruct);
    m_var_Char8Struct = std::move(x.m_var_Char8Struct);
    m_var_Char16Struct = std::move(x.m_var_Char16Struct);
    m_var_StringStruct = std::move(x.m_var_StringStruct);
    m_var_WStringStruct = std::move(x.m_var_WStringStruct);
    m_var_EnumStruct = std::move(x.m_var_EnumStruct);
    m_var_BitMaskStruct = std::move(x.m_var_BitMaskStruct);
    m_var_AliasStruct = std::move(x.m_var_AliasStruct);
    m_var_ShortArrayStruct = std::move(x.m_var_ShortArrayStruct);
    m_var_SequenceStruct = std::move(x.m_var_SequenceStruct);
    m_var_MapStruct = std::move(x.m_var_MapStruct);
    m_var_UnionStruct = std::move(x.m_var_UnionStruct);
    m_var_StructureStruct = std::move(x.m_var_StructureStruct);
    m_var_BitsetStruct = std::move(x.m_var_BitsetStruct);
    m_var_EmptyStructure = std::move(x.m_var_EmptyStructure);
}

Structures& Structures::operator =(
        const Structures& x)
{

    m_var_ShortStruct = x.m_var_ShortStruct;
    m_var_UnsignedShortStruct = x.m_var_UnsignedShortStruct;
    m_var_LongStruct = x.m_var_LongStruct;
    m_var_UnsignedLongStruct = x.m_var_UnsignedLongStruct;
    m_var_LongLongStruct = x.m_var_LongLongStruct;
    m_var_UnsignedLongLongStruct = x.m_var_UnsignedLongLongStruct;
    m_var_FloatStruct = x.m_var_FloatStruct;
    m_var_DoubleStruct = x.m_var_DoubleStruct;
    m_var_LongDoubleStruct = x.m_var_LongDoubleStruct;
    m_var_BooleanStruct = x.m_var_BooleanStruct;
    m_var_OctetStruct = x.m_var_OctetStruct;
    m_var_Char8Struct = x.m_var_Char8Struct;
    m_var_Char16Struct = x.m_var_Char16Struct;
    m_var_StringStruct = x.m_var_StringStruct;
    m_var_WStringStruct = x.m_var_WStringStruct;
    m_var_EnumStruct = x.m_var_EnumStruct;
    m_var_BitMaskStruct = x.m_var_BitMaskStruct;
    m_var_AliasStruct = x.m_var_AliasStruct;
    m_var_ShortArrayStruct = x.m_var_ShortArrayStruct;
    m_var_SequenceStruct = x.m_var_SequenceStruct;
    m_var_MapStruct = x.m_var_MapStruct;
    m_var_UnionStruct = x.m_var_UnionStruct;
    m_var_StructureStruct = x.m_var_StructureStruct;
    m_var_BitsetStruct = x.m_var_BitsetStruct;
    m_var_EmptyStructure = x.m_var_EmptyStructure;

    return *this;
}

Structures& Structures::operator =(
        Structures&& x) noexcept
{

    m_var_ShortStruct = std::move(x.m_var_ShortStruct);
    m_var_UnsignedShortStruct = std::move(x.m_var_UnsignedShortStruct);
    m_var_LongStruct = std::move(x.m_var_LongStruct);
    m_var_UnsignedLongStruct = std::move(x.m_var_UnsignedLongStruct);
    m_var_LongLongStruct = std::move(x.m_var_LongLongStruct);
    m_var_UnsignedLongLongStruct = std::move(x.m_var_UnsignedLongLongStruct);
    m_var_FloatStruct = std::move(x.m_var_FloatStruct);
    m_var_DoubleStruct = std::move(x.m_var_DoubleStruct);
    m_var_LongDoubleStruct = std::move(x.m_var_LongDoubleStruct);
    m_var_BooleanStruct = std::move(x.m_var_BooleanStruct);
    m_var_OctetStruct = std::move(x.m_var_OctetStruct);
    m_var_Char8Struct = std::move(x.m_var_Char8Struct);
    m_var_Char16Struct = std::move(x.m_var_Char16Struct);
    m_var_StringStruct = std::move(x.m_var_StringStruct);
    m_var_WStringStruct = std::move(x.m_var_WStringStruct);
    m_var_EnumStruct = std::move(x.m_var_EnumStruct);
    m_var_BitMaskStruct = std::move(x.m_var_BitMaskStruct);
    m_var_AliasStruct = std::move(x.m_var_AliasStruct);
    m_var_ShortArrayStruct = std::move(x.m_var_ShortArrayStruct);
    m_var_SequenceStruct = std::move(x.m_var_SequenceStruct);
    m_var_MapStruct = std::move(x.m_var_MapStruct);
    m_var_UnionStruct = std::move(x.m_var_UnionStruct);
    m_var_StructureStruct = std::move(x.m_var_StructureStruct);
    m_var_BitsetStruct = std::move(x.m_var_BitsetStruct);
    m_var_EmptyStructure = std::move(x.m_var_EmptyStructure);

    return *this;
}

bool Structures::operator ==(
        const Structures& x) const
{

    return (m_var_ShortStruct == x.m_var_ShortStruct && m_var_UnsignedShortStruct == x.m_var_UnsignedShortStruct && m_var_LongStruct == x.m_var_LongStruct && m_var_UnsignedLongStruct == x.m_var_UnsignedLongStruct && m_var_LongLongStruct == x.m_var_LongLongStruct && m_var_UnsignedLongLongStruct == x.m_var_UnsignedLongLongStruct && m_var_FloatStruct == x.m_var_FloatStruct && m_var_DoubleStruct == x.m_var_DoubleStruct && m_var_LongDoubleStruct == x.m_var_LongDoubleStruct && m_var_BooleanStruct == x.m_var_BooleanStruct && m_var_OctetStruct == x.m_var_OctetStruct && m_var_Char8Struct == x.m_var_Char8Struct && m_var_Char16Struct == x.m_var_Char16Struct && m_var_StringStruct == x.m_var_StringStruct && m_var_WStringStruct == x.m_var_WStringStruct && m_var_EnumStruct == x.m_var_EnumStruct && m_var_BitMaskStruct == x.m_var_BitMaskStruct && m_var_AliasStruct == x.m_var_AliasStruct && m_var_ShortArrayStruct == x.m_var_ShortArrayStruct && m_var_SequenceStruct == x.m_var_SequenceStruct && m_var_MapStruct == x.m_var_MapStruct && m_var_UnionStruct == x.m_var_UnionStruct && m_var_StructureStruct == x.m_var_StructureStruct && m_var_BitsetStruct == x.m_var_BitsetStruct && m_var_EmptyStructure == x.m_var_EmptyStructure);
}

bool Structures::operator !=(
        const Structures& x) const
{
    return !(*this == x);
}

size_t Structures::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Structures_max_cdr_typesize;
}

size_t Structures::getCdrSerializedSize(
        const Structures& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ShortStruct::getCdrSerializedSize(data.var_ShortStruct(), current_alignment);
    current_alignment += UnsignedShortStruct::getCdrSerializedSize(data.var_UnsignedShortStruct(), current_alignment);
    current_alignment += LongStruct::getCdrSerializedSize(data.var_LongStruct(), current_alignment);
    current_alignment += UnsignedLongStruct::getCdrSerializedSize(data.var_UnsignedLongStruct(), current_alignment);
    current_alignment += LongLongStruct::getCdrSerializedSize(data.var_LongLongStruct(), current_alignment);
    current_alignment += UnsignedLongLongStruct::getCdrSerializedSize(data.var_UnsignedLongLongStruct(), current_alignment);
    current_alignment += FloatStruct::getCdrSerializedSize(data.var_FloatStruct(), current_alignment);
    current_alignment += DoubleStruct::getCdrSerializedSize(data.var_DoubleStruct(), current_alignment);
    current_alignment += LongDoubleStruct::getCdrSerializedSize(data.var_LongDoubleStruct(), current_alignment);
    current_alignment += BooleanStruct::getCdrSerializedSize(data.var_BooleanStruct(), current_alignment);
    current_alignment += OctetStruct::getCdrSerializedSize(data.var_OctetStruct(), current_alignment);
    current_alignment += Char8Struct::getCdrSerializedSize(data.var_Char8Struct(), current_alignment);
    current_alignment += Char16Struct::getCdrSerializedSize(data.var_Char16Struct(), current_alignment);
    current_alignment += StringStruct::getCdrSerializedSize(data.var_StringStruct(), current_alignment);
    current_alignment += WStringStruct::getCdrSerializedSize(data.var_WStringStruct(), current_alignment);
    current_alignment += EnumStruct::getCdrSerializedSize(data.var_EnumStruct(), current_alignment);
    current_alignment += BitMaskStruct::getCdrSerializedSize(data.var_BitMaskStruct(), current_alignment);
    current_alignment += AliasStruct::getCdrSerializedSize(data.var_AliasStruct(), current_alignment);
    current_alignment += ShortArrayStruct::getCdrSerializedSize(data.var_ShortArrayStruct(), current_alignment);
    current_alignment += SequenceStruct::getCdrSerializedSize(data.var_SequenceStruct(), current_alignment);
    current_alignment += MapStruct::getCdrSerializedSize(data.var_MapStruct(), current_alignment);
    current_alignment += UnionStruct::getCdrSerializedSize(data.var_UnionStruct(), current_alignment);
    current_alignment += StructureStruct::getCdrSerializedSize(data.var_StructureStruct(), current_alignment);
    current_alignment += BitsetStruct::getCdrSerializedSize(data.var_BitsetStruct(), current_alignment);
    current_alignment += EmptyStructure::getCdrSerializedSize(data.var_EmptyStructure(), current_alignment);

    return current_alignment - initial_alignment;
}

void Structures::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ShortStruct;scdr << m_var_UnsignedShortStruct;scdr << m_var_LongStruct;scdr << m_var_UnsignedLongStruct;scdr << m_var_LongLongStruct;scdr << m_var_UnsignedLongLongStruct;scdr << m_var_FloatStruct;scdr << m_var_DoubleStruct;scdr << m_var_LongDoubleStruct;scdr << m_var_BooleanStruct;scdr << m_var_OctetStruct;scdr << m_var_Char8Struct;scdr << m_var_Char16Struct;scdr << m_var_StringStruct;scdr << m_var_WStringStruct;scdr << m_var_EnumStruct;scdr << m_var_BitMaskStruct;scdr << m_var_AliasStruct;scdr << m_var_ShortArrayStruct;scdr << m_var_SequenceStruct;scdr << m_var_MapStruct;scdr << m_var_UnionStruct;scdr << m_var_StructureStruct;scdr << m_var_BitsetStruct;scdr << m_var_EmptyStructure;
}

void Structures::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ShortStruct;
    dcdr >> m_var_UnsignedShortStruct;
    dcdr >> m_var_LongStruct;
    dcdr >> m_var_UnsignedLongStruct;
    dcdr >> m_var_LongLongStruct;
    dcdr >> m_var_UnsignedLongLongStruct;
    dcdr >> m_var_FloatStruct;
    dcdr >> m_var_DoubleStruct;
    dcdr >> m_var_LongDoubleStruct;
    dcdr >> m_var_BooleanStruct;
    dcdr >> m_var_OctetStruct;
    dcdr >> m_var_Char8Struct;
    dcdr >> m_var_Char16Struct;
    dcdr >> m_var_StringStruct;
    dcdr >> m_var_WStringStruct;
    dcdr >> m_var_EnumStruct;
    dcdr >> m_var_BitMaskStruct;
    dcdr >> m_var_AliasStruct;
    dcdr >> m_var_ShortArrayStruct;
    dcdr >> m_var_SequenceStruct;
    dcdr >> m_var_MapStruct;
    dcdr >> m_var_UnionStruct;
    dcdr >> m_var_StructureStruct;
    dcdr >> m_var_BitsetStruct;
    dcdr >> m_var_EmptyStructure;
}

/*!
 * @brief This function copies the value in member var_ShortStruct
 * @param _var_ShortStruct New value to be copied in member var_ShortStruct
 */
void Structures::var_ShortStruct(
        const ShortStruct& _var_ShortStruct)
{
    m_var_ShortStruct = _var_ShortStruct;
}

/*!
 * @brief This function moves the value in member var_ShortStruct
 * @param _var_ShortStruct New value to be moved in member var_ShortStruct
 */
void Structures::var_ShortStruct(
        ShortStruct&& _var_ShortStruct)
{
    m_var_ShortStruct = std::move(_var_ShortStruct);
}

/*!
 * @brief This function returns a constant reference to member var_ShortStruct
 * @return Constant reference to member var_ShortStruct
 */
const ShortStruct& Structures::var_ShortStruct() const
{
    return m_var_ShortStruct;
}

/*!
 * @brief This function returns a reference to member var_ShortStruct
 * @return Reference to member var_ShortStruct
 */
ShortStruct& Structures::var_ShortStruct()
{
    return m_var_ShortStruct;
}
/*!
 * @brief This function copies the value in member var_UnsignedShortStruct
 * @param _var_UnsignedShortStruct New value to be copied in member var_UnsignedShortStruct
 */
void Structures::var_UnsignedShortStruct(
        const UnsignedShortStruct& _var_UnsignedShortStruct)
{
    m_var_UnsignedShortStruct = _var_UnsignedShortStruct;
}

/*!
 * @brief This function moves the value in member var_UnsignedShortStruct
 * @param _var_UnsignedShortStruct New value to be moved in member var_UnsignedShortStruct
 */
void Structures::var_UnsignedShortStruct(
        UnsignedShortStruct&& _var_UnsignedShortStruct)
{
    m_var_UnsignedShortStruct = std::move(_var_UnsignedShortStruct);
}

/*!
 * @brief This function returns a constant reference to member var_UnsignedShortStruct
 * @return Constant reference to member var_UnsignedShortStruct
 */
const UnsignedShortStruct& Structures::var_UnsignedShortStruct() const
{
    return m_var_UnsignedShortStruct;
}

/*!
 * @brief This function returns a reference to member var_UnsignedShortStruct
 * @return Reference to member var_UnsignedShortStruct
 */
UnsignedShortStruct& Structures::var_UnsignedShortStruct()
{
    return m_var_UnsignedShortStruct;
}
/*!
 * @brief This function copies the value in member var_LongStruct
 * @param _var_LongStruct New value to be copied in member var_LongStruct
 */
void Structures::var_LongStruct(
        const LongStruct& _var_LongStruct)
{
    m_var_LongStruct = _var_LongStruct;
}

/*!
 * @brief This function moves the value in member var_LongStruct
 * @param _var_LongStruct New value to be moved in member var_LongStruct
 */
void Structures::var_LongStruct(
        LongStruct&& _var_LongStruct)
{
    m_var_LongStruct = std::move(_var_LongStruct);
}

/*!
 * @brief This function returns a constant reference to member var_LongStruct
 * @return Constant reference to member var_LongStruct
 */
const LongStruct& Structures::var_LongStruct() const
{
    return m_var_LongStruct;
}

/*!
 * @brief This function returns a reference to member var_LongStruct
 * @return Reference to member var_LongStruct
 */
LongStruct& Structures::var_LongStruct()
{
    return m_var_LongStruct;
}
/*!
 * @brief This function copies the value in member var_UnsignedLongStruct
 * @param _var_UnsignedLongStruct New value to be copied in member var_UnsignedLongStruct
 */
void Structures::var_UnsignedLongStruct(
        const UnsignedLongStruct& _var_UnsignedLongStruct)
{
    m_var_UnsignedLongStruct = _var_UnsignedLongStruct;
}

/*!
 * @brief This function moves the value in member var_UnsignedLongStruct
 * @param _var_UnsignedLongStruct New value to be moved in member var_UnsignedLongStruct
 */
void Structures::var_UnsignedLongStruct(
        UnsignedLongStruct&& _var_UnsignedLongStruct)
{
    m_var_UnsignedLongStruct = std::move(_var_UnsignedLongStruct);
}

/*!
 * @brief This function returns a constant reference to member var_UnsignedLongStruct
 * @return Constant reference to member var_UnsignedLongStruct
 */
const UnsignedLongStruct& Structures::var_UnsignedLongStruct() const
{
    return m_var_UnsignedLongStruct;
}

/*!
 * @brief This function returns a reference to member var_UnsignedLongStruct
 * @return Reference to member var_UnsignedLongStruct
 */
UnsignedLongStruct& Structures::var_UnsignedLongStruct()
{
    return m_var_UnsignedLongStruct;
}
/*!
 * @brief This function copies the value in member var_LongLongStruct
 * @param _var_LongLongStruct New value to be copied in member var_LongLongStruct
 */
void Structures::var_LongLongStruct(
        const LongLongStruct& _var_LongLongStruct)
{
    m_var_LongLongStruct = _var_LongLongStruct;
}

/*!
 * @brief This function moves the value in member var_LongLongStruct
 * @param _var_LongLongStruct New value to be moved in member var_LongLongStruct
 */
void Structures::var_LongLongStruct(
        LongLongStruct&& _var_LongLongStruct)
{
    m_var_LongLongStruct = std::move(_var_LongLongStruct);
}

/*!
 * @brief This function returns a constant reference to member var_LongLongStruct
 * @return Constant reference to member var_LongLongStruct
 */
const LongLongStruct& Structures::var_LongLongStruct() const
{
    return m_var_LongLongStruct;
}

/*!
 * @brief This function returns a reference to member var_LongLongStruct
 * @return Reference to member var_LongLongStruct
 */
LongLongStruct& Structures::var_LongLongStruct()
{
    return m_var_LongLongStruct;
}
/*!
 * @brief This function copies the value in member var_UnsignedLongLongStruct
 * @param _var_UnsignedLongLongStruct New value to be copied in member var_UnsignedLongLongStruct
 */
void Structures::var_UnsignedLongLongStruct(
        const UnsignedLongLongStruct& _var_UnsignedLongLongStruct)
{
    m_var_UnsignedLongLongStruct = _var_UnsignedLongLongStruct;
}

/*!
 * @brief This function moves the value in member var_UnsignedLongLongStruct
 * @param _var_UnsignedLongLongStruct New value to be moved in member var_UnsignedLongLongStruct
 */
void Structures::var_UnsignedLongLongStruct(
        UnsignedLongLongStruct&& _var_UnsignedLongLongStruct)
{
    m_var_UnsignedLongLongStruct = std::move(_var_UnsignedLongLongStruct);
}

/*!
 * @brief This function returns a constant reference to member var_UnsignedLongLongStruct
 * @return Constant reference to member var_UnsignedLongLongStruct
 */
const UnsignedLongLongStruct& Structures::var_UnsignedLongLongStruct() const
{
    return m_var_UnsignedLongLongStruct;
}

/*!
 * @brief This function returns a reference to member var_UnsignedLongLongStruct
 * @return Reference to member var_UnsignedLongLongStruct
 */
UnsignedLongLongStruct& Structures::var_UnsignedLongLongStruct()
{
    return m_var_UnsignedLongLongStruct;
}
/*!
 * @brief This function copies the value in member var_FloatStruct
 * @param _var_FloatStruct New value to be copied in member var_FloatStruct
 */
void Structures::var_FloatStruct(
        const FloatStruct& _var_FloatStruct)
{
    m_var_FloatStruct = _var_FloatStruct;
}

/*!
 * @brief This function moves the value in member var_FloatStruct
 * @param _var_FloatStruct New value to be moved in member var_FloatStruct
 */
void Structures::var_FloatStruct(
        FloatStruct&& _var_FloatStruct)
{
    m_var_FloatStruct = std::move(_var_FloatStruct);
}

/*!
 * @brief This function returns a constant reference to member var_FloatStruct
 * @return Constant reference to member var_FloatStruct
 */
const FloatStruct& Structures::var_FloatStruct() const
{
    return m_var_FloatStruct;
}

/*!
 * @brief This function returns a reference to member var_FloatStruct
 * @return Reference to member var_FloatStruct
 */
FloatStruct& Structures::var_FloatStruct()
{
    return m_var_FloatStruct;
}
/*!
 * @brief This function copies the value in member var_DoubleStruct
 * @param _var_DoubleStruct New value to be copied in member var_DoubleStruct
 */
void Structures::var_DoubleStruct(
        const DoubleStruct& _var_DoubleStruct)
{
    m_var_DoubleStruct = _var_DoubleStruct;
}

/*!
 * @brief This function moves the value in member var_DoubleStruct
 * @param _var_DoubleStruct New value to be moved in member var_DoubleStruct
 */
void Structures::var_DoubleStruct(
        DoubleStruct&& _var_DoubleStruct)
{
    m_var_DoubleStruct = std::move(_var_DoubleStruct);
}

/*!
 * @brief This function returns a constant reference to member var_DoubleStruct
 * @return Constant reference to member var_DoubleStruct
 */
const DoubleStruct& Structures::var_DoubleStruct() const
{
    return m_var_DoubleStruct;
}

/*!
 * @brief This function returns a reference to member var_DoubleStruct
 * @return Reference to member var_DoubleStruct
 */
DoubleStruct& Structures::var_DoubleStruct()
{
    return m_var_DoubleStruct;
}
/*!
 * @brief This function copies the value in member var_LongDoubleStruct
 * @param _var_LongDoubleStruct New value to be copied in member var_LongDoubleStruct
 */
void Structures::var_LongDoubleStruct(
        const LongDoubleStruct& _var_LongDoubleStruct)
{
    m_var_LongDoubleStruct = _var_LongDoubleStruct;
}

/*!
 * @brief This function moves the value in member var_LongDoubleStruct
 * @param _var_LongDoubleStruct New value to be moved in member var_LongDoubleStruct
 */
void Structures::var_LongDoubleStruct(
        LongDoubleStruct&& _var_LongDoubleStruct)
{
    m_var_LongDoubleStruct = std::move(_var_LongDoubleStruct);
}

/*!
 * @brief This function returns a constant reference to member var_LongDoubleStruct
 * @return Constant reference to member var_LongDoubleStruct
 */
const LongDoubleStruct& Structures::var_LongDoubleStruct() const
{
    return m_var_LongDoubleStruct;
}

/*!
 * @brief This function returns a reference to member var_LongDoubleStruct
 * @return Reference to member var_LongDoubleStruct
 */
LongDoubleStruct& Structures::var_LongDoubleStruct()
{
    return m_var_LongDoubleStruct;
}
/*!
 * @brief This function copies the value in member var_BooleanStruct
 * @param _var_BooleanStruct New value to be copied in member var_BooleanStruct
 */
void Structures::var_BooleanStruct(
        const BooleanStruct& _var_BooleanStruct)
{
    m_var_BooleanStruct = _var_BooleanStruct;
}

/*!
 * @brief This function moves the value in member var_BooleanStruct
 * @param _var_BooleanStruct New value to be moved in member var_BooleanStruct
 */
void Structures::var_BooleanStruct(
        BooleanStruct&& _var_BooleanStruct)
{
    m_var_BooleanStruct = std::move(_var_BooleanStruct);
}

/*!
 * @brief This function returns a constant reference to member var_BooleanStruct
 * @return Constant reference to member var_BooleanStruct
 */
const BooleanStruct& Structures::var_BooleanStruct() const
{
    return m_var_BooleanStruct;
}

/*!
 * @brief This function returns a reference to member var_BooleanStruct
 * @return Reference to member var_BooleanStruct
 */
BooleanStruct& Structures::var_BooleanStruct()
{
    return m_var_BooleanStruct;
}
/*!
 * @brief This function copies the value in member var_OctetStruct
 * @param _var_OctetStruct New value to be copied in member var_OctetStruct
 */
void Structures::var_OctetStruct(
        const OctetStruct& _var_OctetStruct)
{
    m_var_OctetStruct = _var_OctetStruct;
}

/*!
 * @brief This function moves the value in member var_OctetStruct
 * @param _var_OctetStruct New value to be moved in member var_OctetStruct
 */
void Structures::var_OctetStruct(
        OctetStruct&& _var_OctetStruct)
{
    m_var_OctetStruct = std::move(_var_OctetStruct);
}

/*!
 * @brief This function returns a constant reference to member var_OctetStruct
 * @return Constant reference to member var_OctetStruct
 */
const OctetStruct& Structures::var_OctetStruct() const
{
    return m_var_OctetStruct;
}

/*!
 * @brief This function returns a reference to member var_OctetStruct
 * @return Reference to member var_OctetStruct
 */
OctetStruct& Structures::var_OctetStruct()
{
    return m_var_OctetStruct;
}
/*!
 * @brief This function copies the value in member var_Char8Struct
 * @param _var_Char8Struct New value to be copied in member var_Char8Struct
 */
void Structures::var_Char8Struct(
        const Char8Struct& _var_Char8Struct)
{
    m_var_Char8Struct = _var_Char8Struct;
}

/*!
 * @brief This function moves the value in member var_Char8Struct
 * @param _var_Char8Struct New value to be moved in member var_Char8Struct
 */
void Structures::var_Char8Struct(
        Char8Struct&& _var_Char8Struct)
{
    m_var_Char8Struct = std::move(_var_Char8Struct);
}

/*!
 * @brief This function returns a constant reference to member var_Char8Struct
 * @return Constant reference to member var_Char8Struct
 */
const Char8Struct& Structures::var_Char8Struct() const
{
    return m_var_Char8Struct;
}

/*!
 * @brief This function returns a reference to member var_Char8Struct
 * @return Reference to member var_Char8Struct
 */
Char8Struct& Structures::var_Char8Struct()
{
    return m_var_Char8Struct;
}
/*!
 * @brief This function copies the value in member var_Char16Struct
 * @param _var_Char16Struct New value to be copied in member var_Char16Struct
 */
void Structures::var_Char16Struct(
        const Char16Struct& _var_Char16Struct)
{
    m_var_Char16Struct = _var_Char16Struct;
}

/*!
 * @brief This function moves the value in member var_Char16Struct
 * @param _var_Char16Struct New value to be moved in member var_Char16Struct
 */
void Structures::var_Char16Struct(
        Char16Struct&& _var_Char16Struct)
{
    m_var_Char16Struct = std::move(_var_Char16Struct);
}

/*!
 * @brief This function returns a constant reference to member var_Char16Struct
 * @return Constant reference to member var_Char16Struct
 */
const Char16Struct& Structures::var_Char16Struct() const
{
    return m_var_Char16Struct;
}

/*!
 * @brief This function returns a reference to member var_Char16Struct
 * @return Reference to member var_Char16Struct
 */
Char16Struct& Structures::var_Char16Struct()
{
    return m_var_Char16Struct;
}
/*!
 * @brief This function copies the value in member var_StringStruct
 * @param _var_StringStruct New value to be copied in member var_StringStruct
 */
void Structures::var_StringStruct(
        const StringStruct& _var_StringStruct)
{
    m_var_StringStruct = _var_StringStruct;
}

/*!
 * @brief This function moves the value in member var_StringStruct
 * @param _var_StringStruct New value to be moved in member var_StringStruct
 */
void Structures::var_StringStruct(
        StringStruct&& _var_StringStruct)
{
    m_var_StringStruct = std::move(_var_StringStruct);
}

/*!
 * @brief This function returns a constant reference to member var_StringStruct
 * @return Constant reference to member var_StringStruct
 */
const StringStruct& Structures::var_StringStruct() const
{
    return m_var_StringStruct;
}

/*!
 * @brief This function returns a reference to member var_StringStruct
 * @return Reference to member var_StringStruct
 */
StringStruct& Structures::var_StringStruct()
{
    return m_var_StringStruct;
}
/*!
 * @brief This function copies the value in member var_WStringStruct
 * @param _var_WStringStruct New value to be copied in member var_WStringStruct
 */
void Structures::var_WStringStruct(
        const WStringStruct& _var_WStringStruct)
{
    m_var_WStringStruct = _var_WStringStruct;
}

/*!
 * @brief This function moves the value in member var_WStringStruct
 * @param _var_WStringStruct New value to be moved in member var_WStringStruct
 */
void Structures::var_WStringStruct(
        WStringStruct&& _var_WStringStruct)
{
    m_var_WStringStruct = std::move(_var_WStringStruct);
}

/*!
 * @brief This function returns a constant reference to member var_WStringStruct
 * @return Constant reference to member var_WStringStruct
 */
const WStringStruct& Structures::var_WStringStruct() const
{
    return m_var_WStringStruct;
}

/*!
 * @brief This function returns a reference to member var_WStringStruct
 * @return Reference to member var_WStringStruct
 */
WStringStruct& Structures::var_WStringStruct()
{
    return m_var_WStringStruct;
}
/*!
 * @brief This function copies the value in member var_EnumStruct
 * @param _var_EnumStruct New value to be copied in member var_EnumStruct
 */
void Structures::var_EnumStruct(
        const EnumStruct& _var_EnumStruct)
{
    m_var_EnumStruct = _var_EnumStruct;
}

/*!
 * @brief This function moves the value in member var_EnumStruct
 * @param _var_EnumStruct New value to be moved in member var_EnumStruct
 */
void Structures::var_EnumStruct(
        EnumStruct&& _var_EnumStruct)
{
    m_var_EnumStruct = std::move(_var_EnumStruct);
}

/*!
 * @brief This function returns a constant reference to member var_EnumStruct
 * @return Constant reference to member var_EnumStruct
 */
const EnumStruct& Structures::var_EnumStruct() const
{
    return m_var_EnumStruct;
}

/*!
 * @brief This function returns a reference to member var_EnumStruct
 * @return Reference to member var_EnumStruct
 */
EnumStruct& Structures::var_EnumStruct()
{
    return m_var_EnumStruct;
}
/*!
 * @brief This function copies the value in member var_BitMaskStruct
 * @param _var_BitMaskStruct New value to be copied in member var_BitMaskStruct
 */
void Structures::var_BitMaskStruct(
        const BitMaskStruct& _var_BitMaskStruct)
{
    m_var_BitMaskStruct = _var_BitMaskStruct;
}

/*!
 * @brief This function moves the value in member var_BitMaskStruct
 * @param _var_BitMaskStruct New value to be moved in member var_BitMaskStruct
 */
void Structures::var_BitMaskStruct(
        BitMaskStruct&& _var_BitMaskStruct)
{
    m_var_BitMaskStruct = std::move(_var_BitMaskStruct);
}

/*!
 * @brief This function returns a constant reference to member var_BitMaskStruct
 * @return Constant reference to member var_BitMaskStruct
 */
const BitMaskStruct& Structures::var_BitMaskStruct() const
{
    return m_var_BitMaskStruct;
}

/*!
 * @brief This function returns a reference to member var_BitMaskStruct
 * @return Reference to member var_BitMaskStruct
 */
BitMaskStruct& Structures::var_BitMaskStruct()
{
    return m_var_BitMaskStruct;
}
/*!
 * @brief This function copies the value in member var_AliasStruct
 * @param _var_AliasStruct New value to be copied in member var_AliasStruct
 */
void Structures::var_AliasStruct(
        const AliasStruct& _var_AliasStruct)
{
    m_var_AliasStruct = _var_AliasStruct;
}

/*!
 * @brief This function moves the value in member var_AliasStruct
 * @param _var_AliasStruct New value to be moved in member var_AliasStruct
 */
void Structures::var_AliasStruct(
        AliasStruct&& _var_AliasStruct)
{
    m_var_AliasStruct = std::move(_var_AliasStruct);
}

/*!
 * @brief This function returns a constant reference to member var_AliasStruct
 * @return Constant reference to member var_AliasStruct
 */
const AliasStruct& Structures::var_AliasStruct() const
{
    return m_var_AliasStruct;
}

/*!
 * @brief This function returns a reference to member var_AliasStruct
 * @return Reference to member var_AliasStruct
 */
AliasStruct& Structures::var_AliasStruct()
{
    return m_var_AliasStruct;
}
/*!
 * @brief This function copies the value in member var_ShortArrayStruct
 * @param _var_ShortArrayStruct New value to be copied in member var_ShortArrayStruct
 */
void Structures::var_ShortArrayStruct(
        const ShortArrayStruct& _var_ShortArrayStruct)
{
    m_var_ShortArrayStruct = _var_ShortArrayStruct;
}

/*!
 * @brief This function moves the value in member var_ShortArrayStruct
 * @param _var_ShortArrayStruct New value to be moved in member var_ShortArrayStruct
 */
void Structures::var_ShortArrayStruct(
        ShortArrayStruct&& _var_ShortArrayStruct)
{
    m_var_ShortArrayStruct = std::move(_var_ShortArrayStruct);
}

/*!
 * @brief This function returns a constant reference to member var_ShortArrayStruct
 * @return Constant reference to member var_ShortArrayStruct
 */
const ShortArrayStruct& Structures::var_ShortArrayStruct() const
{
    return m_var_ShortArrayStruct;
}

/*!
 * @brief This function returns a reference to member var_ShortArrayStruct
 * @return Reference to member var_ShortArrayStruct
 */
ShortArrayStruct& Structures::var_ShortArrayStruct()
{
    return m_var_ShortArrayStruct;
}
/*!
 * @brief This function copies the value in member var_SequenceStruct
 * @param _var_SequenceStruct New value to be copied in member var_SequenceStruct
 */
void Structures::var_SequenceStruct(
        const SequenceStruct& _var_SequenceStruct)
{
    m_var_SequenceStruct = _var_SequenceStruct;
}

/*!
 * @brief This function moves the value in member var_SequenceStruct
 * @param _var_SequenceStruct New value to be moved in member var_SequenceStruct
 */
void Structures::var_SequenceStruct(
        SequenceStruct&& _var_SequenceStruct)
{
    m_var_SequenceStruct = std::move(_var_SequenceStruct);
}

/*!
 * @brief This function returns a constant reference to member var_SequenceStruct
 * @return Constant reference to member var_SequenceStruct
 */
const SequenceStruct& Structures::var_SequenceStruct() const
{
    return m_var_SequenceStruct;
}

/*!
 * @brief This function returns a reference to member var_SequenceStruct
 * @return Reference to member var_SequenceStruct
 */
SequenceStruct& Structures::var_SequenceStruct()
{
    return m_var_SequenceStruct;
}
/*!
 * @brief This function copies the value in member var_MapStruct
 * @param _var_MapStruct New value to be copied in member var_MapStruct
 */
void Structures::var_MapStruct(
        const MapStruct& _var_MapStruct)
{
    m_var_MapStruct = _var_MapStruct;
}

/*!
 * @brief This function moves the value in member var_MapStruct
 * @param _var_MapStruct New value to be moved in member var_MapStruct
 */
void Structures::var_MapStruct(
        MapStruct&& _var_MapStruct)
{
    m_var_MapStruct = std::move(_var_MapStruct);
}

/*!
 * @brief This function returns a constant reference to member var_MapStruct
 * @return Constant reference to member var_MapStruct
 */
const MapStruct& Structures::var_MapStruct() const
{
    return m_var_MapStruct;
}

/*!
 * @brief This function returns a reference to member var_MapStruct
 * @return Reference to member var_MapStruct
 */
MapStruct& Structures::var_MapStruct()
{
    return m_var_MapStruct;
}
/*!
 * @brief This function copies the value in member var_UnionStruct
 * @param _var_UnionStruct New value to be copied in member var_UnionStruct
 */
void Structures::var_UnionStruct(
        const UnionStruct& _var_UnionStruct)
{
    m_var_UnionStruct = _var_UnionStruct;
}

/*!
 * @brief This function moves the value in member var_UnionStruct
 * @param _var_UnionStruct New value to be moved in member var_UnionStruct
 */
void Structures::var_UnionStruct(
        UnionStruct&& _var_UnionStruct)
{
    m_var_UnionStruct = std::move(_var_UnionStruct);
}

/*!
 * @brief This function returns a constant reference to member var_UnionStruct
 * @return Constant reference to member var_UnionStruct
 */
const UnionStruct& Structures::var_UnionStruct() const
{
    return m_var_UnionStruct;
}

/*!
 * @brief This function returns a reference to member var_UnionStruct
 * @return Reference to member var_UnionStruct
 */
UnionStruct& Structures::var_UnionStruct()
{
    return m_var_UnionStruct;
}
/*!
 * @brief This function copies the value in member var_StructureStruct
 * @param _var_StructureStruct New value to be copied in member var_StructureStruct
 */
void Structures::var_StructureStruct(
        const StructureStruct& _var_StructureStruct)
{
    m_var_StructureStruct = _var_StructureStruct;
}

/*!
 * @brief This function moves the value in member var_StructureStruct
 * @param _var_StructureStruct New value to be moved in member var_StructureStruct
 */
void Structures::var_StructureStruct(
        StructureStruct&& _var_StructureStruct)
{
    m_var_StructureStruct = std::move(_var_StructureStruct);
}

/*!
 * @brief This function returns a constant reference to member var_StructureStruct
 * @return Constant reference to member var_StructureStruct
 */
const StructureStruct& Structures::var_StructureStruct() const
{
    return m_var_StructureStruct;
}

/*!
 * @brief This function returns a reference to member var_StructureStruct
 * @return Reference to member var_StructureStruct
 */
StructureStruct& Structures::var_StructureStruct()
{
    return m_var_StructureStruct;
}
/*!
 * @brief This function copies the value in member var_BitsetStruct
 * @param _var_BitsetStruct New value to be copied in member var_BitsetStruct
 */
void Structures::var_BitsetStruct(
        const BitsetStruct& _var_BitsetStruct)
{
    m_var_BitsetStruct = _var_BitsetStruct;
}

/*!
 * @brief This function moves the value in member var_BitsetStruct
 * @param _var_BitsetStruct New value to be moved in member var_BitsetStruct
 */
void Structures::var_BitsetStruct(
        BitsetStruct&& _var_BitsetStruct)
{
    m_var_BitsetStruct = std::move(_var_BitsetStruct);
}

/*!
 * @brief This function returns a constant reference to member var_BitsetStruct
 * @return Constant reference to member var_BitsetStruct
 */
const BitsetStruct& Structures::var_BitsetStruct() const
{
    return m_var_BitsetStruct;
}

/*!
 * @brief This function returns a reference to member var_BitsetStruct
 * @return Reference to member var_BitsetStruct
 */
BitsetStruct& Structures::var_BitsetStruct()
{
    return m_var_BitsetStruct;
}
/*!
 * @brief This function copies the value in member var_EmptyStructure
 * @param _var_EmptyStructure New value to be copied in member var_EmptyStructure
 */
void Structures::var_EmptyStructure(
        const EmptyStructure& _var_EmptyStructure)
{
    m_var_EmptyStructure = _var_EmptyStructure;
}

/*!
 * @brief This function moves the value in member var_EmptyStructure
 * @param _var_EmptyStructure New value to be moved in member var_EmptyStructure
 */
void Structures::var_EmptyStructure(
        EmptyStructure&& _var_EmptyStructure)
{
    m_var_EmptyStructure = std::move(_var_EmptyStructure);
}

/*!
 * @brief This function returns a constant reference to member var_EmptyStructure
 * @return Constant reference to member var_EmptyStructure
 */
const EmptyStructure& Structures::var_EmptyStructure() const
{
    return m_var_EmptyStructure;
}

/*!
 * @brief This function returns a reference to member var_EmptyStructure
 * @return Reference to member var_EmptyStructure
 */
EmptyStructure& Structures::var_EmptyStructure()
{
    return m_var_EmptyStructure;
}


size_t Structures::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Structures_max_key_cdr_typesize;
}

bool Structures::isKeyDefined()
{
    return false;
}

void Structures::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

