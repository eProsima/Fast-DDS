// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file structuresTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "structures.h"
#include "structuresTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

void registerstructuresTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(true),
                GetInnerEnumHelperObject(true));
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(false),
                GetInnerEnumHelperObject(false));

                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(true),
                GetInnerBitMaskHelperObject(true));
                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(false),
                GetInnerBitMaskHelperObject(false));

                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(true),
                GetInnerAliasHelperObject(true));
                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(false),
                GetInnerAliasHelperObject(false));

                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(true),
                GetInnerStructureHelperObject(true));
                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(false),
                GetInnerStructureHelperObject(false));

                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(true),
                GetInnerEmptyStructureHelperObject(true));
                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(false),
                GetInnerEmptyStructureHelperObject(false));

                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(true),
                GetInnerUnionHelperObject(true));
                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(false),
                GetInnerUnionHelperObject(false));

                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(true),
                GetInnerBitsetHelperObject(true));
                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(false),
                GetInnerBitsetHelperObject(false));

                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(true),
                GetInner_alias_bounded_string_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(false),
                GetInner_alias_bounded_string_helperObject(false));

                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(true),
                GetInner_alias_bounded_wstring_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(false),
                GetInner_alias_bounded_wstring_helperObject(false));

                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(true),
                GetInner_alias_array_helperObject(true));
                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(false),
                GetInner_alias_array_helperObject(false));

                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(true),
                GetInner_alias_sequence_helperObject(true));
                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(false),
                GetInner_alias_sequence_helperObject(false));

                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(true),
                GetInner_alias_map_helperObject(true));
                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(false),
                GetInner_alias_map_helperObject(false));

                factory->add_type_object("StructShort", GetStructShortIdentifier(true),
                GetStructShortObject(true));
                factory->add_type_object("StructShort", GetStructShortIdentifier(false),
                GetStructShortObject(false));

                factory->add_type_object("StructUnsignedShort", GetStructUnsignedShortIdentifier(true),
                GetStructUnsignedShortObject(true));
                factory->add_type_object("StructUnsignedShort", GetStructUnsignedShortIdentifier(false),
                GetStructUnsignedShortObject(false));

                factory->add_type_object("StructLong", GetStructLongIdentifier(true),
                GetStructLongObject(true));
                factory->add_type_object("StructLong", GetStructLongIdentifier(false),
                GetStructLongObject(false));

                factory->add_type_object("StructUnsignedLong", GetStructUnsignedLongIdentifier(true),
                GetStructUnsignedLongObject(true));
                factory->add_type_object("StructUnsignedLong", GetStructUnsignedLongIdentifier(false),
                GetStructUnsignedLongObject(false));

                factory->add_type_object("StructLongLong", GetStructLongLongIdentifier(true),
                GetStructLongLongObject(true));
                factory->add_type_object("StructLongLong", GetStructLongLongIdentifier(false),
                GetStructLongLongObject(false));

                factory->add_type_object("StructUnsignedLongLong", GetStructUnsignedLongLongIdentifier(true),
                GetStructUnsignedLongLongObject(true));
                factory->add_type_object("StructUnsignedLongLong", GetStructUnsignedLongLongIdentifier(false),
                GetStructUnsignedLongLongObject(false));

                factory->add_type_object("StructFloat", GetStructFloatIdentifier(true),
                GetStructFloatObject(true));
                factory->add_type_object("StructFloat", GetStructFloatIdentifier(false),
                GetStructFloatObject(false));

                factory->add_type_object("StructDouble", GetStructDoubleIdentifier(true),
                GetStructDoubleObject(true));
                factory->add_type_object("StructDouble", GetStructDoubleIdentifier(false),
                GetStructDoubleObject(false));

                factory->add_type_object("StructLongDouble", GetStructLongDoubleIdentifier(true),
                GetStructLongDoubleObject(true));
                factory->add_type_object("StructLongDouble", GetStructLongDoubleIdentifier(false),
                GetStructLongDoubleObject(false));

                factory->add_type_object("StructBoolean", GetStructBooleanIdentifier(true),
                GetStructBooleanObject(true));
                factory->add_type_object("StructBoolean", GetStructBooleanIdentifier(false),
                GetStructBooleanObject(false));

                factory->add_type_object("StructOctet", GetStructOctetIdentifier(true),
                GetStructOctetObject(true));
                factory->add_type_object("StructOctet", GetStructOctetIdentifier(false),
                GetStructOctetObject(false));

                factory->add_type_object("StructChar8", GetStructChar8Identifier(true),
                GetStructChar8Object(true));
                factory->add_type_object("StructChar8", GetStructChar8Identifier(false),
                GetStructChar8Object(false));

                factory->add_type_object("StructChar16", GetStructChar16Identifier(true),
                GetStructChar16Object(true));
                factory->add_type_object("StructChar16", GetStructChar16Identifier(false),
                GetStructChar16Object(false));

                factory->add_type_object("StructString", GetStructStringIdentifier(true),
                GetStructStringObject(true));
                factory->add_type_object("StructString", GetStructStringIdentifier(false),
                GetStructStringObject(false));

                factory->add_type_object("StructWString", GetStructWStringIdentifier(true),
                GetStructWStringObject(true));
                factory->add_type_object("StructWString", GetStructWStringIdentifier(false),
                GetStructWStringObject(false));

                factory->add_type_object("StructBoundedString", GetStructBoundedStringIdentifier(true),
                GetStructBoundedStringObject(true));
                factory->add_type_object("StructBoundedString", GetStructBoundedStringIdentifier(false),
                GetStructBoundedStringObject(false));

                factory->add_type_object("StructBoundedWString", GetStructBoundedWStringIdentifier(true),
                GetStructBoundedWStringObject(true));
                factory->add_type_object("StructBoundedWString", GetStructBoundedWStringIdentifier(false),
                GetStructBoundedWStringObject(false));

                factory->add_type_object("StructEnum", GetStructEnumIdentifier(true),
                GetStructEnumObject(true));
                factory->add_type_object("StructEnum", GetStructEnumIdentifier(false),
                GetStructEnumObject(false));

                factory->add_type_object("StructBitMask", GetStructBitMaskIdentifier(true),
                GetStructBitMaskObject(true));
                factory->add_type_object("StructBitMask", GetStructBitMaskIdentifier(false),
                GetStructBitMaskObject(false));

                factory->add_type_object("StructAlias", GetStructAliasIdentifier(true),
                GetStructAliasObject(true));
                factory->add_type_object("StructAlias", GetStructAliasIdentifier(false),
                GetStructAliasObject(false));

                factory->add_type_object("StructShortArray", GetStructShortArrayIdentifier(true),
                GetStructShortArrayObject(true));
                factory->add_type_object("StructShortArray", GetStructShortArrayIdentifier(false),
                GetStructShortArrayObject(false));

                factory->add_type_object("StructSequence", GetStructSequenceIdentifier(true),
                GetStructSequenceObject(true));
                factory->add_type_object("StructSequence", GetStructSequenceIdentifier(false),
                GetStructSequenceObject(false));

                factory->add_type_object("StructMap", GetStructMapIdentifier(true),
                GetStructMapObject(true));
                factory->add_type_object("StructMap", GetStructMapIdentifier(false),
                GetStructMapObject(false));

                factory->add_type_object("StructUnion", GetStructUnionIdentifier(true),
                GetStructUnionObject(true));
                factory->add_type_object("StructUnion", GetStructUnionIdentifier(false),
                GetStructUnionObject(false));

                factory->add_type_object("StructStructure", GetStructStructureIdentifier(true),
                GetStructStructureObject(true));
                factory->add_type_object("StructStructure", GetStructStructureIdentifier(false),
                GetStructStructureObject(false));

                factory->add_type_object("StructBitset", GetStructBitsetIdentifier(true),
                GetStructBitsetObject(true));
                factory->add_type_object("StructBitset", GetStructBitsetIdentifier(false),
                GetStructBitsetObject(false));

                factory->add_type_object("StructEmpty", GetStructEmptyIdentifier(true),
                GetStructEmptyObject(true));
                factory->add_type_object("StructEmpty", GetStructEmptyIdentifier(false),
                GetStructEmptyObject(false));

                factory->add_type_object("Structures", GetStructuresIdentifier(true),
                GetStructuresObject(true));
                factory->add_type_object("Structures", GetStructuresIdentifier(false),
                GetStructuresObject(false));

            });
}

const TypeIdentifier* GetStructShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructShort", complete);
}

const TypeObject* GetStructShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructShortObject();
    }
    //else
    return GetMinimalStructShortObject();
}

const TypeObject* GetMinimalStructShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_short;
    mst_var_short.common().member_id(memberId++);
    mst_var_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_short.common().member_flags().IS_KEY(false);
    mst_var_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    MD5 var_short_hash("var_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_short.detail().name_hash()[i] = var_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructShort", false);
}

const TypeObject* GetCompleteStructShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_short;
    cst_var_short.common().member_id(memberId++);
    cst_var_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_short.common().member_flags().IS_KEY(false);
    cst_var_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    cst_var_short.detail().name("var_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructShort", true);
}

const TypeIdentifier* GetStructUnsignedShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructUnsignedShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructUnsignedShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructUnsignedShort", complete);
}

const TypeObject* GetStructUnsignedShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructUnsignedShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructUnsignedShortObject();
    }
    //else
    return GetMinimalStructUnsignedShortObject();
}

const TypeObject* GetMinimalStructUnsignedShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructUnsignedShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ushort;
    mst_var_ushort.common().member_id(memberId++);
    mst_var_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ushort.common().member_flags().IS_KEY(false);
    mst_var_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 var_ushort_hash("var_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ushort.detail().name_hash()[i] = var_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructUnsignedShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructUnsignedShort", false);
}

const TypeObject* GetCompleteStructUnsignedShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructUnsignedShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ushort;
    cst_var_ushort.common().member_id(memberId++);
    cst_var_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ushort.common().member_flags().IS_KEY(false);
    cst_var_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_var_ushort.detail().name("var_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructUnsignedShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructUnsignedShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructUnsignedShort", true);
}

const TypeIdentifier* GetStructLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructLong", complete);
}

const TypeObject* GetStructLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructLongObject();
    }
    //else
    return GetMinimalStructLongObject();
}

const TypeObject* GetMinimalStructLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_long;
    mst_var_long.common().member_id(memberId++);
    mst_var_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_long.common().member_flags().IS_KEY(false);
    mst_var_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MD5 var_long_hash("var_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_long.detail().name_hash()[i] = var_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructLong", false);
}

const TypeObject* GetCompleteStructLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_long;
    cst_var_long.common().member_id(memberId++);
    cst_var_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_long.common().member_flags().IS_KEY(false);
    cst_var_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    cst_var_long.detail().name("var_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructLong", true);
}

const TypeIdentifier* GetStructUnsignedLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructUnsignedLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructUnsignedLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructUnsignedLong", complete);
}

const TypeObject* GetStructUnsignedLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructUnsignedLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructUnsignedLongObject();
    }
    //else
    return GetMinimalStructUnsignedLongObject();
}

const TypeObject* GetMinimalStructUnsignedLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructUnsignedLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ulong;
    mst_var_ulong.common().member_id(memberId++);
    mst_var_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ulong.common().member_flags().IS_KEY(false);
    mst_var_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 var_ulong_hash("var_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ulong.detail().name_hash()[i] = var_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructUnsignedLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructUnsignedLong", false);
}

const TypeObject* GetCompleteStructUnsignedLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructUnsignedLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ulong;
    cst_var_ulong.common().member_id(memberId++);
    cst_var_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ulong.common().member_flags().IS_KEY(false);
    cst_var_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_var_ulong.detail().name("var_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructUnsignedLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructUnsignedLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructUnsignedLong", true);
}

const TypeIdentifier* GetStructLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructLongLong", complete);
}

const TypeObject* GetStructLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructLongLongObject();
    }
    //else
    return GetMinimalStructLongLongObject();
}

const TypeObject* GetMinimalStructLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_longlong;
    mst_var_longlong.common().member_id(memberId++);
    mst_var_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_longlong.common().member_flags().IS_KEY(false);
    mst_var_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    MD5 var_longlong_hash("var_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_longlong.detail().name_hash()[i] = var_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructLongLong", false);
}

const TypeObject* GetCompleteStructLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_longlong;
    cst_var_longlong.common().member_id(memberId++);
    cst_var_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_longlong.common().member_flags().IS_KEY(false);
    cst_var_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    cst_var_longlong.detail().name("var_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructLongLong", true);
}

const TypeIdentifier* GetStructUnsignedLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructUnsignedLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructUnsignedLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructUnsignedLongLong", complete);
}

const TypeObject* GetStructUnsignedLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructUnsignedLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructUnsignedLongLongObject();
    }
    //else
    return GetMinimalStructUnsignedLongLongObject();
}

const TypeObject* GetMinimalStructUnsignedLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructUnsignedLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ulonglong;
    mst_var_ulonglong.common().member_id(memberId++);
    mst_var_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    MD5 var_ulonglong_hash("var_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ulonglong.detail().name_hash()[i] = var_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructUnsignedLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructUnsignedLongLong", false);
}

const TypeObject* GetCompleteStructUnsignedLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructUnsignedLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ulonglong;
    cst_var_ulonglong.common().member_id(memberId++);
    cst_var_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    cst_var_ulonglong.detail().name("var_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructUnsignedLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructUnsignedLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructUnsignedLongLong", true);
}

const TypeIdentifier* GetStructFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructFloat", complete);
}

const TypeObject* GetStructFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructFloatObject();
    }
    //else
    return GetMinimalStructFloatObject();
}

const TypeObject* GetMinimalStructFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_float;
    mst_var_float.common().member_id(memberId++);
    mst_var_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_float.common().member_flags().IS_KEY(false);
    mst_var_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 var_float_hash("var_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_float.detail().name_hash()[i] = var_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructFloat", false);
}

const TypeObject* GetCompleteStructFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_float;
    cst_var_float.common().member_id(memberId++);
    cst_var_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_float.common().member_flags().IS_KEY(false);
    cst_var_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_var_float.detail().name("var_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructFloat", true);
}

const TypeIdentifier* GetStructDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructDouble", complete);
}

const TypeObject* GetStructDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructDoubleObject();
    }
    //else
    return GetMinimalStructDoubleObject();
}

const TypeObject* GetMinimalStructDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_double;
    mst_var_double.common().member_id(memberId++);
    mst_var_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_double.common().member_flags().IS_KEY(false);
    mst_var_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    MD5 var_double_hash("var_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_double.detail().name_hash()[i] = var_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructDouble", false);
}

const TypeObject* GetCompleteStructDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_double;
    cst_var_double.common().member_id(memberId++);
    cst_var_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_double.common().member_flags().IS_KEY(false);
    cst_var_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    cst_var_double.detail().name("var_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructDouble", true);
}

const TypeIdentifier* GetStructLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructLongDouble", complete);
}

const TypeObject* GetStructLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructLongDoubleObject();
    }
    //else
    return GetMinimalStructLongDoubleObject();
}

const TypeObject* GetMinimalStructLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_longdouble;
    mst_var_longdouble.common().member_id(memberId++);
    mst_var_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_longdouble.common().member_flags().IS_KEY(false);
    mst_var_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    MD5 var_longdouble_hash("var_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_longdouble.detail().name_hash()[i] = var_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructLongDouble", false);
}

const TypeObject* GetCompleteStructLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_longdouble;
    cst_var_longdouble.common().member_id(memberId++);
    cst_var_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_longdouble.common().member_flags().IS_KEY(false);
    cst_var_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    cst_var_longdouble.detail().name("var_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructLongDouble", true);
}

const TypeIdentifier* GetStructBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructBoolean", complete);
}

const TypeObject* GetStructBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructBooleanObject();
    }
    //else
    return GetMinimalStructBooleanObject();
}

const TypeObject* GetMinimalStructBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_boolean;
    mst_var_boolean.common().member_id(memberId++);
    mst_var_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_boolean.common().member_flags().IS_KEY(false);
    mst_var_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    MD5 var_boolean_hash("var_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_boolean.detail().name_hash()[i] = var_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructBoolean", false);
}

const TypeObject* GetCompleteStructBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_boolean;
    cst_var_boolean.common().member_id(memberId++);
    cst_var_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_boolean.common().member_flags().IS_KEY(false);
    cst_var_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    cst_var_boolean.detail().name("var_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructBoolean", true);
}

const TypeIdentifier* GetStructOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructOctet", complete);
}

const TypeObject* GetStructOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructOctetObject();
    }
    //else
    return GetMinimalStructOctetObject();
}

const TypeObject* GetMinimalStructOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_octet;
    mst_var_octet.common().member_id(memberId++);
    mst_var_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_octet.common().member_flags().IS_KEY(false);
    mst_var_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 var_octet_hash("var_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_octet.detail().name_hash()[i] = var_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructOctet", false);
}

const TypeObject* GetCompleteStructOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_octet;
    cst_var_octet.common().member_id(memberId++);
    cst_var_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_octet.common().member_flags().IS_KEY(false);
    cst_var_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_var_octet.detail().name("var_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructOctet", true);
}

const TypeIdentifier* GetStructChar8Identifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructChar8", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructChar8Object(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructChar8", complete);
}

const TypeObject* GetStructChar8Object(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructChar8", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructChar8Object();
    }
    //else
    return GetMinimalStructChar8Object();
}

const TypeObject* GetMinimalStructChar8Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructChar8", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_char8;
    mst_var_char8.common().member_id(memberId++);
    mst_var_char8.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_char8.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_char8.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_char8.common().member_flags().IS_OPTIONAL(false);
    mst_var_char8.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_char8.common().member_flags().IS_KEY(false);
    mst_var_char8.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_char8.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    MD5 var_char8_hash("var_char8");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_char8.detail().name_hash()[i] = var_char8_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_char8);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructChar8", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructChar8", false);
}

const TypeObject* GetCompleteStructChar8Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructChar8", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_char8;
    cst_var_char8.common().member_id(memberId++);
    cst_var_char8.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_char8.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_char8.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_char8.common().member_flags().IS_OPTIONAL(false);
    cst_var_char8.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_char8.common().member_flags().IS_KEY(false);
    cst_var_char8.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_char8.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    cst_var_char8.detail().name("var_char8");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_char8);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructChar8");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructChar8", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructChar8", true);
}

const TypeIdentifier* GetStructChar16Identifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructChar16", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructChar16Object(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructChar16", complete);
}

const TypeObject* GetStructChar16Object(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructChar16", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructChar16Object();
    }
    //else
    return GetMinimalStructChar16Object();
}

const TypeObject* GetMinimalStructChar16Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructChar16", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_char16;
    mst_var_char16.common().member_id(memberId++);
    mst_var_char16.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_char16.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_char16.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_char16.common().member_flags().IS_OPTIONAL(false);
    mst_var_char16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_char16.common().member_flags().IS_KEY(false);
    mst_var_char16.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_char16.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    MD5 var_char16_hash("var_char16");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_char16.detail().name_hash()[i] = var_char16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_char16);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructChar16", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructChar16", false);
}

const TypeObject* GetCompleteStructChar16Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructChar16", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_char16;
    cst_var_char16.common().member_id(memberId++);
    cst_var_char16.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_char16.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_char16.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_char16.common().member_flags().IS_OPTIONAL(false);
    cst_var_char16.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_char16.common().member_flags().IS_KEY(false);
    cst_var_char16.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_char16.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    cst_var_char16.detail().name("var_char16");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_char16);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructChar16");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructChar16", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructChar16", true);
}

const TypeIdentifier* GetStructStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructString", complete);
}

const TypeObject* GetStructStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructStringObject();
    }
    //else
    return GetMinimalStructStringObject();
}

const TypeObject* GetMinimalStructStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_string;
    mst_var_string.common().member_id(memberId++);
    mst_var_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_string.common().member_flags().IS_KEY(false);
    mst_var_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    MD5 var_string_hash("var_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_string.detail().name_hash()[i] = var_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructString", false);
}

const TypeObject* GetCompleteStructStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_string;
    cst_var_string.common().member_id(memberId++);
    cst_var_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_string.common().member_flags().IS_KEY(false);
    cst_var_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    cst_var_string.detail().name("var_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructString", true);
}

const TypeIdentifier* GetStructWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructWString", complete);
}

const TypeObject* GetStructWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructWStringObject();
    }
    //else
    return GetMinimalStructWStringObject();
}

const TypeObject* GetMinimalStructWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_wstring;
    mst_var_wstring.common().member_id(memberId++);
    mst_var_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_wstring.common().member_flags().IS_KEY(false);
    mst_var_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, true));


    MD5 var_wstring_hash("var_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_wstring.detail().name_hash()[i] = var_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructWString", false);
}

const TypeObject* GetCompleteStructWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_wstring;
    cst_var_wstring.common().member_id(memberId++);
    cst_var_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_wstring.common().member_flags().IS_KEY(false);
    cst_var_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, true));


    cst_var_wstring.detail().name("var_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructWString", true);
}

const TypeIdentifier* GetStructBoundedStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructBoundedString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructBoundedStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructBoundedString", complete);
}

const TypeObject* GetStructBoundedStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBoundedString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructBoundedStringObject();
    }
    //else
    return GetMinimalStructBoundedStringObject();
}

const TypeObject* GetMinimalStructBoundedStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBoundedString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_bounded_string;
    mst_var_bounded_string.common().member_id(memberId++);
    mst_var_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_bounded_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_bounded_string.common().member_flags().IS_KEY(false);
    mst_var_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_bounded_string.common().member_type_id(*GetInner_alias_bounded_string_helperIdentifier(false));
    MD5 var_bounded_string_hash("var_bounded_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_bounded_string.detail().name_hash()[i] = var_bounded_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_bounded_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructBoundedString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructBoundedString", false);
}

const TypeObject* GetCompleteStructBoundedStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBoundedString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_bounded_string;
    cst_var_bounded_string.common().member_id(memberId++);
    cst_var_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_bounded_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_bounded_string.common().member_flags().IS_KEY(false);
    cst_var_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_bounded_string.common().member_type_id(*GetInner_alias_bounded_string_helperIdentifier(true));
    cst_var_bounded_string.detail().name("var_bounded_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_bounded_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructBoundedString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructBoundedString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructBoundedString", true);
}

const TypeIdentifier* GetStructBoundedWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructBoundedWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructBoundedWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructBoundedWString", complete);
}

const TypeObject* GetStructBoundedWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBoundedWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructBoundedWStringObject();
    }
    //else
    return GetMinimalStructBoundedWStringObject();
}

const TypeObject* GetMinimalStructBoundedWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBoundedWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_bounded_wstring;
    mst_var_bounded_wstring.common().member_id(memberId++);
    mst_var_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_bounded_wstring.common().member_flags().IS_KEY(false);
    mst_var_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_bounded_wstring.common().member_type_id(*GetInner_alias_bounded_wstring_helperIdentifier(false));
    MD5 var_bounded_wstring_hash("var_bounded_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_bounded_wstring.detail().name_hash()[i] = var_bounded_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_bounded_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructBoundedWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructBoundedWString", false);
}

const TypeObject* GetCompleteStructBoundedWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBoundedWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_bounded_wstring;
    cst_var_bounded_wstring.common().member_id(memberId++);
    cst_var_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_bounded_wstring.common().member_flags().IS_KEY(false);
    cst_var_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_bounded_wstring.common().member_type_id(*GetInner_alias_bounded_wstring_helperIdentifier(true));
    cst_var_bounded_wstring.detail().name("var_bounded_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_bounded_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructBoundedWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructBoundedWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructBoundedWString", true);
}

const TypeIdentifier* GetStructEnumIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructEnum", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructEnumObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructEnum", complete);
}

const TypeObject* GetStructEnumObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructEnum", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructEnumObject();
    }
    //else
    return GetMinimalStructEnumObject();
}

const TypeObject* GetMinimalStructEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructEnum", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_enum;
    mst_var_enum.common().member_id(memberId++);
    mst_var_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_enum.common().member_flags().IS_OPTIONAL(false);
    mst_var_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_enum.common().member_flags().IS_KEY(false);
    mst_var_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_enum.common().member_type_id(*GetInnerEnumHelperIdentifier(false));
    MD5 var_enum_hash("var_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_enum.detail().name_hash()[i] = var_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_enum);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructEnum", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructEnum", false);
}

const TypeObject* GetCompleteStructEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructEnum", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_enum;
    cst_var_enum.common().member_id(memberId++);
    cst_var_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_enum.common().member_flags().IS_OPTIONAL(false);
    cst_var_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_enum.common().member_flags().IS_KEY(false);
    cst_var_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_enum.common().member_type_id(*GetInnerEnumHelperIdentifier(true));
    cst_var_enum.detail().name("var_enum");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_enum);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructEnum");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructEnum", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructEnum", true);
}

const TypeIdentifier* GetStructBitMaskIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructBitMask", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructBitMaskObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructBitMask", complete);
}

const TypeObject* GetStructBitMaskObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBitMask", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructBitMaskObject();
    }
    //else
    return GetMinimalStructBitMaskObject();
}

const TypeObject* GetMinimalStructBitMaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBitMask", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_bitmask;
    mst_var_bitmask.common().member_id(memberId++);
    mst_var_bitmask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_bitmask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_bitmask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_bitmask.common().member_flags().IS_OPTIONAL(false);
    mst_var_bitmask.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_bitmask.common().member_flags().IS_KEY(false);
    mst_var_bitmask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_bitmask.common().member_type_id(*GetInnerBitMaskHelperIdentifier(false));
    MD5 var_bitmask_hash("var_bitmask");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_bitmask.detail().name_hash()[i] = var_bitmask_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_bitmask);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructBitMask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructBitMask", false);
}

const TypeObject* GetCompleteStructBitMaskObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBitMask", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_bitmask;
    cst_var_bitmask.common().member_id(memberId++);
    cst_var_bitmask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_bitmask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_bitmask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_bitmask.common().member_flags().IS_OPTIONAL(false);
    cst_var_bitmask.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_bitmask.common().member_flags().IS_KEY(false);
    cst_var_bitmask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_bitmask.common().member_type_id(*GetInnerBitMaskHelperIdentifier(true));
    cst_var_bitmask.detail().name("var_bitmask");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_bitmask);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructBitMask");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructBitMask", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructBitMask", true);
}

const TypeIdentifier* GetStructAliasIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructAlias", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructAliasObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructAlias", complete);
}

const TypeObject* GetStructAliasObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructAlias", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructAliasObject();
    }
    //else
    return GetMinimalStructAliasObject();
}

const TypeObject* GetMinimalStructAliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructAlias", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_alias;
    mst_var_alias.common().member_id(memberId++);
    mst_var_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_alias.common().member_flags().IS_OPTIONAL(false);
    mst_var_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_alias.common().member_flags().IS_KEY(false);
    mst_var_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_alias.common().member_type_id(*GetInnerAliasHelperIdentifier(false));
    MD5 var_alias_hash("var_alias");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_alias.detail().name_hash()[i] = var_alias_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_alias);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructAlias", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructAlias", false);
}

const TypeObject* GetCompleteStructAliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructAlias", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_alias;
    cst_var_alias.common().member_id(memberId++);
    cst_var_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_alias.common().member_flags().IS_OPTIONAL(false);
    cst_var_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_alias.common().member_flags().IS_KEY(false);
    cst_var_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_alias.common().member_type_id(*GetInnerAliasHelperIdentifier(true));
    cst_var_alias.detail().name("var_alias");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_alias);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructAlias");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructAlias", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructAlias", true);
}

const TypeIdentifier* GetStructShortArrayIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructShortArray", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructShortArrayObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructShortArray", complete);
}

const TypeObject* GetStructShortArrayObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructShortArray", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructShortArrayObject();
    }
    //else
    return GetMinimalStructShortArrayObject();
}

const TypeObject* GetMinimalStructShortArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructShortArray", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_short;
    mst_var_array_short.common().member_id(memberId++);
    mst_var_array_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_short.common().member_flags().IS_KEY(false);
    mst_var_array_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10}, false));


    MD5 var_array_short_hash("var_array_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_short.detail().name_hash()[i] = var_array_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructShortArray", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructShortArray", false);
}

const TypeObject* GetCompleteStructShortArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructShortArray", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_short;
    cst_var_array_short.common().member_id(memberId++);
    cst_var_array_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_short.common().member_flags().IS_KEY(false);
    cst_var_array_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10}, true));


    cst_var_array_short.detail().name("var_array_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructShortArray");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructShortArray", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructShortArray", true);
}

const TypeIdentifier* GetStructSequenceIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructSequence", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructSequenceObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructSequence", complete);
}

const TypeObject* GetStructSequenceObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructSequence", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructSequenceObject();
    }
    //else
    return GetMinimalStructSequenceObject();
}

const TypeObject* GetMinimalStructSequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructSequence", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence;
    mst_var_sequence.common().member_id(memberId++);
    mst_var_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence.common().member_flags().IS_KEY(false);
    mst_var_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int32_t", 100, false));


    MD5 var_sequence_hash("var_sequence");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence.detail().name_hash()[i] = var_sequence_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructSequence", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructSequence", false);
}

const TypeObject* GetCompleteStructSequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructSequence", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence;
    cst_var_sequence.common().member_id(memberId++);
    cst_var_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence.common().member_flags().IS_KEY(false);
    cst_var_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int32_t", 100, true));


    cst_var_sequence.detail().name("var_sequence");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructSequence");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructSequence", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructSequence", true);
}

const TypeIdentifier* GetStructMapIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructMap", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructMapObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructMap", complete);
}

const TypeObject* GetStructMapObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructMap", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructMapObject();
    }
    //else
    return GetMinimalStructMapObject();
}

const TypeObject* GetMinimalStructMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructMap", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map;
    mst_var_map.common().member_id(memberId++);
    mst_var_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map.common().member_flags().IS_OPTIONAL(false);
    mst_var_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map.common().member_flags().IS_KEY(false);
    mst_var_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int32_t", 100, false));


    MD5 var_map_hash("var_map");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map.detail().name_hash()[i] = var_map_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructMap", false);
}

const TypeObject* GetCompleteStructMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructMap", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map;
    cst_var_map.common().member_id(memberId++);
    cst_var_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map.common().member_flags().IS_OPTIONAL(false);
    cst_var_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map.common().member_flags().IS_KEY(false);
    cst_var_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int32_t", 100, true));


    cst_var_map.detail().name("var_map");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructMap");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructMap", true);
}

const TypeIdentifier* GetStructUnionIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructUnion", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructUnionObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructUnion", complete);
}

const TypeObject* GetStructUnionObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructUnion", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructUnionObject();
    }
    //else
    return GetMinimalStructUnionObject();
}

const TypeObject* GetMinimalStructUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructUnion", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union;
    mst_var_union.common().member_id(memberId++);
    mst_var_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union.common().member_flags().IS_OPTIONAL(false);
    mst_var_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union.common().member_flags().IS_KEY(false);
    mst_var_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union.common().member_type_id(*GetInnerUnionHelperIdentifier(false));
    MD5 var_union_hash("var_union");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union.detail().name_hash()[i] = var_union_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructUnion", false);
}

const TypeObject* GetCompleteStructUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructUnion", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union;
    cst_var_union.common().member_id(memberId++);
    cst_var_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union.common().member_flags().IS_OPTIONAL(false);
    cst_var_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union.common().member_flags().IS_KEY(false);
    cst_var_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union.common().member_type_id(*GetInnerUnionHelperIdentifier(true));
    cst_var_union.detail().name("var_union");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructUnion");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructUnion", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructUnion", true);
}

const TypeIdentifier* GetStructStructureIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructStructure", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructStructureObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructStructure", complete);
}

const TypeObject* GetStructStructureObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructStructure", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructStructureObject();
    }
    //else
    return GetMinimalStructStructureObject();
}

const TypeObject* GetMinimalStructStructureObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructStructure", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_structure;
    mst_var_structure.common().member_id(memberId++);
    mst_var_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_structure.common().member_flags().IS_OPTIONAL(false);
    mst_var_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_structure.common().member_flags().IS_KEY(false);
    mst_var_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_structure.common().member_type_id(*GetInnerStructureHelperIdentifier(false));
    MD5 var_structure_hash("var_structure");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_structure.detail().name_hash()[i] = var_structure_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_structure);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructStructure", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructStructure", false);
}

const TypeObject* GetCompleteStructStructureObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructStructure", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_structure;
    cst_var_structure.common().member_id(memberId++);
    cst_var_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_structure.common().member_flags().IS_OPTIONAL(false);
    cst_var_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_structure.common().member_flags().IS_KEY(false);
    cst_var_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_structure.common().member_type_id(*GetInnerStructureHelperIdentifier(true));
    cst_var_structure.detail().name("var_structure");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_structure);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructStructure");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructStructure", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructStructure", true);
}

const TypeIdentifier* GetStructBitsetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructBitset", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructBitsetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructBitset", complete);
}

const TypeObject* GetStructBitsetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBitset", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructBitsetObject();
    }
    //else
    return GetMinimalStructBitsetObject();
}

const TypeObject* GetMinimalStructBitsetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBitset", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_bitset;
    mst_var_bitset.common().member_id(memberId++);
    mst_var_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_bitset.common().member_flags().IS_OPTIONAL(false);
    mst_var_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_bitset.common().member_flags().IS_KEY(false);
    mst_var_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_bitset.common().member_type_id(*GetInnerBitsetHelperIdentifier(false));
    MD5 var_bitset_hash("var_bitset");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_bitset.detail().name_hash()[i] = var_bitset_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_bitset);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructBitset", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructBitset", false);
}

const TypeObject* GetCompleteStructBitsetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructBitset", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_bitset;
    cst_var_bitset.common().member_id(memberId++);
    cst_var_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_bitset.common().member_flags().IS_OPTIONAL(false);
    cst_var_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_bitset.common().member_flags().IS_KEY(false);
    cst_var_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_bitset.common().member_type_id(*GetInnerBitsetHelperIdentifier(true));
    cst_var_bitset.detail().name("var_bitset");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_bitset);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructBitset");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructBitset", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructBitset", true);
}

const TypeIdentifier* GetStructEmptyIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructEmpty", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructEmptyObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructEmpty", complete);
}

const TypeObject* GetStructEmptyObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructEmpty", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructEmptyObject();
    }
    //else
    return GetMinimalStructEmptyObject();
}

const TypeObject* GetMinimalStructEmptyObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructEmpty", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;

    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructEmpty", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructEmpty", false);
}

const TypeObject* GetCompleteStructEmptyObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructEmpty", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;

    // Header
    type_object->complete().struct_type().header().detail().type_name("StructEmpty");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructEmpty", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructEmpty", true);
}

const TypeIdentifier* GetStructuresIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Structures", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructuresObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Structures", complete);
}

const TypeObject* GetStructuresObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Structures", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructuresObject();
    }
    //else
    return GetMinimalStructuresObject();
}

const TypeObject* GetMinimalStructuresObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Structures", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_StructShort;
    mst_var_StructShort.common().member_id(memberId++);
    mst_var_StructShort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructShort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructShort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructShort.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructShort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructShort.common().member_flags().IS_KEY(false);
    mst_var_StructShort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructShort.common().member_type_id(*GetStructShortIdentifier(false));
    MD5 var_StructShort_hash("var_StructShort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructShort.detail().name_hash()[i] = var_StructShort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructShort);

    MinimalStructMember mst_var_StructUnsignedShort;
    mst_var_StructUnsignedShort.common().member_id(memberId++);
    mst_var_StructUnsignedShort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructUnsignedShort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructUnsignedShort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructUnsignedShort.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructUnsignedShort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructUnsignedShort.common().member_flags().IS_KEY(false);
    mst_var_StructUnsignedShort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructUnsignedShort.common().member_type_id(*GetStructUnsignedShortIdentifier(false));
    MD5 var_StructUnsignedShort_hash("var_StructUnsignedShort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructUnsignedShort.detail().name_hash()[i] = var_StructUnsignedShort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructUnsignedShort);

    MinimalStructMember mst_var_StructLong;
    mst_var_StructLong.common().member_id(memberId++);
    mst_var_StructLong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructLong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructLong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructLong.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructLong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructLong.common().member_flags().IS_KEY(false);
    mst_var_StructLong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructLong.common().member_type_id(*GetStructLongIdentifier(false));
    MD5 var_StructLong_hash("var_StructLong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructLong.detail().name_hash()[i] = var_StructLong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructLong);

    MinimalStructMember mst_var_StructUnsignedLong;
    mst_var_StructUnsignedLong.common().member_id(memberId++);
    mst_var_StructUnsignedLong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructUnsignedLong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructUnsignedLong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructUnsignedLong.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructUnsignedLong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructUnsignedLong.common().member_flags().IS_KEY(false);
    mst_var_StructUnsignedLong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructUnsignedLong.common().member_type_id(*GetStructUnsignedLongIdentifier(false));
    MD5 var_StructUnsignedLong_hash("var_StructUnsignedLong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructUnsignedLong.detail().name_hash()[i] = var_StructUnsignedLong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructUnsignedLong);

    MinimalStructMember mst_var_StructLongLong;
    mst_var_StructLongLong.common().member_id(memberId++);
    mst_var_StructLongLong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructLongLong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructLongLong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructLongLong.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructLongLong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructLongLong.common().member_flags().IS_KEY(false);
    mst_var_StructLongLong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructLongLong.common().member_type_id(*GetStructLongLongIdentifier(false));
    MD5 var_StructLongLong_hash("var_StructLongLong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructLongLong.detail().name_hash()[i] = var_StructLongLong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructLongLong);

    MinimalStructMember mst_var_StructUnsignedLongLong;
    mst_var_StructUnsignedLongLong.common().member_id(memberId++);
    mst_var_StructUnsignedLongLong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructUnsignedLongLong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructUnsignedLongLong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructUnsignedLongLong.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructUnsignedLongLong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructUnsignedLongLong.common().member_flags().IS_KEY(false);
    mst_var_StructUnsignedLongLong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructUnsignedLongLong.common().member_type_id(*GetStructUnsignedLongLongIdentifier(false));
    MD5 var_StructUnsignedLongLong_hash("var_StructUnsignedLongLong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructUnsignedLongLong.detail().name_hash()[i] = var_StructUnsignedLongLong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructUnsignedLongLong);

    MinimalStructMember mst_var_StructFloat;
    mst_var_StructFloat.common().member_id(memberId++);
    mst_var_StructFloat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructFloat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructFloat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructFloat.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructFloat.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructFloat.common().member_flags().IS_KEY(false);
    mst_var_StructFloat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructFloat.common().member_type_id(*GetStructFloatIdentifier(false));
    MD5 var_StructFloat_hash("var_StructFloat");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructFloat.detail().name_hash()[i] = var_StructFloat_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructFloat);

    MinimalStructMember mst_var_StructDouble;
    mst_var_StructDouble.common().member_id(memberId++);
    mst_var_StructDouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructDouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructDouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructDouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructDouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructDouble.common().member_flags().IS_KEY(false);
    mst_var_StructDouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructDouble.common().member_type_id(*GetStructDoubleIdentifier(false));
    MD5 var_StructDouble_hash("var_StructDouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructDouble.detail().name_hash()[i] = var_StructDouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructDouble);

    MinimalStructMember mst_var_StructLongDouble;
    mst_var_StructLongDouble.common().member_id(memberId++);
    mst_var_StructLongDouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructLongDouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructLongDouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructLongDouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructLongDouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructLongDouble.common().member_flags().IS_KEY(false);
    mst_var_StructLongDouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructLongDouble.common().member_type_id(*GetStructLongDoubleIdentifier(false));
    MD5 var_StructLongDouble_hash("var_StructLongDouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructLongDouble.detail().name_hash()[i] = var_StructLongDouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructLongDouble);

    MinimalStructMember mst_var_StructBoolean;
    mst_var_StructBoolean.common().member_id(memberId++);
    mst_var_StructBoolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructBoolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructBoolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructBoolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructBoolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructBoolean.common().member_flags().IS_KEY(false);
    mst_var_StructBoolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructBoolean.common().member_type_id(*GetStructBooleanIdentifier(false));
    MD5 var_StructBoolean_hash("var_StructBoolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructBoolean.detail().name_hash()[i] = var_StructBoolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructBoolean);

    MinimalStructMember mst_var_StructOctet;
    mst_var_StructOctet.common().member_id(memberId++);
    mst_var_StructOctet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructOctet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructOctet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructOctet.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructOctet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructOctet.common().member_flags().IS_KEY(false);
    mst_var_StructOctet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructOctet.common().member_type_id(*GetStructOctetIdentifier(false));
    MD5 var_StructOctet_hash("var_StructOctet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructOctet.detail().name_hash()[i] = var_StructOctet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructOctet);

    MinimalStructMember mst_var_StructChar8;
    mst_var_StructChar8.common().member_id(memberId++);
    mst_var_StructChar8.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructChar8.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructChar8.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructChar8.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructChar8.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructChar8.common().member_flags().IS_KEY(false);
    mst_var_StructChar8.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructChar8.common().member_type_id(*GetStructChar8Identifier(false));
    MD5 var_StructChar8_hash("var_StructChar8");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructChar8.detail().name_hash()[i] = var_StructChar8_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructChar8);

    MinimalStructMember mst_var_StructChar16;
    mst_var_StructChar16.common().member_id(memberId++);
    mst_var_StructChar16.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructChar16.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructChar16.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructChar16.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructChar16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructChar16.common().member_flags().IS_KEY(false);
    mst_var_StructChar16.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructChar16.common().member_type_id(*GetStructChar16Identifier(false));
    MD5 var_StructChar16_hash("var_StructChar16");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructChar16.detail().name_hash()[i] = var_StructChar16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructChar16);

    MinimalStructMember mst_var_StructString;
    mst_var_StructString.common().member_id(memberId++);
    mst_var_StructString.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructString.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructString.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructString.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructString.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructString.common().member_flags().IS_KEY(false);
    mst_var_StructString.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructString.common().member_type_id(*GetStructStringIdentifier(false));
    MD5 var_StructString_hash("var_StructString");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructString.detail().name_hash()[i] = var_StructString_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructString);

    MinimalStructMember mst_var_StructWString;
    mst_var_StructWString.common().member_id(memberId++);
    mst_var_StructWString.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructWString.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructWString.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructWString.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructWString.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructWString.common().member_flags().IS_KEY(false);
    mst_var_StructWString.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructWString.common().member_type_id(*GetStructWStringIdentifier(false));
    MD5 var_StructWString_hash("var_StructWString");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructWString.detail().name_hash()[i] = var_StructWString_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructWString);

    MinimalStructMember mst_var_StructEnum;
    mst_var_StructEnum.common().member_id(memberId++);
    mst_var_StructEnum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructEnum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructEnum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructEnum.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructEnum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructEnum.common().member_flags().IS_KEY(false);
    mst_var_StructEnum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructEnum.common().member_type_id(*GetStructEnumIdentifier(false));
    MD5 var_StructEnum_hash("var_StructEnum");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructEnum.detail().name_hash()[i] = var_StructEnum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructEnum);

    MinimalStructMember mst_var_StructBitMask;
    mst_var_StructBitMask.common().member_id(memberId++);
    mst_var_StructBitMask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructBitMask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructBitMask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructBitMask.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructBitMask.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructBitMask.common().member_flags().IS_KEY(false);
    mst_var_StructBitMask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructBitMask.common().member_type_id(*GetStructBitMaskIdentifier(false));
    MD5 var_StructBitMask_hash("var_StructBitMask");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructBitMask.detail().name_hash()[i] = var_StructBitMask_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructBitMask);

    MinimalStructMember mst_var_StructAlias;
    mst_var_StructAlias.common().member_id(memberId++);
    mst_var_StructAlias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructAlias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructAlias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructAlias.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructAlias.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructAlias.common().member_flags().IS_KEY(false);
    mst_var_StructAlias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructAlias.common().member_type_id(*GetStructAliasIdentifier(false));
    MD5 var_StructAlias_hash("var_StructAlias");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructAlias.detail().name_hash()[i] = var_StructAlias_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructAlias);

    MinimalStructMember mst_var_StructShortArray;
    mst_var_StructShortArray.common().member_id(memberId++);
    mst_var_StructShortArray.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructShortArray.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructShortArray.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructShortArray.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructShortArray.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructShortArray.common().member_flags().IS_KEY(false);
    mst_var_StructShortArray.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructShortArray.common().member_type_id(*GetStructShortArrayIdentifier(false));
    MD5 var_StructShortArray_hash("var_StructShortArray");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructShortArray.detail().name_hash()[i] = var_StructShortArray_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructShortArray);

    MinimalStructMember mst_var_StructSequence;
    mst_var_StructSequence.common().member_id(memberId++);
    mst_var_StructSequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructSequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructSequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructSequence.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructSequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructSequence.common().member_flags().IS_KEY(false);
    mst_var_StructSequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructSequence.common().member_type_id(*GetStructSequenceIdentifier(false));
    MD5 var_StructSequence_hash("var_StructSequence");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructSequence.detail().name_hash()[i] = var_StructSequence_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructSequence);

    MinimalStructMember mst_var_StructMap;
    mst_var_StructMap.common().member_id(memberId++);
    mst_var_StructMap.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructMap.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructMap.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructMap.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructMap.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructMap.common().member_flags().IS_KEY(false);
    mst_var_StructMap.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructMap.common().member_type_id(*GetStructMapIdentifier(false));
    MD5 var_StructMap_hash("var_StructMap");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructMap.detail().name_hash()[i] = var_StructMap_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructMap);

    MinimalStructMember mst_var_StructUnion;
    mst_var_StructUnion.common().member_id(memberId++);
    mst_var_StructUnion.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructUnion.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructUnion.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructUnion.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructUnion.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructUnion.common().member_flags().IS_KEY(false);
    mst_var_StructUnion.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructUnion.common().member_type_id(*GetStructUnionIdentifier(false));
    MD5 var_StructUnion_hash("var_StructUnion");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructUnion.detail().name_hash()[i] = var_StructUnion_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructUnion);

    MinimalStructMember mst_var_StructStructure;
    mst_var_StructStructure.common().member_id(memberId++);
    mst_var_StructStructure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructStructure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructStructure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructStructure.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructStructure.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructStructure.common().member_flags().IS_KEY(false);
    mst_var_StructStructure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructStructure.common().member_type_id(*GetStructStructureIdentifier(false));
    MD5 var_StructStructure_hash("var_StructStructure");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructStructure.detail().name_hash()[i] = var_StructStructure_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructStructure);

    MinimalStructMember mst_var_StructBitset;
    mst_var_StructBitset.common().member_id(memberId++);
    mst_var_StructBitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructBitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructBitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructBitset.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructBitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructBitset.common().member_flags().IS_KEY(false);
    mst_var_StructBitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructBitset.common().member_type_id(*GetStructBitsetIdentifier(false));
    MD5 var_StructBitset_hash("var_StructBitset");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructBitset.detail().name_hash()[i] = var_StructBitset_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructBitset);

    MinimalStructMember mst_var_StructEmpty;
    mst_var_StructEmpty.common().member_id(memberId++);
    mst_var_StructEmpty.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructEmpty.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructEmpty.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructEmpty.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructEmpty.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructEmpty.common().member_flags().IS_KEY(false);
    mst_var_StructEmpty.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructEmpty.common().member_type_id(*GetStructEmptyIdentifier(false));
    MD5 var_StructEmpty_hash("var_StructEmpty");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructEmpty.detail().name_hash()[i] = var_StructEmpty_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructEmpty);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Structures", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Structures", false);
}

const TypeObject* GetCompleteStructuresObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Structures", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_StructShort;
    cst_var_StructShort.common().member_id(memberId++);
    cst_var_StructShort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructShort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructShort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructShort.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructShort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructShort.common().member_flags().IS_KEY(false);
    cst_var_StructShort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructShort.common().member_type_id(*GetStructShortIdentifier(true));
    cst_var_StructShort.detail().name("var_StructShort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructShort);

    CompleteStructMember cst_var_StructUnsignedShort;
    cst_var_StructUnsignedShort.common().member_id(memberId++);
    cst_var_StructUnsignedShort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructUnsignedShort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructUnsignedShort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructUnsignedShort.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructUnsignedShort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructUnsignedShort.common().member_flags().IS_KEY(false);
    cst_var_StructUnsignedShort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructUnsignedShort.common().member_type_id(*GetStructUnsignedShortIdentifier(true));
    cst_var_StructUnsignedShort.detail().name("var_StructUnsignedShort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructUnsignedShort);

    CompleteStructMember cst_var_StructLong;
    cst_var_StructLong.common().member_id(memberId++);
    cst_var_StructLong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructLong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructLong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructLong.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructLong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructLong.common().member_flags().IS_KEY(false);
    cst_var_StructLong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructLong.common().member_type_id(*GetStructLongIdentifier(true));
    cst_var_StructLong.detail().name("var_StructLong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructLong);

    CompleteStructMember cst_var_StructUnsignedLong;
    cst_var_StructUnsignedLong.common().member_id(memberId++);
    cst_var_StructUnsignedLong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructUnsignedLong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructUnsignedLong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructUnsignedLong.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructUnsignedLong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructUnsignedLong.common().member_flags().IS_KEY(false);
    cst_var_StructUnsignedLong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructUnsignedLong.common().member_type_id(*GetStructUnsignedLongIdentifier(true));
    cst_var_StructUnsignedLong.detail().name("var_StructUnsignedLong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructUnsignedLong);

    CompleteStructMember cst_var_StructLongLong;
    cst_var_StructLongLong.common().member_id(memberId++);
    cst_var_StructLongLong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructLongLong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructLongLong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructLongLong.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructLongLong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructLongLong.common().member_flags().IS_KEY(false);
    cst_var_StructLongLong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructLongLong.common().member_type_id(*GetStructLongLongIdentifier(true));
    cst_var_StructLongLong.detail().name("var_StructLongLong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructLongLong);

    CompleteStructMember cst_var_StructUnsignedLongLong;
    cst_var_StructUnsignedLongLong.common().member_id(memberId++);
    cst_var_StructUnsignedLongLong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructUnsignedLongLong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructUnsignedLongLong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructUnsignedLongLong.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructUnsignedLongLong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructUnsignedLongLong.common().member_flags().IS_KEY(false);
    cst_var_StructUnsignedLongLong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructUnsignedLongLong.common().member_type_id(*GetStructUnsignedLongLongIdentifier(true));
    cst_var_StructUnsignedLongLong.detail().name("var_StructUnsignedLongLong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructUnsignedLongLong);

    CompleteStructMember cst_var_StructFloat;
    cst_var_StructFloat.common().member_id(memberId++);
    cst_var_StructFloat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructFloat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructFloat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructFloat.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructFloat.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructFloat.common().member_flags().IS_KEY(false);
    cst_var_StructFloat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructFloat.common().member_type_id(*GetStructFloatIdentifier(true));
    cst_var_StructFloat.detail().name("var_StructFloat");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructFloat);

    CompleteStructMember cst_var_StructDouble;
    cst_var_StructDouble.common().member_id(memberId++);
    cst_var_StructDouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructDouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructDouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructDouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructDouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructDouble.common().member_flags().IS_KEY(false);
    cst_var_StructDouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructDouble.common().member_type_id(*GetStructDoubleIdentifier(true));
    cst_var_StructDouble.detail().name("var_StructDouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructDouble);

    CompleteStructMember cst_var_StructLongDouble;
    cst_var_StructLongDouble.common().member_id(memberId++);
    cst_var_StructLongDouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructLongDouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructLongDouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructLongDouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructLongDouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructLongDouble.common().member_flags().IS_KEY(false);
    cst_var_StructLongDouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructLongDouble.common().member_type_id(*GetStructLongDoubleIdentifier(true));
    cst_var_StructLongDouble.detail().name("var_StructLongDouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructLongDouble);

    CompleteStructMember cst_var_StructBoolean;
    cst_var_StructBoolean.common().member_id(memberId++);
    cst_var_StructBoolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructBoolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructBoolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructBoolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructBoolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructBoolean.common().member_flags().IS_KEY(false);
    cst_var_StructBoolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructBoolean.common().member_type_id(*GetStructBooleanIdentifier(true));
    cst_var_StructBoolean.detail().name("var_StructBoolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructBoolean);

    CompleteStructMember cst_var_StructOctet;
    cst_var_StructOctet.common().member_id(memberId++);
    cst_var_StructOctet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructOctet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructOctet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructOctet.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructOctet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructOctet.common().member_flags().IS_KEY(false);
    cst_var_StructOctet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructOctet.common().member_type_id(*GetStructOctetIdentifier(true));
    cst_var_StructOctet.detail().name("var_StructOctet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructOctet);

    CompleteStructMember cst_var_StructChar8;
    cst_var_StructChar8.common().member_id(memberId++);
    cst_var_StructChar8.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructChar8.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructChar8.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructChar8.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructChar8.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructChar8.common().member_flags().IS_KEY(false);
    cst_var_StructChar8.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructChar8.common().member_type_id(*GetStructChar8Identifier(true));
    cst_var_StructChar8.detail().name("var_StructChar8");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructChar8);

    CompleteStructMember cst_var_StructChar16;
    cst_var_StructChar16.common().member_id(memberId++);
    cst_var_StructChar16.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructChar16.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructChar16.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructChar16.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructChar16.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructChar16.common().member_flags().IS_KEY(false);
    cst_var_StructChar16.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructChar16.common().member_type_id(*GetStructChar16Identifier(true));
    cst_var_StructChar16.detail().name("var_StructChar16");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructChar16);

    CompleteStructMember cst_var_StructString;
    cst_var_StructString.common().member_id(memberId++);
    cst_var_StructString.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructString.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructString.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructString.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructString.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructString.common().member_flags().IS_KEY(false);
    cst_var_StructString.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructString.common().member_type_id(*GetStructStringIdentifier(true));
    cst_var_StructString.detail().name("var_StructString");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructString);

    CompleteStructMember cst_var_StructWString;
    cst_var_StructWString.common().member_id(memberId++);
    cst_var_StructWString.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructWString.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructWString.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructWString.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructWString.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructWString.common().member_flags().IS_KEY(false);
    cst_var_StructWString.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructWString.common().member_type_id(*GetStructWStringIdentifier(true));
    cst_var_StructWString.detail().name("var_StructWString");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructWString);

    CompleteStructMember cst_var_StructEnum;
    cst_var_StructEnum.common().member_id(memberId++);
    cst_var_StructEnum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructEnum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructEnum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructEnum.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructEnum.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructEnum.common().member_flags().IS_KEY(false);
    cst_var_StructEnum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructEnum.common().member_type_id(*GetStructEnumIdentifier(true));
    cst_var_StructEnum.detail().name("var_StructEnum");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructEnum);

    CompleteStructMember cst_var_StructBitMask;
    cst_var_StructBitMask.common().member_id(memberId++);
    cst_var_StructBitMask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructBitMask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructBitMask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructBitMask.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructBitMask.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructBitMask.common().member_flags().IS_KEY(false);
    cst_var_StructBitMask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructBitMask.common().member_type_id(*GetStructBitMaskIdentifier(true));
    cst_var_StructBitMask.detail().name("var_StructBitMask");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructBitMask);

    CompleteStructMember cst_var_StructAlias;
    cst_var_StructAlias.common().member_id(memberId++);
    cst_var_StructAlias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructAlias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructAlias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructAlias.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructAlias.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructAlias.common().member_flags().IS_KEY(false);
    cst_var_StructAlias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructAlias.common().member_type_id(*GetStructAliasIdentifier(true));
    cst_var_StructAlias.detail().name("var_StructAlias");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructAlias);

    CompleteStructMember cst_var_StructShortArray;
    cst_var_StructShortArray.common().member_id(memberId++);
    cst_var_StructShortArray.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructShortArray.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructShortArray.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructShortArray.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructShortArray.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructShortArray.common().member_flags().IS_KEY(false);
    cst_var_StructShortArray.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructShortArray.common().member_type_id(*GetStructShortArrayIdentifier(true));
    cst_var_StructShortArray.detail().name("var_StructShortArray");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructShortArray);

    CompleteStructMember cst_var_StructSequence;
    cst_var_StructSequence.common().member_id(memberId++);
    cst_var_StructSequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructSequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructSequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructSequence.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructSequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructSequence.common().member_flags().IS_KEY(false);
    cst_var_StructSequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructSequence.common().member_type_id(*GetStructSequenceIdentifier(true));
    cst_var_StructSequence.detail().name("var_StructSequence");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructSequence);

    CompleteStructMember cst_var_StructMap;
    cst_var_StructMap.common().member_id(memberId++);
    cst_var_StructMap.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructMap.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructMap.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructMap.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructMap.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructMap.common().member_flags().IS_KEY(false);
    cst_var_StructMap.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructMap.common().member_type_id(*GetStructMapIdentifier(true));
    cst_var_StructMap.detail().name("var_StructMap");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructMap);

    CompleteStructMember cst_var_StructUnion;
    cst_var_StructUnion.common().member_id(memberId++);
    cst_var_StructUnion.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructUnion.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructUnion.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructUnion.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructUnion.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructUnion.common().member_flags().IS_KEY(false);
    cst_var_StructUnion.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructUnion.common().member_type_id(*GetStructUnionIdentifier(true));
    cst_var_StructUnion.detail().name("var_StructUnion");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructUnion);

    CompleteStructMember cst_var_StructStructure;
    cst_var_StructStructure.common().member_id(memberId++);
    cst_var_StructStructure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructStructure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructStructure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructStructure.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructStructure.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructStructure.common().member_flags().IS_KEY(false);
    cst_var_StructStructure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructStructure.common().member_type_id(*GetStructStructureIdentifier(true));
    cst_var_StructStructure.detail().name("var_StructStructure");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructStructure);

    CompleteStructMember cst_var_StructBitset;
    cst_var_StructBitset.common().member_id(memberId++);
    cst_var_StructBitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructBitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructBitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructBitset.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructBitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructBitset.common().member_flags().IS_KEY(false);
    cst_var_StructBitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructBitset.common().member_type_id(*GetStructBitsetIdentifier(true));
    cst_var_StructBitset.detail().name("var_StructBitset");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructBitset);

    CompleteStructMember cst_var_StructEmpty;
    cst_var_StructEmpty.common().member_id(memberId++);
    cst_var_StructEmpty.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructEmpty.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructEmpty.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructEmpty.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructEmpty.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructEmpty.common().member_flags().IS_KEY(false);
    cst_var_StructEmpty.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructEmpty.common().member_type_id(*GetStructEmptyIdentifier(true));
    cst_var_StructEmpty.detail().name("var_StructEmpty");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructEmpty);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Structures");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Structures", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Structures", true);
}
