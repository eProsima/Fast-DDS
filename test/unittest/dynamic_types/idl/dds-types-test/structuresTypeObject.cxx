// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file structuresTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "structures.h"
#include "structuresTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

void registerstructuresTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(true),
                GetInnerEnumHelperObject(true));
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(false),
                GetInnerEnumHelperObject(false));

                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(true),
                GetInnerBitMaskHelperObject(true));
                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(false),
                GetInnerBitMaskHelperObject(false));

                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(true),
                GetInnerAliasHelperObject(true));
                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(false),
                GetInnerAliasHelperObject(false));

                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(true),
                GetInnerStructureHelperObject(true));
                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(false),
                GetInnerStructureHelperObject(false));

                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(true),
                GetInnerEmptyStructureHelperObject(true));
                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(false),
                GetInnerEmptyStructureHelperObject(false));

                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(true),
                GetInnerUnionHelperObject(true));
                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(false),
                GetInnerUnionHelperObject(false));

                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(true),
                GetInnerBitsetHelperObject(true));
                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(false),
                GetInnerBitsetHelperObject(false));

                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(true),
                GetInner_alias_bounded_string_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(false),
                GetInner_alias_bounded_string_helperObject(false));

                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(true),
                GetInner_alias_bounded_wstring_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(false),
                GetInner_alias_bounded_wstring_helperObject(false));

                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(true),
                GetInner_alias_array_helperObject(true));
                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(false),
                GetInner_alias_array_helperObject(false));

                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(true),
                GetInner_alias_sequence_helperObject(true));
                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(false),
                GetInner_alias_sequence_helperObject(false));

                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(true),
                GetInner_alias_map_helperObject(true));
                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(false),
                GetInner_alias_map_helperObject(false));

                factory->add_type_object("ShortStruct", GetShortStructIdentifier(true),
                GetShortStructObject(true));
                factory->add_type_object("ShortStruct", GetShortStructIdentifier(false),
                GetShortStructObject(false));

                factory->add_type_object("UnsignedShortStruct", GetUnsignedShortStructIdentifier(true),
                GetUnsignedShortStructObject(true));
                factory->add_type_object("UnsignedShortStruct", GetUnsignedShortStructIdentifier(false),
                GetUnsignedShortStructObject(false));

                factory->add_type_object("LongStruct", GetLongStructIdentifier(true),
                GetLongStructObject(true));
                factory->add_type_object("LongStruct", GetLongStructIdentifier(false),
                GetLongStructObject(false));

                factory->add_type_object("UnsignedLongStruct", GetUnsignedLongStructIdentifier(true),
                GetUnsignedLongStructObject(true));
                factory->add_type_object("UnsignedLongStruct", GetUnsignedLongStructIdentifier(false),
                GetUnsignedLongStructObject(false));

                factory->add_type_object("LongLongStruct", GetLongLongStructIdentifier(true),
                GetLongLongStructObject(true));
                factory->add_type_object("LongLongStruct", GetLongLongStructIdentifier(false),
                GetLongLongStructObject(false));

                factory->add_type_object("UnsignedLongLongStruct", GetUnsignedLongLongStructIdentifier(true),
                GetUnsignedLongLongStructObject(true));
                factory->add_type_object("UnsignedLongLongStruct", GetUnsignedLongLongStructIdentifier(false),
                GetUnsignedLongLongStructObject(false));

                factory->add_type_object("FloatStruct", GetFloatStructIdentifier(true),
                GetFloatStructObject(true));
                factory->add_type_object("FloatStruct", GetFloatStructIdentifier(false),
                GetFloatStructObject(false));

                factory->add_type_object("DoubleStruct", GetDoubleStructIdentifier(true),
                GetDoubleStructObject(true));
                factory->add_type_object("DoubleStruct", GetDoubleStructIdentifier(false),
                GetDoubleStructObject(false));

                factory->add_type_object("LongDoubleStruct", GetLongDoubleStructIdentifier(true),
                GetLongDoubleStructObject(true));
                factory->add_type_object("LongDoubleStruct", GetLongDoubleStructIdentifier(false),
                GetLongDoubleStructObject(false));

                factory->add_type_object("BooleanStruct", GetBooleanStructIdentifier(true),
                GetBooleanStructObject(true));
                factory->add_type_object("BooleanStruct", GetBooleanStructIdentifier(false),
                GetBooleanStructObject(false));

                factory->add_type_object("OctetStruct", GetOctetStructIdentifier(true),
                GetOctetStructObject(true));
                factory->add_type_object("OctetStruct", GetOctetStructIdentifier(false),
                GetOctetStructObject(false));

                factory->add_type_object("Char8Struct", GetChar8StructIdentifier(true),
                GetChar8StructObject(true));
                factory->add_type_object("Char8Struct", GetChar8StructIdentifier(false),
                GetChar8StructObject(false));

                factory->add_type_object("Char16Struct", GetChar16StructIdentifier(true),
                GetChar16StructObject(true));
                factory->add_type_object("Char16Struct", GetChar16StructIdentifier(false),
                GetChar16StructObject(false));

                factory->add_type_object("StringStruct", GetStringStructIdentifier(true),
                GetStringStructObject(true));
                factory->add_type_object("StringStruct", GetStringStructIdentifier(false),
                GetStringStructObject(false));

                factory->add_type_object("WStringStruct", GetWStringStructIdentifier(true),
                GetWStringStructObject(true));
                factory->add_type_object("WStringStruct", GetWStringStructIdentifier(false),
                GetWStringStructObject(false));

                factory->add_type_object("BoundedStringStruct", GetBoundedStringStructIdentifier(true),
                GetBoundedStringStructObject(true));
                factory->add_type_object("BoundedStringStruct", GetBoundedStringStructIdentifier(false),
                GetBoundedStringStructObject(false));

                factory->add_type_object("BoundedWStringStruct", GetBoundedWStringStructIdentifier(true),
                GetBoundedWStringStructObject(true));
                factory->add_type_object("BoundedWStringStruct", GetBoundedWStringStructIdentifier(false),
                GetBoundedWStringStructObject(false));

                factory->add_type_object("EnumStruct", GetEnumStructIdentifier(true),
                GetEnumStructObject(true));
                factory->add_type_object("EnumStruct", GetEnumStructIdentifier(false),
                GetEnumStructObject(false));

                factory->add_type_object("BitMaskStruct", GetBitMaskStructIdentifier(true),
                GetBitMaskStructObject(true));
                factory->add_type_object("BitMaskStruct", GetBitMaskStructIdentifier(false),
                GetBitMaskStructObject(false));

                factory->add_type_object("AliasStruct", GetAliasStructIdentifier(true),
                GetAliasStructObject(true));
                factory->add_type_object("AliasStruct", GetAliasStructIdentifier(false),
                GetAliasStructObject(false));

                factory->add_type_object("ShortArrayStruct", GetShortArrayStructIdentifier(true),
                GetShortArrayStructObject(true));
                factory->add_type_object("ShortArrayStruct", GetShortArrayStructIdentifier(false),
                GetShortArrayStructObject(false));

                factory->add_type_object("SequenceStruct", GetSequenceStructIdentifier(true),
                GetSequenceStructObject(true));
                factory->add_type_object("SequenceStruct", GetSequenceStructIdentifier(false),
                GetSequenceStructObject(false));

                factory->add_type_object("MapStruct", GetMapStructIdentifier(true),
                GetMapStructObject(true));
                factory->add_type_object("MapStruct", GetMapStructIdentifier(false),
                GetMapStructObject(false));

                factory->add_type_object("UnionStruct", GetUnionStructIdentifier(true),
                GetUnionStructObject(true));
                factory->add_type_object("UnionStruct", GetUnionStructIdentifier(false),
                GetUnionStructObject(false));

                factory->add_type_object("StructureStruct", GetStructureStructIdentifier(true),
                GetStructureStructObject(true));
                factory->add_type_object("StructureStruct", GetStructureStructIdentifier(false),
                GetStructureStructObject(false));

                factory->add_type_object("BitsetStruct", GetBitsetStructIdentifier(true),
                GetBitsetStructObject(true));
                factory->add_type_object("BitsetStruct", GetBitsetStructIdentifier(false),
                GetBitsetStructObject(false));

                factory->add_type_object("EmptyStructure", GetEmptyStructureIdentifier(true),
                GetEmptyStructureObject(true));
                factory->add_type_object("EmptyStructure", GetEmptyStructureIdentifier(false),
                GetEmptyStructureObject(false));

                factory->add_type_object("Structures", GetStructuresIdentifier(true),
                GetStructuresObject(true));
                factory->add_type_object("Structures", GetStructuresIdentifier(false),
                GetStructuresObject(false));

            });
}

const TypeIdentifier* GetInnerAliasHelperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("InnerAliasHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInnerAliasHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("InnerAliasHelper", complete);
}

const TypeObject* GetInnerAliasHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerAliasHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInnerAliasHelperObject();
    }
    else
    {
        return GetMinimalInnerAliasHelperObject();
    }
}

const TypeObject* GetMinimalInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerAliasHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("InnerAliasHelper", "int32_t");

    TypeObjectFactory::get_instance()->add_type_object("InnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerAliasHelper", false);
}

const TypeObject* GetCompleteInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InnerAliasHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("InnerAliasHelper");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("int32_t");


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("InnerAliasHelper", "int32_t");

    TypeObjectFactory::get_instance()->add_type_object("InnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("InnerAliasHelper", true);
}

const TypeIdentifier* GetInner_alias_bounded_string_helperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_bounded_string_helper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInner_alias_bounded_string_helperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_bounded_string_helper", complete);
}

const TypeObject* GetInner_alias_bounded_string_helperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_string_helper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInner_alias_bounded_string_helperObject();
    }
    else
    {
        return GetMinimalInner_alias_bounded_string_helperObject();
    }
}

const TypeObject* GetMinimalInner_alias_bounded_string_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_string_helper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_string_type_name(10, false), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_bounded_string_helper", TypeNamesGenerator::get_string_type_name(10, false));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_bounded_string_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_string_helper", false);
}

const TypeObject* GetCompleteInner_alias_bounded_string_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_string_helper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("Inner_alias_bounded_string_helper");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_string_type_name(10, false));


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_bounded_string_helper", TypeNamesGenerator::get_string_type_name(10, false));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_bounded_string_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_string_helper", true);
}

const TypeIdentifier* GetInner_alias_bounded_wstring_helperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_bounded_wstring_helper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInner_alias_bounded_wstring_helperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_bounded_wstring_helper", complete);
}

const TypeObject* GetInner_alias_bounded_wstring_helperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_wstring_helper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInner_alias_bounded_wstring_helperObject();
    }
    else
    {
        return GetMinimalInner_alias_bounded_wstring_helperObject();
    }
}

const TypeObject* GetMinimalInner_alias_bounded_wstring_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_wstring_helper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_string_type_name(10, true), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_bounded_wstring_helper", TypeNamesGenerator::get_string_type_name(10, true));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_bounded_wstring_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_wstring_helper", false);
}

const TypeObject* GetCompleteInner_alias_bounded_wstring_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_wstring_helper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("Inner_alias_bounded_wstring_helper");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_string_type_name(10, true));


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_bounded_wstring_helper", TypeNamesGenerator::get_string_type_name(10, true));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_bounded_wstring_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_bounded_wstring_helper", true);
}

const TypeIdentifier* GetInner_alias_array_helperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_array_helper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInner_alias_array_helperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_array_helper", complete);
}

const TypeObject* GetInner_alias_array_helperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_array_helper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInner_alias_array_helperObject();
    }
    else
    {
        return GetMinimalInner_alias_array_helperObject();
    }
}

const TypeObject* GetMinimalInner_alias_array_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_array_helper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_array_type_name("int16_t", {2}), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_array_helper", TypeNamesGenerator::get_array_type_name("int16_t", {2}));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_array_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_array_helper", false);
}

const TypeObject* GetCompleteInner_alias_array_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_array_helper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("Inner_alias_array_helper");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_array_type_name("int16_t", {2}));


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_array_helper", TypeNamesGenerator::get_array_type_name("int16_t", {2}));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_array_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_array_helper", true);
}

const TypeIdentifier* GetInner_alias_sequence_helperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_sequence_helper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInner_alias_sequence_helperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_sequence_helper", complete);
}

const TypeObject* GetInner_alias_sequence_helperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_sequence_helper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInner_alias_sequence_helperObject();
    }
    else
    {
        return GetMinimalInner_alias_sequence_helperObject();
    }
}

const TypeObject* GetMinimalInner_alias_sequence_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_sequence_helper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_sequence_type_name("int16_t", 100), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_sequence_helper", TypeNamesGenerator::get_sequence_type_name("int16_t", 100));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_sequence_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_sequence_helper", false);
}

const TypeObject* GetCompleteInner_alias_sequence_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_sequence_helper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("Inner_alias_sequence_helper");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_sequence_type_name("int16_t", 100));


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_sequence_helper", TypeNamesGenerator::get_sequence_type_name("int16_t", 100));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_sequence_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_sequence_helper", true);
}

const TypeIdentifier* GetInner_alias_map_helperIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_map_helper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetInner_alias_map_helperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Inner_alias_map_helper", complete);
}

const TypeObject* GetInner_alias_map_helperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_map_helper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteInner_alias_map_helperObject();
    }
    else
    {
        return GetMinimalInner_alias_map_helperObject();
    }
}

const TypeObject* GetMinimalInner_alias_map_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_map_helper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);

    // No flags apply
    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    // No flags apply
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_map_helper", TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_map_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_map_helper", false);
}

const TypeObject* GetCompleteInner_alias_map_helperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Inner_alias_map_helper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);

    // No flags apply
    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("Inner_alias_map_helper");

    // No flags apply
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100));


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::get_instance()->add_alias("Inner_alias_map_helper", TypeNamesGenerator::get_map_type_name("int32_t", "int32_t", 100));

    TypeObjectFactory::get_instance()->add_type_object("Inner_alias_map_helper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Inner_alias_map_helper", true);
}

const TypeIdentifier* GetShortStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ShortStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetShortStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ShortStruct", complete);
}

const TypeObject* GetShortStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ShortStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteShortStructObject();
    }
    //else
    return GetMinimalShortStructObject();
}

const TypeObject* GetMinimalShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ShortStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_short;
    mst_var_short.common().member_id(memberId++);
    mst_var_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_short.common().member_flags().IS_KEY(false);
    mst_var_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    MD5 var_short_hash("var_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_short.detail().name_hash()[i] = var_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ShortStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ShortStruct", false);
}

const TypeObject* GetCompleteShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ShortStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_short;
    cst_var_short.common().member_id(memberId++);
    cst_var_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_short.common().member_flags().IS_KEY(false);
    cst_var_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    cst_var_short.detail().name("var_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ShortStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ShortStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ShortStruct", true);
}

const TypeIdentifier* GetUnsignedShortStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnsignedShortStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnsignedShortStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnsignedShortStruct", complete);
}

const TypeObject* GetUnsignedShortStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnsignedShortStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnsignedShortStructObject();
    }
    //else
    return GetMinimalUnsignedShortStructObject();
}

const TypeObject* GetMinimalUnsignedShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnsignedShortStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ushort;
    mst_var_ushort.common().member_id(memberId++);
    mst_var_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ushort.common().member_flags().IS_KEY(false);
    mst_var_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 var_ushort_hash("var_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ushort.detail().name_hash()[i] = var_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnsignedShortStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnsignedShortStruct", false);
}

const TypeObject* GetCompleteUnsignedShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnsignedShortStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ushort;
    cst_var_ushort.common().member_id(memberId++);
    cst_var_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ushort.common().member_flags().IS_KEY(false);
    cst_var_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_var_ushort.detail().name("var_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnsignedShortStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnsignedShortStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnsignedShortStruct", true);
}

const TypeIdentifier* GetLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("LongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("LongStruct", complete);
}

const TypeObject* GetLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLongStructObject();
    }
    //else
    return GetMinimalLongStructObject();
}

const TypeObject* GetMinimalLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_long;
    mst_var_long.common().member_id(memberId++);
    mst_var_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_long.common().member_flags().IS_KEY(false);
    mst_var_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MD5 var_long_hash("var_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_long.detail().name_hash()[i] = var_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("LongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("LongStruct", false);
}

const TypeObject* GetCompleteLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_long;
    cst_var_long.common().member_id(memberId++);
    cst_var_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_long.common().member_flags().IS_KEY(false);
    cst_var_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    cst_var_long.detail().name("var_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("LongStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("LongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("LongStruct", true);
}

const TypeIdentifier* GetUnsignedLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnsignedLongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnsignedLongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnsignedLongStruct", complete);
}

const TypeObject* GetUnsignedLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnsignedLongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnsignedLongStructObject();
    }
    //else
    return GetMinimalUnsignedLongStructObject();
}

const TypeObject* GetMinimalUnsignedLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnsignedLongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ulong;
    mst_var_ulong.common().member_id(memberId++);
    mst_var_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ulong.common().member_flags().IS_KEY(false);
    mst_var_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 var_ulong_hash("var_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ulong.detail().name_hash()[i] = var_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnsignedLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnsignedLongStruct", false);
}

const TypeObject* GetCompleteUnsignedLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnsignedLongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ulong;
    cst_var_ulong.common().member_id(memberId++);
    cst_var_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ulong.common().member_flags().IS_KEY(false);
    cst_var_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_var_ulong.detail().name("var_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnsignedLongStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnsignedLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnsignedLongStruct", true);
}

const TypeIdentifier* GetLongLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("LongLongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLongLongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("LongLongStruct", complete);
}

const TypeObject* GetLongLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongLongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLongLongStructObject();
    }
    //else
    return GetMinimalLongLongStructObject();
}

const TypeObject* GetMinimalLongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongLongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_longlong;
    mst_var_longlong.common().member_id(memberId++);
    mst_var_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_longlong.common().member_flags().IS_KEY(false);
    mst_var_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    MD5 var_longlong_hash("var_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_longlong.detail().name_hash()[i] = var_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("LongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("LongLongStruct", false);
}

const TypeObject* GetCompleteLongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongLongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_longlong;
    cst_var_longlong.common().member_id(memberId++);
    cst_var_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_longlong.common().member_flags().IS_KEY(false);
    cst_var_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    cst_var_longlong.detail().name("var_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("LongLongStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("LongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("LongLongStruct", true);
}

const TypeIdentifier* GetUnsignedLongLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnsignedLongLongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnsignedLongLongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnsignedLongLongStruct", complete);
}

const TypeObject* GetUnsignedLongLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnsignedLongLongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnsignedLongLongStructObject();
    }
    //else
    return GetMinimalUnsignedLongLongStructObject();
}

const TypeObject* GetMinimalUnsignedLongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnsignedLongLongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ulonglong;
    mst_var_ulonglong.common().member_id(memberId++);
    mst_var_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    MD5 var_ulonglong_hash("var_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ulonglong.detail().name_hash()[i] = var_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnsignedLongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnsignedLongLongStruct", false);
}

const TypeObject* GetCompleteUnsignedLongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnsignedLongLongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ulonglong;
    cst_var_ulonglong.common().member_id(memberId++);
    cst_var_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    cst_var_ulonglong.detail().name("var_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnsignedLongLongStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnsignedLongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnsignedLongLongStruct", true);
}

const TypeIdentifier* GetFloatStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("FloatStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFloatStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("FloatStruct", complete);
}

const TypeObject* GetFloatStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FloatStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFloatStructObject();
    }
    //else
    return GetMinimalFloatStructObject();
}

const TypeObject* GetMinimalFloatStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FloatStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_float;
    mst_var_float.common().member_id(memberId++);
    mst_var_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_float.common().member_flags().IS_KEY(false);
    mst_var_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 var_float_hash("var_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_float.detail().name_hash()[i] = var_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FloatStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FloatStruct", false);
}

const TypeObject* GetCompleteFloatStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("FloatStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_float;
    cst_var_float.common().member_id(memberId++);
    cst_var_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_float.common().member_flags().IS_KEY(false);
    cst_var_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_var_float.detail().name("var_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FloatStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("FloatStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("FloatStruct", true);
}

const TypeIdentifier* GetDoubleStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("DoubleStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetDoubleStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("DoubleStruct", complete);
}

const TypeObject* GetDoubleStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("DoubleStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteDoubleStructObject();
    }
    //else
    return GetMinimalDoubleStructObject();
}

const TypeObject* GetMinimalDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("DoubleStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_double;
    mst_var_double.common().member_id(memberId++);
    mst_var_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_double.common().member_flags().IS_KEY(false);
    mst_var_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    MD5 var_double_hash("var_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_double.detail().name_hash()[i] = var_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("DoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("DoubleStruct", false);
}

const TypeObject* GetCompleteDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("DoubleStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_double;
    cst_var_double.common().member_id(memberId++);
    cst_var_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_double.common().member_flags().IS_KEY(false);
    cst_var_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    cst_var_double.detail().name("var_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("DoubleStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("DoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("DoubleStruct", true);
}

const TypeIdentifier* GetLongDoubleStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("LongDoubleStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLongDoubleStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("LongDoubleStruct", complete);
}

const TypeObject* GetLongDoubleStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongDoubleStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLongDoubleStructObject();
    }
    //else
    return GetMinimalLongDoubleStructObject();
}

const TypeObject* GetMinimalLongDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongDoubleStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_longdouble;
    mst_var_longdouble.common().member_id(memberId++);
    mst_var_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_longdouble.common().member_flags().IS_KEY(false);
    mst_var_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    MD5 var_longdouble_hash("var_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_longdouble.detail().name_hash()[i] = var_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("LongDoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("LongDoubleStruct", false);
}

const TypeObject* GetCompleteLongDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LongDoubleStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_longdouble;
    cst_var_longdouble.common().member_id(memberId++);
    cst_var_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_longdouble.common().member_flags().IS_KEY(false);
    cst_var_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    cst_var_longdouble.detail().name("var_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("LongDoubleStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("LongDoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("LongDoubleStruct", true);
}

const TypeIdentifier* GetBooleanStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("BooleanStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBooleanStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("BooleanStruct", complete);
}

const TypeObject* GetBooleanStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BooleanStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBooleanStructObject();
    }
    //else
    return GetMinimalBooleanStructObject();
}

const TypeObject* GetMinimalBooleanStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BooleanStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_boolean;
    mst_var_boolean.common().member_id(memberId++);
    mst_var_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_boolean.common().member_flags().IS_KEY(false);
    mst_var_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    MD5 var_boolean_hash("var_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_boolean.detail().name_hash()[i] = var_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BooleanStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BooleanStruct", false);
}

const TypeObject* GetCompleteBooleanStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BooleanStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_boolean;
    cst_var_boolean.common().member_id(memberId++);
    cst_var_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_boolean.common().member_flags().IS_KEY(false);
    cst_var_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    cst_var_boolean.detail().name("var_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BooleanStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BooleanStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BooleanStruct", true);
}

const TypeIdentifier* GetOctetStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("OctetStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetOctetStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("OctetStruct", complete);
}

const TypeObject* GetOctetStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("OctetStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteOctetStructObject();
    }
    //else
    return GetMinimalOctetStructObject();
}

const TypeObject* GetMinimalOctetStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("OctetStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_octet;
    mst_var_octet.common().member_id(memberId++);
    mst_var_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_octet.common().member_flags().IS_KEY(false);
    mst_var_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 var_octet_hash("var_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_octet.detail().name_hash()[i] = var_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("OctetStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("OctetStruct", false);
}

const TypeObject* GetCompleteOctetStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("OctetStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_octet;
    cst_var_octet.common().member_id(memberId++);
    cst_var_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_octet.common().member_flags().IS_KEY(false);
    cst_var_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_var_octet.detail().name("var_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("OctetStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("OctetStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("OctetStruct", true);
}

const TypeIdentifier* GetChar8StructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Char8Struct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetChar8StructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Char8Struct", complete);
}

const TypeObject* GetChar8StructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Char8Struct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteChar8StructObject();
    }
    //else
    return GetMinimalChar8StructObject();
}

const TypeObject* GetMinimalChar8StructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Char8Struct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_char8;
    mst_var_char8.common().member_id(memberId++);
    mst_var_char8.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_char8.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_char8.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_char8.common().member_flags().IS_OPTIONAL(false);
    mst_var_char8.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_char8.common().member_flags().IS_KEY(false);
    mst_var_char8.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_char8.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    MD5 var_char8_hash("var_char8");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_char8.detail().name_hash()[i] = var_char8_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_char8);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Char8Struct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Char8Struct", false);
}

const TypeObject* GetCompleteChar8StructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Char8Struct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_char8;
    cst_var_char8.common().member_id(memberId++);
    cst_var_char8.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_char8.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_char8.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_char8.common().member_flags().IS_OPTIONAL(false);
    cst_var_char8.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_char8.common().member_flags().IS_KEY(false);
    cst_var_char8.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_char8.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    cst_var_char8.detail().name("var_char8");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_char8);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Char8Struct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Char8Struct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Char8Struct", true);
}

const TypeIdentifier* GetChar16StructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Char16Struct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetChar16StructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Char16Struct", complete);
}

const TypeObject* GetChar16StructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Char16Struct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteChar16StructObject();
    }
    //else
    return GetMinimalChar16StructObject();
}

const TypeObject* GetMinimalChar16StructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Char16Struct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_char16;
    mst_var_char16.common().member_id(memberId++);
    mst_var_char16.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_char16.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_char16.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_char16.common().member_flags().IS_OPTIONAL(false);
    mst_var_char16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_char16.common().member_flags().IS_KEY(false);
    mst_var_char16.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_char16.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    MD5 var_char16_hash("var_char16");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_char16.detail().name_hash()[i] = var_char16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_char16);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Char16Struct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Char16Struct", false);
}

const TypeObject* GetCompleteChar16StructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Char16Struct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_char16;
    cst_var_char16.common().member_id(memberId++);
    cst_var_char16.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_char16.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_char16.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_char16.common().member_flags().IS_OPTIONAL(false);
    cst_var_char16.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_char16.common().member_flags().IS_KEY(false);
    cst_var_char16.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_char16.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    cst_var_char16.detail().name("var_char16");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_char16);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Char16Struct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Char16Struct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Char16Struct", true);
}

const TypeIdentifier* GetStringStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StringStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStringStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StringStruct", complete);
}

const TypeObject* GetStringStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StringStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStringStructObject();
    }
    //else
    return GetMinimalStringStructObject();
}

const TypeObject* GetMinimalStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StringStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_string;
    mst_var_string.common().member_id(memberId++);
    mst_var_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_string.common().member_flags().IS_KEY(false);
    mst_var_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    MD5 var_string_hash("var_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_string.detail().name_hash()[i] = var_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StringStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StringStruct", false);
}

const TypeObject* GetCompleteStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StringStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_string;
    cst_var_string.common().member_id(memberId++);
    cst_var_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_string.common().member_flags().IS_KEY(false);
    cst_var_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_string.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    cst_var_string.detail().name("var_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StringStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StringStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StringStruct", true);
}

const TypeIdentifier* GetWStringStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("WStringStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetWStringStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("WStringStruct", complete);
}

const TypeObject* GetWStringStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("WStringStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteWStringStructObject();
    }
    //else
    return GetMinimalWStringStructObject();
}

const TypeObject* GetMinimalWStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("WStringStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_wstring;
    mst_var_wstring.common().member_id(memberId++);
    mst_var_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_wstring.common().member_flags().IS_KEY(false);
    mst_var_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, true));


    MD5 var_wstring_hash("var_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_wstring.detail().name_hash()[i] = var_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("WStringStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("WStringStruct", false);
}

const TypeObject* GetCompleteWStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("WStringStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_wstring;
    cst_var_wstring.common().member_id(memberId++);
    cst_var_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_wstring.common().member_flags().IS_KEY(false);
    cst_var_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_wstring.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, true));


    cst_var_wstring.detail().name("var_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("WStringStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("WStringStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("WStringStruct", true);
}

const TypeIdentifier* GetBoundedStringStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("BoundedStringStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBoundedStringStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("BoundedStringStruct", complete);
}

const TypeObject* GetBoundedStringStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedStringStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBoundedStringStructObject();
    }
    //else
    return GetMinimalBoundedStringStructObject();
}

const TypeObject* GetMinimalBoundedStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedStringStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_bounded_string;
    mst_var_bounded_string.common().member_id(memberId++);
    mst_var_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_bounded_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_bounded_string.common().member_flags().IS_KEY(false);
    mst_var_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_bounded_string.common().member_type_id(*GetInner_alias_bounded_string_helperIdentifier(false));
    MD5 var_bounded_string_hash("var_bounded_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_bounded_string.detail().name_hash()[i] = var_bounded_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_bounded_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedStringStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedStringStruct", false);
}

const TypeObject* GetCompleteBoundedStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedStringStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_bounded_string;
    cst_var_bounded_string.common().member_id(memberId++);
    cst_var_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_bounded_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_bounded_string.common().member_flags().IS_KEY(false);
    cst_var_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_bounded_string.common().member_type_id(*GetInner_alias_bounded_string_helperIdentifier(true));
    cst_var_bounded_string.detail().name("var_bounded_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_bounded_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BoundedStringStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedStringStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedStringStruct", true);
}

const TypeIdentifier* GetBoundedWStringStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("BoundedWStringStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBoundedWStringStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("BoundedWStringStruct", complete);
}

const TypeObject* GetBoundedWStringStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedWStringStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBoundedWStringStructObject();
    }
    //else
    return GetMinimalBoundedWStringStructObject();
}

const TypeObject* GetMinimalBoundedWStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedWStringStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_bounded_wstring;
    mst_var_bounded_wstring.common().member_id(memberId++);
    mst_var_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_bounded_wstring.common().member_flags().IS_KEY(false);
    mst_var_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_bounded_wstring.common().member_type_id(*GetInner_alias_bounded_wstring_helperIdentifier(false));
    MD5 var_bounded_wstring_hash("var_bounded_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_bounded_wstring.detail().name_hash()[i] = var_bounded_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_bounded_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedWStringStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedWStringStruct", false);
}

const TypeObject* GetCompleteBoundedWStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BoundedWStringStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_bounded_wstring;
    cst_var_bounded_wstring.common().member_id(memberId++);
    cst_var_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_bounded_wstring.common().member_flags().IS_KEY(false);
    cst_var_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_bounded_wstring.common().member_type_id(*GetInner_alias_bounded_wstring_helperIdentifier(true));
    cst_var_bounded_wstring.detail().name("var_bounded_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_bounded_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BoundedWStringStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BoundedWStringStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BoundedWStringStruct", true);
}

const TypeIdentifier* GetEnumStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("EnumStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetEnumStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("EnumStruct", complete);
}

const TypeObject* GetEnumStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("EnumStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteEnumStructObject();
    }
    //else
    return GetMinimalEnumStructObject();
}

const TypeObject* GetMinimalEnumStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("EnumStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_enum;
    mst_var_enum.common().member_id(memberId++);
    mst_var_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_enum.common().member_flags().IS_OPTIONAL(false);
    mst_var_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_enum.common().member_flags().IS_KEY(false);
    mst_var_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_enum.common().member_type_id(*GetInnerEnumHelperIdentifier(false));
    MD5 var_enum_hash("var_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_enum.detail().name_hash()[i] = var_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_enum);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("EnumStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("EnumStruct", false);
}

const TypeObject* GetCompleteEnumStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("EnumStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_enum;
    cst_var_enum.common().member_id(memberId++);
    cst_var_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_enum.common().member_flags().IS_OPTIONAL(false);
    cst_var_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_enum.common().member_flags().IS_KEY(false);
    cst_var_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_enum.common().member_type_id(*GetInnerEnumHelperIdentifier(true));
    cst_var_enum.detail().name("var_enum");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_enum);


    // Header
    type_object->complete().struct_type().header().detail().type_name("EnumStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("EnumStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("EnumStruct", true);
}

const TypeIdentifier* GetBitMaskStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("BitMaskStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBitMaskStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("BitMaskStruct", complete);
}

const TypeObject* GetBitMaskStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BitMaskStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBitMaskStructObject();
    }
    //else
    return GetMinimalBitMaskStructObject();
}

const TypeObject* GetMinimalBitMaskStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BitMaskStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_bitmask;
    mst_var_bitmask.common().member_id(memberId++);
    mst_var_bitmask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_bitmask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_bitmask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_bitmask.common().member_flags().IS_OPTIONAL(false);
    mst_var_bitmask.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_bitmask.common().member_flags().IS_KEY(false);
    mst_var_bitmask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_bitmask.common().member_type_id(*GetInnerBitMaskHelperIdentifier(false));
    MD5 var_bitmask_hash("var_bitmask");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_bitmask.detail().name_hash()[i] = var_bitmask_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_bitmask);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BitMaskStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BitMaskStruct", false);
}

const TypeObject* GetCompleteBitMaskStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BitMaskStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_bitmask;
    cst_var_bitmask.common().member_id(memberId++);
    cst_var_bitmask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_bitmask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_bitmask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_bitmask.common().member_flags().IS_OPTIONAL(false);
    cst_var_bitmask.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_bitmask.common().member_flags().IS_KEY(false);
    cst_var_bitmask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_bitmask.common().member_type_id(*GetInnerBitMaskHelperIdentifier(true));
    cst_var_bitmask.detail().name("var_bitmask");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_bitmask);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BitMaskStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BitMaskStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BitMaskStruct", true);
}

const TypeIdentifier* GetAliasStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AliasStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAliasStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AliasStruct", complete);
}

const TypeObject* GetAliasStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AliasStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAliasStructObject();
    }
    //else
    return GetMinimalAliasStructObject();
}

const TypeObject* GetMinimalAliasStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AliasStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_alias;
    mst_var_alias.common().member_id(memberId++);
    mst_var_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_alias.common().member_flags().IS_OPTIONAL(false);
    mst_var_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_alias.common().member_flags().IS_KEY(false);
    mst_var_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_alias.common().member_type_id(*GetInnerAliasHelperIdentifier(false));
    MD5 var_alias_hash("var_alias");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_alias.detail().name_hash()[i] = var_alias_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_alias);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AliasStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AliasStruct", false);
}

const TypeObject* GetCompleteAliasStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AliasStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_alias;
    cst_var_alias.common().member_id(memberId++);
    cst_var_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_alias.common().member_flags().IS_OPTIONAL(false);
    cst_var_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_alias.common().member_flags().IS_KEY(false);
    cst_var_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_alias.common().member_type_id(*GetInnerAliasHelperIdentifier(true));
    cst_var_alias.detail().name("var_alias");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_alias);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AliasStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AliasStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AliasStruct", true);
}

const TypeIdentifier* GetShortArrayStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ShortArrayStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetShortArrayStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ShortArrayStruct", complete);
}

const TypeObject* GetShortArrayStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ShortArrayStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteShortArrayStructObject();
    }
    //else
    return GetMinimalShortArrayStructObject();
}

const TypeObject* GetMinimalShortArrayStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ShortArrayStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_array_short;
    mst_var_array_short.common().member_id(memberId++);
    mst_var_array_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_array_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_array_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_array_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_array_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_array_short.common().member_flags().IS_KEY(false);
    mst_var_array_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_array_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10}, false));


    MD5 var_array_short_hash("var_array_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_array_short.detail().name_hash()[i] = var_array_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_array_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ShortArrayStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ShortArrayStruct", false);
}

const TypeObject* GetCompleteShortArrayStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ShortArrayStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_array_short;
    cst_var_array_short.common().member_id(memberId++);
    cst_var_array_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_array_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_array_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_array_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_array_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_array_short.common().member_flags().IS_KEY(false);
    cst_var_array_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_array_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("int16_t", {10}, true));


    cst_var_array_short.detail().name("var_array_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_array_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ShortArrayStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ShortArrayStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ShortArrayStruct", true);
}

const TypeIdentifier* GetSequenceStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("SequenceStruct", complete);
}

const TypeObject* GetSequenceStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceStructObject();
    }
    //else
    return GetMinimalSequenceStructObject();
}

const TypeObject* GetMinimalSequenceStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_sequence;
    mst_var_sequence.common().member_id(memberId++);
    mst_var_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_sequence.common().member_flags().IS_OPTIONAL(false);
    mst_var_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_sequence.common().member_flags().IS_KEY(false);
    mst_var_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_sequence.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int32_t", 100, false));


    MD5 var_sequence_hash("var_sequence");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_sequence.detail().name_hash()[i] = var_sequence_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_sequence);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceStruct", false);
}

const TypeObject* GetCompleteSequenceStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_sequence;
    cst_var_sequence.common().member_id(memberId++);
    cst_var_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_sequence.common().member_flags().IS_OPTIONAL(false);
    cst_var_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_sequence.common().member_flags().IS_KEY(false);
    cst_var_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_sequence.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int32_t", 100, true));


    cst_var_sequence.detail().name("var_sequence");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_sequence);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("SequenceStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("SequenceStruct", true);
}

const TypeIdentifier* GetMapStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("MapStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("MapStruct", complete);
}

const TypeObject* GetMapStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStructObject();
    }
    //else
    return GetMinimalMapStructObject();
}

const TypeObject* GetMinimalMapStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_map;
    mst_var_map.common().member_id(memberId++);
    mst_var_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_map.common().member_flags().IS_OPTIONAL(false);
    mst_var_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_map.common().member_flags().IS_KEY(false);
    mst_var_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int32_t", 100, false));


    MD5 var_map_hash("var_map");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_map.detail().name_hash()[i] = var_map_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_map);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStruct", false);
}

const TypeObject* GetCompleteMapStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("MapStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_map;
    cst_var_map.common().member_id(memberId++);
    cst_var_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_map.common().member_flags().IS_OPTIONAL(false);
    cst_var_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_map.common().member_flags().IS_KEY(false);
    cst_var_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_map.common().member_type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int32_t", 100, true));


    cst_var_map.detail().name("var_map");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_map);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("MapStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("MapStruct", true);
}

const TypeIdentifier* GetUnionStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionStruct", complete);
}

const TypeObject* GetUnionStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionStructObject();
    }
    //else
    return GetMinimalUnionStructObject();
}

const TypeObject* GetMinimalUnionStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union;
    mst_var_union.common().member_id(memberId++);
    mst_var_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union.common().member_flags().IS_OPTIONAL(false);
    mst_var_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union.common().member_flags().IS_KEY(false);
    mst_var_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union.common().member_type_id(*GetInnerUnionHelperIdentifier(false));
    MD5 var_union_hash("var_union");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union.detail().name_hash()[i] = var_union_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionStruct", false);
}

const TypeObject* GetCompleteUnionStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union;
    cst_var_union.common().member_id(memberId++);
    cst_var_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union.common().member_flags().IS_OPTIONAL(false);
    cst_var_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union.common().member_flags().IS_KEY(false);
    cst_var_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union.common().member_type_id(*GetInnerUnionHelperIdentifier(true));
    cst_var_union.detail().name("var_union");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionStruct", true);
}

const TypeIdentifier* GetStructureStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("StructureStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructureStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("StructureStruct", complete);
}

const TypeObject* GetStructureStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructureStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructureStructObject();
    }
    //else
    return GetMinimalStructureStructObject();
}

const TypeObject* GetMinimalStructureStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructureStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_structure;
    mst_var_structure.common().member_id(memberId++);
    mst_var_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_structure.common().member_flags().IS_OPTIONAL(false);
    mst_var_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_structure.common().member_flags().IS_KEY(false);
    mst_var_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_structure.common().member_type_id(*GetInnerStructureHelperIdentifier(false));
    MD5 var_structure_hash("var_structure");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_structure.detail().name_hash()[i] = var_structure_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_structure);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructureStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructureStruct", false);
}

const TypeObject* GetCompleteStructureStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("StructureStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_structure;
    cst_var_structure.common().member_id(memberId++);
    cst_var_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_structure.common().member_flags().IS_OPTIONAL(false);
    cst_var_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_structure.common().member_flags().IS_KEY(false);
    cst_var_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_structure.common().member_type_id(*GetInnerStructureHelperIdentifier(true));
    cst_var_structure.detail().name("var_structure");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_structure);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructureStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("StructureStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("StructureStruct", true);
}

const TypeIdentifier* GetBitsetStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("BitsetStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBitsetStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("BitsetStruct", complete);
}

const TypeObject* GetBitsetStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BitsetStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBitsetStructObject();
    }
    //else
    return GetMinimalBitsetStructObject();
}

const TypeObject* GetMinimalBitsetStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BitsetStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_bitset;
    mst_var_bitset.common().member_id(memberId++);
    mst_var_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_bitset.common().member_flags().IS_OPTIONAL(false);
    mst_var_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_bitset.common().member_flags().IS_KEY(false);
    mst_var_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_bitset.common().member_type_id(*GetInnerBitsetHelperIdentifier(false));
    MD5 var_bitset_hash("var_bitset");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_bitset.detail().name_hash()[i] = var_bitset_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_bitset);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BitsetStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BitsetStruct", false);
}

const TypeObject* GetCompleteBitsetStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BitsetStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_bitset;
    cst_var_bitset.common().member_id(memberId++);
    cst_var_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_bitset.common().member_flags().IS_OPTIONAL(false);
    cst_var_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_bitset.common().member_flags().IS_KEY(false);
    cst_var_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_bitset.common().member_type_id(*GetInnerBitsetHelperIdentifier(true));
    cst_var_bitset.detail().name("var_bitset");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_bitset);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BitsetStruct");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BitsetStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BitsetStruct", true);
}

const TypeIdentifier* GetEmptyStructureIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("EmptyStructure", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetEmptyStructureObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("EmptyStructure", complete);
}

const TypeObject* GetEmptyStructureObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("EmptyStructure", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteEmptyStructureObject();
    }
    //else
    return GetMinimalEmptyStructureObject();
}

const TypeObject* GetMinimalEmptyStructureObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("EmptyStructure", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;

    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("EmptyStructure", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("EmptyStructure", false);
}

const TypeObject* GetCompleteEmptyStructureObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("EmptyStructure", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;

    // Header
    type_object->complete().struct_type().header().detail().type_name("EmptyStructure");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("EmptyStructure", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("EmptyStructure", true);
}

const TypeIdentifier* GetStructuresIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Structures", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructuresObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Structures", complete);
}

const TypeObject* GetStructuresObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Structures", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructuresObject();
    }
    //else
    return GetMinimalStructuresObject();
}

const TypeObject* GetMinimalStructuresObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Structures", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ShortStruct;
    mst_var_ShortStruct.common().member_id(memberId++);
    mst_var_ShortStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ShortStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ShortStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ShortStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_ShortStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ShortStruct.common().member_flags().IS_KEY(false);
    mst_var_ShortStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ShortStruct.common().member_type_id(*GetShortStructIdentifier(false));
    MD5 var_ShortStruct_hash("var_ShortStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ShortStruct.detail().name_hash()[i] = var_ShortStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ShortStruct);

    MinimalStructMember mst_var_UnsignedShortStruct;
    mst_var_UnsignedShortStruct.common().member_id(memberId++);
    mst_var_UnsignedShortStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_UnsignedShortStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_UnsignedShortStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_UnsignedShortStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_UnsignedShortStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_UnsignedShortStruct.common().member_flags().IS_KEY(false);
    mst_var_UnsignedShortStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_UnsignedShortStruct.common().member_type_id(*GetUnsignedShortStructIdentifier(false));
    MD5 var_UnsignedShortStruct_hash("var_UnsignedShortStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_UnsignedShortStruct.detail().name_hash()[i] = var_UnsignedShortStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_UnsignedShortStruct);

    MinimalStructMember mst_var_LongStruct;
    mst_var_LongStruct.common().member_id(memberId++);
    mst_var_LongStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_LongStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_LongStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_LongStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_LongStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_LongStruct.common().member_flags().IS_KEY(false);
    mst_var_LongStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_LongStruct.common().member_type_id(*GetLongStructIdentifier(false));
    MD5 var_LongStruct_hash("var_LongStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_LongStruct.detail().name_hash()[i] = var_LongStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_LongStruct);

    MinimalStructMember mst_var_UnsignedLongStruct;
    mst_var_UnsignedLongStruct.common().member_id(memberId++);
    mst_var_UnsignedLongStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_UnsignedLongStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_UnsignedLongStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_UnsignedLongStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_UnsignedLongStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_UnsignedLongStruct.common().member_flags().IS_KEY(false);
    mst_var_UnsignedLongStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_UnsignedLongStruct.common().member_type_id(*GetUnsignedLongStructIdentifier(false));
    MD5 var_UnsignedLongStruct_hash("var_UnsignedLongStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_UnsignedLongStruct.detail().name_hash()[i] = var_UnsignedLongStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_UnsignedLongStruct);

    MinimalStructMember mst_var_LongLongStruct;
    mst_var_LongLongStruct.common().member_id(memberId++);
    mst_var_LongLongStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_LongLongStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_LongLongStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_LongLongStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_LongLongStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_LongLongStruct.common().member_flags().IS_KEY(false);
    mst_var_LongLongStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_LongLongStruct.common().member_type_id(*GetLongLongStructIdentifier(false));
    MD5 var_LongLongStruct_hash("var_LongLongStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_LongLongStruct.detail().name_hash()[i] = var_LongLongStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_LongLongStruct);

    MinimalStructMember mst_var_UnsignedLongLongStruct;
    mst_var_UnsignedLongLongStruct.common().member_id(memberId++);
    mst_var_UnsignedLongLongStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_UnsignedLongLongStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_UnsignedLongLongStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_UnsignedLongLongStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_UnsignedLongLongStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_UnsignedLongLongStruct.common().member_flags().IS_KEY(false);
    mst_var_UnsignedLongLongStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_UnsignedLongLongStruct.common().member_type_id(*GetUnsignedLongLongStructIdentifier(false));
    MD5 var_UnsignedLongLongStruct_hash("var_UnsignedLongLongStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_UnsignedLongLongStruct.detail().name_hash()[i] = var_UnsignedLongLongStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_UnsignedLongLongStruct);

    MinimalStructMember mst_var_FloatStruct;
    mst_var_FloatStruct.common().member_id(memberId++);
    mst_var_FloatStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_FloatStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_FloatStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_FloatStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_FloatStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_FloatStruct.common().member_flags().IS_KEY(false);
    mst_var_FloatStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_FloatStruct.common().member_type_id(*GetFloatStructIdentifier(false));
    MD5 var_FloatStruct_hash("var_FloatStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_FloatStruct.detail().name_hash()[i] = var_FloatStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_FloatStruct);

    MinimalStructMember mst_var_DoubleStruct;
    mst_var_DoubleStruct.common().member_id(memberId++);
    mst_var_DoubleStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_DoubleStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_DoubleStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_DoubleStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_DoubleStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_DoubleStruct.common().member_flags().IS_KEY(false);
    mst_var_DoubleStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_DoubleStruct.common().member_type_id(*GetDoubleStructIdentifier(false));
    MD5 var_DoubleStruct_hash("var_DoubleStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_DoubleStruct.detail().name_hash()[i] = var_DoubleStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_DoubleStruct);

    MinimalStructMember mst_var_LongDoubleStruct;
    mst_var_LongDoubleStruct.common().member_id(memberId++);
    mst_var_LongDoubleStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_LongDoubleStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_LongDoubleStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_LongDoubleStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_LongDoubleStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_LongDoubleStruct.common().member_flags().IS_KEY(false);
    mst_var_LongDoubleStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_LongDoubleStruct.common().member_type_id(*GetLongDoubleStructIdentifier(false));
    MD5 var_LongDoubleStruct_hash("var_LongDoubleStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_LongDoubleStruct.detail().name_hash()[i] = var_LongDoubleStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_LongDoubleStruct);

    MinimalStructMember mst_var_BooleanStruct;
    mst_var_BooleanStruct.common().member_id(memberId++);
    mst_var_BooleanStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_BooleanStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_BooleanStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_BooleanStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_BooleanStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_BooleanStruct.common().member_flags().IS_KEY(false);
    mst_var_BooleanStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_BooleanStruct.common().member_type_id(*GetBooleanStructIdentifier(false));
    MD5 var_BooleanStruct_hash("var_BooleanStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_BooleanStruct.detail().name_hash()[i] = var_BooleanStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_BooleanStruct);

    MinimalStructMember mst_var_OctetStruct;
    mst_var_OctetStruct.common().member_id(memberId++);
    mst_var_OctetStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_OctetStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_OctetStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_OctetStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_OctetStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_OctetStruct.common().member_flags().IS_KEY(false);
    mst_var_OctetStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_OctetStruct.common().member_type_id(*GetOctetStructIdentifier(false));
    MD5 var_OctetStruct_hash("var_OctetStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_OctetStruct.detail().name_hash()[i] = var_OctetStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_OctetStruct);

    MinimalStructMember mst_var_Char8Struct;
    mst_var_Char8Struct.common().member_id(memberId++);
    mst_var_Char8Struct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_Char8Struct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_Char8Struct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_Char8Struct.common().member_flags().IS_OPTIONAL(false);
    mst_var_Char8Struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_Char8Struct.common().member_flags().IS_KEY(false);
    mst_var_Char8Struct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_Char8Struct.common().member_type_id(*GetChar8StructIdentifier(false));
    MD5 var_Char8Struct_hash("var_Char8Struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_Char8Struct.detail().name_hash()[i] = var_Char8Struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_Char8Struct);

    MinimalStructMember mst_var_Char16Struct;
    mst_var_Char16Struct.common().member_id(memberId++);
    mst_var_Char16Struct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_Char16Struct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_Char16Struct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_Char16Struct.common().member_flags().IS_OPTIONAL(false);
    mst_var_Char16Struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_Char16Struct.common().member_flags().IS_KEY(false);
    mst_var_Char16Struct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_Char16Struct.common().member_type_id(*GetChar16StructIdentifier(false));
    MD5 var_Char16Struct_hash("var_Char16Struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_Char16Struct.detail().name_hash()[i] = var_Char16Struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_Char16Struct);

    MinimalStructMember mst_var_StringStruct;
    mst_var_StringStruct.common().member_id(memberId++);
    mst_var_StringStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StringStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StringStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StringStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_StringStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StringStruct.common().member_flags().IS_KEY(false);
    mst_var_StringStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StringStruct.common().member_type_id(*GetStringStructIdentifier(false));
    MD5 var_StringStruct_hash("var_StringStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StringStruct.detail().name_hash()[i] = var_StringStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StringStruct);

    MinimalStructMember mst_var_WStringStruct;
    mst_var_WStringStruct.common().member_id(memberId++);
    mst_var_WStringStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_WStringStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_WStringStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_WStringStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_WStringStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_WStringStruct.common().member_flags().IS_KEY(false);
    mst_var_WStringStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_WStringStruct.common().member_type_id(*GetWStringStructIdentifier(false));
    MD5 var_WStringStruct_hash("var_WStringStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_WStringStruct.detail().name_hash()[i] = var_WStringStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_WStringStruct);

    MinimalStructMember mst_var_EnumStruct;
    mst_var_EnumStruct.common().member_id(memberId++);
    mst_var_EnumStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_EnumStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_EnumStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_EnumStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_EnumStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_EnumStruct.common().member_flags().IS_KEY(false);
    mst_var_EnumStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_EnumStruct.common().member_type_id(*GetEnumStructIdentifier(false));
    MD5 var_EnumStruct_hash("var_EnumStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_EnumStruct.detail().name_hash()[i] = var_EnumStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_EnumStruct);

    MinimalStructMember mst_var_BitMaskStruct;
    mst_var_BitMaskStruct.common().member_id(memberId++);
    mst_var_BitMaskStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_BitMaskStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_BitMaskStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_BitMaskStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_BitMaskStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_BitMaskStruct.common().member_flags().IS_KEY(false);
    mst_var_BitMaskStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_BitMaskStruct.common().member_type_id(*GetBitMaskStructIdentifier(false));
    MD5 var_BitMaskStruct_hash("var_BitMaskStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_BitMaskStruct.detail().name_hash()[i] = var_BitMaskStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_BitMaskStruct);

    MinimalStructMember mst_var_AliasStruct;
    mst_var_AliasStruct.common().member_id(memberId++);
    mst_var_AliasStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_AliasStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_AliasStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_AliasStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_AliasStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_AliasStruct.common().member_flags().IS_KEY(false);
    mst_var_AliasStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_AliasStruct.common().member_type_id(*GetAliasStructIdentifier(false));
    MD5 var_AliasStruct_hash("var_AliasStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_AliasStruct.detail().name_hash()[i] = var_AliasStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_AliasStruct);

    MinimalStructMember mst_var_ShortArrayStruct;
    mst_var_ShortArrayStruct.common().member_id(memberId++);
    mst_var_ShortArrayStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ShortArrayStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ShortArrayStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ShortArrayStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_ShortArrayStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ShortArrayStruct.common().member_flags().IS_KEY(false);
    mst_var_ShortArrayStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ShortArrayStruct.common().member_type_id(*GetShortArrayStructIdentifier(false));
    MD5 var_ShortArrayStruct_hash("var_ShortArrayStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ShortArrayStruct.detail().name_hash()[i] = var_ShortArrayStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ShortArrayStruct);

    MinimalStructMember mst_var_SequenceStruct;
    mst_var_SequenceStruct.common().member_id(memberId++);
    mst_var_SequenceStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_SequenceStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_SequenceStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_SequenceStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_SequenceStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_SequenceStruct.common().member_flags().IS_KEY(false);
    mst_var_SequenceStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_SequenceStruct.common().member_type_id(*GetSequenceStructIdentifier(false));
    MD5 var_SequenceStruct_hash("var_SequenceStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_SequenceStruct.detail().name_hash()[i] = var_SequenceStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_SequenceStruct);

    MinimalStructMember mst_var_MapStruct;
    mst_var_MapStruct.common().member_id(memberId++);
    mst_var_MapStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_MapStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_MapStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_MapStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_MapStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_MapStruct.common().member_flags().IS_KEY(false);
    mst_var_MapStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_MapStruct.common().member_type_id(*GetMapStructIdentifier(false));
    MD5 var_MapStruct_hash("var_MapStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_MapStruct.detail().name_hash()[i] = var_MapStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_MapStruct);

    MinimalStructMember mst_var_UnionStruct;
    mst_var_UnionStruct.common().member_id(memberId++);
    mst_var_UnionStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_UnionStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_UnionStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_UnionStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_UnionStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_UnionStruct.common().member_flags().IS_KEY(false);
    mst_var_UnionStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_UnionStruct.common().member_type_id(*GetUnionStructIdentifier(false));
    MD5 var_UnionStruct_hash("var_UnionStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_UnionStruct.detail().name_hash()[i] = var_UnionStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_UnionStruct);

    MinimalStructMember mst_var_StructureStruct;
    mst_var_StructureStruct.common().member_id(memberId++);
    mst_var_StructureStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_StructureStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_StructureStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_StructureStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_StructureStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_StructureStruct.common().member_flags().IS_KEY(false);
    mst_var_StructureStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_StructureStruct.common().member_type_id(*GetStructureStructIdentifier(false));
    MD5 var_StructureStruct_hash("var_StructureStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_StructureStruct.detail().name_hash()[i] = var_StructureStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_StructureStruct);

    MinimalStructMember mst_var_BitsetStruct;
    mst_var_BitsetStruct.common().member_id(memberId++);
    mst_var_BitsetStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_BitsetStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_BitsetStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_BitsetStruct.common().member_flags().IS_OPTIONAL(false);
    mst_var_BitsetStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_BitsetStruct.common().member_flags().IS_KEY(false);
    mst_var_BitsetStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_BitsetStruct.common().member_type_id(*GetBitsetStructIdentifier(false));
    MD5 var_BitsetStruct_hash("var_BitsetStruct");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_BitsetStruct.detail().name_hash()[i] = var_BitsetStruct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_BitsetStruct);

    MinimalStructMember mst_var_EmptyStructure;
    mst_var_EmptyStructure.common().member_id(memberId++);
    mst_var_EmptyStructure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_EmptyStructure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_EmptyStructure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_EmptyStructure.common().member_flags().IS_OPTIONAL(false);
    mst_var_EmptyStructure.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_EmptyStructure.common().member_flags().IS_KEY(false);
    mst_var_EmptyStructure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_EmptyStructure.common().member_type_id(*GetEmptyStructureIdentifier(false));
    MD5 var_EmptyStructure_hash("var_EmptyStructure");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_EmptyStructure.detail().name_hash()[i] = var_EmptyStructure_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_EmptyStructure);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Structures", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Structures", false);
}

const TypeObject* GetCompleteStructuresObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Structures", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ShortStruct;
    cst_var_ShortStruct.common().member_id(memberId++);
    cst_var_ShortStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ShortStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ShortStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ShortStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_ShortStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ShortStruct.common().member_flags().IS_KEY(false);
    cst_var_ShortStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ShortStruct.common().member_type_id(*GetShortStructIdentifier(true));
    cst_var_ShortStruct.detail().name("var_ShortStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ShortStruct);

    CompleteStructMember cst_var_UnsignedShortStruct;
    cst_var_UnsignedShortStruct.common().member_id(memberId++);
    cst_var_UnsignedShortStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_UnsignedShortStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_UnsignedShortStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_UnsignedShortStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_UnsignedShortStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_UnsignedShortStruct.common().member_flags().IS_KEY(false);
    cst_var_UnsignedShortStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_UnsignedShortStruct.common().member_type_id(*GetUnsignedShortStructIdentifier(true));
    cst_var_UnsignedShortStruct.detail().name("var_UnsignedShortStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_UnsignedShortStruct);

    CompleteStructMember cst_var_LongStruct;
    cst_var_LongStruct.common().member_id(memberId++);
    cst_var_LongStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_LongStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_LongStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_LongStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_LongStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_LongStruct.common().member_flags().IS_KEY(false);
    cst_var_LongStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_LongStruct.common().member_type_id(*GetLongStructIdentifier(true));
    cst_var_LongStruct.detail().name("var_LongStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_LongStruct);

    CompleteStructMember cst_var_UnsignedLongStruct;
    cst_var_UnsignedLongStruct.common().member_id(memberId++);
    cst_var_UnsignedLongStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_UnsignedLongStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_UnsignedLongStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_UnsignedLongStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_UnsignedLongStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_UnsignedLongStruct.common().member_flags().IS_KEY(false);
    cst_var_UnsignedLongStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_UnsignedLongStruct.common().member_type_id(*GetUnsignedLongStructIdentifier(true));
    cst_var_UnsignedLongStruct.detail().name("var_UnsignedLongStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_UnsignedLongStruct);

    CompleteStructMember cst_var_LongLongStruct;
    cst_var_LongLongStruct.common().member_id(memberId++);
    cst_var_LongLongStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_LongLongStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_LongLongStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_LongLongStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_LongLongStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_LongLongStruct.common().member_flags().IS_KEY(false);
    cst_var_LongLongStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_LongLongStruct.common().member_type_id(*GetLongLongStructIdentifier(true));
    cst_var_LongLongStruct.detail().name("var_LongLongStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_LongLongStruct);

    CompleteStructMember cst_var_UnsignedLongLongStruct;
    cst_var_UnsignedLongLongStruct.common().member_id(memberId++);
    cst_var_UnsignedLongLongStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_UnsignedLongLongStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_UnsignedLongLongStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_UnsignedLongLongStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_UnsignedLongLongStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_UnsignedLongLongStruct.common().member_flags().IS_KEY(false);
    cst_var_UnsignedLongLongStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_UnsignedLongLongStruct.common().member_type_id(*GetUnsignedLongLongStructIdentifier(true));
    cst_var_UnsignedLongLongStruct.detail().name("var_UnsignedLongLongStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_UnsignedLongLongStruct);

    CompleteStructMember cst_var_FloatStruct;
    cst_var_FloatStruct.common().member_id(memberId++);
    cst_var_FloatStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_FloatStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_FloatStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_FloatStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_FloatStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_FloatStruct.common().member_flags().IS_KEY(false);
    cst_var_FloatStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_FloatStruct.common().member_type_id(*GetFloatStructIdentifier(true));
    cst_var_FloatStruct.detail().name("var_FloatStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_FloatStruct);

    CompleteStructMember cst_var_DoubleStruct;
    cst_var_DoubleStruct.common().member_id(memberId++);
    cst_var_DoubleStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_DoubleStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_DoubleStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_DoubleStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_DoubleStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_DoubleStruct.common().member_flags().IS_KEY(false);
    cst_var_DoubleStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_DoubleStruct.common().member_type_id(*GetDoubleStructIdentifier(true));
    cst_var_DoubleStruct.detail().name("var_DoubleStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_DoubleStruct);

    CompleteStructMember cst_var_LongDoubleStruct;
    cst_var_LongDoubleStruct.common().member_id(memberId++);
    cst_var_LongDoubleStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_LongDoubleStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_LongDoubleStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_LongDoubleStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_LongDoubleStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_LongDoubleStruct.common().member_flags().IS_KEY(false);
    cst_var_LongDoubleStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_LongDoubleStruct.common().member_type_id(*GetLongDoubleStructIdentifier(true));
    cst_var_LongDoubleStruct.detail().name("var_LongDoubleStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_LongDoubleStruct);

    CompleteStructMember cst_var_BooleanStruct;
    cst_var_BooleanStruct.common().member_id(memberId++);
    cst_var_BooleanStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_BooleanStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_BooleanStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_BooleanStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_BooleanStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_BooleanStruct.common().member_flags().IS_KEY(false);
    cst_var_BooleanStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_BooleanStruct.common().member_type_id(*GetBooleanStructIdentifier(true));
    cst_var_BooleanStruct.detail().name("var_BooleanStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_BooleanStruct);

    CompleteStructMember cst_var_OctetStruct;
    cst_var_OctetStruct.common().member_id(memberId++);
    cst_var_OctetStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_OctetStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_OctetStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_OctetStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_OctetStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_OctetStruct.common().member_flags().IS_KEY(false);
    cst_var_OctetStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_OctetStruct.common().member_type_id(*GetOctetStructIdentifier(true));
    cst_var_OctetStruct.detail().name("var_OctetStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_OctetStruct);

    CompleteStructMember cst_var_Char8Struct;
    cst_var_Char8Struct.common().member_id(memberId++);
    cst_var_Char8Struct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_Char8Struct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_Char8Struct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_Char8Struct.common().member_flags().IS_OPTIONAL(false);
    cst_var_Char8Struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_Char8Struct.common().member_flags().IS_KEY(false);
    cst_var_Char8Struct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_Char8Struct.common().member_type_id(*GetChar8StructIdentifier(true));
    cst_var_Char8Struct.detail().name("var_Char8Struct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_Char8Struct);

    CompleteStructMember cst_var_Char16Struct;
    cst_var_Char16Struct.common().member_id(memberId++);
    cst_var_Char16Struct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_Char16Struct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_Char16Struct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_Char16Struct.common().member_flags().IS_OPTIONAL(false);
    cst_var_Char16Struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_Char16Struct.common().member_flags().IS_KEY(false);
    cst_var_Char16Struct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_Char16Struct.common().member_type_id(*GetChar16StructIdentifier(true));
    cst_var_Char16Struct.detail().name("var_Char16Struct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_Char16Struct);

    CompleteStructMember cst_var_StringStruct;
    cst_var_StringStruct.common().member_id(memberId++);
    cst_var_StringStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StringStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StringStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StringStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_StringStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StringStruct.common().member_flags().IS_KEY(false);
    cst_var_StringStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StringStruct.common().member_type_id(*GetStringStructIdentifier(true));
    cst_var_StringStruct.detail().name("var_StringStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StringStruct);

    CompleteStructMember cst_var_WStringStruct;
    cst_var_WStringStruct.common().member_id(memberId++);
    cst_var_WStringStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_WStringStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_WStringStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_WStringStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_WStringStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_WStringStruct.common().member_flags().IS_KEY(false);
    cst_var_WStringStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_WStringStruct.common().member_type_id(*GetWStringStructIdentifier(true));
    cst_var_WStringStruct.detail().name("var_WStringStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_WStringStruct);

    CompleteStructMember cst_var_EnumStruct;
    cst_var_EnumStruct.common().member_id(memberId++);
    cst_var_EnumStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_EnumStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_EnumStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_EnumStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_EnumStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_EnumStruct.common().member_flags().IS_KEY(false);
    cst_var_EnumStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_EnumStruct.common().member_type_id(*GetEnumStructIdentifier(true));
    cst_var_EnumStruct.detail().name("var_EnumStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_EnumStruct);

    CompleteStructMember cst_var_BitMaskStruct;
    cst_var_BitMaskStruct.common().member_id(memberId++);
    cst_var_BitMaskStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_BitMaskStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_BitMaskStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_BitMaskStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_BitMaskStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_BitMaskStruct.common().member_flags().IS_KEY(false);
    cst_var_BitMaskStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_BitMaskStruct.common().member_type_id(*GetBitMaskStructIdentifier(true));
    cst_var_BitMaskStruct.detail().name("var_BitMaskStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_BitMaskStruct);

    CompleteStructMember cst_var_AliasStruct;
    cst_var_AliasStruct.common().member_id(memberId++);
    cst_var_AliasStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_AliasStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_AliasStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_AliasStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_AliasStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_AliasStruct.common().member_flags().IS_KEY(false);
    cst_var_AliasStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_AliasStruct.common().member_type_id(*GetAliasStructIdentifier(true));
    cst_var_AliasStruct.detail().name("var_AliasStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_AliasStruct);

    CompleteStructMember cst_var_ShortArrayStruct;
    cst_var_ShortArrayStruct.common().member_id(memberId++);
    cst_var_ShortArrayStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ShortArrayStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ShortArrayStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ShortArrayStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_ShortArrayStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ShortArrayStruct.common().member_flags().IS_KEY(false);
    cst_var_ShortArrayStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ShortArrayStruct.common().member_type_id(*GetShortArrayStructIdentifier(true));
    cst_var_ShortArrayStruct.detail().name("var_ShortArrayStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ShortArrayStruct);

    CompleteStructMember cst_var_SequenceStruct;
    cst_var_SequenceStruct.common().member_id(memberId++);
    cst_var_SequenceStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_SequenceStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_SequenceStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_SequenceStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_SequenceStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_SequenceStruct.common().member_flags().IS_KEY(false);
    cst_var_SequenceStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_SequenceStruct.common().member_type_id(*GetSequenceStructIdentifier(true));
    cst_var_SequenceStruct.detail().name("var_SequenceStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_SequenceStruct);

    CompleteStructMember cst_var_MapStruct;
    cst_var_MapStruct.common().member_id(memberId++);
    cst_var_MapStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_MapStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_MapStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_MapStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_MapStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_MapStruct.common().member_flags().IS_KEY(false);
    cst_var_MapStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_MapStruct.common().member_type_id(*GetMapStructIdentifier(true));
    cst_var_MapStruct.detail().name("var_MapStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_MapStruct);

    CompleteStructMember cst_var_UnionStruct;
    cst_var_UnionStruct.common().member_id(memberId++);
    cst_var_UnionStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_UnionStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_UnionStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_UnionStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_UnionStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_UnionStruct.common().member_flags().IS_KEY(false);
    cst_var_UnionStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_UnionStruct.common().member_type_id(*GetUnionStructIdentifier(true));
    cst_var_UnionStruct.detail().name("var_UnionStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_UnionStruct);

    CompleteStructMember cst_var_StructureStruct;
    cst_var_StructureStruct.common().member_id(memberId++);
    cst_var_StructureStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_StructureStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_StructureStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_StructureStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_StructureStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_StructureStruct.common().member_flags().IS_KEY(false);
    cst_var_StructureStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_StructureStruct.common().member_type_id(*GetStructureStructIdentifier(true));
    cst_var_StructureStruct.detail().name("var_StructureStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_StructureStruct);

    CompleteStructMember cst_var_BitsetStruct;
    cst_var_BitsetStruct.common().member_id(memberId++);
    cst_var_BitsetStruct.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_BitsetStruct.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_BitsetStruct.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_BitsetStruct.common().member_flags().IS_OPTIONAL(false);
    cst_var_BitsetStruct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_BitsetStruct.common().member_flags().IS_KEY(false);
    cst_var_BitsetStruct.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_BitsetStruct.common().member_type_id(*GetBitsetStructIdentifier(true));
    cst_var_BitsetStruct.detail().name("var_BitsetStruct");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_BitsetStruct);

    CompleteStructMember cst_var_EmptyStructure;
    cst_var_EmptyStructure.common().member_id(memberId++);
    cst_var_EmptyStructure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_EmptyStructure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_EmptyStructure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_EmptyStructure.common().member_flags().IS_OPTIONAL(false);
    cst_var_EmptyStructure.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_EmptyStructure.common().member_flags().IS_KEY(false);
    cst_var_EmptyStructure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_EmptyStructure.common().member_type_id(*GetEmptyStructureIdentifier(true));
    cst_var_EmptyStructure.detail().name("var_EmptyStructure");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_EmptyStructure);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Structures");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Structures", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Structures", true);
}
