// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file unions.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "unions.h"
#include "unionsTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define UnionMap_max_cdr_typesize 808ULL;
#define InnerStructureHelper_max_cdr_typesize 8ULL;









#define UnionLongDouble_max_cdr_typesize 24ULL;
#define UnionDiscriminatorOctet_max_cdr_typesize 16ULL;


#define UnionBoolean_max_cdr_typesize 5ULL;
#define UnionDiscriminatorULong_max_cdr_typesize 16ULL;
#define UnionDouble_max_cdr_typesize 16ULL;
#define UnionArray_max_cdr_typesize 8ULL;
#define UnionBoundedWString_max_cdr_typesize 48ULL;

#define UnionDiscriminatorShort_max_cdr_typesize 16ULL;



#define UnionULong_max_cdr_typesize 8ULL;
#define UnionDiscriminatorEnum_max_cdr_typesize 16ULL;
#define InnerEmptyStructureHelper_max_cdr_typesize 0ULL;

#define UnionChar_max_cdr_typesize 5ULL;
#define UnionDiscriminatorUShort_max_cdr_typesize 16ULL;


#define UnionInnerEnumHelper_max_cdr_typesize 8ULL;




#define UnionInnerStructureHelper_max_cdr_typesize 12ULL;

#define UnionDiscriminatorLong_max_cdr_typesize 16ULL;





#define UnionSequence_max_cdr_typesize 208ULL;


#define UnionDiscriminatorChar_max_cdr_typesize 16ULL;

#define UnionULongLong_max_cdr_typesize 16ULL;
#define UnionLong_max_cdr_typesize 8ULL;
#define UnionBoundedString_max_cdr_typesize 19ULL;
#define UnionDiscriminatorAlias_max_cdr_typesize 16ULL;



#define UnionFloat_max_cdr_typesize 8ULL;
#define UnionOctet_max_cdr_typesize 5ULL;
#define UnionDiscriminatorWChar_max_cdr_typesize 16ULL;
#define UnionInnerUnionHelper_max_cdr_typesize 12ULL;


#define UnionInnerAliasHelper_max_cdr_typesize 8ULL;



#define UnionWChar_max_cdr_typesize 8ULL;
#define UnionDiscriminatorULongLong_max_cdr_typesize 16ULL;


#define UnionInnerBitMaskHelper_max_cdr_typesize 8ULL;
#define UnionLongLong_max_cdr_typesize 16ULL;




#define UnionString_max_cdr_typesize 264ULL;
#define UnionUShort_max_cdr_typesize 6ULL;
#define UnionShort_max_cdr_typesize 6ULL;
#define UnionWString_max_cdr_typesize 1028ULL;
#define UnionInnerBitsetHelper_max_cdr_typesize 12ULL;
#define UnionDiscriminatorLongLong_max_cdr_typesize 16ULL;



#define UnionDiscriminatorBoolean_max_cdr_typesize 16ULL;
#define UnionMap_max_key_cdr_typesize 0ULL;
#define InnerStructureHelper_max_key_cdr_typesize 0ULL;









#define UnionLongDouble_max_key_cdr_typesize 0ULL;
#define UnionDiscriminatorOctet_max_key_cdr_typesize 0ULL;


#define UnionBoolean_max_key_cdr_typesize 0ULL;
#define UnionDiscriminatorULong_max_key_cdr_typesize 0ULL;
#define UnionDouble_max_key_cdr_typesize 0ULL;
#define UnionArray_max_key_cdr_typesize 0ULL;
#define UnionBoundedWString_max_key_cdr_typesize 0ULL;

#define UnionDiscriminatorShort_max_key_cdr_typesize 0ULL;



#define UnionULong_max_key_cdr_typesize 0ULL;
#define UnionDiscriminatorEnum_max_key_cdr_typesize 0ULL;
#define InnerEmptyStructureHelper_max_key_cdr_typesize 0ULL;

#define UnionChar_max_key_cdr_typesize 0ULL;
#define UnionDiscriminatorUShort_max_key_cdr_typesize 0ULL;


#define UnionInnerEnumHelper_max_key_cdr_typesize 0ULL;




#define UnionInnerStructureHelper_max_key_cdr_typesize 0ULL;

#define UnionDiscriminatorLong_max_key_cdr_typesize 0ULL;





#define UnionSequence_max_key_cdr_typesize 0ULL;


#define UnionDiscriminatorChar_max_key_cdr_typesize 0ULL;

#define UnionULongLong_max_key_cdr_typesize 0ULL;
#define UnionLong_max_key_cdr_typesize 0ULL;
#define UnionBoundedString_max_key_cdr_typesize 0ULL;
#define UnionDiscriminatorAlias_max_key_cdr_typesize 0ULL;



#define UnionFloat_max_key_cdr_typesize 0ULL;
#define UnionOctet_max_key_cdr_typesize 0ULL;
#define UnionDiscriminatorWChar_max_key_cdr_typesize 0ULL;
#define UnionInnerUnionHelper_max_key_cdr_typesize 0ULL;


#define UnionInnerAliasHelper_max_key_cdr_typesize 0ULL;



#define UnionWChar_max_key_cdr_typesize 0ULL;
#define UnionDiscriminatorULongLong_max_key_cdr_typesize 0ULL;


#define UnionInnerBitMaskHelper_max_key_cdr_typesize 0ULL;
#define UnionLongLong_max_key_cdr_typesize 0ULL;




#define UnionString_max_key_cdr_typesize 0ULL;
#define UnionUShort_max_key_cdr_typesize 0ULL;
#define UnionShort_max_key_cdr_typesize 0ULL;
#define UnionWString_max_key_cdr_typesize 0ULL;
#define UnionInnerBitsetHelper_max_key_cdr_typesize 0ULL;
#define UnionDiscriminatorLongLong_max_key_cdr_typesize 0ULL;



#define UnionDiscriminatorBoolean_max_key_cdr_typesize 0ULL;







Union_Short::Union_Short()
{
    m__d = 0;
    // short m_a
    m_a = 0;
}

Union_Short::~Union_Short()
{
}

Union_Short::Union_Short(
        const Union_Short& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_a = x.m_a;
        break;
        default:
        break;
    }
}

Union_Short::Union_Short(
        Union_Short&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_a = x.m_a;
        break;
        default:
        break;
    }
}

Union_Short& Union_Short::operator =(
        const Union_Short& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_a = x.m_a;
        break;
        default:
        break;
    }

    return *this;
}

Union_Short& Union_Short::operator =(
        Union_Short&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_a = x.m_a;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Short::operator ==(
        const Union_Short& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 0:
            return (m_a == x.m_a);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Short::operator !=(
        const Union_Short& x) const
{
    return !(*this == x);
}

void Union_Short::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        switch(__d)
        {
            case 0:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_Short::_d() const
{
    return m__d;
}

int32_t& Union_Short::_d()
{
    return m__d;
}

void Union_Short::a(
        int16_t _a)
{
    m_a = _a;
    m__d = 0;
}

int16_t Union_Short::a() const
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_a;
}

int16_t& Union_Short::a()
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_a;
}

// TODO(Ricardo) Review
size_t Union_Short::getCdrSerializedSize(
        const Union_Short& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 0:
        current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Short::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 0:
        scdr << m_a;
        break;
        default:
        break;
    }
}

void Union_Short::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 0:
        dcdr >> m_a;
        break;
        default:
        break;
    }
}


Union_UShort::Union_UShort()
{
    m__d = 1;
    // unsigned short m_b
    m_b = 0;
}

Union_UShort::~Union_UShort()
{
}

Union_UShort::Union_UShort(
        const Union_UShort& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_b = x.m_b;
        break;
        default:
        break;
    }
}

Union_UShort::Union_UShort(
        Union_UShort&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_b = x.m_b;
        break;
        default:
        break;
    }
}

Union_UShort& Union_UShort::operator =(
        const Union_UShort& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_b = x.m_b;
        break;
        default:
        break;
    }

    return *this;
}

Union_UShort& Union_UShort::operator =(
        Union_UShort&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_b = x.m_b;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_UShort::operator ==(
        const Union_UShort& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 1:
            return (m_b == x.m_b);
            break;
        default:
        break;
    }
    return false;
}

bool Union_UShort::operator !=(
        const Union_UShort& x) const
{
    return !(*this == x);
}

void Union_UShort::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_UShort::_d() const
{
    return m__d;
}

int32_t& Union_UShort::_d()
{
    return m__d;
}

void Union_UShort::b(
        uint16_t _b)
{
    m_b = _b;
    m__d = 1;
}

uint16_t Union_UShort::b() const
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_b;
}

uint16_t& Union_UShort::b()
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_b;
}

// TODO(Ricardo) Review
size_t Union_UShort::getCdrSerializedSize(
        const Union_UShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 1:
        current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_UShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 1:
        scdr << m_b;
        break;
        default:
        break;
    }
}

void Union_UShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 1:
        dcdr >> m_b;
        break;
        default:
        break;
    }
}


Union_Long::Union_Long()
{
    m__d = 2;
    // long m_c
    m_c = 0;
}

Union_Long::~Union_Long()
{
}

Union_Long::Union_Long(
        const Union_Long& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 2:
        m_c = x.m_c;
        break;
        default:
        break;
    }
}

Union_Long::Union_Long(
        Union_Long&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 2:
        m_c = x.m_c;
        break;
        default:
        break;
    }
}

Union_Long& Union_Long::operator =(
        const Union_Long& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 2:
        m_c = x.m_c;
        break;
        default:
        break;
    }

    return *this;
}

Union_Long& Union_Long::operator =(
        Union_Long&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 2:
        m_c = x.m_c;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Long::operator ==(
        const Union_Long& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 2:
            return (m_c == x.m_c);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Long::operator !=(
        const Union_Long& x) const
{
    return !(*this == x);
}

void Union_Long::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        switch(__d)
        {
            case 2:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_Long::_d() const
{
    return m__d;
}

int32_t& Union_Long::_d()
{
    return m__d;
}

void Union_Long::c(
        int32_t _c)
{
    m_c = _c;
    m__d = 2;
}

int32_t Union_Long::c() const
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_c;
}

int32_t& Union_Long::c()
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_c;
}

// TODO(Ricardo) Review
size_t Union_Long::getCdrSerializedSize(
        const Union_Long& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 2:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Long::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 2:
        scdr << m_c;
        break;
        default:
        break;
    }
}

void Union_Long::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 2:
        dcdr >> m_c;
        break;
        default:
        break;
    }
}


Union_ULong::Union_ULong()
{
    m__d = 3;
    // unsigned long m_d
    m_d = 0;
}

Union_ULong::~Union_ULong()
{
}

Union_ULong::Union_ULong(
        const Union_ULong& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 3:
        m_d = x.m_d;
        break;
        default:
        break;
    }
}

Union_ULong::Union_ULong(
        Union_ULong&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 3:
        m_d = x.m_d;
        break;
        default:
        break;
    }
}

Union_ULong& Union_ULong::operator =(
        const Union_ULong& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 3:
        m_d = x.m_d;
        break;
        default:
        break;
    }

    return *this;
}

Union_ULong& Union_ULong::operator =(
        Union_ULong&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 3:
        m_d = x.m_d;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_ULong::operator ==(
        const Union_ULong& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 3:
            return (m_d == x.m_d);
            break;
        default:
        break;
    }
    return false;
}

bool Union_ULong::operator !=(
        const Union_ULong& x) const
{
    return !(*this == x);
}

void Union_ULong::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 3:
        switch(__d)
        {
            case 3:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_ULong::_d() const
{
    return m__d;
}

int32_t& Union_ULong::_d()
{
    return m__d;
}

void Union_ULong::d(
        uint32_t _d)
{
    m_d = _d;
    m__d = 3;
}

uint32_t Union_ULong::d() const
{
    bool b = false;

    switch(m__d)
    {
        case 3:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_d;
}

uint32_t& Union_ULong::d()
{
    bool b = false;

    switch(m__d)
    {
        case 3:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_d;
}

// TODO(Ricardo) Review
size_t Union_ULong::getCdrSerializedSize(
        const Union_ULong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 3:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_ULong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 3:
        scdr << m_d;
        break;
        default:
        break;
    }
}

void Union_ULong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 3:
        dcdr >> m_d;
        break;
        default:
        break;
    }
}


Union_LongLong::Union_LongLong()
{
    m__d = 4;
    // long long m_e
    m_e = 0;
}

Union_LongLong::~Union_LongLong()
{
}

Union_LongLong::Union_LongLong(
        const Union_LongLong& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 4:
        m_e = x.m_e;
        break;
        default:
        break;
    }
}

Union_LongLong::Union_LongLong(
        Union_LongLong&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 4:
        m_e = x.m_e;
        break;
        default:
        break;
    }
}

Union_LongLong& Union_LongLong::operator =(
        const Union_LongLong& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 4:
        m_e = x.m_e;
        break;
        default:
        break;
    }

    return *this;
}

Union_LongLong& Union_LongLong::operator =(
        Union_LongLong&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 4:
        m_e = x.m_e;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_LongLong::operator ==(
        const Union_LongLong& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 4:
            return (m_e == x.m_e);
            break;
        default:
        break;
    }
    return false;
}

bool Union_LongLong::operator !=(
        const Union_LongLong& x) const
{
    return !(*this == x);
}

void Union_LongLong::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 4:
        switch(__d)
        {
            case 4:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_LongLong::_d() const
{
    return m__d;
}

int32_t& Union_LongLong::_d()
{
    return m__d;
}

void Union_LongLong::e(
        int64_t _e)
{
    m_e = _e;
    m__d = 4;
}

int64_t Union_LongLong::e() const
{
    bool b = false;

    switch(m__d)
    {
        case 4:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_e;
}

int64_t& Union_LongLong::e()
{
    bool b = false;

    switch(m__d)
    {
        case 4:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_e;
}

// TODO(Ricardo) Review
size_t Union_LongLong::getCdrSerializedSize(
        const Union_LongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 4:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_LongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 4:
        scdr << m_e;
        break;
        default:
        break;
    }
}

void Union_LongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 4:
        dcdr >> m_e;
        break;
        default:
        break;
    }
}


Union_ULongLOng::Union_ULongLOng()
{
    m__d = 5;
    // unsigned long long m_f
    m_f = 0;
}

Union_ULongLOng::~Union_ULongLOng()
{
}

Union_ULongLOng::Union_ULongLOng(
        const Union_ULongLOng& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 5:
        m_f = x.m_f;
        break;
        default:
        break;
    }
}

Union_ULongLOng::Union_ULongLOng(
        Union_ULongLOng&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 5:
        m_f = x.m_f;
        break;
        default:
        break;
    }
}

Union_ULongLOng& Union_ULongLOng::operator =(
        const Union_ULongLOng& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 5:
        m_f = x.m_f;
        break;
        default:
        break;
    }

    return *this;
}

Union_ULongLOng& Union_ULongLOng::operator =(
        Union_ULongLOng&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 5:
        m_f = x.m_f;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_ULongLOng::operator ==(
        const Union_ULongLOng& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 5:
            return (m_f == x.m_f);
            break;
        default:
        break;
    }
    return false;
}

bool Union_ULongLOng::operator !=(
        const Union_ULongLOng& x) const
{
    return !(*this == x);
}

void Union_ULongLOng::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 5:
        switch(__d)
        {
            case 5:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_ULongLOng::_d() const
{
    return m__d;
}

int32_t& Union_ULongLOng::_d()
{
    return m__d;
}

void Union_ULongLOng::f(
        uint64_t _f)
{
    m_f = _f;
    m__d = 5;
}

uint64_t Union_ULongLOng::f() const
{
    bool b = false;

    switch(m__d)
    {
        case 5:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_f;
}

uint64_t& Union_ULongLOng::f()
{
    bool b = false;

    switch(m__d)
    {
        case 5:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_f;
}

// TODO(Ricardo) Review
size_t Union_ULongLOng::getCdrSerializedSize(
        const Union_ULongLOng& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 5:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_ULongLOng::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 5:
        scdr << m_f;
        break;
        default:
        break;
    }
}

void Union_ULongLOng::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 5:
        dcdr >> m_f;
        break;
        default:
        break;
    }
}


Union_Float::Union_Float()
{
    m__d = 6;
    // float m_g
    m_g = 0.0;
}

Union_Float::~Union_Float()
{
}

Union_Float::Union_Float(
        const Union_Float& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 6:
        m_g = x.m_g;
        break;
        default:
        break;
    }
}

Union_Float::Union_Float(
        Union_Float&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 6:
        m_g = x.m_g;
        break;
        default:
        break;
    }
}

Union_Float& Union_Float::operator =(
        const Union_Float& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 6:
        m_g = x.m_g;
        break;
        default:
        break;
    }

    return *this;
}

Union_Float& Union_Float::operator =(
        Union_Float&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 6:
        m_g = x.m_g;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Float::operator ==(
        const Union_Float& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 6:
            return (m_g == x.m_g);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Float::operator !=(
        const Union_Float& x) const
{
    return !(*this == x);
}

void Union_Float::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 6:
        switch(__d)
        {
            case 6:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_Float::_d() const
{
    return m__d;
}

int32_t& Union_Float::_d()
{
    return m__d;
}

void Union_Float::g(
        float _g)
{
    m_g = _g;
    m__d = 6;
}

float Union_Float::g() const
{
    bool b = false;

    switch(m__d)
    {
        case 6:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_g;
}

float& Union_Float::g()
{
    bool b = false;

    switch(m__d)
    {
        case 6:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_g;
}

// TODO(Ricardo) Review
size_t Union_Float::getCdrSerializedSize(
        const Union_Float& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 6:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Float::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 6:
        scdr << m_g;
        break;
        default:
        break;
    }
}

void Union_Float::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 6:
        dcdr >> m_g;
        break;
        default:
        break;
    }
}


Union_Double::Union_Double()
{
    m__d = 7;
    // double m_h
    m_h = 0.0;
}

Union_Double::~Union_Double()
{
}

Union_Double::Union_Double(
        const Union_Double& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 7:
        m_h = x.m_h;
        break;
        default:
        break;
    }
}

Union_Double::Union_Double(
        Union_Double&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 7:
        m_h = x.m_h;
        break;
        default:
        break;
    }
}

Union_Double& Union_Double::operator =(
        const Union_Double& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 7:
        m_h = x.m_h;
        break;
        default:
        break;
    }

    return *this;
}

Union_Double& Union_Double::operator =(
        Union_Double&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 7:
        m_h = x.m_h;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Double::operator ==(
        const Union_Double& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 7:
            return (m_h == x.m_h);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Double::operator !=(
        const Union_Double& x) const
{
    return !(*this == x);
}

void Union_Double::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 7:
        switch(__d)
        {
            case 7:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_Double::_d() const
{
    return m__d;
}

int32_t& Union_Double::_d()
{
    return m__d;
}

void Union_Double::h(
        double _h)
{
    m_h = _h;
    m__d = 7;
}

double Union_Double::h() const
{
    bool b = false;

    switch(m__d)
    {
        case 7:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_h;
}

double& Union_Double::h()
{
    bool b = false;

    switch(m__d)
    {
        case 7:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_h;
}

// TODO(Ricardo) Review
size_t Union_Double::getCdrSerializedSize(
        const Union_Double& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 7:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Double::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 7:
        scdr << m_h;
        break;
        default:
        break;
    }
}

void Union_Double::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 7:
        dcdr >> m_h;
        break;
        default:
        break;
    }
}


Union_LongDouble::Union_LongDouble()
{
    m__d = 8;
    // long double m_i
    m_i = 0.0;
}

Union_LongDouble::~Union_LongDouble()
{
}

Union_LongDouble::Union_LongDouble(
        const Union_LongDouble& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 8:
        m_i = x.m_i;
        break;
        default:
        break;
    }
}

Union_LongDouble::Union_LongDouble(
        Union_LongDouble&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 8:
        m_i = x.m_i;
        break;
        default:
        break;
    }
}

Union_LongDouble& Union_LongDouble::operator =(
        const Union_LongDouble& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 8:
        m_i = x.m_i;
        break;
        default:
        break;
    }

    return *this;
}

Union_LongDouble& Union_LongDouble::operator =(
        Union_LongDouble&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 8:
        m_i = x.m_i;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_LongDouble::operator ==(
        const Union_LongDouble& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 8:
            return (m_i == x.m_i);
            break;
        default:
        break;
    }
    return false;
}

bool Union_LongDouble::operator !=(
        const Union_LongDouble& x) const
{
    return !(*this == x);
}

void Union_LongDouble::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 8:
        switch(__d)
        {
            case 8:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_LongDouble::_d() const
{
    return m__d;
}

int32_t& Union_LongDouble::_d()
{
    return m__d;
}

void Union_LongDouble::i(
        long double _i)
{
    m_i = _i;
    m__d = 8;
}

long double Union_LongDouble::i() const
{
    bool b = false;

    switch(m__d)
    {
        case 8:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_i;
}

long double& Union_LongDouble::i()
{
    bool b = false;

    switch(m__d)
    {
        case 8:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_i;
}

// TODO(Ricardo) Review
size_t Union_LongDouble::getCdrSerializedSize(
        const Union_LongDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 8:
        current_alignment += 16 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8); // 128 bits, but aligned as 64

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_LongDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 8:
        scdr << m_i;
        break;
        default:
        break;
    }
}

void Union_LongDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 8:
        dcdr >> m_i;
        break;
        default:
        break;
    }
}


Union_Boolean::Union_Boolean()
{
    m__d = 9;
    // boolean m_j
    m_j = false;
}

Union_Boolean::~Union_Boolean()
{
}

Union_Boolean::Union_Boolean(
        const Union_Boolean& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 9:
        m_j = x.m_j;
        break;
        default:
        break;
    }
}

Union_Boolean::Union_Boolean(
        Union_Boolean&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 9:
        m_j = x.m_j;
        break;
        default:
        break;
    }
}

Union_Boolean& Union_Boolean::operator =(
        const Union_Boolean& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 9:
        m_j = x.m_j;
        break;
        default:
        break;
    }

    return *this;
}

Union_Boolean& Union_Boolean::operator =(
        Union_Boolean&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 9:
        m_j = x.m_j;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Boolean::operator ==(
        const Union_Boolean& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 9:
            return (m_j == x.m_j);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Boolean::operator !=(
        const Union_Boolean& x) const
{
    return !(*this == x);
}

void Union_Boolean::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 9:
        switch(__d)
        {
            case 9:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_Boolean::_d() const
{
    return m__d;
}

int32_t& Union_Boolean::_d()
{
    return m__d;
}

void Union_Boolean::j(
        bool _j)
{
    m_j = _j;
    m__d = 9;
}

bool Union_Boolean::j() const
{
    bool b = false;

    switch(m__d)
    {
        case 9:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_j;
}

bool& Union_Boolean::j()
{
    bool b = false;

    switch(m__d)
    {
        case 9:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_j;
}

// TODO(Ricardo) Review
size_t Union_Boolean::getCdrSerializedSize(
        const Union_Boolean& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 9:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Boolean::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 9:
        scdr << m_j;
        break;
        default:
        break;
    }
}

void Union_Boolean::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 9:
        dcdr >> m_j;
        break;
        default:
        break;
    }
}


Union_Octet::Union_Octet()
{
    m__d = 10;
    // octet m_k
    m_k = 0;
}

Union_Octet::~Union_Octet()
{
}

Union_Octet::Union_Octet(
        const Union_Octet& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 10:
        m_k = x.m_k;
        break;
        default:
        break;
    }
}

Union_Octet::Union_Octet(
        Union_Octet&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 10:
        m_k = x.m_k;
        break;
        default:
        break;
    }
}

Union_Octet& Union_Octet::operator =(
        const Union_Octet& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 10:
        m_k = x.m_k;
        break;
        default:
        break;
    }

    return *this;
}

Union_Octet& Union_Octet::operator =(
        Union_Octet&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 10:
        m_k = x.m_k;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Octet::operator ==(
        const Union_Octet& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 10:
            return (m_k == x.m_k);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Octet::operator !=(
        const Union_Octet& x) const
{
    return !(*this == x);
}

void Union_Octet::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 10:
        switch(__d)
        {
            case 10:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_Octet::_d() const
{
    return m__d;
}

int32_t& Union_Octet::_d()
{
    return m__d;
}

void Union_Octet::k(
        uint8_t _k)
{
    m_k = _k;
    m__d = 10;
}

uint8_t Union_Octet::k() const
{
    bool b = false;

    switch(m__d)
    {
        case 10:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_k;
}

uint8_t& Union_Octet::k()
{
    bool b = false;

    switch(m__d)
    {
        case 10:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_k;
}

// TODO(Ricardo) Review
size_t Union_Octet::getCdrSerializedSize(
        const Union_Octet& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 10:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Octet::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 10:
        scdr << m_k;
        break;
        default:
        break;
    }
}

void Union_Octet::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 10:
        dcdr >> m_k;
        break;
        default:
        break;
    }
}


Union_Char::Union_Char()
{
    m__d = 11;
    // char m_l
    m_l = 0;
}

Union_Char::~Union_Char()
{
}

Union_Char::Union_Char(
        const Union_Char& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 11:
        m_l = x.m_l;
        break;
        default:
        break;
    }
}

Union_Char::Union_Char(
        Union_Char&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 11:
        m_l = x.m_l;
        break;
        default:
        break;
    }
}

Union_Char& Union_Char::operator =(
        const Union_Char& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 11:
        m_l = x.m_l;
        break;
        default:
        break;
    }

    return *this;
}

Union_Char& Union_Char::operator =(
        Union_Char&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 11:
        m_l = x.m_l;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Char::operator ==(
        const Union_Char& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 11:
            return (m_l == x.m_l);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Char::operator !=(
        const Union_Char& x) const
{
    return !(*this == x);
}

void Union_Char::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 11:
        switch(__d)
        {
            case 11:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_Char::_d() const
{
    return m__d;
}

int32_t& Union_Char::_d()
{
    return m__d;
}

void Union_Char::l(
        char _l)
{
    m_l = _l;
    m__d = 11;
}

char Union_Char::l() const
{
    bool b = false;

    switch(m__d)
    {
        case 11:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_l;
}

char& Union_Char::l()
{
    bool b = false;

    switch(m__d)
    {
        case 11:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_l;
}

// TODO(Ricardo) Review
size_t Union_Char::getCdrSerializedSize(
        const Union_Char& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 11:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Char::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 11:
        scdr << m_l;
        break;
        default:
        break;
    }
}

void Union_Char::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 11:
        dcdr >> m_l;
        break;
        default:
        break;
    }
}


Union_WChar::Union_WChar()
{
    m__d = 12;
    // wchar m_m
    m_m = 0;
}

Union_WChar::~Union_WChar()
{
}

Union_WChar::Union_WChar(
        const Union_WChar& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 12:
        m_m = x.m_m;
        break;
        default:
        break;
    }
}

Union_WChar::Union_WChar(
        Union_WChar&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 12:
        m_m = x.m_m;
        break;
        default:
        break;
    }
}

Union_WChar& Union_WChar::operator =(
        const Union_WChar& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 12:
        m_m = x.m_m;
        break;
        default:
        break;
    }

    return *this;
}

Union_WChar& Union_WChar::operator =(
        Union_WChar&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 12:
        m_m = x.m_m;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_WChar::operator ==(
        const Union_WChar& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 12:
            return (m_m == x.m_m);
            break;
        default:
        break;
    }
    return false;
}

bool Union_WChar::operator !=(
        const Union_WChar& x) const
{
    return !(*this == x);
}

void Union_WChar::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 12:
        switch(__d)
        {
            case 12:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_WChar::_d() const
{
    return m__d;
}

int32_t& Union_WChar::_d()
{
    return m__d;
}

void Union_WChar::m(
        wchar_t _m)
{
    m_m = _m;
    m__d = 12;
}

wchar_t Union_WChar::m() const
{
    bool b = false;

    switch(m__d)
    {
        case 12:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_m;
}

wchar_t& Union_WChar::m()
{
    bool b = false;

    switch(m__d)
    {
        case 12:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_m;
}

// TODO(Ricardo) Review
size_t Union_WChar::getCdrSerializedSize(
        const Union_WChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 12:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_WChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 12:
        scdr << m_m;
        break;
        default:
        break;
    }
}

void Union_WChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 12:
        dcdr >> m_m;
        break;
        default:
        break;
    }
}


Union_String::Union_String()
{
    m__d = 13;
    // string m_n
    m_n = "";

}

Union_String::~Union_String()
{
}

Union_String::Union_String(
        const Union_String& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 13:
        m_n = x.m_n;
        break;
        default:
        break;
    }
}

Union_String::Union_String(
        Union_String&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 13:
        m_n = std::move(x.m_n);
        break;
        default:
        break;
    }
}

Union_String& Union_String::operator =(
        const Union_String& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 13:
        m_n = x.m_n;
        break;
        default:
        break;
    }

    return *this;
}

Union_String& Union_String::operator =(
        Union_String&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 13:
        m_n = std::move(x.m_n);
        break;
        default:
        break;
    }

    return *this;
}

bool Union_String::operator ==(
        const Union_String& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 13:
            return (m_n == x.m_n);
            break;
        default:
        break;
    }
    return false;
}

bool Union_String::operator !=(
        const Union_String& x) const
{
    return !(*this == x);
}

void Union_String::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 13:
        switch(__d)
        {
            case 13:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_String::_d() const
{
    return m__d;
}

int32_t& Union_String::_d()
{
    return m__d;
}

void Union_String::n(
        const std::string& _n)
{
    m_n = _n;
    m__d = 13;
}

void Union_String::n(
        std::string&& _n)
{
    m_n = std::move(_n);
    m__d = 13;
}

const std::string& Union_String::n() const
{
    bool b = false;

    switch(m__d)
    {
        case 13:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_n;
}

std::string& Union_String::n()
{
    bool b = false;

    switch(m__d)
    {
        case 13:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_n;
}

// TODO(Ricardo) Review
size_t Union_String::getCdrSerializedSize(
        const Union_String& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 13:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.n().size() + 1;
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_String::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 13:
        scdr << m_n.c_str();
        break;
        default:
        break;
    }
}

void Union_String::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 13:
        dcdr >> m_n;break;
        default:
        break;
    }
}


Union_WString::Union_WString()
{
    m__d = 14;
    // wstring m_o
    m_o = L"";

}

Union_WString::~Union_WString()
{
}

Union_WString::Union_WString(
        const Union_WString& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 14:
        m_o = x.m_o;
        break;
        default:
        break;
    }
}

Union_WString::Union_WString(
        Union_WString&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 14:
        m_o = std::move(x.m_o);
        break;
        default:
        break;
    }
}

Union_WString& Union_WString::operator =(
        const Union_WString& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 14:
        m_o = x.m_o;
        break;
        default:
        break;
    }

    return *this;
}

Union_WString& Union_WString::operator =(
        Union_WString&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 14:
        m_o = std::move(x.m_o);
        break;
        default:
        break;
    }

    return *this;
}

bool Union_WString::operator ==(
        const Union_WString& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 14:
            return (m_o == x.m_o);
            break;
        default:
        break;
    }
    return false;
}

bool Union_WString::operator !=(
        const Union_WString& x) const
{
    return !(*this == x);
}

void Union_WString::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 14:
        switch(__d)
        {
            case 14:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_WString::_d() const
{
    return m__d;
}

int32_t& Union_WString::_d()
{
    return m__d;
}

void Union_WString::o(
        const std::wstring& _o)
{
    m_o = _o;
    m__d = 14;
}

void Union_WString::o(
        std::wstring&& _o)
{
    m_o = std::move(_o);
    m__d = 14;
}

const std::wstring& Union_WString::o() const
{
    bool b = false;

    switch(m__d)
    {
        case 14:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_o;
}

std::wstring& Union_WString::o()
{
    bool b = false;

    switch(m__d)
    {
        case 14:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_o;
}

// TODO(Ricardo) Review
size_t Union_WString::getCdrSerializedSize(
        const Union_WString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 14:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.o().size()) * 4; // 32 bits
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_WString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 14:
        scdr << m_o;
        break;
        default:
        break;
    }
}

void Union_WString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 14:
        dcdr >> m_o;
        break;
        default:
        break;
    }
}


Union_BoundedString::Union_BoundedString()
{
    m__d = 13;
    // Inner_alias_bounded_string_helper m_bn
    m_bn = "";

}

Union_BoundedString::~Union_BoundedString()
{
}

Union_BoundedString::Union_BoundedString(
        const Union_BoundedString& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 13:
        m_bn = x.m_bn;
        break;
        default:
        break;
    }
}

Union_BoundedString::Union_BoundedString(
        Union_BoundedString&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 13:
        m_bn = std::move(x.m_bn);
        break;
        default:
        break;
    }
}

Union_BoundedString& Union_BoundedString::operator =(
        const Union_BoundedString& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 13:
        m_bn = x.m_bn;
        break;
        default:
        break;
    }

    return *this;
}

Union_BoundedString& Union_BoundedString::operator =(
        Union_BoundedString&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 13:
        m_bn = std::move(x.m_bn);
        break;
        default:
        break;
    }

    return *this;
}

bool Union_BoundedString::operator ==(
        const Union_BoundedString& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 13:
            return (m_bn == x.m_bn);
            break;
        default:
        break;
    }
    return false;
}

bool Union_BoundedString::operator !=(
        const Union_BoundedString& x) const
{
    return !(*this == x);
}

void Union_BoundedString::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 13:
        switch(__d)
        {
            case 13:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_BoundedString::_d() const
{
    return m__d;
}

int32_t& Union_BoundedString::_d()
{
    return m__d;
}

void Union_BoundedString::bn(
        const Inner_alias_bounded_string_helper& _bn)
{
    m_bn = _bn;
    m__d = 13;
}

void Union_BoundedString::bn(
        Inner_alias_bounded_string_helper&& _bn)
{
    m_bn = std::move(_bn);
    m__d = 13;
}

const Inner_alias_bounded_string_helper& Union_BoundedString::bn() const
{
    bool b = false;

    switch(m__d)
    {
        case 13:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_bn;
}

Inner_alias_bounded_string_helper& Union_BoundedString::bn()
{
    bool b = false;

    switch(m__d)
    {
        case 13:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_bn;
}

// TODO(Ricardo) Review
size_t Union_BoundedString::getCdrSerializedSize(
        const Union_BoundedString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 13:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.bn().size() + 1;
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_BoundedString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 13:
        scdr << m_bn.c_str();
        break;
        default:
        break;
    }
}

void Union_BoundedString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 13:
        {
            std::string aux;
            dcdr >> aux;
            m_bn = aux.c_str();
        }break;
        default:
        break;
    }
}


Union_BoundedWString::Union_BoundedWString()
{
    m__d = 14;
    // Inner_alias_bounded_wstring_helper m_bo
    m_bo = L"";

}

Union_BoundedWString::~Union_BoundedWString()
{
}

Union_BoundedWString::Union_BoundedWString(
        const Union_BoundedWString& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 14:
        m_bo = x.m_bo;
        break;
        default:
        break;
    }
}

Union_BoundedWString::Union_BoundedWString(
        Union_BoundedWString&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 14:
        m_bo = std::move(x.m_bo);
        break;
        default:
        break;
    }
}

Union_BoundedWString& Union_BoundedWString::operator =(
        const Union_BoundedWString& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 14:
        m_bo = x.m_bo;
        break;
        default:
        break;
    }

    return *this;
}

Union_BoundedWString& Union_BoundedWString::operator =(
        Union_BoundedWString&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 14:
        m_bo = std::move(x.m_bo);
        break;
        default:
        break;
    }

    return *this;
}

bool Union_BoundedWString::operator ==(
        const Union_BoundedWString& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 14:
            return (m_bo == x.m_bo);
            break;
        default:
        break;
    }
    return false;
}

bool Union_BoundedWString::operator !=(
        const Union_BoundedWString& x) const
{
    return !(*this == x);
}

void Union_BoundedWString::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 14:
        switch(__d)
        {
            case 14:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_BoundedWString::_d() const
{
    return m__d;
}

int32_t& Union_BoundedWString::_d()
{
    return m__d;
}

void Union_BoundedWString::bo(
        const Inner_alias_bounded_wstring_helper& _bo)
{
    m_bo = _bo;
    m__d = 14;
}

void Union_BoundedWString::bo(
        Inner_alias_bounded_wstring_helper&& _bo)
{
    m_bo = std::move(_bo);
    m__d = 14;
}

const Inner_alias_bounded_wstring_helper& Union_BoundedWString::bo() const
{
    bool b = false;

    switch(m__d)
    {
        case 14:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_bo;
}

Inner_alias_bounded_wstring_helper& Union_BoundedWString::bo()
{
    bool b = false;

    switch(m__d)
    {
        case 14:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_bo;
}

// TODO(Ricardo) Review
size_t Union_BoundedWString::getCdrSerializedSize(
        const Union_BoundedWString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 14:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.bo().size()) * 4; // 32 bits
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_BoundedWString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 14:
        scdr << m_bo;
        break;
        default:
        break;
    }
}

void Union_BoundedWString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 14:
        dcdr >> m_bo;
        break;
        default:
        break;
    }
}


Union_InnerEnumHelper::Union_InnerEnumHelper()
{
    m__d = 15;
    // InnerEnumHelper m_p
    m_p = ::ENUM_VALUE_1;
}

Union_InnerEnumHelper::~Union_InnerEnumHelper()
{
}

Union_InnerEnumHelper::Union_InnerEnumHelper(
        const Union_InnerEnumHelper& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 15:
        m_p = x.m_p;
        break;
        default:
        break;
    }
}

Union_InnerEnumHelper::Union_InnerEnumHelper(
        Union_InnerEnumHelper&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 15:
        m_p = x.m_p;
        break;
        default:
        break;
    }
}

Union_InnerEnumHelper& Union_InnerEnumHelper::operator =(
        const Union_InnerEnumHelper& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 15:
        m_p = x.m_p;
        break;
        default:
        break;
    }

    return *this;
}

Union_InnerEnumHelper& Union_InnerEnumHelper::operator =(
        Union_InnerEnumHelper&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 15:
        m_p = x.m_p;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_InnerEnumHelper::operator ==(
        const Union_InnerEnumHelper& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 15:
            return (m_p == x.m_p);
            break;
        default:
        break;
    }
    return false;
}

bool Union_InnerEnumHelper::operator !=(
        const Union_InnerEnumHelper& x) const
{
    return !(*this == x);
}

void Union_InnerEnumHelper::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 15:
        switch(__d)
        {
            case 15:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_InnerEnumHelper::_d() const
{
    return m__d;
}

int32_t& Union_InnerEnumHelper::_d()
{
    return m__d;
}

void Union_InnerEnumHelper::p(
        InnerEnumHelper _p)
{
    m_p = _p;
    m__d = 15;
}

InnerEnumHelper Union_InnerEnumHelper::p() const
{
    bool b = false;

    switch(m__d)
    {
        case 15:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_p;
}

InnerEnumHelper& Union_InnerEnumHelper::p()
{
    bool b = false;

    switch(m__d)
    {
        case 15:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_p;
}

// TODO(Ricardo) Review
size_t Union_InnerEnumHelper::getCdrSerializedSize(
        const Union_InnerEnumHelper& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 15:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_InnerEnumHelper::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 15:
        scdr << (uint32_t)m_p;
        break;
        default:
        break;
    }
}

void Union_InnerEnumHelper::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 15:
        {
            uint32_t enum_value = 0;
            dcdr >> enum_value;
            m_p = (InnerEnumHelper)enum_value;
        }

        break;
        default:
        break;
    }
}


Union_InnerBitMaskHelper::Union_InnerBitMaskHelper()
{
    m__d = 16;
    // InnerBitMaskHelper m_q
    m_q = static_cast<InnerBitMaskHelper>(0);
}

Union_InnerBitMaskHelper::~Union_InnerBitMaskHelper()
{
}

Union_InnerBitMaskHelper::Union_InnerBitMaskHelper(
        const Union_InnerBitMaskHelper& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 16:
        m_q = x.m_q;
        break;
        default:
        break;
    }
}

Union_InnerBitMaskHelper::Union_InnerBitMaskHelper(
        Union_InnerBitMaskHelper&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 16:
        m_q = x.m_q;
        break;
        default:
        break;
    }
}

Union_InnerBitMaskHelper& Union_InnerBitMaskHelper::operator =(
        const Union_InnerBitMaskHelper& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 16:
        m_q = x.m_q;
        break;
        default:
        break;
    }

    return *this;
}

Union_InnerBitMaskHelper& Union_InnerBitMaskHelper::operator =(
        Union_InnerBitMaskHelper&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 16:
        m_q = x.m_q;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_InnerBitMaskHelper::operator ==(
        const Union_InnerBitMaskHelper& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 16:
            return (m_q == x.m_q);
            break;
        default:
        break;
    }
    return false;
}

bool Union_InnerBitMaskHelper::operator !=(
        const Union_InnerBitMaskHelper& x) const
{
    return !(*this == x);
}

void Union_InnerBitMaskHelper::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 16:
        switch(__d)
        {
            case 16:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_InnerBitMaskHelper::_d() const
{
    return m__d;
}

int32_t& Union_InnerBitMaskHelper::_d()
{
    return m__d;
}

void Union_InnerBitMaskHelper::q(
        InnerBitMaskHelper _q)
{
    m_q = _q;
    m__d = 16;
}

InnerBitMaskHelper Union_InnerBitMaskHelper::q() const
{
    bool b = false;

    switch(m__d)
    {
        case 16:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_q;
}

InnerBitMaskHelper& Union_InnerBitMaskHelper::q()
{
    bool b = false;

    switch(m__d)
    {
        case 16:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_q;
}

// TODO(Ricardo) Review
size_t Union_InnerBitMaskHelper::getCdrSerializedSize(
        const Union_InnerBitMaskHelper& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 16:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_InnerBitMaskHelper::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 16:
        scdr << (uint32_t)m_q;
        break;
        default:
        break;
    }
}

void Union_InnerBitMaskHelper::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 16:
        {
            uint32_t bitmask_value = 0;
            dcdr >> bitmask_value;
            m_q = (InnerBitMaskHelper)bitmask_value;
        }

        break;
        default:
        break;
    }
}


Union_InnerAliasHelper::Union_InnerAliasHelper()
{
    m__d = 17;
    // InnerAliasHelper m_r
    m_r = 0;
}

Union_InnerAliasHelper::~Union_InnerAliasHelper()
{
}

Union_InnerAliasHelper::Union_InnerAliasHelper(
        const Union_InnerAliasHelper& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 17:
        m_r = x.m_r;
        break;
        default:
        break;
    }
}

Union_InnerAliasHelper::Union_InnerAliasHelper(
        Union_InnerAliasHelper&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 17:
        m_r = x.m_r;
        break;
        default:
        break;
    }
}

Union_InnerAliasHelper& Union_InnerAliasHelper::operator =(
        const Union_InnerAliasHelper& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 17:
        m_r = x.m_r;
        break;
        default:
        break;
    }

    return *this;
}

Union_InnerAliasHelper& Union_InnerAliasHelper::operator =(
        Union_InnerAliasHelper&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 17:
        m_r = x.m_r;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_InnerAliasHelper::operator ==(
        const Union_InnerAliasHelper& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 17:
            return (m_r == x.m_r);
            break;
        default:
        break;
    }
    return false;
}

bool Union_InnerAliasHelper::operator !=(
        const Union_InnerAliasHelper& x) const
{
    return !(*this == x);
}

void Union_InnerAliasHelper::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 17:
        switch(__d)
        {
            case 17:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_InnerAliasHelper::_d() const
{
    return m__d;
}

int32_t& Union_InnerAliasHelper::_d()
{
    return m__d;
}

void Union_InnerAliasHelper::r(
        InnerAliasHelper _r)
{
    m_r = _r;
    m__d = 17;
}

InnerAliasHelper Union_InnerAliasHelper::r() const
{
    bool b = false;

    switch(m__d)
    {
        case 17:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_r;
}

InnerAliasHelper& Union_InnerAliasHelper::r()
{
    bool b = false;

    switch(m__d)
    {
        case 17:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_r;
}

// TODO(Ricardo) Review
size_t Union_InnerAliasHelper::getCdrSerializedSize(
        const Union_InnerAliasHelper& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 17:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_InnerAliasHelper::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 17:
        scdr << m_r;
        break;
        default:
        break;
    }
}

void Union_InnerAliasHelper::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 17:
        dcdr >> m_r;
        break;
        default:
        break;
    }
}


Union_Array::Union_Array()
{
    m__d = 18;
    // Inner_alias_array_helper m_s
    memset(&m_s, 0, (2) * 2);

}

Union_Array::~Union_Array()
{
}

Union_Array::Union_Array(
        const Union_Array& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 18:
        m_s = x.m_s;
        break;
        default:
        break;
    }
}

Union_Array::Union_Array(
        Union_Array&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 18:
        m_s = std::move(x.m_s);
        break;
        default:
        break;
    }
}

Union_Array& Union_Array::operator =(
        const Union_Array& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 18:
        m_s = x.m_s;
        break;
        default:
        break;
    }

    return *this;
}

Union_Array& Union_Array::operator =(
        Union_Array&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 18:
        m_s = std::move(x.m_s);
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Array::operator ==(
        const Union_Array& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 18:
            return (m_s == x.m_s);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Array::operator !=(
        const Union_Array& x) const
{
    return !(*this == x);
}

void Union_Array::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 18:
        switch(__d)
        {
            case 18:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_Array::_d() const
{
    return m__d;
}

int32_t& Union_Array::_d()
{
    return m__d;
}

void Union_Array::s(
        const Inner_alias_array_helper& _s)
{
    m_s = _s;
    m__d = 18;
}

void Union_Array::s(
        Inner_alias_array_helper&& _s)
{
    m_s = std::move(_s);
    m__d = 18;
}

const Inner_alias_array_helper& Union_Array::s() const
{
    bool b = false;

    switch(m__d)
    {
        case 18:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_s;
}

Inner_alias_array_helper& Union_Array::s()
{
    bool b = false;

    switch(m__d)
    {
        case 18:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_s;
}

// TODO(Ricardo) Review
size_t Union_Array::getCdrSerializedSize(
        const Union_Array& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 18:
        current_alignment += ((2) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Array::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 18:
        scdr << m_s;

        break;
        default:
        break;
    }
}

void Union_Array::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 18:
        dcdr >> m_s;

        break;
        default:
        break;
    }
}


Union_Sequence::Union_Sequence()
{
    m__d = 19;
    // sequence<short> m_t

}

Union_Sequence::~Union_Sequence()
{
}

Union_Sequence::Union_Sequence(
        const Union_Sequence& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 19:
        m_t = x.m_t;
        break;
        default:
        break;
    }
}

Union_Sequence::Union_Sequence(
        Union_Sequence&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 19:
        m_t = std::move(x.m_t);
        break;
        default:
        break;
    }
}

Union_Sequence& Union_Sequence::operator =(
        const Union_Sequence& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 19:
        m_t = x.m_t;
        break;
        default:
        break;
    }

    return *this;
}

Union_Sequence& Union_Sequence::operator =(
        Union_Sequence&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 19:
        m_t = std::move(x.m_t);
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Sequence::operator ==(
        const Union_Sequence& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 19:
            return (m_t == x.m_t);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Sequence::operator !=(
        const Union_Sequence& x) const
{
    return !(*this == x);
}

void Union_Sequence::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 19:
        switch(__d)
        {
            case 19:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_Sequence::_d() const
{
    return m__d;
}

int32_t& Union_Sequence::_d()
{
    return m__d;
}

void Union_Sequence::t(
        const std::vector<int16_t>& _t)
{
    m_t = _t;
    m__d = 19;
}

void Union_Sequence::t(
        std::vector<int16_t>&& _t)
{
    m_t = std::move(_t);
    m__d = 19;
}

const std::vector<int16_t>& Union_Sequence::t() const
{
    bool b = false;

    switch(m__d)
    {
        case 19:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_t;
}

std::vector<int16_t>& Union_Sequence::t()
{
    bool b = false;

    switch(m__d)
    {
        case 19:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_t;
}

// TODO(Ricardo) Review
size_t Union_Sequence::getCdrSerializedSize(
        const Union_Sequence& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 19:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        if (data.t().size() > 0)
        {
            current_alignment += (data.t().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
        }


        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Sequence::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 19:
        scdr << m_t;
        break;
        default:
        break;
    }
}

void Union_Sequence::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 19:
        dcdr >> m_t;break;
        default:
        break;
    }
}


Union_Map::Union_Map()
{
    m__d = 20;
    // map<long, long> m_u

}

Union_Map::~Union_Map()
{
}

Union_Map::Union_Map(
        const Union_Map& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 20:
        m_u = x.m_u;
        break;
        default:
        break;
    }
}

Union_Map::Union_Map(
        Union_Map&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 20:
        m_u = std::move(x.m_u);
        break;
        default:
        break;
    }
}

Union_Map& Union_Map::operator =(
        const Union_Map& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 20:
        m_u = x.m_u;
        break;
        default:
        break;
    }

    return *this;
}

Union_Map& Union_Map::operator =(
        Union_Map&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 20:
        m_u = std::move(x.m_u);
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Map::operator ==(
        const Union_Map& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 20:
            return (m_u == x.m_u);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Map::operator !=(
        const Union_Map& x) const
{
    return !(*this == x);
}

void Union_Map::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 20:
        switch(__d)
        {
            case 20:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_Map::_d() const
{
    return m__d;
}

int32_t& Union_Map::_d()
{
    return m__d;
}

void Union_Map::u(
        const std::map<int32_t, int32_t>& _u)
{
    m_u = _u;
    m__d = 20;
}

void Union_Map::u(
        std::map<int32_t, int32_t>&& _u)
{
    m_u = std::move(_u);
    m__d = 20;
}

const std::map<int32_t, int32_t>& Union_Map::u() const
{
    bool b = false;

    switch(m__d)
    {
        case 20:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_u;
}

std::map<int32_t, int32_t>& Union_Map::u()
{
    bool b = false;

    switch(m__d)
    {
        case 20:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_u;
}

// TODO(Ricardo) Review
size_t Union_Map::getCdrSerializedSize(
        const Union_Map& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 20:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for(auto a : data.u())
        {
            (void)a;

                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        }
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Map::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 20:
        scdr << static_cast<uint32_t>(m_u.size());
        for (const auto& pair : m_u)
        {
            scdr << pair.first;    scdr << pair.second;}break;
        default:
        break;
    }
}

void Union_Map::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 20:

            dcdr >> m_u;
        break;
        default:
        break;
    }
}


Union_InnerUnionHelper::Union_InnerUnionHelper()
{
    m__d = 21;
    // InnerUnionHelper m_v

}

Union_InnerUnionHelper::~Union_InnerUnionHelper()
{
}

Union_InnerUnionHelper::Union_InnerUnionHelper(
        const Union_InnerUnionHelper& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 21:
        m_v = x.m_v;
        break;
        default:
        break;
    }
}

Union_InnerUnionHelper::Union_InnerUnionHelper(
        Union_InnerUnionHelper&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 21:
        m_v = std::move(x.m_v);
        break;
        default:
        break;
    }
}

Union_InnerUnionHelper& Union_InnerUnionHelper::operator =(
        const Union_InnerUnionHelper& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 21:
        m_v = x.m_v;
        break;
        default:
        break;
    }

    return *this;
}

Union_InnerUnionHelper& Union_InnerUnionHelper::operator =(
        Union_InnerUnionHelper&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 21:
        m_v = std::move(x.m_v);
        break;
        default:
        break;
    }

    return *this;
}

bool Union_InnerUnionHelper::operator ==(
        const Union_InnerUnionHelper& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 21:
            return (m_v == x.m_v);
            break;
        default:
        break;
    }
    return false;
}

bool Union_InnerUnionHelper::operator !=(
        const Union_InnerUnionHelper& x) const
{
    return !(*this == x);
}

void Union_InnerUnionHelper::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 21:
        switch(__d)
        {
            case 21:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_InnerUnionHelper::_d() const
{
    return m__d;
}

int32_t& Union_InnerUnionHelper::_d()
{
    return m__d;
}

void Union_InnerUnionHelper::v(
        const InnerUnionHelper& _v)
{
    m_v = _v;
    m__d = 21;
}

void Union_InnerUnionHelper::v(
        InnerUnionHelper&& _v)
{
    m_v = std::move(_v);
    m__d = 21;
}

const InnerUnionHelper& Union_InnerUnionHelper::v() const
{
    bool b = false;

    switch(m__d)
    {
        case 21:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_v;
}

InnerUnionHelper& Union_InnerUnionHelper::v()
{
    bool b = false;

    switch(m__d)
    {
        case 21:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_v;
}

// TODO(Ricardo) Review
size_t Union_InnerUnionHelper::getCdrSerializedSize(
        const Union_InnerUnionHelper& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 21:
        current_alignment += InnerUnionHelper::getCdrSerializedSize(data.v(), current_alignment);
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_InnerUnionHelper::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 21:
        scdr << m_v;
        break;
        default:
        break;
    }
}

void Union_InnerUnionHelper::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 21:
        dcdr >> m_v;
        break;
        default:
        break;
    }
}


Union_InnerStructureHelper::Union_InnerStructureHelper()
{
    m__d = 22;
    // InnerStructureHelper m_w

}

Union_InnerStructureHelper::~Union_InnerStructureHelper()
{
}

Union_InnerStructureHelper::Union_InnerStructureHelper(
        const Union_InnerStructureHelper& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 22:
        m_w = x.m_w;
        break;
        default:
        break;
    }
}

Union_InnerStructureHelper::Union_InnerStructureHelper(
        Union_InnerStructureHelper&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 22:
        m_w = std::move(x.m_w);
        break;
        default:
        break;
    }
}

Union_InnerStructureHelper& Union_InnerStructureHelper::operator =(
        const Union_InnerStructureHelper& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 22:
        m_w = x.m_w;
        break;
        default:
        break;
    }

    return *this;
}

Union_InnerStructureHelper& Union_InnerStructureHelper::operator =(
        Union_InnerStructureHelper&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 22:
        m_w = std::move(x.m_w);
        break;
        default:
        break;
    }

    return *this;
}

bool Union_InnerStructureHelper::operator ==(
        const Union_InnerStructureHelper& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 22:
            return (m_w == x.m_w);
            break;
        default:
        break;
    }
    return false;
}

bool Union_InnerStructureHelper::operator !=(
        const Union_InnerStructureHelper& x) const
{
    return !(*this == x);
}

void Union_InnerStructureHelper::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 22:
        switch(__d)
        {
            case 22:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_InnerStructureHelper::_d() const
{
    return m__d;
}

int32_t& Union_InnerStructureHelper::_d()
{
    return m__d;
}

void Union_InnerStructureHelper::w(
        const InnerStructureHelper& _w)
{
    m_w = _w;
    m__d = 22;
}

void Union_InnerStructureHelper::w(
        InnerStructureHelper&& _w)
{
    m_w = std::move(_w);
    m__d = 22;
}

const InnerStructureHelper& Union_InnerStructureHelper::w() const
{
    bool b = false;

    switch(m__d)
    {
        case 22:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_w;
}

InnerStructureHelper& Union_InnerStructureHelper::w()
{
    bool b = false;

    switch(m__d)
    {
        case 22:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_w;
}

// TODO(Ricardo) Review
size_t Union_InnerStructureHelper::getCdrSerializedSize(
        const Union_InnerStructureHelper& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 22:
        current_alignment += InnerStructureHelper::getCdrSerializedSize(data.w(), current_alignment);
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_InnerStructureHelper::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 22:
        scdr << m_w;
        break;
        default:
        break;
    }
}

void Union_InnerStructureHelper::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 22:
        dcdr >> m_w;
        break;
        default:
        break;
    }
}


Union_InnerBitsetHelper::Union_InnerBitsetHelper()
{
    m__d = 23;
    // InnerBitsetHelper m_x

}

Union_InnerBitsetHelper::~Union_InnerBitsetHelper()
{
}

Union_InnerBitsetHelper::Union_InnerBitsetHelper(
        const Union_InnerBitsetHelper& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 23:
        m_x = x.m_x;
        break;
        default:
        break;
    }
}

Union_InnerBitsetHelper::Union_InnerBitsetHelper(
        Union_InnerBitsetHelper&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 23:
        m_x = std::move(x.m_x);
        break;
        default:
        break;
    }
}

Union_InnerBitsetHelper& Union_InnerBitsetHelper::operator =(
        const Union_InnerBitsetHelper& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 23:
        m_x = x.m_x;
        break;
        default:
        break;
    }

    return *this;
}

Union_InnerBitsetHelper& Union_InnerBitsetHelper::operator =(
        Union_InnerBitsetHelper&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 23:
        m_x = std::move(x.m_x);
        break;
        default:
        break;
    }

    return *this;
}

bool Union_InnerBitsetHelper::operator ==(
        const Union_InnerBitsetHelper& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 23:
            return (m_x == x.m_x);
            break;
        default:
        break;
    }
    return false;
}

bool Union_InnerBitsetHelper::operator !=(
        const Union_InnerBitsetHelper& x) const
{
    return !(*this == x);
}

void Union_InnerBitsetHelper::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 23:
        switch(__d)
        {
            case 23:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_InnerBitsetHelper::_d() const
{
    return m__d;
}

int32_t& Union_InnerBitsetHelper::_d()
{
    return m__d;
}

void Union_InnerBitsetHelper::x(
        const InnerBitsetHelper& _x)
{
    m_x = _x;
    m__d = 23;
}

void Union_InnerBitsetHelper::x(
        InnerBitsetHelper&& _x)
{
    m_x = std::move(_x);
    m__d = 23;
}

const InnerBitsetHelper& Union_InnerBitsetHelper::x() const
{
    bool b = false;

    switch(m__d)
    {
        case 23:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_x;
}

InnerBitsetHelper& Union_InnerBitsetHelper::x()
{
    bool b = false;

    switch(m__d)
    {
        case 23:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_x;
}

// TODO(Ricardo) Review
size_t Union_InnerBitsetHelper::getCdrSerializedSize(
        const Union_InnerBitsetHelper& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 23:
        current_alignment += InnerBitsetHelper::getCdrSerializedSize(data.x(), current_alignment);
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_InnerBitsetHelper::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 23:
        scdr << m_x;
        break;
        default:
        break;
    }
}

void Union_InnerBitsetHelper::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 23:
        dcdr >> m_x;
        break;
        default:
        break;
    }
}


Union_Discriminator_short::Union_Discriminator_short()
{
    m__d = 1;
    // long m_first
    m_first = 0;
    // long long m_second
    m_second = 0;
}

Union_Discriminator_short::~Union_Discriminator_short()
{
}

Union_Discriminator_short::Union_Discriminator_short(
        const Union_Discriminator_short& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case -2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_short::Union_Discriminator_short(
        Union_Discriminator_short&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case -2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_short& Union_Discriminator_short::operator =(
        const Union_Discriminator_short& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case -2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

Union_Discriminator_short& Union_Discriminator_short::operator =(
        Union_Discriminator_short&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case -2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Discriminator_short::operator ==(
        const Union_Discriminator_short& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 1:
            return (m_first == x.m_first);
            break;
        case -2:
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Discriminator_short::operator !=(
        const Union_Discriminator_short& x) const
{
    return !(*this == x);
}

void Union_Discriminator_short::_d(
        int16_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
        case -2:
        switch(__d)
        {
            case -2:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int16_t Union_Discriminator_short::_d() const
{
    return m__d;
}

int16_t& Union_Discriminator_short::_d()
{
    return m__d;
}

void Union_Discriminator_short::first(
        int32_t _first)
{
    m_first = _first;
    m__d = 1;
}

int32_t Union_Discriminator_short::first() const
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& Union_Discriminator_short::first()
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}
void Union_Discriminator_short::second(
        int64_t _second)
{
    m_second = _second;
    m__d = -2;
}

int64_t Union_Discriminator_short::second() const
{
    bool b = false;

    switch(m__d)
    {
        case -2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

int64_t& Union_Discriminator_short::second()
{
    bool b = false;

    switch(m__d)
    {
        case -2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

// TODO(Ricardo) Review
size_t Union_Discriminator_short::getCdrSerializedSize(
        const Union_Discriminator_short& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    switch(data.m__d)
    {
        case 1:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case -2:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Discriminator_short::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 1:
        scdr << m_first;
        break;
        case -2:
        scdr << m_second;
        break;
        default:
        break;
    }
}

void Union_Discriminator_short::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 1:
        dcdr >> m_first;
        break;
        case -2:
        dcdr >> m_second;
        break;
        default:
        break;
    }
}


Union_Discriminator_unsigned_short::Union_Discriminator_unsigned_short()
{
    m__d = 1;
    // long m_first
    m_first = 0;
    // long long m_second
    m_second = 0;
}

Union_Discriminator_unsigned_short::~Union_Discriminator_unsigned_short()
{
}

Union_Discriminator_unsigned_short::Union_Discriminator_unsigned_short(
        const Union_Discriminator_unsigned_short& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_unsigned_short::Union_Discriminator_unsigned_short(
        Union_Discriminator_unsigned_short&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_unsigned_short& Union_Discriminator_unsigned_short::operator =(
        const Union_Discriminator_unsigned_short& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

Union_Discriminator_unsigned_short& Union_Discriminator_unsigned_short::operator =(
        Union_Discriminator_unsigned_short&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Discriminator_unsigned_short::operator ==(
        const Union_Discriminator_unsigned_short& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 1:
            return (m_first == x.m_first);
            break;
        case 2:
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Discriminator_unsigned_short::operator !=(
        const Union_Discriminator_unsigned_short& x) const
{
    return !(*this == x);
}

void Union_Discriminator_unsigned_short::_d(
        uint16_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 2:
        switch(__d)
        {
            case 2:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

uint16_t Union_Discriminator_unsigned_short::_d() const
{
    return m__d;
}

uint16_t& Union_Discriminator_unsigned_short::_d()
{
    return m__d;
}

void Union_Discriminator_unsigned_short::first(
        int32_t _first)
{
    m_first = _first;
    m__d = 1;
}

int32_t Union_Discriminator_unsigned_short::first() const
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& Union_Discriminator_unsigned_short::first()
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}
void Union_Discriminator_unsigned_short::second(
        int64_t _second)
{
    m_second = _second;
    m__d = 2;
}

int64_t Union_Discriminator_unsigned_short::second() const
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

int64_t& Union_Discriminator_unsigned_short::second()
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

// TODO(Ricardo) Review
size_t Union_Discriminator_unsigned_short::getCdrSerializedSize(
        const Union_Discriminator_unsigned_short& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    switch(data.m__d)
    {
        case 1:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 2:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Discriminator_unsigned_short::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 1:
        scdr << m_first;
        break;
        case 2:
        scdr << m_second;
        break;
        default:
        break;
    }
}

void Union_Discriminator_unsigned_short::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 1:
        dcdr >> m_first;
        break;
        case 2:
        dcdr >> m_second;
        break;
        default:
        break;
    }
}


Union_Discriminator_long::Union_Discriminator_long()
{
    m__d = 1;
    // long m_first
    m_first = 0;
    // long long m_second
    m_second = 0;
}

Union_Discriminator_long::~Union_Discriminator_long()
{
}

Union_Discriminator_long::Union_Discriminator_long(
        const Union_Discriminator_long& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case -2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_long::Union_Discriminator_long(
        Union_Discriminator_long&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case -2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_long& Union_Discriminator_long::operator =(
        const Union_Discriminator_long& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case -2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

Union_Discriminator_long& Union_Discriminator_long::operator =(
        Union_Discriminator_long&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case -2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Discriminator_long::operator ==(
        const Union_Discriminator_long& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 1:
            return (m_first == x.m_first);
            break;
        case -2:
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Discriminator_long::operator !=(
        const Union_Discriminator_long& x) const
{
    return !(*this == x);
}

void Union_Discriminator_long::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
        case -2:
        switch(__d)
        {
            case -2:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Union_Discriminator_long::_d() const
{
    return m__d;
}

int32_t& Union_Discriminator_long::_d()
{
    return m__d;
}

void Union_Discriminator_long::first(
        int32_t _first)
{
    m_first = _first;
    m__d = 1;
}

int32_t Union_Discriminator_long::first() const
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& Union_Discriminator_long::first()
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}
void Union_Discriminator_long::second(
        int64_t _second)
{
    m_second = _second;
    m__d = -2;
}

int64_t Union_Discriminator_long::second() const
{
    bool b = false;

    switch(m__d)
    {
        case -2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

int64_t& Union_Discriminator_long::second()
{
    bool b = false;

    switch(m__d)
    {
        case -2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

// TODO(Ricardo) Review
size_t Union_Discriminator_long::getCdrSerializedSize(
        const Union_Discriminator_long& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 1:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case -2:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Discriminator_long::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 1:
        scdr << m_first;
        break;
        case -2:
        scdr << m_second;
        break;
        default:
        break;
    }
}

void Union_Discriminator_long::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 1:
        dcdr >> m_first;
        break;
        case -2:
        dcdr >> m_second;
        break;
        default:
        break;
    }
}


Union_Discriminator_unsigned_long::Union_Discriminator_unsigned_long()
{
    m__d = 1;
    // long m_first
    m_first = 0;
    // long long m_second
    m_second = 0;
}

Union_Discriminator_unsigned_long::~Union_Discriminator_unsigned_long()
{
}

Union_Discriminator_unsigned_long::Union_Discriminator_unsigned_long(
        const Union_Discriminator_unsigned_long& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_unsigned_long::Union_Discriminator_unsigned_long(
        Union_Discriminator_unsigned_long&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_unsigned_long& Union_Discriminator_unsigned_long::operator =(
        const Union_Discriminator_unsigned_long& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

Union_Discriminator_unsigned_long& Union_Discriminator_unsigned_long::operator =(
        Union_Discriminator_unsigned_long&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Discriminator_unsigned_long::operator ==(
        const Union_Discriminator_unsigned_long& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 1:
            return (m_first == x.m_first);
            break;
        case 2:
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Discriminator_unsigned_long::operator !=(
        const Union_Discriminator_unsigned_long& x) const
{
    return !(*this == x);
}

void Union_Discriminator_unsigned_long::_d(
        uint32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 2:
        switch(__d)
        {
            case 2:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

uint32_t Union_Discriminator_unsigned_long::_d() const
{
    return m__d;
}

uint32_t& Union_Discriminator_unsigned_long::_d()
{
    return m__d;
}

void Union_Discriminator_unsigned_long::first(
        int32_t _first)
{
    m_first = _first;
    m__d = 1;
}

int32_t Union_Discriminator_unsigned_long::first() const
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& Union_Discriminator_unsigned_long::first()
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}
void Union_Discriminator_unsigned_long::second(
        int64_t _second)
{
    m_second = _second;
    m__d = 2;
}

int64_t Union_Discriminator_unsigned_long::second() const
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

int64_t& Union_Discriminator_unsigned_long::second()
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

// TODO(Ricardo) Review
size_t Union_Discriminator_unsigned_long::getCdrSerializedSize(
        const Union_Discriminator_unsigned_long& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 1:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 2:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Discriminator_unsigned_long::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 1:
        scdr << m_first;
        break;
        case 2:
        scdr << m_second;
        break;
        default:
        break;
    }
}

void Union_Discriminator_unsigned_long::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 1:
        dcdr >> m_first;
        break;
        case 2:
        dcdr >> m_second;
        break;
        default:
        break;
    }
}


Union_Discriminator_long_long::Union_Discriminator_long_long()
{
    m__d = 1;
    // long m_first
    m_first = 0;
    // long long m_second
    m_second = 0;
}

Union_Discriminator_long_long::~Union_Discriminator_long_long()
{
}

Union_Discriminator_long_long::Union_Discriminator_long_long(
        const Union_Discriminator_long_long& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case -2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_long_long::Union_Discriminator_long_long(
        Union_Discriminator_long_long&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case -2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_long_long& Union_Discriminator_long_long::operator =(
        const Union_Discriminator_long_long& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case -2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

Union_Discriminator_long_long& Union_Discriminator_long_long::operator =(
        Union_Discriminator_long_long&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case -2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Discriminator_long_long::operator ==(
        const Union_Discriminator_long_long& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 1:
            return (m_first == x.m_first);
            break;
        case -2:
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Discriminator_long_long::operator !=(
        const Union_Discriminator_long_long& x) const
{
    return !(*this == x);
}

void Union_Discriminator_long_long::_d(
        int64_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
        case -2:
        switch(__d)
        {
            case -2:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int64_t Union_Discriminator_long_long::_d() const
{
    return m__d;
}

int64_t& Union_Discriminator_long_long::_d()
{
    return m__d;
}

void Union_Discriminator_long_long::first(
        int32_t _first)
{
    m_first = _first;
    m__d = 1;
}

int32_t Union_Discriminator_long_long::first() const
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& Union_Discriminator_long_long::first()
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}
void Union_Discriminator_long_long::second(
        int64_t _second)
{
    m_second = _second;
    m__d = -2;
}

int64_t Union_Discriminator_long_long::second() const
{
    bool b = false;

    switch(m__d)
    {
        case -2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

int64_t& Union_Discriminator_long_long::second()
{
    bool b = false;

    switch(m__d)
    {
        case -2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

// TODO(Ricardo) Review
size_t Union_Discriminator_long_long::getCdrSerializedSize(
        const Union_Discriminator_long_long& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    switch(data.m__d)
    {
        case 1:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case -2:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Discriminator_long_long::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 1:
        scdr << m_first;
        break;
        case -2:
        scdr << m_second;
        break;
        default:
        break;
    }
}

void Union_Discriminator_long_long::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 1:
        dcdr >> m_first;
        break;
        case -2:
        dcdr >> m_second;
        break;
        default:
        break;
    }
}


Union_Discriminator_unsigned_long_long::Union_Discriminator_unsigned_long_long()
{
    m__d = 1;
    // long m_first
    m_first = 0;
    // long long m_second
    m_second = 0;
}

Union_Discriminator_unsigned_long_long::~Union_Discriminator_unsigned_long_long()
{
}

Union_Discriminator_unsigned_long_long::Union_Discriminator_unsigned_long_long(
        const Union_Discriminator_unsigned_long_long& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_unsigned_long_long::Union_Discriminator_unsigned_long_long(
        Union_Discriminator_unsigned_long_long&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_unsigned_long_long& Union_Discriminator_unsigned_long_long::operator =(
        const Union_Discriminator_unsigned_long_long& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

Union_Discriminator_unsigned_long_long& Union_Discriminator_unsigned_long_long::operator =(
        Union_Discriminator_unsigned_long_long&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Discriminator_unsigned_long_long::operator ==(
        const Union_Discriminator_unsigned_long_long& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 1:
            return (m_first == x.m_first);
            break;
        case 2:
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Discriminator_unsigned_long_long::operator !=(
        const Union_Discriminator_unsigned_long_long& x) const
{
    return !(*this == x);
}

void Union_Discriminator_unsigned_long_long::_d(
        uint64_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 2:
        switch(__d)
        {
            case 2:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

uint64_t Union_Discriminator_unsigned_long_long::_d() const
{
    return m__d;
}

uint64_t& Union_Discriminator_unsigned_long_long::_d()
{
    return m__d;
}

void Union_Discriminator_unsigned_long_long::first(
        int32_t _first)
{
    m_first = _first;
    m__d = 1;
}

int32_t Union_Discriminator_unsigned_long_long::first() const
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& Union_Discriminator_unsigned_long_long::first()
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}
void Union_Discriminator_unsigned_long_long::second(
        int64_t _second)
{
    m_second = _second;
    m__d = 2;
}

int64_t Union_Discriminator_unsigned_long_long::second() const
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

int64_t& Union_Discriminator_unsigned_long_long::second()
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

// TODO(Ricardo) Review
size_t Union_Discriminator_unsigned_long_long::getCdrSerializedSize(
        const Union_Discriminator_unsigned_long_long& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    switch(data.m__d)
    {
        case 1:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 2:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Discriminator_unsigned_long_long::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 1:
        scdr << m_first;
        break;
        case 2:
        scdr << m_second;
        break;
        default:
        break;
    }
}

void Union_Discriminator_unsigned_long_long::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 1:
        dcdr >> m_first;
        break;
        case 2:
        dcdr >> m_second;
        break;
        default:
        break;
    }
}


Union_Discriminator_boolean::Union_Discriminator_boolean()
{
    m__d = true;
    // long m_first
    m_first = 0;
    // long long m_second
    m_second = 0;
}

Union_Discriminator_boolean::~Union_Discriminator_boolean()
{
}

Union_Discriminator_boolean::Union_Discriminator_boolean(
        const Union_Discriminator_boolean& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case true:
        m_first = x.m_first;
        break;
        case false:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_boolean::Union_Discriminator_boolean(
        Union_Discriminator_boolean&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case true:
        m_first = x.m_first;
        break;
        case false:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_boolean& Union_Discriminator_boolean::operator =(
        const Union_Discriminator_boolean& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case true:
        m_first = x.m_first;
        break;
        case false:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

Union_Discriminator_boolean& Union_Discriminator_boolean::operator =(
        Union_Discriminator_boolean&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case true:
        m_first = x.m_first;
        break;
        case false:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Discriminator_boolean::operator ==(
        const Union_Discriminator_boolean& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case true:
            return (m_first == x.m_first);
            break;
        case false:
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Discriminator_boolean::operator !=(
        const Union_Discriminator_boolean& x) const
{
    return !(*this == x);
}

void Union_Discriminator_boolean::_d(
        bool __d)
{
    bool b = false;

    switch(m__d)
    {
        case true:
        switch(__d)
        {
            case true:
            b = true;
            break;
            default:
            break;
        }
        break;
        case false:
        switch(__d)
        {
            case false:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

bool Union_Discriminator_boolean::_d() const
{
    return m__d;
}

bool& Union_Discriminator_boolean::_d()
{
    return m__d;
}

void Union_Discriminator_boolean::first(
        int32_t _first)
{
    m_first = _first;
    m__d = true;
}

int32_t Union_Discriminator_boolean::first() const
{
    bool b = false;

    switch(m__d)
    {
        case true:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& Union_Discriminator_boolean::first()
{
    bool b = false;

    switch(m__d)
    {
        case true:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}
void Union_Discriminator_boolean::second(
        int64_t _second)
{
    m_second = _second;
    m__d = false;
}

int64_t Union_Discriminator_boolean::second() const
{
    bool b = false;

    switch(m__d)
    {
        case false:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

int64_t& Union_Discriminator_boolean::second()
{
    bool b = false;

    switch(m__d)
    {
        case false:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

// TODO(Ricardo) Review
size_t Union_Discriminator_boolean::getCdrSerializedSize(
        const Union_Discriminator_boolean& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case true:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case false:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Discriminator_boolean::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case true:
        scdr << m_first;
        break;
        case false:
        scdr << m_second;
        break;
        default:
        break;
    }
}

void Union_Discriminator_boolean::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case true:
        dcdr >> m_first;
        break;
        case false:
        dcdr >> m_second;
        break;
        default:
        break;
    }
}


Union_Discriminator_octet::Union_Discriminator_octet()
{
    m__d = 0;
    // long m_first
    m_first = 0;
    // long long m_second
    m_second = 0;
}

Union_Discriminator_octet::~Union_Discriminator_octet()
{
}

Union_Discriminator_octet::Union_Discriminator_octet(
        const Union_Discriminator_octet& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_first = x.m_first;
        break;
        case 1:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_octet::Union_Discriminator_octet(
        Union_Discriminator_octet&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_first = x.m_first;
        break;
        case 1:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_octet& Union_Discriminator_octet::operator =(
        const Union_Discriminator_octet& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_first = x.m_first;
        break;
        case 1:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

Union_Discriminator_octet& Union_Discriminator_octet::operator =(
        Union_Discriminator_octet&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_first = x.m_first;
        break;
        case 1:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Discriminator_octet::operator ==(
        const Union_Discriminator_octet& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 0:
            return (m_first == x.m_first);
            break;
        case 1:
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Discriminator_octet::operator !=(
        const Union_Discriminator_octet& x) const
{
    return !(*this == x);
}

void Union_Discriminator_octet::_d(
        uint8_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        switch(__d)
        {
            case 0:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

uint8_t Union_Discriminator_octet::_d() const
{
    return m__d;
}

uint8_t& Union_Discriminator_octet::_d()
{
    return m__d;
}

void Union_Discriminator_octet::first(
        int32_t _first)
{
    m_first = _first;
    m__d = 0;
}

int32_t Union_Discriminator_octet::first() const
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& Union_Discriminator_octet::first()
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}
void Union_Discriminator_octet::second(
        int64_t _second)
{
    m_second = _second;
    m__d = 1;
}

int64_t Union_Discriminator_octet::second() const
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

int64_t& Union_Discriminator_octet::second()
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

// TODO(Ricardo) Review
size_t Union_Discriminator_octet::getCdrSerializedSize(
        const Union_Discriminator_octet& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case 0:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 1:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Discriminator_octet::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 0:
        scdr << m_first;
        break;
        case 1:
        scdr << m_second;
        break;
        default:
        break;
    }
}

void Union_Discriminator_octet::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 0:
        dcdr >> m_first;
        break;
        case 1:
        dcdr >> m_second;
        break;
        default:
        break;
    }
}


Union_Discriminator_char::Union_Discriminator_char()
{
    m__d = 'a';
    // long m_first
    m_first = 0;
    // long long m_second
    m_second = 0;
}

Union_Discriminator_char::~Union_Discriminator_char()
{
}

Union_Discriminator_char::Union_Discriminator_char(
        const Union_Discriminator_char& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 'a':
        m_first = x.m_first;
        break;
        case 'b':
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_char::Union_Discriminator_char(
        Union_Discriminator_char&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 'a':
        m_first = x.m_first;
        break;
        case 'b':
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_char& Union_Discriminator_char::operator =(
        const Union_Discriminator_char& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 'a':
        m_first = x.m_first;
        break;
        case 'b':
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

Union_Discriminator_char& Union_Discriminator_char::operator =(
        Union_Discriminator_char&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 'a':
        m_first = x.m_first;
        break;
        case 'b':
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Discriminator_char::operator ==(
        const Union_Discriminator_char& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 'a':
            return (m_first == x.m_first);
            break;
        case 'b':
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Discriminator_char::operator !=(
        const Union_Discriminator_char& x) const
{
    return !(*this == x);
}

void Union_Discriminator_char::_d(
        char __d)
{
    bool b = false;

    switch(m__d)
    {
        case 'a':
        switch(__d)
        {
            case 'a':
            b = true;
            break;
            default:
            break;
        }
        break;
        case 'b':
        switch(__d)
        {
            case 'b':
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

char Union_Discriminator_char::_d() const
{
    return m__d;
}

char& Union_Discriminator_char::_d()
{
    return m__d;
}

void Union_Discriminator_char::first(
        int32_t _first)
{
    m_first = _first;
    m__d = 'a';
}

int32_t Union_Discriminator_char::first() const
{
    bool b = false;

    switch(m__d)
    {
        case 'a':
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& Union_Discriminator_char::first()
{
    bool b = false;

    switch(m__d)
    {
        case 'a':
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}
void Union_Discriminator_char::second(
        int64_t _second)
{
    m_second = _second;
    m__d = 'b';
}

int64_t Union_Discriminator_char::second() const
{
    bool b = false;

    switch(m__d)
    {
        case 'b':
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

int64_t& Union_Discriminator_char::second()
{
    bool b = false;

    switch(m__d)
    {
        case 'b':
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

// TODO(Ricardo) Review
size_t Union_Discriminator_char::getCdrSerializedSize(
        const Union_Discriminator_char& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case 'a':
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 'b':
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Discriminator_char::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 'a':
        scdr << m_first;
        break;
        case 'b':
        scdr << m_second;
        break;
        default:
        break;
    }
}

void Union_Discriminator_char::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 'a':
        dcdr >> m_first;
        break;
        case 'b':
        dcdr >> m_second;
        break;
        default:
        break;
    }
}


Union_Discriminator_wchar::Union_Discriminator_wchar()
{
    m__d = 'a';
    // long m_first
    m_first = 0;
    // long long m_second
    m_second = 0;
}

Union_Discriminator_wchar::~Union_Discriminator_wchar()
{
}

Union_Discriminator_wchar::Union_Discriminator_wchar(
        const Union_Discriminator_wchar& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 'a':
        m_first = x.m_first;
        break;
        case 'b':
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_wchar::Union_Discriminator_wchar(
        Union_Discriminator_wchar&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 'a':
        m_first = x.m_first;
        break;
        case 'b':
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_wchar& Union_Discriminator_wchar::operator =(
        const Union_Discriminator_wchar& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 'a':
        m_first = x.m_first;
        break;
        case 'b':
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

Union_Discriminator_wchar& Union_Discriminator_wchar::operator =(
        Union_Discriminator_wchar&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 'a':
        m_first = x.m_first;
        break;
        case 'b':
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Discriminator_wchar::operator ==(
        const Union_Discriminator_wchar& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 'a':
            return (m_first == x.m_first);
            break;
        case 'b':
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Discriminator_wchar::operator !=(
        const Union_Discriminator_wchar& x) const
{
    return !(*this == x);
}

void Union_Discriminator_wchar::_d(
        wchar_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 'a':
        switch(__d)
        {
            case 'a':
            b = true;
            break;
            default:
            break;
        }
        break;
        case 'b':
        switch(__d)
        {
            case 'b':
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

wchar_t Union_Discriminator_wchar::_d() const
{
    return m__d;
}

wchar_t& Union_Discriminator_wchar::_d()
{
    return m__d;
}

void Union_Discriminator_wchar::first(
        int32_t _first)
{
    m_first = _first;
    m__d = 'a';
}

int32_t Union_Discriminator_wchar::first() const
{
    bool b = false;

    switch(m__d)
    {
        case 'a':
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& Union_Discriminator_wchar::first()
{
    bool b = false;

    switch(m__d)
    {
        case 'a':
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}
void Union_Discriminator_wchar::second(
        int64_t _second)
{
    m_second = _second;
    m__d = 'b';
}

int64_t Union_Discriminator_wchar::second() const
{
    bool b = false;

    switch(m__d)
    {
        case 'b':
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

int64_t& Union_Discriminator_wchar::second()
{
    bool b = false;

    switch(m__d)
    {
        case 'b':
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

// TODO(Ricardo) Review
size_t Union_Discriminator_wchar::getCdrSerializedSize(
        const Union_Discriminator_wchar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 'a':
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 'b':
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Discriminator_wchar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 'a':
        scdr << m_first;
        break;
        case 'b':
        scdr << m_second;
        break;
        default:
        break;
    }
}

void Union_Discriminator_wchar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 'a':
        dcdr >> m_first;
        break;
        case 'b':
        dcdr >> m_second;
        break;
        default:
        break;
    }
}


Union_Discriminator_enum::Union_Discriminator_enum()
{
    m__d = ::ENUM_VALUE_1;
    // long m_first
    m_first = 0;
    // long long m_second
    m_second = 0;
}

Union_Discriminator_enum::~Union_Discriminator_enum()
{
}

Union_Discriminator_enum::Union_Discriminator_enum(
        const Union_Discriminator_enum& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case ::ENUM_VALUE_1:
        m_first = x.m_first;
        break;
        case ::ENUM_VALUE_2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_enum::Union_Discriminator_enum(
        Union_Discriminator_enum&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case ::ENUM_VALUE_1:
        m_first = x.m_first;
        break;
        case ::ENUM_VALUE_2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_enum& Union_Discriminator_enum::operator =(
        const Union_Discriminator_enum& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case ::ENUM_VALUE_1:
        m_first = x.m_first;
        break;
        case ::ENUM_VALUE_2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

Union_Discriminator_enum& Union_Discriminator_enum::operator =(
        Union_Discriminator_enum&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case ::ENUM_VALUE_1:
        m_first = x.m_first;
        break;
        case ::ENUM_VALUE_2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Discriminator_enum::operator ==(
        const Union_Discriminator_enum& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case ::ENUM_VALUE_1:
            return (m_first == x.m_first);
            break;
        case ::ENUM_VALUE_2:
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Discriminator_enum::operator !=(
        const Union_Discriminator_enum& x) const
{
    return !(*this == x);
}

void Union_Discriminator_enum::_d(
        InnerEnumHelper __d)
{
    bool b = false;

    switch(m__d)
    {
        case ::ENUM_VALUE_1:
        switch(__d)
        {
            case ::ENUM_VALUE_1:
            b = true;
            break;
            default:
            break;
        }
        break;
        case ::ENUM_VALUE_2:
        switch(__d)
        {
            case ::ENUM_VALUE_2:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

InnerEnumHelper Union_Discriminator_enum::_d() const
{
    return m__d;
}

InnerEnumHelper& Union_Discriminator_enum::_d()
{
    return m__d;
}

void Union_Discriminator_enum::first(
        int32_t _first)
{
    m_first = _first;
    m__d = ::ENUM_VALUE_1;
}

int32_t Union_Discriminator_enum::first() const
{
    bool b = false;

    switch(m__d)
    {
        case ::ENUM_VALUE_1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& Union_Discriminator_enum::first()
{
    bool b = false;

    switch(m__d)
    {
        case ::ENUM_VALUE_1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}
void Union_Discriminator_enum::second(
        int64_t _second)
{
    m_second = _second;
    m__d = ::ENUM_VALUE_2;
}

int64_t Union_Discriminator_enum::second() const
{
    bool b = false;

    switch(m__d)
    {
        case ::ENUM_VALUE_2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

int64_t& Union_Discriminator_enum::second()
{
    bool b = false;

    switch(m__d)
    {
        case ::ENUM_VALUE_2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

// TODO(Ricardo) Review
size_t Union_Discriminator_enum::getCdrSerializedSize(
        const Union_Discriminator_enum& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case ::ENUM_VALUE_1:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case ::ENUM_VALUE_2:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Discriminator_enum::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << (uint32_t)m__d;

    switch(m__d)
    {
        case ::ENUM_VALUE_1:
        scdr << m_first;
        break;
        case ::ENUM_VALUE_2:
        scdr << m_second;
        break;
        default:
        break;
    }
}

void Union_Discriminator_enum::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m__d = (InnerEnumHelper)enum_value;
    }


    switch(m__d)
    {
        case ::ENUM_VALUE_1:
        dcdr >> m_first;
        break;
        case ::ENUM_VALUE_2:
        dcdr >> m_second;
        break;
        default:
        break;
    }
}


Union_Discriminator_alias::Union_Discriminator_alias()
{
    m__d = 1;
    // long m_first
    m_first = 0;
    // long long m_second
    m_second = 0;
}

Union_Discriminator_alias::~Union_Discriminator_alias()
{
}

Union_Discriminator_alias::Union_Discriminator_alias(
        const Union_Discriminator_alias& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_alias::Union_Discriminator_alias(
        Union_Discriminator_alias&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

Union_Discriminator_alias& Union_Discriminator_alias::operator =(
        const Union_Discriminator_alias& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

Union_Discriminator_alias& Union_Discriminator_alias::operator =(
        Union_Discriminator_alias&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 1:
        m_first = x.m_first;
        break;
        case 2:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool Union_Discriminator_alias::operator ==(
        const Union_Discriminator_alias& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 1:
            return (m_first == x.m_first);
            break;
        case 2:
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool Union_Discriminator_alias::operator !=(
        const Union_Discriminator_alias& x) const
{
    return !(*this == x);
}

void Union_Discriminator_alias::_d(
        InnerAliasHelper __d)
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 2:
        switch(__d)
        {
            case 2:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

InnerAliasHelper Union_Discriminator_alias::_d() const
{
    return m__d;
}

InnerAliasHelper& Union_Discriminator_alias::_d()
{
    return m__d;
}

void Union_Discriminator_alias::first(
        int32_t _first)
{
    m_first = _first;
    m__d = 1;
}

int32_t Union_Discriminator_alias::first() const
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& Union_Discriminator_alias::first()
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}
void Union_Discriminator_alias::second(
        int64_t _second)
{
    m_second = _second;
    m__d = 2;
}

int64_t Union_Discriminator_alias::second() const
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

int64_t& Union_Discriminator_alias::second()
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

// TODO(Ricardo) Review
size_t Union_Discriminator_alias::getCdrSerializedSize(
        const Union_Discriminator_alias& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 1:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 2:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Union_Discriminator_alias::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 1:
        scdr << m_first;
        break;
        case 2:
        scdr << m_second;
        break;
        default:
        break;
    }
}

void Union_Discriminator_alias::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 1:
        dcdr >> m_first;
        break;
        case 2:
        dcdr >> m_second;
        break;
        default:
        break;
    }
}


UnionShort::UnionShort()
{
    // Union_Short m_var_union_short


    // Just to register all known types
    registerunionsTypes();
}

UnionShort::~UnionShort()
{
}

UnionShort::UnionShort(
        const UnionShort& x)
{
    m_var_union_short = x.m_var_union_short;
}

UnionShort::UnionShort(
        UnionShort&& x) noexcept 
{
    m_var_union_short = std::move(x.m_var_union_short);
}

UnionShort& UnionShort::operator =(
        const UnionShort& x)
{

    m_var_union_short = x.m_var_union_short;

    return *this;
}

UnionShort& UnionShort::operator =(
        UnionShort&& x) noexcept
{

    m_var_union_short = std::move(x.m_var_union_short);

    return *this;
}

bool UnionShort::operator ==(
        const UnionShort& x) const
{

    return (m_var_union_short == x.m_var_union_short);
}

bool UnionShort::operator !=(
        const UnionShort& x) const
{
    return !(*this == x);
}

size_t UnionShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionShort_max_cdr_typesize;
}

size_t UnionShort::getCdrSerializedSize(
        const UnionShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Short::getCdrSerializedSize(data.var_union_short(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_short;
}

void UnionShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_short;
}

/*!
 * @brief This function copies the value in member var_union_short
 * @param _var_union_short New value to be copied in member var_union_short
 */
void UnionShort::var_union_short(
        const Union_Short& _var_union_short)
{
    m_var_union_short = _var_union_short;
}

/*!
 * @brief This function moves the value in member var_union_short
 * @param _var_union_short New value to be moved in member var_union_short
 */
void UnionShort::var_union_short(
        Union_Short&& _var_union_short)
{
    m_var_union_short = std::move(_var_union_short);
}

/*!
 * @brief This function returns a constant reference to member var_union_short
 * @return Constant reference to member var_union_short
 */
const Union_Short& UnionShort::var_union_short() const
{
    return m_var_union_short;
}

/*!
 * @brief This function returns a reference to member var_union_short
 * @return Reference to member var_union_short
 */
Union_Short& UnionShort::var_union_short()
{
    return m_var_union_short;
}


size_t UnionShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionShort_max_key_cdr_typesize;
}

bool UnionShort::isKeyDefined()
{
    return false;
}

void UnionShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionUShort::UnionUShort()
{
    // Union_UShort m_var_union_ushort


    // Just to register all known types
    registerunionsTypes();
}

UnionUShort::~UnionUShort()
{
}

UnionUShort::UnionUShort(
        const UnionUShort& x)
{
    m_var_union_ushort = x.m_var_union_ushort;
}

UnionUShort::UnionUShort(
        UnionUShort&& x) noexcept 
{
    m_var_union_ushort = std::move(x.m_var_union_ushort);
}

UnionUShort& UnionUShort::operator =(
        const UnionUShort& x)
{

    m_var_union_ushort = x.m_var_union_ushort;

    return *this;
}

UnionUShort& UnionUShort::operator =(
        UnionUShort&& x) noexcept
{

    m_var_union_ushort = std::move(x.m_var_union_ushort);

    return *this;
}

bool UnionUShort::operator ==(
        const UnionUShort& x) const
{

    return (m_var_union_ushort == x.m_var_union_ushort);
}

bool UnionUShort::operator !=(
        const UnionUShort& x) const
{
    return !(*this == x);
}

size_t UnionUShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionUShort_max_cdr_typesize;
}

size_t UnionUShort::getCdrSerializedSize(
        const UnionUShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_UShort::getCdrSerializedSize(data.var_union_ushort(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionUShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_ushort;
}

void UnionUShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_ushort;
}

/*!
 * @brief This function copies the value in member var_union_ushort
 * @param _var_union_ushort New value to be copied in member var_union_ushort
 */
void UnionUShort::var_union_ushort(
        const Union_UShort& _var_union_ushort)
{
    m_var_union_ushort = _var_union_ushort;
}

/*!
 * @brief This function moves the value in member var_union_ushort
 * @param _var_union_ushort New value to be moved in member var_union_ushort
 */
void UnionUShort::var_union_ushort(
        Union_UShort&& _var_union_ushort)
{
    m_var_union_ushort = std::move(_var_union_ushort);
}

/*!
 * @brief This function returns a constant reference to member var_union_ushort
 * @return Constant reference to member var_union_ushort
 */
const Union_UShort& UnionUShort::var_union_ushort() const
{
    return m_var_union_ushort;
}

/*!
 * @brief This function returns a reference to member var_union_ushort
 * @return Reference to member var_union_ushort
 */
Union_UShort& UnionUShort::var_union_ushort()
{
    return m_var_union_ushort;
}


size_t UnionUShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionUShort_max_key_cdr_typesize;
}

bool UnionUShort::isKeyDefined()
{
    return false;
}

void UnionUShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionLong::UnionLong()
{
    // Union_Long m_var_union_long


    // Just to register all known types
    registerunionsTypes();
}

UnionLong::~UnionLong()
{
}

UnionLong::UnionLong(
        const UnionLong& x)
{
    m_var_union_long = x.m_var_union_long;
}

UnionLong::UnionLong(
        UnionLong&& x) noexcept 
{
    m_var_union_long = std::move(x.m_var_union_long);
}

UnionLong& UnionLong::operator =(
        const UnionLong& x)
{

    m_var_union_long = x.m_var_union_long;

    return *this;
}

UnionLong& UnionLong::operator =(
        UnionLong&& x) noexcept
{

    m_var_union_long = std::move(x.m_var_union_long);

    return *this;
}

bool UnionLong::operator ==(
        const UnionLong& x) const
{

    return (m_var_union_long == x.m_var_union_long);
}

bool UnionLong::operator !=(
        const UnionLong& x) const
{
    return !(*this == x);
}

size_t UnionLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionLong_max_cdr_typesize;
}

size_t UnionLong::getCdrSerializedSize(
        const UnionLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Long::getCdrSerializedSize(data.var_union_long(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_long;
}

void UnionLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_long;
}

/*!
 * @brief This function copies the value in member var_union_long
 * @param _var_union_long New value to be copied in member var_union_long
 */
void UnionLong::var_union_long(
        const Union_Long& _var_union_long)
{
    m_var_union_long = _var_union_long;
}

/*!
 * @brief This function moves the value in member var_union_long
 * @param _var_union_long New value to be moved in member var_union_long
 */
void UnionLong::var_union_long(
        Union_Long&& _var_union_long)
{
    m_var_union_long = std::move(_var_union_long);
}

/*!
 * @brief This function returns a constant reference to member var_union_long
 * @return Constant reference to member var_union_long
 */
const Union_Long& UnionLong::var_union_long() const
{
    return m_var_union_long;
}

/*!
 * @brief This function returns a reference to member var_union_long
 * @return Reference to member var_union_long
 */
Union_Long& UnionLong::var_union_long()
{
    return m_var_union_long;
}


size_t UnionLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionLong_max_key_cdr_typesize;
}

bool UnionLong::isKeyDefined()
{
    return false;
}

void UnionLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionULong::UnionULong()
{
    // Union_ULong m_var_union_ulong


    // Just to register all known types
    registerunionsTypes();
}

UnionULong::~UnionULong()
{
}

UnionULong::UnionULong(
        const UnionULong& x)
{
    m_var_union_ulong = x.m_var_union_ulong;
}

UnionULong::UnionULong(
        UnionULong&& x) noexcept 
{
    m_var_union_ulong = std::move(x.m_var_union_ulong);
}

UnionULong& UnionULong::operator =(
        const UnionULong& x)
{

    m_var_union_ulong = x.m_var_union_ulong;

    return *this;
}

UnionULong& UnionULong::operator =(
        UnionULong&& x) noexcept
{

    m_var_union_ulong = std::move(x.m_var_union_ulong);

    return *this;
}

bool UnionULong::operator ==(
        const UnionULong& x) const
{

    return (m_var_union_ulong == x.m_var_union_ulong);
}

bool UnionULong::operator !=(
        const UnionULong& x) const
{
    return !(*this == x);
}

size_t UnionULong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionULong_max_cdr_typesize;
}

size_t UnionULong::getCdrSerializedSize(
        const UnionULong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_ULong::getCdrSerializedSize(data.var_union_ulong(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionULong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_ulong;
}

void UnionULong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_ulong;
}

/*!
 * @brief This function copies the value in member var_union_ulong
 * @param _var_union_ulong New value to be copied in member var_union_ulong
 */
void UnionULong::var_union_ulong(
        const Union_ULong& _var_union_ulong)
{
    m_var_union_ulong = _var_union_ulong;
}

/*!
 * @brief This function moves the value in member var_union_ulong
 * @param _var_union_ulong New value to be moved in member var_union_ulong
 */
void UnionULong::var_union_ulong(
        Union_ULong&& _var_union_ulong)
{
    m_var_union_ulong = std::move(_var_union_ulong);
}

/*!
 * @brief This function returns a constant reference to member var_union_ulong
 * @return Constant reference to member var_union_ulong
 */
const Union_ULong& UnionULong::var_union_ulong() const
{
    return m_var_union_ulong;
}

/*!
 * @brief This function returns a reference to member var_union_ulong
 * @return Reference to member var_union_ulong
 */
Union_ULong& UnionULong::var_union_ulong()
{
    return m_var_union_ulong;
}


size_t UnionULong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionULong_max_key_cdr_typesize;
}

bool UnionULong::isKeyDefined()
{
    return false;
}

void UnionULong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionLongLong::UnionLongLong()
{
    // Union_LongLong m_var_union_long_long


    // Just to register all known types
    registerunionsTypes();
}

UnionLongLong::~UnionLongLong()
{
}

UnionLongLong::UnionLongLong(
        const UnionLongLong& x)
{
    m_var_union_long_long = x.m_var_union_long_long;
}

UnionLongLong::UnionLongLong(
        UnionLongLong&& x) noexcept 
{
    m_var_union_long_long = std::move(x.m_var_union_long_long);
}

UnionLongLong& UnionLongLong::operator =(
        const UnionLongLong& x)
{

    m_var_union_long_long = x.m_var_union_long_long;

    return *this;
}

UnionLongLong& UnionLongLong::operator =(
        UnionLongLong&& x) noexcept
{

    m_var_union_long_long = std::move(x.m_var_union_long_long);

    return *this;
}

bool UnionLongLong::operator ==(
        const UnionLongLong& x) const
{

    return (m_var_union_long_long == x.m_var_union_long_long);
}

bool UnionLongLong::operator !=(
        const UnionLongLong& x) const
{
    return !(*this == x);
}

size_t UnionLongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionLongLong_max_cdr_typesize;
}

size_t UnionLongLong::getCdrSerializedSize(
        const UnionLongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_LongLong::getCdrSerializedSize(data.var_union_long_long(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionLongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_long_long;
}

void UnionLongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_long_long;
}

/*!
 * @brief This function copies the value in member var_union_long_long
 * @param _var_union_long_long New value to be copied in member var_union_long_long
 */
void UnionLongLong::var_union_long_long(
        const Union_LongLong& _var_union_long_long)
{
    m_var_union_long_long = _var_union_long_long;
}

/*!
 * @brief This function moves the value in member var_union_long_long
 * @param _var_union_long_long New value to be moved in member var_union_long_long
 */
void UnionLongLong::var_union_long_long(
        Union_LongLong&& _var_union_long_long)
{
    m_var_union_long_long = std::move(_var_union_long_long);
}

/*!
 * @brief This function returns a constant reference to member var_union_long_long
 * @return Constant reference to member var_union_long_long
 */
const Union_LongLong& UnionLongLong::var_union_long_long() const
{
    return m_var_union_long_long;
}

/*!
 * @brief This function returns a reference to member var_union_long_long
 * @return Reference to member var_union_long_long
 */
Union_LongLong& UnionLongLong::var_union_long_long()
{
    return m_var_union_long_long;
}


size_t UnionLongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionLongLong_max_key_cdr_typesize;
}

bool UnionLongLong::isKeyDefined()
{
    return false;
}

void UnionLongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionULongLong::UnionULongLong()
{
    // Union_ULongLOng m_var_union_ulong_long


    // Just to register all known types
    registerunionsTypes();
}

UnionULongLong::~UnionULongLong()
{
}

UnionULongLong::UnionULongLong(
        const UnionULongLong& x)
{
    m_var_union_ulong_long = x.m_var_union_ulong_long;
}

UnionULongLong::UnionULongLong(
        UnionULongLong&& x) noexcept 
{
    m_var_union_ulong_long = std::move(x.m_var_union_ulong_long);
}

UnionULongLong& UnionULongLong::operator =(
        const UnionULongLong& x)
{

    m_var_union_ulong_long = x.m_var_union_ulong_long;

    return *this;
}

UnionULongLong& UnionULongLong::operator =(
        UnionULongLong&& x) noexcept
{

    m_var_union_ulong_long = std::move(x.m_var_union_ulong_long);

    return *this;
}

bool UnionULongLong::operator ==(
        const UnionULongLong& x) const
{

    return (m_var_union_ulong_long == x.m_var_union_ulong_long);
}

bool UnionULongLong::operator !=(
        const UnionULongLong& x) const
{
    return !(*this == x);
}

size_t UnionULongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionULongLong_max_cdr_typesize;
}

size_t UnionULongLong::getCdrSerializedSize(
        const UnionULongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_ULongLOng::getCdrSerializedSize(data.var_union_ulong_long(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionULongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_ulong_long;
}

void UnionULongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_ulong_long;
}

/*!
 * @brief This function copies the value in member var_union_ulong_long
 * @param _var_union_ulong_long New value to be copied in member var_union_ulong_long
 */
void UnionULongLong::var_union_ulong_long(
        const Union_ULongLOng& _var_union_ulong_long)
{
    m_var_union_ulong_long = _var_union_ulong_long;
}

/*!
 * @brief This function moves the value in member var_union_ulong_long
 * @param _var_union_ulong_long New value to be moved in member var_union_ulong_long
 */
void UnionULongLong::var_union_ulong_long(
        Union_ULongLOng&& _var_union_ulong_long)
{
    m_var_union_ulong_long = std::move(_var_union_ulong_long);
}

/*!
 * @brief This function returns a constant reference to member var_union_ulong_long
 * @return Constant reference to member var_union_ulong_long
 */
const Union_ULongLOng& UnionULongLong::var_union_ulong_long() const
{
    return m_var_union_ulong_long;
}

/*!
 * @brief This function returns a reference to member var_union_ulong_long
 * @return Reference to member var_union_ulong_long
 */
Union_ULongLOng& UnionULongLong::var_union_ulong_long()
{
    return m_var_union_ulong_long;
}


size_t UnionULongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionULongLong_max_key_cdr_typesize;
}

bool UnionULongLong::isKeyDefined()
{
    return false;
}

void UnionULongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionFloat::UnionFloat()
{
    // Union_Float m_var_union_float


    // Just to register all known types
    registerunionsTypes();
}

UnionFloat::~UnionFloat()
{
}

UnionFloat::UnionFloat(
        const UnionFloat& x)
{
    m_var_union_float = x.m_var_union_float;
}

UnionFloat::UnionFloat(
        UnionFloat&& x) noexcept 
{
    m_var_union_float = std::move(x.m_var_union_float);
}

UnionFloat& UnionFloat::operator =(
        const UnionFloat& x)
{

    m_var_union_float = x.m_var_union_float;

    return *this;
}

UnionFloat& UnionFloat::operator =(
        UnionFloat&& x) noexcept
{

    m_var_union_float = std::move(x.m_var_union_float);

    return *this;
}

bool UnionFloat::operator ==(
        const UnionFloat& x) const
{

    return (m_var_union_float == x.m_var_union_float);
}

bool UnionFloat::operator !=(
        const UnionFloat& x) const
{
    return !(*this == x);
}

size_t UnionFloat::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionFloat_max_cdr_typesize;
}

size_t UnionFloat::getCdrSerializedSize(
        const UnionFloat& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Float::getCdrSerializedSize(data.var_union_float(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionFloat::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_float;
}

void UnionFloat::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_float;
}

/*!
 * @brief This function copies the value in member var_union_float
 * @param _var_union_float New value to be copied in member var_union_float
 */
void UnionFloat::var_union_float(
        const Union_Float& _var_union_float)
{
    m_var_union_float = _var_union_float;
}

/*!
 * @brief This function moves the value in member var_union_float
 * @param _var_union_float New value to be moved in member var_union_float
 */
void UnionFloat::var_union_float(
        Union_Float&& _var_union_float)
{
    m_var_union_float = std::move(_var_union_float);
}

/*!
 * @brief This function returns a constant reference to member var_union_float
 * @return Constant reference to member var_union_float
 */
const Union_Float& UnionFloat::var_union_float() const
{
    return m_var_union_float;
}

/*!
 * @brief This function returns a reference to member var_union_float
 * @return Reference to member var_union_float
 */
Union_Float& UnionFloat::var_union_float()
{
    return m_var_union_float;
}


size_t UnionFloat::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionFloat_max_key_cdr_typesize;
}

bool UnionFloat::isKeyDefined()
{
    return false;
}

void UnionFloat::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionDouble::UnionDouble()
{
    // Union_Double m_var_union_double


    // Just to register all known types
    registerunionsTypes();
}

UnionDouble::~UnionDouble()
{
}

UnionDouble::UnionDouble(
        const UnionDouble& x)
{
    m_var_union_double = x.m_var_union_double;
}

UnionDouble::UnionDouble(
        UnionDouble&& x) noexcept 
{
    m_var_union_double = std::move(x.m_var_union_double);
}

UnionDouble& UnionDouble::operator =(
        const UnionDouble& x)
{

    m_var_union_double = x.m_var_union_double;

    return *this;
}

UnionDouble& UnionDouble::operator =(
        UnionDouble&& x) noexcept
{

    m_var_union_double = std::move(x.m_var_union_double);

    return *this;
}

bool UnionDouble::operator ==(
        const UnionDouble& x) const
{

    return (m_var_union_double == x.m_var_union_double);
}

bool UnionDouble::operator !=(
        const UnionDouble& x) const
{
    return !(*this == x);
}

size_t UnionDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDouble_max_cdr_typesize;
}

size_t UnionDouble::getCdrSerializedSize(
        const UnionDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Double::getCdrSerializedSize(data.var_union_double(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_double;
}

void UnionDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_double;
}

/*!
 * @brief This function copies the value in member var_union_double
 * @param _var_union_double New value to be copied in member var_union_double
 */
void UnionDouble::var_union_double(
        const Union_Double& _var_union_double)
{
    m_var_union_double = _var_union_double;
}

/*!
 * @brief This function moves the value in member var_union_double
 * @param _var_union_double New value to be moved in member var_union_double
 */
void UnionDouble::var_union_double(
        Union_Double&& _var_union_double)
{
    m_var_union_double = std::move(_var_union_double);
}

/*!
 * @brief This function returns a constant reference to member var_union_double
 * @return Constant reference to member var_union_double
 */
const Union_Double& UnionDouble::var_union_double() const
{
    return m_var_union_double;
}

/*!
 * @brief This function returns a reference to member var_union_double
 * @return Reference to member var_union_double
 */
Union_Double& UnionDouble::var_union_double()
{
    return m_var_union_double;
}


size_t UnionDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDouble_max_key_cdr_typesize;
}

bool UnionDouble::isKeyDefined()
{
    return false;
}

void UnionDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionLongDouble::UnionLongDouble()
{
    // Union_LongDouble m_var_union_long_double


    // Just to register all known types
    registerunionsTypes();
}

UnionLongDouble::~UnionLongDouble()
{
}

UnionLongDouble::UnionLongDouble(
        const UnionLongDouble& x)
{
    m_var_union_long_double = x.m_var_union_long_double;
}

UnionLongDouble::UnionLongDouble(
        UnionLongDouble&& x) noexcept 
{
    m_var_union_long_double = std::move(x.m_var_union_long_double);
}

UnionLongDouble& UnionLongDouble::operator =(
        const UnionLongDouble& x)
{

    m_var_union_long_double = x.m_var_union_long_double;

    return *this;
}

UnionLongDouble& UnionLongDouble::operator =(
        UnionLongDouble&& x) noexcept
{

    m_var_union_long_double = std::move(x.m_var_union_long_double);

    return *this;
}

bool UnionLongDouble::operator ==(
        const UnionLongDouble& x) const
{

    return (m_var_union_long_double == x.m_var_union_long_double);
}

bool UnionLongDouble::operator !=(
        const UnionLongDouble& x) const
{
    return !(*this == x);
}

size_t UnionLongDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionLongDouble_max_cdr_typesize;
}

size_t UnionLongDouble::getCdrSerializedSize(
        const UnionLongDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_LongDouble::getCdrSerializedSize(data.var_union_long_double(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionLongDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_long_double;
}

void UnionLongDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_long_double;
}

/*!
 * @brief This function copies the value in member var_union_long_double
 * @param _var_union_long_double New value to be copied in member var_union_long_double
 */
void UnionLongDouble::var_union_long_double(
        const Union_LongDouble& _var_union_long_double)
{
    m_var_union_long_double = _var_union_long_double;
}

/*!
 * @brief This function moves the value in member var_union_long_double
 * @param _var_union_long_double New value to be moved in member var_union_long_double
 */
void UnionLongDouble::var_union_long_double(
        Union_LongDouble&& _var_union_long_double)
{
    m_var_union_long_double = std::move(_var_union_long_double);
}

/*!
 * @brief This function returns a constant reference to member var_union_long_double
 * @return Constant reference to member var_union_long_double
 */
const Union_LongDouble& UnionLongDouble::var_union_long_double() const
{
    return m_var_union_long_double;
}

/*!
 * @brief This function returns a reference to member var_union_long_double
 * @return Reference to member var_union_long_double
 */
Union_LongDouble& UnionLongDouble::var_union_long_double()
{
    return m_var_union_long_double;
}


size_t UnionLongDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionLongDouble_max_key_cdr_typesize;
}

bool UnionLongDouble::isKeyDefined()
{
    return false;
}

void UnionLongDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionBoolean::UnionBoolean()
{
    // Union_Boolean m_var_union_boolean


    // Just to register all known types
    registerunionsTypes();
}

UnionBoolean::~UnionBoolean()
{
}

UnionBoolean::UnionBoolean(
        const UnionBoolean& x)
{
    m_var_union_boolean = x.m_var_union_boolean;
}

UnionBoolean::UnionBoolean(
        UnionBoolean&& x) noexcept 
{
    m_var_union_boolean = std::move(x.m_var_union_boolean);
}

UnionBoolean& UnionBoolean::operator =(
        const UnionBoolean& x)
{

    m_var_union_boolean = x.m_var_union_boolean;

    return *this;
}

UnionBoolean& UnionBoolean::operator =(
        UnionBoolean&& x) noexcept
{

    m_var_union_boolean = std::move(x.m_var_union_boolean);

    return *this;
}

bool UnionBoolean::operator ==(
        const UnionBoolean& x) const
{

    return (m_var_union_boolean == x.m_var_union_boolean);
}

bool UnionBoolean::operator !=(
        const UnionBoolean& x) const
{
    return !(*this == x);
}

size_t UnionBoolean::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionBoolean_max_cdr_typesize;
}

size_t UnionBoolean::getCdrSerializedSize(
        const UnionBoolean& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Boolean::getCdrSerializedSize(data.var_union_boolean(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionBoolean::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_boolean;
}

void UnionBoolean::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_boolean;
}

/*!
 * @brief This function copies the value in member var_union_boolean
 * @param _var_union_boolean New value to be copied in member var_union_boolean
 */
void UnionBoolean::var_union_boolean(
        const Union_Boolean& _var_union_boolean)
{
    m_var_union_boolean = _var_union_boolean;
}

/*!
 * @brief This function moves the value in member var_union_boolean
 * @param _var_union_boolean New value to be moved in member var_union_boolean
 */
void UnionBoolean::var_union_boolean(
        Union_Boolean&& _var_union_boolean)
{
    m_var_union_boolean = std::move(_var_union_boolean);
}

/*!
 * @brief This function returns a constant reference to member var_union_boolean
 * @return Constant reference to member var_union_boolean
 */
const Union_Boolean& UnionBoolean::var_union_boolean() const
{
    return m_var_union_boolean;
}

/*!
 * @brief This function returns a reference to member var_union_boolean
 * @return Reference to member var_union_boolean
 */
Union_Boolean& UnionBoolean::var_union_boolean()
{
    return m_var_union_boolean;
}


size_t UnionBoolean::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionBoolean_max_key_cdr_typesize;
}

bool UnionBoolean::isKeyDefined()
{
    return false;
}

void UnionBoolean::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionOctet::UnionOctet()
{
    // Union_Octet m_var_union_octet


    // Just to register all known types
    registerunionsTypes();
}

UnionOctet::~UnionOctet()
{
}

UnionOctet::UnionOctet(
        const UnionOctet& x)
{
    m_var_union_octet = x.m_var_union_octet;
}

UnionOctet::UnionOctet(
        UnionOctet&& x) noexcept 
{
    m_var_union_octet = std::move(x.m_var_union_octet);
}

UnionOctet& UnionOctet::operator =(
        const UnionOctet& x)
{

    m_var_union_octet = x.m_var_union_octet;

    return *this;
}

UnionOctet& UnionOctet::operator =(
        UnionOctet&& x) noexcept
{

    m_var_union_octet = std::move(x.m_var_union_octet);

    return *this;
}

bool UnionOctet::operator ==(
        const UnionOctet& x) const
{

    return (m_var_union_octet == x.m_var_union_octet);
}

bool UnionOctet::operator !=(
        const UnionOctet& x) const
{
    return !(*this == x);
}

size_t UnionOctet::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionOctet_max_cdr_typesize;
}

size_t UnionOctet::getCdrSerializedSize(
        const UnionOctet& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Octet::getCdrSerializedSize(data.var_union_octet(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionOctet::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_octet;
}

void UnionOctet::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_octet;
}

/*!
 * @brief This function copies the value in member var_union_octet
 * @param _var_union_octet New value to be copied in member var_union_octet
 */
void UnionOctet::var_union_octet(
        const Union_Octet& _var_union_octet)
{
    m_var_union_octet = _var_union_octet;
}

/*!
 * @brief This function moves the value in member var_union_octet
 * @param _var_union_octet New value to be moved in member var_union_octet
 */
void UnionOctet::var_union_octet(
        Union_Octet&& _var_union_octet)
{
    m_var_union_octet = std::move(_var_union_octet);
}

/*!
 * @brief This function returns a constant reference to member var_union_octet
 * @return Constant reference to member var_union_octet
 */
const Union_Octet& UnionOctet::var_union_octet() const
{
    return m_var_union_octet;
}

/*!
 * @brief This function returns a reference to member var_union_octet
 * @return Reference to member var_union_octet
 */
Union_Octet& UnionOctet::var_union_octet()
{
    return m_var_union_octet;
}


size_t UnionOctet::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionOctet_max_key_cdr_typesize;
}

bool UnionOctet::isKeyDefined()
{
    return false;
}

void UnionOctet::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionChar::UnionChar()
{
    // Union_Char m_var_union_char


    // Just to register all known types
    registerunionsTypes();
}

UnionChar::~UnionChar()
{
}

UnionChar::UnionChar(
        const UnionChar& x)
{
    m_var_union_char = x.m_var_union_char;
}

UnionChar::UnionChar(
        UnionChar&& x) noexcept 
{
    m_var_union_char = std::move(x.m_var_union_char);
}

UnionChar& UnionChar::operator =(
        const UnionChar& x)
{

    m_var_union_char = x.m_var_union_char;

    return *this;
}

UnionChar& UnionChar::operator =(
        UnionChar&& x) noexcept
{

    m_var_union_char = std::move(x.m_var_union_char);

    return *this;
}

bool UnionChar::operator ==(
        const UnionChar& x) const
{

    return (m_var_union_char == x.m_var_union_char);
}

bool UnionChar::operator !=(
        const UnionChar& x) const
{
    return !(*this == x);
}

size_t UnionChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionChar_max_cdr_typesize;
}

size_t UnionChar::getCdrSerializedSize(
        const UnionChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Char::getCdrSerializedSize(data.var_union_char(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_char;
}

void UnionChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_char;
}

/*!
 * @brief This function copies the value in member var_union_char
 * @param _var_union_char New value to be copied in member var_union_char
 */
void UnionChar::var_union_char(
        const Union_Char& _var_union_char)
{
    m_var_union_char = _var_union_char;
}

/*!
 * @brief This function moves the value in member var_union_char
 * @param _var_union_char New value to be moved in member var_union_char
 */
void UnionChar::var_union_char(
        Union_Char&& _var_union_char)
{
    m_var_union_char = std::move(_var_union_char);
}

/*!
 * @brief This function returns a constant reference to member var_union_char
 * @return Constant reference to member var_union_char
 */
const Union_Char& UnionChar::var_union_char() const
{
    return m_var_union_char;
}

/*!
 * @brief This function returns a reference to member var_union_char
 * @return Reference to member var_union_char
 */
Union_Char& UnionChar::var_union_char()
{
    return m_var_union_char;
}


size_t UnionChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionChar_max_key_cdr_typesize;
}

bool UnionChar::isKeyDefined()
{
    return false;
}

void UnionChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionWChar::UnionWChar()
{
    // Union_WChar m_var_union_wchar


    // Just to register all known types
    registerunionsTypes();
}

UnionWChar::~UnionWChar()
{
}

UnionWChar::UnionWChar(
        const UnionWChar& x)
{
    m_var_union_wchar = x.m_var_union_wchar;
}

UnionWChar::UnionWChar(
        UnionWChar&& x) noexcept 
{
    m_var_union_wchar = std::move(x.m_var_union_wchar);
}

UnionWChar& UnionWChar::operator =(
        const UnionWChar& x)
{

    m_var_union_wchar = x.m_var_union_wchar;

    return *this;
}

UnionWChar& UnionWChar::operator =(
        UnionWChar&& x) noexcept
{

    m_var_union_wchar = std::move(x.m_var_union_wchar);

    return *this;
}

bool UnionWChar::operator ==(
        const UnionWChar& x) const
{

    return (m_var_union_wchar == x.m_var_union_wchar);
}

bool UnionWChar::operator !=(
        const UnionWChar& x) const
{
    return !(*this == x);
}

size_t UnionWChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionWChar_max_cdr_typesize;
}

size_t UnionWChar::getCdrSerializedSize(
        const UnionWChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_WChar::getCdrSerializedSize(data.var_union_wchar(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionWChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_wchar;
}

void UnionWChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_wchar;
}

/*!
 * @brief This function copies the value in member var_union_wchar
 * @param _var_union_wchar New value to be copied in member var_union_wchar
 */
void UnionWChar::var_union_wchar(
        const Union_WChar& _var_union_wchar)
{
    m_var_union_wchar = _var_union_wchar;
}

/*!
 * @brief This function moves the value in member var_union_wchar
 * @param _var_union_wchar New value to be moved in member var_union_wchar
 */
void UnionWChar::var_union_wchar(
        Union_WChar&& _var_union_wchar)
{
    m_var_union_wchar = std::move(_var_union_wchar);
}

/*!
 * @brief This function returns a constant reference to member var_union_wchar
 * @return Constant reference to member var_union_wchar
 */
const Union_WChar& UnionWChar::var_union_wchar() const
{
    return m_var_union_wchar;
}

/*!
 * @brief This function returns a reference to member var_union_wchar
 * @return Reference to member var_union_wchar
 */
Union_WChar& UnionWChar::var_union_wchar()
{
    return m_var_union_wchar;
}


size_t UnionWChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionWChar_max_key_cdr_typesize;
}

bool UnionWChar::isKeyDefined()
{
    return false;
}

void UnionWChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionString::UnionString()
{
    // Union_String m_var_union_string


    // Just to register all known types
    registerunionsTypes();
}

UnionString::~UnionString()
{
}

UnionString::UnionString(
        const UnionString& x)
{
    m_var_union_string = x.m_var_union_string;
}

UnionString::UnionString(
        UnionString&& x) noexcept 
{
    m_var_union_string = std::move(x.m_var_union_string);
}

UnionString& UnionString::operator =(
        const UnionString& x)
{

    m_var_union_string = x.m_var_union_string;

    return *this;
}

UnionString& UnionString::operator =(
        UnionString&& x) noexcept
{

    m_var_union_string = std::move(x.m_var_union_string);

    return *this;
}

bool UnionString::operator ==(
        const UnionString& x) const
{

    return (m_var_union_string == x.m_var_union_string);
}

bool UnionString::operator !=(
        const UnionString& x) const
{
    return !(*this == x);
}

size_t UnionString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionString_max_cdr_typesize;
}

size_t UnionString::getCdrSerializedSize(
        const UnionString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_String::getCdrSerializedSize(data.var_union_string(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_string;
}

void UnionString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_string;
}

/*!
 * @brief This function copies the value in member var_union_string
 * @param _var_union_string New value to be copied in member var_union_string
 */
void UnionString::var_union_string(
        const Union_String& _var_union_string)
{
    m_var_union_string = _var_union_string;
}

/*!
 * @brief This function moves the value in member var_union_string
 * @param _var_union_string New value to be moved in member var_union_string
 */
void UnionString::var_union_string(
        Union_String&& _var_union_string)
{
    m_var_union_string = std::move(_var_union_string);
}

/*!
 * @brief This function returns a constant reference to member var_union_string
 * @return Constant reference to member var_union_string
 */
const Union_String& UnionString::var_union_string() const
{
    return m_var_union_string;
}

/*!
 * @brief This function returns a reference to member var_union_string
 * @return Reference to member var_union_string
 */
Union_String& UnionString::var_union_string()
{
    return m_var_union_string;
}


size_t UnionString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionString_max_key_cdr_typesize;
}

bool UnionString::isKeyDefined()
{
    return false;
}

void UnionString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionWString::UnionWString()
{
    // Union_WString m_var_union_wstring


    // Just to register all known types
    registerunionsTypes();
}

UnionWString::~UnionWString()
{
}

UnionWString::UnionWString(
        const UnionWString& x)
{
    m_var_union_wstring = x.m_var_union_wstring;
}

UnionWString::UnionWString(
        UnionWString&& x) noexcept 
{
    m_var_union_wstring = std::move(x.m_var_union_wstring);
}

UnionWString& UnionWString::operator =(
        const UnionWString& x)
{

    m_var_union_wstring = x.m_var_union_wstring;

    return *this;
}

UnionWString& UnionWString::operator =(
        UnionWString&& x) noexcept
{

    m_var_union_wstring = std::move(x.m_var_union_wstring);

    return *this;
}

bool UnionWString::operator ==(
        const UnionWString& x) const
{

    return (m_var_union_wstring == x.m_var_union_wstring);
}

bool UnionWString::operator !=(
        const UnionWString& x) const
{
    return !(*this == x);
}

size_t UnionWString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionWString_max_cdr_typesize;
}

size_t UnionWString::getCdrSerializedSize(
        const UnionWString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_WString::getCdrSerializedSize(data.var_union_wstring(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionWString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_wstring;
}

void UnionWString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_wstring;
}

/*!
 * @brief This function copies the value in member var_union_wstring
 * @param _var_union_wstring New value to be copied in member var_union_wstring
 */
void UnionWString::var_union_wstring(
        const Union_WString& _var_union_wstring)
{
    m_var_union_wstring = _var_union_wstring;
}

/*!
 * @brief This function moves the value in member var_union_wstring
 * @param _var_union_wstring New value to be moved in member var_union_wstring
 */
void UnionWString::var_union_wstring(
        Union_WString&& _var_union_wstring)
{
    m_var_union_wstring = std::move(_var_union_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_union_wstring
 * @return Constant reference to member var_union_wstring
 */
const Union_WString& UnionWString::var_union_wstring() const
{
    return m_var_union_wstring;
}

/*!
 * @brief This function returns a reference to member var_union_wstring
 * @return Reference to member var_union_wstring
 */
Union_WString& UnionWString::var_union_wstring()
{
    return m_var_union_wstring;
}


size_t UnionWString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionWString_max_key_cdr_typesize;
}

bool UnionWString::isKeyDefined()
{
    return false;
}

void UnionWString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionBoundedString::UnionBoundedString()
{
    // Union_BoundedString m_var_union_bounded_string


    // Just to register all known types
    registerunionsTypes();
}

UnionBoundedString::~UnionBoundedString()
{
}

UnionBoundedString::UnionBoundedString(
        const UnionBoundedString& x)
{
    m_var_union_bounded_string = x.m_var_union_bounded_string;
}

UnionBoundedString::UnionBoundedString(
        UnionBoundedString&& x) noexcept 
{
    m_var_union_bounded_string = std::move(x.m_var_union_bounded_string);
}

UnionBoundedString& UnionBoundedString::operator =(
        const UnionBoundedString& x)
{

    m_var_union_bounded_string = x.m_var_union_bounded_string;

    return *this;
}

UnionBoundedString& UnionBoundedString::operator =(
        UnionBoundedString&& x) noexcept
{

    m_var_union_bounded_string = std::move(x.m_var_union_bounded_string);

    return *this;
}

bool UnionBoundedString::operator ==(
        const UnionBoundedString& x) const
{

    return (m_var_union_bounded_string == x.m_var_union_bounded_string);
}

bool UnionBoundedString::operator !=(
        const UnionBoundedString& x) const
{
    return !(*this == x);
}

size_t UnionBoundedString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionBoundedString_max_cdr_typesize;
}

size_t UnionBoundedString::getCdrSerializedSize(
        const UnionBoundedString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_BoundedString::getCdrSerializedSize(data.var_union_bounded_string(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionBoundedString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_bounded_string;
}

void UnionBoundedString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_bounded_string;
}

/*!
 * @brief This function copies the value in member var_union_bounded_string
 * @param _var_union_bounded_string New value to be copied in member var_union_bounded_string
 */
void UnionBoundedString::var_union_bounded_string(
        const Union_BoundedString& _var_union_bounded_string)
{
    m_var_union_bounded_string = _var_union_bounded_string;
}

/*!
 * @brief This function moves the value in member var_union_bounded_string
 * @param _var_union_bounded_string New value to be moved in member var_union_bounded_string
 */
void UnionBoundedString::var_union_bounded_string(
        Union_BoundedString&& _var_union_bounded_string)
{
    m_var_union_bounded_string = std::move(_var_union_bounded_string);
}

/*!
 * @brief This function returns a constant reference to member var_union_bounded_string
 * @return Constant reference to member var_union_bounded_string
 */
const Union_BoundedString& UnionBoundedString::var_union_bounded_string() const
{
    return m_var_union_bounded_string;
}

/*!
 * @brief This function returns a reference to member var_union_bounded_string
 * @return Reference to member var_union_bounded_string
 */
Union_BoundedString& UnionBoundedString::var_union_bounded_string()
{
    return m_var_union_bounded_string;
}


size_t UnionBoundedString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionBoundedString_max_key_cdr_typesize;
}

bool UnionBoundedString::isKeyDefined()
{
    return false;
}

void UnionBoundedString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionBoundedWString::UnionBoundedWString()
{
    // Union_BoundedWString m_var_union_bounded_wstring


    // Just to register all known types
    registerunionsTypes();
}

UnionBoundedWString::~UnionBoundedWString()
{
}

UnionBoundedWString::UnionBoundedWString(
        const UnionBoundedWString& x)
{
    m_var_union_bounded_wstring = x.m_var_union_bounded_wstring;
}

UnionBoundedWString::UnionBoundedWString(
        UnionBoundedWString&& x) noexcept 
{
    m_var_union_bounded_wstring = std::move(x.m_var_union_bounded_wstring);
}

UnionBoundedWString& UnionBoundedWString::operator =(
        const UnionBoundedWString& x)
{

    m_var_union_bounded_wstring = x.m_var_union_bounded_wstring;

    return *this;
}

UnionBoundedWString& UnionBoundedWString::operator =(
        UnionBoundedWString&& x) noexcept
{

    m_var_union_bounded_wstring = std::move(x.m_var_union_bounded_wstring);

    return *this;
}

bool UnionBoundedWString::operator ==(
        const UnionBoundedWString& x) const
{

    return (m_var_union_bounded_wstring == x.m_var_union_bounded_wstring);
}

bool UnionBoundedWString::operator !=(
        const UnionBoundedWString& x) const
{
    return !(*this == x);
}

size_t UnionBoundedWString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionBoundedWString_max_cdr_typesize;
}

size_t UnionBoundedWString::getCdrSerializedSize(
        const UnionBoundedWString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_BoundedWString::getCdrSerializedSize(data.var_union_bounded_wstring(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionBoundedWString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_bounded_wstring;
}

void UnionBoundedWString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_bounded_wstring;
}

/*!
 * @brief This function copies the value in member var_union_bounded_wstring
 * @param _var_union_bounded_wstring New value to be copied in member var_union_bounded_wstring
 */
void UnionBoundedWString::var_union_bounded_wstring(
        const Union_BoundedWString& _var_union_bounded_wstring)
{
    m_var_union_bounded_wstring = _var_union_bounded_wstring;
}

/*!
 * @brief This function moves the value in member var_union_bounded_wstring
 * @param _var_union_bounded_wstring New value to be moved in member var_union_bounded_wstring
 */
void UnionBoundedWString::var_union_bounded_wstring(
        Union_BoundedWString&& _var_union_bounded_wstring)
{
    m_var_union_bounded_wstring = std::move(_var_union_bounded_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_union_bounded_wstring
 * @return Constant reference to member var_union_bounded_wstring
 */
const Union_BoundedWString& UnionBoundedWString::var_union_bounded_wstring() const
{
    return m_var_union_bounded_wstring;
}

/*!
 * @brief This function returns a reference to member var_union_bounded_wstring
 * @return Reference to member var_union_bounded_wstring
 */
Union_BoundedWString& UnionBoundedWString::var_union_bounded_wstring()
{
    return m_var_union_bounded_wstring;
}


size_t UnionBoundedWString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionBoundedWString_max_key_cdr_typesize;
}

bool UnionBoundedWString::isKeyDefined()
{
    return false;
}

void UnionBoundedWString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionInnerEnumHelper::UnionInnerEnumHelper()
{
    // Union_InnerEnumHelper m_var_union_my_enum


    // Just to register all known types
    registerunionsTypes();
}

UnionInnerEnumHelper::~UnionInnerEnumHelper()
{
}

UnionInnerEnumHelper::UnionInnerEnumHelper(
        const UnionInnerEnumHelper& x)
{
    m_var_union_my_enum = x.m_var_union_my_enum;
}

UnionInnerEnumHelper::UnionInnerEnumHelper(
        UnionInnerEnumHelper&& x) noexcept 
{
    m_var_union_my_enum = std::move(x.m_var_union_my_enum);
}

UnionInnerEnumHelper& UnionInnerEnumHelper::operator =(
        const UnionInnerEnumHelper& x)
{

    m_var_union_my_enum = x.m_var_union_my_enum;

    return *this;
}

UnionInnerEnumHelper& UnionInnerEnumHelper::operator =(
        UnionInnerEnumHelper&& x) noexcept
{

    m_var_union_my_enum = std::move(x.m_var_union_my_enum);

    return *this;
}

bool UnionInnerEnumHelper::operator ==(
        const UnionInnerEnumHelper& x) const
{

    return (m_var_union_my_enum == x.m_var_union_my_enum);
}

bool UnionInnerEnumHelper::operator !=(
        const UnionInnerEnumHelper& x) const
{
    return !(*this == x);
}

size_t UnionInnerEnumHelper::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionInnerEnumHelper_max_cdr_typesize;
}

size_t UnionInnerEnumHelper::getCdrSerializedSize(
        const UnionInnerEnumHelper& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_InnerEnumHelper::getCdrSerializedSize(data.var_union_my_enum(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionInnerEnumHelper::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_my_enum;
}

void UnionInnerEnumHelper::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_my_enum;
}

/*!
 * @brief This function copies the value in member var_union_my_enum
 * @param _var_union_my_enum New value to be copied in member var_union_my_enum
 */
void UnionInnerEnumHelper::var_union_my_enum(
        const Union_InnerEnumHelper& _var_union_my_enum)
{
    m_var_union_my_enum = _var_union_my_enum;
}

/*!
 * @brief This function moves the value in member var_union_my_enum
 * @param _var_union_my_enum New value to be moved in member var_union_my_enum
 */
void UnionInnerEnumHelper::var_union_my_enum(
        Union_InnerEnumHelper&& _var_union_my_enum)
{
    m_var_union_my_enum = std::move(_var_union_my_enum);
}

/*!
 * @brief This function returns a constant reference to member var_union_my_enum
 * @return Constant reference to member var_union_my_enum
 */
const Union_InnerEnumHelper& UnionInnerEnumHelper::var_union_my_enum() const
{
    return m_var_union_my_enum;
}

/*!
 * @brief This function returns a reference to member var_union_my_enum
 * @return Reference to member var_union_my_enum
 */
Union_InnerEnumHelper& UnionInnerEnumHelper::var_union_my_enum()
{
    return m_var_union_my_enum;
}


size_t UnionInnerEnumHelper::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionInnerEnumHelper_max_key_cdr_typesize;
}

bool UnionInnerEnumHelper::isKeyDefined()
{
    return false;
}

void UnionInnerEnumHelper::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionInnerBitMaskHelper::UnionInnerBitMaskHelper()
{
    // Union_InnerBitMaskHelper m_var_union_my_bit_mask


    // Just to register all known types
    registerunionsTypes();
}

UnionInnerBitMaskHelper::~UnionInnerBitMaskHelper()
{
}

UnionInnerBitMaskHelper::UnionInnerBitMaskHelper(
        const UnionInnerBitMaskHelper& x)
{
    m_var_union_my_bit_mask = x.m_var_union_my_bit_mask;
}

UnionInnerBitMaskHelper::UnionInnerBitMaskHelper(
        UnionInnerBitMaskHelper&& x) noexcept 
{
    m_var_union_my_bit_mask = std::move(x.m_var_union_my_bit_mask);
}

UnionInnerBitMaskHelper& UnionInnerBitMaskHelper::operator =(
        const UnionInnerBitMaskHelper& x)
{

    m_var_union_my_bit_mask = x.m_var_union_my_bit_mask;

    return *this;
}

UnionInnerBitMaskHelper& UnionInnerBitMaskHelper::operator =(
        UnionInnerBitMaskHelper&& x) noexcept
{

    m_var_union_my_bit_mask = std::move(x.m_var_union_my_bit_mask);

    return *this;
}

bool UnionInnerBitMaskHelper::operator ==(
        const UnionInnerBitMaskHelper& x) const
{

    return (m_var_union_my_bit_mask == x.m_var_union_my_bit_mask);
}

bool UnionInnerBitMaskHelper::operator !=(
        const UnionInnerBitMaskHelper& x) const
{
    return !(*this == x);
}

size_t UnionInnerBitMaskHelper::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionInnerBitMaskHelper_max_cdr_typesize;
}

size_t UnionInnerBitMaskHelper::getCdrSerializedSize(
        const UnionInnerBitMaskHelper& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_InnerBitMaskHelper::getCdrSerializedSize(data.var_union_my_bit_mask(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionInnerBitMaskHelper::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_my_bit_mask;
}

void UnionInnerBitMaskHelper::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_my_bit_mask;
}

/*!
 * @brief This function copies the value in member var_union_my_bit_mask
 * @param _var_union_my_bit_mask New value to be copied in member var_union_my_bit_mask
 */
void UnionInnerBitMaskHelper::var_union_my_bit_mask(
        const Union_InnerBitMaskHelper& _var_union_my_bit_mask)
{
    m_var_union_my_bit_mask = _var_union_my_bit_mask;
}

/*!
 * @brief This function moves the value in member var_union_my_bit_mask
 * @param _var_union_my_bit_mask New value to be moved in member var_union_my_bit_mask
 */
void UnionInnerBitMaskHelper::var_union_my_bit_mask(
        Union_InnerBitMaskHelper&& _var_union_my_bit_mask)
{
    m_var_union_my_bit_mask = std::move(_var_union_my_bit_mask);
}

/*!
 * @brief This function returns a constant reference to member var_union_my_bit_mask
 * @return Constant reference to member var_union_my_bit_mask
 */
const Union_InnerBitMaskHelper& UnionInnerBitMaskHelper::var_union_my_bit_mask() const
{
    return m_var_union_my_bit_mask;
}

/*!
 * @brief This function returns a reference to member var_union_my_bit_mask
 * @return Reference to member var_union_my_bit_mask
 */
Union_InnerBitMaskHelper& UnionInnerBitMaskHelper::var_union_my_bit_mask()
{
    return m_var_union_my_bit_mask;
}


size_t UnionInnerBitMaskHelper::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionInnerBitMaskHelper_max_key_cdr_typesize;
}

bool UnionInnerBitMaskHelper::isKeyDefined()
{
    return false;
}

void UnionInnerBitMaskHelper::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionInnerAliasHelper::UnionInnerAliasHelper()
{
    // Union_InnerAliasHelper m_var_union_my_alias


    // Just to register all known types
    registerunionsTypes();
}

UnionInnerAliasHelper::~UnionInnerAliasHelper()
{
}

UnionInnerAliasHelper::UnionInnerAliasHelper(
        const UnionInnerAliasHelper& x)
{
    m_var_union_my_alias = x.m_var_union_my_alias;
}

UnionInnerAliasHelper::UnionInnerAliasHelper(
        UnionInnerAliasHelper&& x) noexcept 
{
    m_var_union_my_alias = std::move(x.m_var_union_my_alias);
}

UnionInnerAliasHelper& UnionInnerAliasHelper::operator =(
        const UnionInnerAliasHelper& x)
{

    m_var_union_my_alias = x.m_var_union_my_alias;

    return *this;
}

UnionInnerAliasHelper& UnionInnerAliasHelper::operator =(
        UnionInnerAliasHelper&& x) noexcept
{

    m_var_union_my_alias = std::move(x.m_var_union_my_alias);

    return *this;
}

bool UnionInnerAliasHelper::operator ==(
        const UnionInnerAliasHelper& x) const
{

    return (m_var_union_my_alias == x.m_var_union_my_alias);
}

bool UnionInnerAliasHelper::operator !=(
        const UnionInnerAliasHelper& x) const
{
    return !(*this == x);
}

size_t UnionInnerAliasHelper::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionInnerAliasHelper_max_cdr_typesize;
}

size_t UnionInnerAliasHelper::getCdrSerializedSize(
        const UnionInnerAliasHelper& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_InnerAliasHelper::getCdrSerializedSize(data.var_union_my_alias(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionInnerAliasHelper::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_my_alias;
}

void UnionInnerAliasHelper::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_my_alias;
}

/*!
 * @brief This function copies the value in member var_union_my_alias
 * @param _var_union_my_alias New value to be copied in member var_union_my_alias
 */
void UnionInnerAliasHelper::var_union_my_alias(
        const Union_InnerAliasHelper& _var_union_my_alias)
{
    m_var_union_my_alias = _var_union_my_alias;
}

/*!
 * @brief This function moves the value in member var_union_my_alias
 * @param _var_union_my_alias New value to be moved in member var_union_my_alias
 */
void UnionInnerAliasHelper::var_union_my_alias(
        Union_InnerAliasHelper&& _var_union_my_alias)
{
    m_var_union_my_alias = std::move(_var_union_my_alias);
}

/*!
 * @brief This function returns a constant reference to member var_union_my_alias
 * @return Constant reference to member var_union_my_alias
 */
const Union_InnerAliasHelper& UnionInnerAliasHelper::var_union_my_alias() const
{
    return m_var_union_my_alias;
}

/*!
 * @brief This function returns a reference to member var_union_my_alias
 * @return Reference to member var_union_my_alias
 */
Union_InnerAliasHelper& UnionInnerAliasHelper::var_union_my_alias()
{
    return m_var_union_my_alias;
}


size_t UnionInnerAliasHelper::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionInnerAliasHelper_max_key_cdr_typesize;
}

bool UnionInnerAliasHelper::isKeyDefined()
{
    return false;
}

void UnionInnerAliasHelper::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionArray::UnionArray()
{
    // Union_Array m_var_union_array


    // Just to register all known types
    registerunionsTypes();
}

UnionArray::~UnionArray()
{
}

UnionArray::UnionArray(
        const UnionArray& x)
{
    m_var_union_array = x.m_var_union_array;
}

UnionArray::UnionArray(
        UnionArray&& x) noexcept 
{
    m_var_union_array = std::move(x.m_var_union_array);
}

UnionArray& UnionArray::operator =(
        const UnionArray& x)
{

    m_var_union_array = x.m_var_union_array;

    return *this;
}

UnionArray& UnionArray::operator =(
        UnionArray&& x) noexcept
{

    m_var_union_array = std::move(x.m_var_union_array);

    return *this;
}

bool UnionArray::operator ==(
        const UnionArray& x) const
{

    return (m_var_union_array == x.m_var_union_array);
}

bool UnionArray::operator !=(
        const UnionArray& x) const
{
    return !(*this == x);
}

size_t UnionArray::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionArray_max_cdr_typesize;
}

size_t UnionArray::getCdrSerializedSize(
        const UnionArray& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Array::getCdrSerializedSize(data.var_union_array(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionArray::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_array;
}

void UnionArray::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_array;
}

/*!
 * @brief This function copies the value in member var_union_array
 * @param _var_union_array New value to be copied in member var_union_array
 */
void UnionArray::var_union_array(
        const Union_Array& _var_union_array)
{
    m_var_union_array = _var_union_array;
}

/*!
 * @brief This function moves the value in member var_union_array
 * @param _var_union_array New value to be moved in member var_union_array
 */
void UnionArray::var_union_array(
        Union_Array&& _var_union_array)
{
    m_var_union_array = std::move(_var_union_array);
}

/*!
 * @brief This function returns a constant reference to member var_union_array
 * @return Constant reference to member var_union_array
 */
const Union_Array& UnionArray::var_union_array() const
{
    return m_var_union_array;
}

/*!
 * @brief This function returns a reference to member var_union_array
 * @return Reference to member var_union_array
 */
Union_Array& UnionArray::var_union_array()
{
    return m_var_union_array;
}


size_t UnionArray::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionArray_max_key_cdr_typesize;
}

bool UnionArray::isKeyDefined()
{
    return false;
}

void UnionArray::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionSequence::UnionSequence()
{
    // Union_Sequence m_var_union_sequence


    // Just to register all known types
    registerunionsTypes();
}

UnionSequence::~UnionSequence()
{
}

UnionSequence::UnionSequence(
        const UnionSequence& x)
{
    m_var_union_sequence = x.m_var_union_sequence;
}

UnionSequence::UnionSequence(
        UnionSequence&& x) noexcept 
{
    m_var_union_sequence = std::move(x.m_var_union_sequence);
}

UnionSequence& UnionSequence::operator =(
        const UnionSequence& x)
{

    m_var_union_sequence = x.m_var_union_sequence;

    return *this;
}

UnionSequence& UnionSequence::operator =(
        UnionSequence&& x) noexcept
{

    m_var_union_sequence = std::move(x.m_var_union_sequence);

    return *this;
}

bool UnionSequence::operator ==(
        const UnionSequence& x) const
{

    return (m_var_union_sequence == x.m_var_union_sequence);
}

bool UnionSequence::operator !=(
        const UnionSequence& x) const
{
    return !(*this == x);
}

size_t UnionSequence::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionSequence_max_cdr_typesize;
}

size_t UnionSequence::getCdrSerializedSize(
        const UnionSequence& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Sequence::getCdrSerializedSize(data.var_union_sequence(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionSequence::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_sequence;
}

void UnionSequence::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_sequence;
}

/*!
 * @brief This function copies the value in member var_union_sequence
 * @param _var_union_sequence New value to be copied in member var_union_sequence
 */
void UnionSequence::var_union_sequence(
        const Union_Sequence& _var_union_sequence)
{
    m_var_union_sequence = _var_union_sequence;
}

/*!
 * @brief This function moves the value in member var_union_sequence
 * @param _var_union_sequence New value to be moved in member var_union_sequence
 */
void UnionSequence::var_union_sequence(
        Union_Sequence&& _var_union_sequence)
{
    m_var_union_sequence = std::move(_var_union_sequence);
}

/*!
 * @brief This function returns a constant reference to member var_union_sequence
 * @return Constant reference to member var_union_sequence
 */
const Union_Sequence& UnionSequence::var_union_sequence() const
{
    return m_var_union_sequence;
}

/*!
 * @brief This function returns a reference to member var_union_sequence
 * @return Reference to member var_union_sequence
 */
Union_Sequence& UnionSequence::var_union_sequence()
{
    return m_var_union_sequence;
}


size_t UnionSequence::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionSequence_max_key_cdr_typesize;
}

bool UnionSequence::isKeyDefined()
{
    return false;
}

void UnionSequence::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionMap::UnionMap()
{
    // Union_Map m_var_union_map


    // Just to register all known types
    registerunionsTypes();
}

UnionMap::~UnionMap()
{
}

UnionMap::UnionMap(
        const UnionMap& x)
{
    m_var_union_map = x.m_var_union_map;
}

UnionMap::UnionMap(
        UnionMap&& x) noexcept 
{
    m_var_union_map = std::move(x.m_var_union_map);
}

UnionMap& UnionMap::operator =(
        const UnionMap& x)
{

    m_var_union_map = x.m_var_union_map;

    return *this;
}

UnionMap& UnionMap::operator =(
        UnionMap&& x) noexcept
{

    m_var_union_map = std::move(x.m_var_union_map);

    return *this;
}

bool UnionMap::operator ==(
        const UnionMap& x) const
{

    return (m_var_union_map == x.m_var_union_map);
}

bool UnionMap::operator !=(
        const UnionMap& x) const
{
    return !(*this == x);
}

size_t UnionMap::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionMap_max_cdr_typesize;
}

size_t UnionMap::getCdrSerializedSize(
        const UnionMap& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Map::getCdrSerializedSize(data.var_union_map(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionMap::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_map;
}

void UnionMap::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_map;
}

/*!
 * @brief This function copies the value in member var_union_map
 * @param _var_union_map New value to be copied in member var_union_map
 */
void UnionMap::var_union_map(
        const Union_Map& _var_union_map)
{
    m_var_union_map = _var_union_map;
}

/*!
 * @brief This function moves the value in member var_union_map
 * @param _var_union_map New value to be moved in member var_union_map
 */
void UnionMap::var_union_map(
        Union_Map&& _var_union_map)
{
    m_var_union_map = std::move(_var_union_map);
}

/*!
 * @brief This function returns a constant reference to member var_union_map
 * @return Constant reference to member var_union_map
 */
const Union_Map& UnionMap::var_union_map() const
{
    return m_var_union_map;
}

/*!
 * @brief This function returns a reference to member var_union_map
 * @return Reference to member var_union_map
 */
Union_Map& UnionMap::var_union_map()
{
    return m_var_union_map;
}


size_t UnionMap::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionMap_max_key_cdr_typesize;
}

bool UnionMap::isKeyDefined()
{
    return false;
}

void UnionMap::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionInnerUnionHelper::UnionInnerUnionHelper()
{
    // Union_InnerUnionHelper m_var_union_my_union


    // Just to register all known types
    registerunionsTypes();
}

UnionInnerUnionHelper::~UnionInnerUnionHelper()
{
}

UnionInnerUnionHelper::UnionInnerUnionHelper(
        const UnionInnerUnionHelper& x)
{
    m_var_union_my_union = x.m_var_union_my_union;
}

UnionInnerUnionHelper::UnionInnerUnionHelper(
        UnionInnerUnionHelper&& x) noexcept 
{
    m_var_union_my_union = std::move(x.m_var_union_my_union);
}

UnionInnerUnionHelper& UnionInnerUnionHelper::operator =(
        const UnionInnerUnionHelper& x)
{

    m_var_union_my_union = x.m_var_union_my_union;

    return *this;
}

UnionInnerUnionHelper& UnionInnerUnionHelper::operator =(
        UnionInnerUnionHelper&& x) noexcept
{

    m_var_union_my_union = std::move(x.m_var_union_my_union);

    return *this;
}

bool UnionInnerUnionHelper::operator ==(
        const UnionInnerUnionHelper& x) const
{

    return (m_var_union_my_union == x.m_var_union_my_union);
}

bool UnionInnerUnionHelper::operator !=(
        const UnionInnerUnionHelper& x) const
{
    return !(*this == x);
}

size_t UnionInnerUnionHelper::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionInnerUnionHelper_max_cdr_typesize;
}

size_t UnionInnerUnionHelper::getCdrSerializedSize(
        const UnionInnerUnionHelper& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_InnerUnionHelper::getCdrSerializedSize(data.var_union_my_union(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionInnerUnionHelper::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_my_union;
}

void UnionInnerUnionHelper::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_my_union;
}

/*!
 * @brief This function copies the value in member var_union_my_union
 * @param _var_union_my_union New value to be copied in member var_union_my_union
 */
void UnionInnerUnionHelper::var_union_my_union(
        const Union_InnerUnionHelper& _var_union_my_union)
{
    m_var_union_my_union = _var_union_my_union;
}

/*!
 * @brief This function moves the value in member var_union_my_union
 * @param _var_union_my_union New value to be moved in member var_union_my_union
 */
void UnionInnerUnionHelper::var_union_my_union(
        Union_InnerUnionHelper&& _var_union_my_union)
{
    m_var_union_my_union = std::move(_var_union_my_union);
}

/*!
 * @brief This function returns a constant reference to member var_union_my_union
 * @return Constant reference to member var_union_my_union
 */
const Union_InnerUnionHelper& UnionInnerUnionHelper::var_union_my_union() const
{
    return m_var_union_my_union;
}

/*!
 * @brief This function returns a reference to member var_union_my_union
 * @return Reference to member var_union_my_union
 */
Union_InnerUnionHelper& UnionInnerUnionHelper::var_union_my_union()
{
    return m_var_union_my_union;
}


size_t UnionInnerUnionHelper::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionInnerUnionHelper_max_key_cdr_typesize;
}

bool UnionInnerUnionHelper::isKeyDefined()
{
    return false;
}

void UnionInnerUnionHelper::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionInnerStructureHelper::UnionInnerStructureHelper()
{
    // Union_InnerStructureHelper m_var_union_my_structure


    // Just to register all known types
    registerunionsTypes();
}

UnionInnerStructureHelper::~UnionInnerStructureHelper()
{
}

UnionInnerStructureHelper::UnionInnerStructureHelper(
        const UnionInnerStructureHelper& x)
{
    m_var_union_my_structure = x.m_var_union_my_structure;
}

UnionInnerStructureHelper::UnionInnerStructureHelper(
        UnionInnerStructureHelper&& x) noexcept 
{
    m_var_union_my_structure = std::move(x.m_var_union_my_structure);
}

UnionInnerStructureHelper& UnionInnerStructureHelper::operator =(
        const UnionInnerStructureHelper& x)
{

    m_var_union_my_structure = x.m_var_union_my_structure;

    return *this;
}

UnionInnerStructureHelper& UnionInnerStructureHelper::operator =(
        UnionInnerStructureHelper&& x) noexcept
{

    m_var_union_my_structure = std::move(x.m_var_union_my_structure);

    return *this;
}

bool UnionInnerStructureHelper::operator ==(
        const UnionInnerStructureHelper& x) const
{

    return (m_var_union_my_structure == x.m_var_union_my_structure);
}

bool UnionInnerStructureHelper::operator !=(
        const UnionInnerStructureHelper& x) const
{
    return !(*this == x);
}

size_t UnionInnerStructureHelper::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionInnerStructureHelper_max_cdr_typesize;
}

size_t UnionInnerStructureHelper::getCdrSerializedSize(
        const UnionInnerStructureHelper& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_InnerStructureHelper::getCdrSerializedSize(data.var_union_my_structure(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionInnerStructureHelper::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_my_structure;
}

void UnionInnerStructureHelper::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_my_structure;
}

/*!
 * @brief This function copies the value in member var_union_my_structure
 * @param _var_union_my_structure New value to be copied in member var_union_my_structure
 */
void UnionInnerStructureHelper::var_union_my_structure(
        const Union_InnerStructureHelper& _var_union_my_structure)
{
    m_var_union_my_structure = _var_union_my_structure;
}

/*!
 * @brief This function moves the value in member var_union_my_structure
 * @param _var_union_my_structure New value to be moved in member var_union_my_structure
 */
void UnionInnerStructureHelper::var_union_my_structure(
        Union_InnerStructureHelper&& _var_union_my_structure)
{
    m_var_union_my_structure = std::move(_var_union_my_structure);
}

/*!
 * @brief This function returns a constant reference to member var_union_my_structure
 * @return Constant reference to member var_union_my_structure
 */
const Union_InnerStructureHelper& UnionInnerStructureHelper::var_union_my_structure() const
{
    return m_var_union_my_structure;
}

/*!
 * @brief This function returns a reference to member var_union_my_structure
 * @return Reference to member var_union_my_structure
 */
Union_InnerStructureHelper& UnionInnerStructureHelper::var_union_my_structure()
{
    return m_var_union_my_structure;
}


size_t UnionInnerStructureHelper::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionInnerStructureHelper_max_key_cdr_typesize;
}

bool UnionInnerStructureHelper::isKeyDefined()
{
    return false;
}

void UnionInnerStructureHelper::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionInnerBitsetHelper::UnionInnerBitsetHelper()
{
    // Union_InnerBitsetHelper m_var_union_my_bitset


    // Just to register all known types
    registerunionsTypes();
}

UnionInnerBitsetHelper::~UnionInnerBitsetHelper()
{
}

UnionInnerBitsetHelper::UnionInnerBitsetHelper(
        const UnionInnerBitsetHelper& x)
{
    m_var_union_my_bitset = x.m_var_union_my_bitset;
}

UnionInnerBitsetHelper::UnionInnerBitsetHelper(
        UnionInnerBitsetHelper&& x) noexcept 
{
    m_var_union_my_bitset = std::move(x.m_var_union_my_bitset);
}

UnionInnerBitsetHelper& UnionInnerBitsetHelper::operator =(
        const UnionInnerBitsetHelper& x)
{

    m_var_union_my_bitset = x.m_var_union_my_bitset;

    return *this;
}

UnionInnerBitsetHelper& UnionInnerBitsetHelper::operator =(
        UnionInnerBitsetHelper&& x) noexcept
{

    m_var_union_my_bitset = std::move(x.m_var_union_my_bitset);

    return *this;
}

bool UnionInnerBitsetHelper::operator ==(
        const UnionInnerBitsetHelper& x) const
{

    return (m_var_union_my_bitset == x.m_var_union_my_bitset);
}

bool UnionInnerBitsetHelper::operator !=(
        const UnionInnerBitsetHelper& x) const
{
    return !(*this == x);
}

size_t UnionInnerBitsetHelper::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionInnerBitsetHelper_max_cdr_typesize;
}

size_t UnionInnerBitsetHelper::getCdrSerializedSize(
        const UnionInnerBitsetHelper& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_InnerBitsetHelper::getCdrSerializedSize(data.var_union_my_bitset(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionInnerBitsetHelper::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_my_bitset;
}

void UnionInnerBitsetHelper::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_my_bitset;
}

/*!
 * @brief This function copies the value in member var_union_my_bitset
 * @param _var_union_my_bitset New value to be copied in member var_union_my_bitset
 */
void UnionInnerBitsetHelper::var_union_my_bitset(
        const Union_InnerBitsetHelper& _var_union_my_bitset)
{
    m_var_union_my_bitset = _var_union_my_bitset;
}

/*!
 * @brief This function moves the value in member var_union_my_bitset
 * @param _var_union_my_bitset New value to be moved in member var_union_my_bitset
 */
void UnionInnerBitsetHelper::var_union_my_bitset(
        Union_InnerBitsetHelper&& _var_union_my_bitset)
{
    m_var_union_my_bitset = std::move(_var_union_my_bitset);
}

/*!
 * @brief This function returns a constant reference to member var_union_my_bitset
 * @return Constant reference to member var_union_my_bitset
 */
const Union_InnerBitsetHelper& UnionInnerBitsetHelper::var_union_my_bitset() const
{
    return m_var_union_my_bitset;
}

/*!
 * @brief This function returns a reference to member var_union_my_bitset
 * @return Reference to member var_union_my_bitset
 */
Union_InnerBitsetHelper& UnionInnerBitsetHelper::var_union_my_bitset()
{
    return m_var_union_my_bitset;
}


size_t UnionInnerBitsetHelper::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionInnerBitsetHelper_max_key_cdr_typesize;
}

bool UnionInnerBitsetHelper::isKeyDefined()
{
    return false;
}

void UnionInnerBitsetHelper::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionDiscriminatorShort::UnionDiscriminatorShort()
{
    // Union_Discriminator_short m_var_union_discriminator_short


    // Just to register all known types
    registerunionsTypes();
}

UnionDiscriminatorShort::~UnionDiscriminatorShort()
{
}

UnionDiscriminatorShort::UnionDiscriminatorShort(
        const UnionDiscriminatorShort& x)
{
    m_var_union_discriminator_short = x.m_var_union_discriminator_short;
}

UnionDiscriminatorShort::UnionDiscriminatorShort(
        UnionDiscriminatorShort&& x) noexcept 
{
    m_var_union_discriminator_short = std::move(x.m_var_union_discriminator_short);
}

UnionDiscriminatorShort& UnionDiscriminatorShort::operator =(
        const UnionDiscriminatorShort& x)
{

    m_var_union_discriminator_short = x.m_var_union_discriminator_short;

    return *this;
}

UnionDiscriminatorShort& UnionDiscriminatorShort::operator =(
        UnionDiscriminatorShort&& x) noexcept
{

    m_var_union_discriminator_short = std::move(x.m_var_union_discriminator_short);

    return *this;
}

bool UnionDiscriminatorShort::operator ==(
        const UnionDiscriminatorShort& x) const
{

    return (m_var_union_discriminator_short == x.m_var_union_discriminator_short);
}

bool UnionDiscriminatorShort::operator !=(
        const UnionDiscriminatorShort& x) const
{
    return !(*this == x);
}

size_t UnionDiscriminatorShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorShort_max_cdr_typesize;
}

size_t UnionDiscriminatorShort::getCdrSerializedSize(
        const UnionDiscriminatorShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Discriminator_short::getCdrSerializedSize(data.var_union_discriminator_short(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionDiscriminatorShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_discriminator_short;
}

void UnionDiscriminatorShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_discriminator_short;
}

/*!
 * @brief This function copies the value in member var_union_discriminator_short
 * @param _var_union_discriminator_short New value to be copied in member var_union_discriminator_short
 */
void UnionDiscriminatorShort::var_union_discriminator_short(
        const Union_Discriminator_short& _var_union_discriminator_short)
{
    m_var_union_discriminator_short = _var_union_discriminator_short;
}

/*!
 * @brief This function moves the value in member var_union_discriminator_short
 * @param _var_union_discriminator_short New value to be moved in member var_union_discriminator_short
 */
void UnionDiscriminatorShort::var_union_discriminator_short(
        Union_Discriminator_short&& _var_union_discriminator_short)
{
    m_var_union_discriminator_short = std::move(_var_union_discriminator_short);
}

/*!
 * @brief This function returns a constant reference to member var_union_discriminator_short
 * @return Constant reference to member var_union_discriminator_short
 */
const Union_Discriminator_short& UnionDiscriminatorShort::var_union_discriminator_short() const
{
    return m_var_union_discriminator_short;
}

/*!
 * @brief This function returns a reference to member var_union_discriminator_short
 * @return Reference to member var_union_discriminator_short
 */
Union_Discriminator_short& UnionDiscriminatorShort::var_union_discriminator_short()
{
    return m_var_union_discriminator_short;
}


size_t UnionDiscriminatorShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorShort_max_key_cdr_typesize;
}

bool UnionDiscriminatorShort::isKeyDefined()
{
    return false;
}

void UnionDiscriminatorShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionDiscriminatorUShort::UnionDiscriminatorUShort()
{
    // Union_Discriminator_unsigned_short m_var_union_discriminator_ushort


    // Just to register all known types
    registerunionsTypes();
}

UnionDiscriminatorUShort::~UnionDiscriminatorUShort()
{
}

UnionDiscriminatorUShort::UnionDiscriminatorUShort(
        const UnionDiscriminatorUShort& x)
{
    m_var_union_discriminator_ushort = x.m_var_union_discriminator_ushort;
}

UnionDiscriminatorUShort::UnionDiscriminatorUShort(
        UnionDiscriminatorUShort&& x) noexcept 
{
    m_var_union_discriminator_ushort = std::move(x.m_var_union_discriminator_ushort);
}

UnionDiscriminatorUShort& UnionDiscriminatorUShort::operator =(
        const UnionDiscriminatorUShort& x)
{

    m_var_union_discriminator_ushort = x.m_var_union_discriminator_ushort;

    return *this;
}

UnionDiscriminatorUShort& UnionDiscriminatorUShort::operator =(
        UnionDiscriminatorUShort&& x) noexcept
{

    m_var_union_discriminator_ushort = std::move(x.m_var_union_discriminator_ushort);

    return *this;
}

bool UnionDiscriminatorUShort::operator ==(
        const UnionDiscriminatorUShort& x) const
{

    return (m_var_union_discriminator_ushort == x.m_var_union_discriminator_ushort);
}

bool UnionDiscriminatorUShort::operator !=(
        const UnionDiscriminatorUShort& x) const
{
    return !(*this == x);
}

size_t UnionDiscriminatorUShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorUShort_max_cdr_typesize;
}

size_t UnionDiscriminatorUShort::getCdrSerializedSize(
        const UnionDiscriminatorUShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Discriminator_unsigned_short::getCdrSerializedSize(data.var_union_discriminator_ushort(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionDiscriminatorUShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_discriminator_ushort;
}

void UnionDiscriminatorUShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_discriminator_ushort;
}

/*!
 * @brief This function copies the value in member var_union_discriminator_ushort
 * @param _var_union_discriminator_ushort New value to be copied in member var_union_discriminator_ushort
 */
void UnionDiscriminatorUShort::var_union_discriminator_ushort(
        const Union_Discriminator_unsigned_short& _var_union_discriminator_ushort)
{
    m_var_union_discriminator_ushort = _var_union_discriminator_ushort;
}

/*!
 * @brief This function moves the value in member var_union_discriminator_ushort
 * @param _var_union_discriminator_ushort New value to be moved in member var_union_discriminator_ushort
 */
void UnionDiscriminatorUShort::var_union_discriminator_ushort(
        Union_Discriminator_unsigned_short&& _var_union_discriminator_ushort)
{
    m_var_union_discriminator_ushort = std::move(_var_union_discriminator_ushort);
}

/*!
 * @brief This function returns a constant reference to member var_union_discriminator_ushort
 * @return Constant reference to member var_union_discriminator_ushort
 */
const Union_Discriminator_unsigned_short& UnionDiscriminatorUShort::var_union_discriminator_ushort() const
{
    return m_var_union_discriminator_ushort;
}

/*!
 * @brief This function returns a reference to member var_union_discriminator_ushort
 * @return Reference to member var_union_discriminator_ushort
 */
Union_Discriminator_unsigned_short& UnionDiscriminatorUShort::var_union_discriminator_ushort()
{
    return m_var_union_discriminator_ushort;
}


size_t UnionDiscriminatorUShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorUShort_max_key_cdr_typesize;
}

bool UnionDiscriminatorUShort::isKeyDefined()
{
    return false;
}

void UnionDiscriminatorUShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionDiscriminatorLong::UnionDiscriminatorLong()
{
    // Union_Discriminator_long m_var_union_discriminator_long


    // Just to register all known types
    registerunionsTypes();
}

UnionDiscriminatorLong::~UnionDiscriminatorLong()
{
}

UnionDiscriminatorLong::UnionDiscriminatorLong(
        const UnionDiscriminatorLong& x)
{
    m_var_union_discriminator_long = x.m_var_union_discriminator_long;
}

UnionDiscriminatorLong::UnionDiscriminatorLong(
        UnionDiscriminatorLong&& x) noexcept 
{
    m_var_union_discriminator_long = std::move(x.m_var_union_discriminator_long);
}

UnionDiscriminatorLong& UnionDiscriminatorLong::operator =(
        const UnionDiscriminatorLong& x)
{

    m_var_union_discriminator_long = x.m_var_union_discriminator_long;

    return *this;
}

UnionDiscriminatorLong& UnionDiscriminatorLong::operator =(
        UnionDiscriminatorLong&& x) noexcept
{

    m_var_union_discriminator_long = std::move(x.m_var_union_discriminator_long);

    return *this;
}

bool UnionDiscriminatorLong::operator ==(
        const UnionDiscriminatorLong& x) const
{

    return (m_var_union_discriminator_long == x.m_var_union_discriminator_long);
}

bool UnionDiscriminatorLong::operator !=(
        const UnionDiscriminatorLong& x) const
{
    return !(*this == x);
}

size_t UnionDiscriminatorLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorLong_max_cdr_typesize;
}

size_t UnionDiscriminatorLong::getCdrSerializedSize(
        const UnionDiscriminatorLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Discriminator_long::getCdrSerializedSize(data.var_union_discriminator_long(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionDiscriminatorLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_discriminator_long;
}

void UnionDiscriminatorLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_discriminator_long;
}

/*!
 * @brief This function copies the value in member var_union_discriminator_long
 * @param _var_union_discriminator_long New value to be copied in member var_union_discriminator_long
 */
void UnionDiscriminatorLong::var_union_discriminator_long(
        const Union_Discriminator_long& _var_union_discriminator_long)
{
    m_var_union_discriminator_long = _var_union_discriminator_long;
}

/*!
 * @brief This function moves the value in member var_union_discriminator_long
 * @param _var_union_discriminator_long New value to be moved in member var_union_discriminator_long
 */
void UnionDiscriminatorLong::var_union_discriminator_long(
        Union_Discriminator_long&& _var_union_discriminator_long)
{
    m_var_union_discriminator_long = std::move(_var_union_discriminator_long);
}

/*!
 * @brief This function returns a constant reference to member var_union_discriminator_long
 * @return Constant reference to member var_union_discriminator_long
 */
const Union_Discriminator_long& UnionDiscriminatorLong::var_union_discriminator_long() const
{
    return m_var_union_discriminator_long;
}

/*!
 * @brief This function returns a reference to member var_union_discriminator_long
 * @return Reference to member var_union_discriminator_long
 */
Union_Discriminator_long& UnionDiscriminatorLong::var_union_discriminator_long()
{
    return m_var_union_discriminator_long;
}


size_t UnionDiscriminatorLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorLong_max_key_cdr_typesize;
}

bool UnionDiscriminatorLong::isKeyDefined()
{
    return false;
}

void UnionDiscriminatorLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionDiscriminatorULong::UnionDiscriminatorULong()
{
    // Union_Discriminator_unsigned_long m_var_union_discriminator_ulong


    // Just to register all known types
    registerunionsTypes();
}

UnionDiscriminatorULong::~UnionDiscriminatorULong()
{
}

UnionDiscriminatorULong::UnionDiscriminatorULong(
        const UnionDiscriminatorULong& x)
{
    m_var_union_discriminator_ulong = x.m_var_union_discriminator_ulong;
}

UnionDiscriminatorULong::UnionDiscriminatorULong(
        UnionDiscriminatorULong&& x) noexcept 
{
    m_var_union_discriminator_ulong = std::move(x.m_var_union_discriminator_ulong);
}

UnionDiscriminatorULong& UnionDiscriminatorULong::operator =(
        const UnionDiscriminatorULong& x)
{

    m_var_union_discriminator_ulong = x.m_var_union_discriminator_ulong;

    return *this;
}

UnionDiscriminatorULong& UnionDiscriminatorULong::operator =(
        UnionDiscriminatorULong&& x) noexcept
{

    m_var_union_discriminator_ulong = std::move(x.m_var_union_discriminator_ulong);

    return *this;
}

bool UnionDiscriminatorULong::operator ==(
        const UnionDiscriminatorULong& x) const
{

    return (m_var_union_discriminator_ulong == x.m_var_union_discriminator_ulong);
}

bool UnionDiscriminatorULong::operator !=(
        const UnionDiscriminatorULong& x) const
{
    return !(*this == x);
}

size_t UnionDiscriminatorULong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorULong_max_cdr_typesize;
}

size_t UnionDiscriminatorULong::getCdrSerializedSize(
        const UnionDiscriminatorULong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Discriminator_unsigned_long::getCdrSerializedSize(data.var_union_discriminator_ulong(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionDiscriminatorULong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_discriminator_ulong;
}

void UnionDiscriminatorULong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_discriminator_ulong;
}

/*!
 * @brief This function copies the value in member var_union_discriminator_ulong
 * @param _var_union_discriminator_ulong New value to be copied in member var_union_discriminator_ulong
 */
void UnionDiscriminatorULong::var_union_discriminator_ulong(
        const Union_Discriminator_unsigned_long& _var_union_discriminator_ulong)
{
    m_var_union_discriminator_ulong = _var_union_discriminator_ulong;
}

/*!
 * @brief This function moves the value in member var_union_discriminator_ulong
 * @param _var_union_discriminator_ulong New value to be moved in member var_union_discriminator_ulong
 */
void UnionDiscriminatorULong::var_union_discriminator_ulong(
        Union_Discriminator_unsigned_long&& _var_union_discriminator_ulong)
{
    m_var_union_discriminator_ulong = std::move(_var_union_discriminator_ulong);
}

/*!
 * @brief This function returns a constant reference to member var_union_discriminator_ulong
 * @return Constant reference to member var_union_discriminator_ulong
 */
const Union_Discriminator_unsigned_long& UnionDiscriminatorULong::var_union_discriminator_ulong() const
{
    return m_var_union_discriminator_ulong;
}

/*!
 * @brief This function returns a reference to member var_union_discriminator_ulong
 * @return Reference to member var_union_discriminator_ulong
 */
Union_Discriminator_unsigned_long& UnionDiscriminatorULong::var_union_discriminator_ulong()
{
    return m_var_union_discriminator_ulong;
}


size_t UnionDiscriminatorULong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorULong_max_key_cdr_typesize;
}

bool UnionDiscriminatorULong::isKeyDefined()
{
    return false;
}

void UnionDiscriminatorULong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionDiscriminatorLongLong::UnionDiscriminatorLongLong()
{
    // Union_Discriminator_long_long m_var_union_discriminator_long_long


    // Just to register all known types
    registerunionsTypes();
}

UnionDiscriminatorLongLong::~UnionDiscriminatorLongLong()
{
}

UnionDiscriminatorLongLong::UnionDiscriminatorLongLong(
        const UnionDiscriminatorLongLong& x)
{
    m_var_union_discriminator_long_long = x.m_var_union_discriminator_long_long;
}

UnionDiscriminatorLongLong::UnionDiscriminatorLongLong(
        UnionDiscriminatorLongLong&& x) noexcept 
{
    m_var_union_discriminator_long_long = std::move(x.m_var_union_discriminator_long_long);
}

UnionDiscriminatorLongLong& UnionDiscriminatorLongLong::operator =(
        const UnionDiscriminatorLongLong& x)
{

    m_var_union_discriminator_long_long = x.m_var_union_discriminator_long_long;

    return *this;
}

UnionDiscriminatorLongLong& UnionDiscriminatorLongLong::operator =(
        UnionDiscriminatorLongLong&& x) noexcept
{

    m_var_union_discriminator_long_long = std::move(x.m_var_union_discriminator_long_long);

    return *this;
}

bool UnionDiscriminatorLongLong::operator ==(
        const UnionDiscriminatorLongLong& x) const
{

    return (m_var_union_discriminator_long_long == x.m_var_union_discriminator_long_long);
}

bool UnionDiscriminatorLongLong::operator !=(
        const UnionDiscriminatorLongLong& x) const
{
    return !(*this == x);
}

size_t UnionDiscriminatorLongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorLongLong_max_cdr_typesize;
}

size_t UnionDiscriminatorLongLong::getCdrSerializedSize(
        const UnionDiscriminatorLongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Discriminator_long_long::getCdrSerializedSize(data.var_union_discriminator_long_long(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionDiscriminatorLongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_discriminator_long_long;
}

void UnionDiscriminatorLongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_discriminator_long_long;
}

/*!
 * @brief This function copies the value in member var_union_discriminator_long_long
 * @param _var_union_discriminator_long_long New value to be copied in member var_union_discriminator_long_long
 */
void UnionDiscriminatorLongLong::var_union_discriminator_long_long(
        const Union_Discriminator_long_long& _var_union_discriminator_long_long)
{
    m_var_union_discriminator_long_long = _var_union_discriminator_long_long;
}

/*!
 * @brief This function moves the value in member var_union_discriminator_long_long
 * @param _var_union_discriminator_long_long New value to be moved in member var_union_discriminator_long_long
 */
void UnionDiscriminatorLongLong::var_union_discriminator_long_long(
        Union_Discriminator_long_long&& _var_union_discriminator_long_long)
{
    m_var_union_discriminator_long_long = std::move(_var_union_discriminator_long_long);
}

/*!
 * @brief This function returns a constant reference to member var_union_discriminator_long_long
 * @return Constant reference to member var_union_discriminator_long_long
 */
const Union_Discriminator_long_long& UnionDiscriminatorLongLong::var_union_discriminator_long_long() const
{
    return m_var_union_discriminator_long_long;
}

/*!
 * @brief This function returns a reference to member var_union_discriminator_long_long
 * @return Reference to member var_union_discriminator_long_long
 */
Union_Discriminator_long_long& UnionDiscriminatorLongLong::var_union_discriminator_long_long()
{
    return m_var_union_discriminator_long_long;
}


size_t UnionDiscriminatorLongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorLongLong_max_key_cdr_typesize;
}

bool UnionDiscriminatorLongLong::isKeyDefined()
{
    return false;
}

void UnionDiscriminatorLongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionDiscriminatorULongLong::UnionDiscriminatorULongLong()
{
    // Union_Discriminator_unsigned_long_long m_var_union_discriminator_ulong_long_long


    // Just to register all known types
    registerunionsTypes();
}

UnionDiscriminatorULongLong::~UnionDiscriminatorULongLong()
{
}

UnionDiscriminatorULongLong::UnionDiscriminatorULongLong(
        const UnionDiscriminatorULongLong& x)
{
    m_var_union_discriminator_ulong_long_long = x.m_var_union_discriminator_ulong_long_long;
}

UnionDiscriminatorULongLong::UnionDiscriminatorULongLong(
        UnionDiscriminatorULongLong&& x) noexcept 
{
    m_var_union_discriminator_ulong_long_long = std::move(x.m_var_union_discriminator_ulong_long_long);
}

UnionDiscriminatorULongLong& UnionDiscriminatorULongLong::operator =(
        const UnionDiscriminatorULongLong& x)
{

    m_var_union_discriminator_ulong_long_long = x.m_var_union_discriminator_ulong_long_long;

    return *this;
}

UnionDiscriminatorULongLong& UnionDiscriminatorULongLong::operator =(
        UnionDiscriminatorULongLong&& x) noexcept
{

    m_var_union_discriminator_ulong_long_long = std::move(x.m_var_union_discriminator_ulong_long_long);

    return *this;
}

bool UnionDiscriminatorULongLong::operator ==(
        const UnionDiscriminatorULongLong& x) const
{

    return (m_var_union_discriminator_ulong_long_long == x.m_var_union_discriminator_ulong_long_long);
}

bool UnionDiscriminatorULongLong::operator !=(
        const UnionDiscriminatorULongLong& x) const
{
    return !(*this == x);
}

size_t UnionDiscriminatorULongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorULongLong_max_cdr_typesize;
}

size_t UnionDiscriminatorULongLong::getCdrSerializedSize(
        const UnionDiscriminatorULongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Discriminator_unsigned_long_long::getCdrSerializedSize(data.var_union_discriminator_ulong_long_long(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionDiscriminatorULongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_discriminator_ulong_long_long;
}

void UnionDiscriminatorULongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_discriminator_ulong_long_long;
}

/*!
 * @brief This function copies the value in member var_union_discriminator_ulong_long_long
 * @param _var_union_discriminator_ulong_long_long New value to be copied in member var_union_discriminator_ulong_long_long
 */
void UnionDiscriminatorULongLong::var_union_discriminator_ulong_long_long(
        const Union_Discriminator_unsigned_long_long& _var_union_discriminator_ulong_long_long)
{
    m_var_union_discriminator_ulong_long_long = _var_union_discriminator_ulong_long_long;
}

/*!
 * @brief This function moves the value in member var_union_discriminator_ulong_long_long
 * @param _var_union_discriminator_ulong_long_long New value to be moved in member var_union_discriminator_ulong_long_long
 */
void UnionDiscriminatorULongLong::var_union_discriminator_ulong_long_long(
        Union_Discriminator_unsigned_long_long&& _var_union_discriminator_ulong_long_long)
{
    m_var_union_discriminator_ulong_long_long = std::move(_var_union_discriminator_ulong_long_long);
}

/*!
 * @brief This function returns a constant reference to member var_union_discriminator_ulong_long_long
 * @return Constant reference to member var_union_discriminator_ulong_long_long
 */
const Union_Discriminator_unsigned_long_long& UnionDiscriminatorULongLong::var_union_discriminator_ulong_long_long() const
{
    return m_var_union_discriminator_ulong_long_long;
}

/*!
 * @brief This function returns a reference to member var_union_discriminator_ulong_long_long
 * @return Reference to member var_union_discriminator_ulong_long_long
 */
Union_Discriminator_unsigned_long_long& UnionDiscriminatorULongLong::var_union_discriminator_ulong_long_long()
{
    return m_var_union_discriminator_ulong_long_long;
}


size_t UnionDiscriminatorULongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorULongLong_max_key_cdr_typesize;
}

bool UnionDiscriminatorULongLong::isKeyDefined()
{
    return false;
}

void UnionDiscriminatorULongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionDiscriminatorBoolean::UnionDiscriminatorBoolean()
{
    // Union_Discriminator_boolean m_var_union_discriminator_boolean


    // Just to register all known types
    registerunionsTypes();
}

UnionDiscriminatorBoolean::~UnionDiscriminatorBoolean()
{
}

UnionDiscriminatorBoolean::UnionDiscriminatorBoolean(
        const UnionDiscriminatorBoolean& x)
{
    m_var_union_discriminator_boolean = x.m_var_union_discriminator_boolean;
}

UnionDiscriminatorBoolean::UnionDiscriminatorBoolean(
        UnionDiscriminatorBoolean&& x) noexcept 
{
    m_var_union_discriminator_boolean = std::move(x.m_var_union_discriminator_boolean);
}

UnionDiscriminatorBoolean& UnionDiscriminatorBoolean::operator =(
        const UnionDiscriminatorBoolean& x)
{

    m_var_union_discriminator_boolean = x.m_var_union_discriminator_boolean;

    return *this;
}

UnionDiscriminatorBoolean& UnionDiscriminatorBoolean::operator =(
        UnionDiscriminatorBoolean&& x) noexcept
{

    m_var_union_discriminator_boolean = std::move(x.m_var_union_discriminator_boolean);

    return *this;
}

bool UnionDiscriminatorBoolean::operator ==(
        const UnionDiscriminatorBoolean& x) const
{

    return (m_var_union_discriminator_boolean == x.m_var_union_discriminator_boolean);
}

bool UnionDiscriminatorBoolean::operator !=(
        const UnionDiscriminatorBoolean& x) const
{
    return !(*this == x);
}

size_t UnionDiscriminatorBoolean::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorBoolean_max_cdr_typesize;
}

size_t UnionDiscriminatorBoolean::getCdrSerializedSize(
        const UnionDiscriminatorBoolean& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Discriminator_boolean::getCdrSerializedSize(data.var_union_discriminator_boolean(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionDiscriminatorBoolean::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_discriminator_boolean;
}

void UnionDiscriminatorBoolean::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_discriminator_boolean;
}

/*!
 * @brief This function copies the value in member var_union_discriminator_boolean
 * @param _var_union_discriminator_boolean New value to be copied in member var_union_discriminator_boolean
 */
void UnionDiscriminatorBoolean::var_union_discriminator_boolean(
        const Union_Discriminator_boolean& _var_union_discriminator_boolean)
{
    m_var_union_discriminator_boolean = _var_union_discriminator_boolean;
}

/*!
 * @brief This function moves the value in member var_union_discriminator_boolean
 * @param _var_union_discriminator_boolean New value to be moved in member var_union_discriminator_boolean
 */
void UnionDiscriminatorBoolean::var_union_discriminator_boolean(
        Union_Discriminator_boolean&& _var_union_discriminator_boolean)
{
    m_var_union_discriminator_boolean = std::move(_var_union_discriminator_boolean);
}

/*!
 * @brief This function returns a constant reference to member var_union_discriminator_boolean
 * @return Constant reference to member var_union_discriminator_boolean
 */
const Union_Discriminator_boolean& UnionDiscriminatorBoolean::var_union_discriminator_boolean() const
{
    return m_var_union_discriminator_boolean;
}

/*!
 * @brief This function returns a reference to member var_union_discriminator_boolean
 * @return Reference to member var_union_discriminator_boolean
 */
Union_Discriminator_boolean& UnionDiscriminatorBoolean::var_union_discriminator_boolean()
{
    return m_var_union_discriminator_boolean;
}


size_t UnionDiscriminatorBoolean::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorBoolean_max_key_cdr_typesize;
}

bool UnionDiscriminatorBoolean::isKeyDefined()
{
    return false;
}

void UnionDiscriminatorBoolean::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionDiscriminatorOctet::UnionDiscriminatorOctet()
{
    // Union_Discriminator_octet m_var_union_discriminator_octet


    // Just to register all known types
    registerunionsTypes();
}

UnionDiscriminatorOctet::~UnionDiscriminatorOctet()
{
}

UnionDiscriminatorOctet::UnionDiscriminatorOctet(
        const UnionDiscriminatorOctet& x)
{
    m_var_union_discriminator_octet = x.m_var_union_discriminator_octet;
}

UnionDiscriminatorOctet::UnionDiscriminatorOctet(
        UnionDiscriminatorOctet&& x) noexcept 
{
    m_var_union_discriminator_octet = std::move(x.m_var_union_discriminator_octet);
}

UnionDiscriminatorOctet& UnionDiscriminatorOctet::operator =(
        const UnionDiscriminatorOctet& x)
{

    m_var_union_discriminator_octet = x.m_var_union_discriminator_octet;

    return *this;
}

UnionDiscriminatorOctet& UnionDiscriminatorOctet::operator =(
        UnionDiscriminatorOctet&& x) noexcept
{

    m_var_union_discriminator_octet = std::move(x.m_var_union_discriminator_octet);

    return *this;
}

bool UnionDiscriminatorOctet::operator ==(
        const UnionDiscriminatorOctet& x) const
{

    return (m_var_union_discriminator_octet == x.m_var_union_discriminator_octet);
}

bool UnionDiscriminatorOctet::operator !=(
        const UnionDiscriminatorOctet& x) const
{
    return !(*this == x);
}

size_t UnionDiscriminatorOctet::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorOctet_max_cdr_typesize;
}

size_t UnionDiscriminatorOctet::getCdrSerializedSize(
        const UnionDiscriminatorOctet& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Discriminator_octet::getCdrSerializedSize(data.var_union_discriminator_octet(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionDiscriminatorOctet::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_discriminator_octet;
}

void UnionDiscriminatorOctet::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_discriminator_octet;
}

/*!
 * @brief This function copies the value in member var_union_discriminator_octet
 * @param _var_union_discriminator_octet New value to be copied in member var_union_discriminator_octet
 */
void UnionDiscriminatorOctet::var_union_discriminator_octet(
        const Union_Discriminator_octet& _var_union_discriminator_octet)
{
    m_var_union_discriminator_octet = _var_union_discriminator_octet;
}

/*!
 * @brief This function moves the value in member var_union_discriminator_octet
 * @param _var_union_discriminator_octet New value to be moved in member var_union_discriminator_octet
 */
void UnionDiscriminatorOctet::var_union_discriminator_octet(
        Union_Discriminator_octet&& _var_union_discriminator_octet)
{
    m_var_union_discriminator_octet = std::move(_var_union_discriminator_octet);
}

/*!
 * @brief This function returns a constant reference to member var_union_discriminator_octet
 * @return Constant reference to member var_union_discriminator_octet
 */
const Union_Discriminator_octet& UnionDiscriminatorOctet::var_union_discriminator_octet() const
{
    return m_var_union_discriminator_octet;
}

/*!
 * @brief This function returns a reference to member var_union_discriminator_octet
 * @return Reference to member var_union_discriminator_octet
 */
Union_Discriminator_octet& UnionDiscriminatorOctet::var_union_discriminator_octet()
{
    return m_var_union_discriminator_octet;
}


size_t UnionDiscriminatorOctet::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorOctet_max_key_cdr_typesize;
}

bool UnionDiscriminatorOctet::isKeyDefined()
{
    return false;
}

void UnionDiscriminatorOctet::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionDiscriminatorChar::UnionDiscriminatorChar()
{
    // Union_Discriminator_char m_var_union_discriminator_char


    // Just to register all known types
    registerunionsTypes();
}

UnionDiscriminatorChar::~UnionDiscriminatorChar()
{
}

UnionDiscriminatorChar::UnionDiscriminatorChar(
        const UnionDiscriminatorChar& x)
{
    m_var_union_discriminator_char = x.m_var_union_discriminator_char;
}

UnionDiscriminatorChar::UnionDiscriminatorChar(
        UnionDiscriminatorChar&& x) noexcept 
{
    m_var_union_discriminator_char = std::move(x.m_var_union_discriminator_char);
}

UnionDiscriminatorChar& UnionDiscriminatorChar::operator =(
        const UnionDiscriminatorChar& x)
{

    m_var_union_discriminator_char = x.m_var_union_discriminator_char;

    return *this;
}

UnionDiscriminatorChar& UnionDiscriminatorChar::operator =(
        UnionDiscriminatorChar&& x) noexcept
{

    m_var_union_discriminator_char = std::move(x.m_var_union_discriminator_char);

    return *this;
}

bool UnionDiscriminatorChar::operator ==(
        const UnionDiscriminatorChar& x) const
{

    return (m_var_union_discriminator_char == x.m_var_union_discriminator_char);
}

bool UnionDiscriminatorChar::operator !=(
        const UnionDiscriminatorChar& x) const
{
    return !(*this == x);
}

size_t UnionDiscriminatorChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorChar_max_cdr_typesize;
}

size_t UnionDiscriminatorChar::getCdrSerializedSize(
        const UnionDiscriminatorChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Discriminator_char::getCdrSerializedSize(data.var_union_discriminator_char(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionDiscriminatorChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_discriminator_char;
}

void UnionDiscriminatorChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_discriminator_char;
}

/*!
 * @brief This function copies the value in member var_union_discriminator_char
 * @param _var_union_discriminator_char New value to be copied in member var_union_discriminator_char
 */
void UnionDiscriminatorChar::var_union_discriminator_char(
        const Union_Discriminator_char& _var_union_discriminator_char)
{
    m_var_union_discriminator_char = _var_union_discriminator_char;
}

/*!
 * @brief This function moves the value in member var_union_discriminator_char
 * @param _var_union_discriminator_char New value to be moved in member var_union_discriminator_char
 */
void UnionDiscriminatorChar::var_union_discriminator_char(
        Union_Discriminator_char&& _var_union_discriminator_char)
{
    m_var_union_discriminator_char = std::move(_var_union_discriminator_char);
}

/*!
 * @brief This function returns a constant reference to member var_union_discriminator_char
 * @return Constant reference to member var_union_discriminator_char
 */
const Union_Discriminator_char& UnionDiscriminatorChar::var_union_discriminator_char() const
{
    return m_var_union_discriminator_char;
}

/*!
 * @brief This function returns a reference to member var_union_discriminator_char
 * @return Reference to member var_union_discriminator_char
 */
Union_Discriminator_char& UnionDiscriminatorChar::var_union_discriminator_char()
{
    return m_var_union_discriminator_char;
}


size_t UnionDiscriminatorChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorChar_max_key_cdr_typesize;
}

bool UnionDiscriminatorChar::isKeyDefined()
{
    return false;
}

void UnionDiscriminatorChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionDiscriminatorWChar::UnionDiscriminatorWChar()
{
    // Union_Discriminator_wchar m_var_union_discriminator_wchar


    // Just to register all known types
    registerunionsTypes();
}

UnionDiscriminatorWChar::~UnionDiscriminatorWChar()
{
}

UnionDiscriminatorWChar::UnionDiscriminatorWChar(
        const UnionDiscriminatorWChar& x)
{
    m_var_union_discriminator_wchar = x.m_var_union_discriminator_wchar;
}

UnionDiscriminatorWChar::UnionDiscriminatorWChar(
        UnionDiscriminatorWChar&& x) noexcept 
{
    m_var_union_discriminator_wchar = std::move(x.m_var_union_discriminator_wchar);
}

UnionDiscriminatorWChar& UnionDiscriminatorWChar::operator =(
        const UnionDiscriminatorWChar& x)
{

    m_var_union_discriminator_wchar = x.m_var_union_discriminator_wchar;

    return *this;
}

UnionDiscriminatorWChar& UnionDiscriminatorWChar::operator =(
        UnionDiscriminatorWChar&& x) noexcept
{

    m_var_union_discriminator_wchar = std::move(x.m_var_union_discriminator_wchar);

    return *this;
}

bool UnionDiscriminatorWChar::operator ==(
        const UnionDiscriminatorWChar& x) const
{

    return (m_var_union_discriminator_wchar == x.m_var_union_discriminator_wchar);
}

bool UnionDiscriminatorWChar::operator !=(
        const UnionDiscriminatorWChar& x) const
{
    return !(*this == x);
}

size_t UnionDiscriminatorWChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorWChar_max_cdr_typesize;
}

size_t UnionDiscriminatorWChar::getCdrSerializedSize(
        const UnionDiscriminatorWChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Discriminator_wchar::getCdrSerializedSize(data.var_union_discriminator_wchar(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionDiscriminatorWChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_discriminator_wchar;
}

void UnionDiscriminatorWChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_discriminator_wchar;
}

/*!
 * @brief This function copies the value in member var_union_discriminator_wchar
 * @param _var_union_discriminator_wchar New value to be copied in member var_union_discriminator_wchar
 */
void UnionDiscriminatorWChar::var_union_discriminator_wchar(
        const Union_Discriminator_wchar& _var_union_discriminator_wchar)
{
    m_var_union_discriminator_wchar = _var_union_discriminator_wchar;
}

/*!
 * @brief This function moves the value in member var_union_discriminator_wchar
 * @param _var_union_discriminator_wchar New value to be moved in member var_union_discriminator_wchar
 */
void UnionDiscriminatorWChar::var_union_discriminator_wchar(
        Union_Discriminator_wchar&& _var_union_discriminator_wchar)
{
    m_var_union_discriminator_wchar = std::move(_var_union_discriminator_wchar);
}

/*!
 * @brief This function returns a constant reference to member var_union_discriminator_wchar
 * @return Constant reference to member var_union_discriminator_wchar
 */
const Union_Discriminator_wchar& UnionDiscriminatorWChar::var_union_discriminator_wchar() const
{
    return m_var_union_discriminator_wchar;
}

/*!
 * @brief This function returns a reference to member var_union_discriminator_wchar
 * @return Reference to member var_union_discriminator_wchar
 */
Union_Discriminator_wchar& UnionDiscriminatorWChar::var_union_discriminator_wchar()
{
    return m_var_union_discriminator_wchar;
}


size_t UnionDiscriminatorWChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorWChar_max_key_cdr_typesize;
}

bool UnionDiscriminatorWChar::isKeyDefined()
{
    return false;
}

void UnionDiscriminatorWChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionDiscriminatorEnum::UnionDiscriminatorEnum()
{
    // Union_Discriminator_enum m_var_union_discriminator_enum


    // Just to register all known types
    registerunionsTypes();
}

UnionDiscriminatorEnum::~UnionDiscriminatorEnum()
{
}

UnionDiscriminatorEnum::UnionDiscriminatorEnum(
        const UnionDiscriminatorEnum& x)
{
    m_var_union_discriminator_enum = x.m_var_union_discriminator_enum;
}

UnionDiscriminatorEnum::UnionDiscriminatorEnum(
        UnionDiscriminatorEnum&& x) noexcept 
{
    m_var_union_discriminator_enum = std::move(x.m_var_union_discriminator_enum);
}

UnionDiscriminatorEnum& UnionDiscriminatorEnum::operator =(
        const UnionDiscriminatorEnum& x)
{

    m_var_union_discriminator_enum = x.m_var_union_discriminator_enum;

    return *this;
}

UnionDiscriminatorEnum& UnionDiscriminatorEnum::operator =(
        UnionDiscriminatorEnum&& x) noexcept
{

    m_var_union_discriminator_enum = std::move(x.m_var_union_discriminator_enum);

    return *this;
}

bool UnionDiscriminatorEnum::operator ==(
        const UnionDiscriminatorEnum& x) const
{

    return (m_var_union_discriminator_enum == x.m_var_union_discriminator_enum);
}

bool UnionDiscriminatorEnum::operator !=(
        const UnionDiscriminatorEnum& x) const
{
    return !(*this == x);
}

size_t UnionDiscriminatorEnum::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorEnum_max_cdr_typesize;
}

size_t UnionDiscriminatorEnum::getCdrSerializedSize(
        const UnionDiscriminatorEnum& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Discriminator_enum::getCdrSerializedSize(data.var_union_discriminator_enum(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionDiscriminatorEnum::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_discriminator_enum;
}

void UnionDiscriminatorEnum::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_discriminator_enum;
}

/*!
 * @brief This function copies the value in member var_union_discriminator_enum
 * @param _var_union_discriminator_enum New value to be copied in member var_union_discriminator_enum
 */
void UnionDiscriminatorEnum::var_union_discriminator_enum(
        const Union_Discriminator_enum& _var_union_discriminator_enum)
{
    m_var_union_discriminator_enum = _var_union_discriminator_enum;
}

/*!
 * @brief This function moves the value in member var_union_discriminator_enum
 * @param _var_union_discriminator_enum New value to be moved in member var_union_discriminator_enum
 */
void UnionDiscriminatorEnum::var_union_discriminator_enum(
        Union_Discriminator_enum&& _var_union_discriminator_enum)
{
    m_var_union_discriminator_enum = std::move(_var_union_discriminator_enum);
}

/*!
 * @brief This function returns a constant reference to member var_union_discriminator_enum
 * @return Constant reference to member var_union_discriminator_enum
 */
const Union_Discriminator_enum& UnionDiscriminatorEnum::var_union_discriminator_enum() const
{
    return m_var_union_discriminator_enum;
}

/*!
 * @brief This function returns a reference to member var_union_discriminator_enum
 * @return Reference to member var_union_discriminator_enum
 */
Union_Discriminator_enum& UnionDiscriminatorEnum::var_union_discriminator_enum()
{
    return m_var_union_discriminator_enum;
}


size_t UnionDiscriminatorEnum::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorEnum_max_key_cdr_typesize;
}

bool UnionDiscriminatorEnum::isKeyDefined()
{
    return false;
}

void UnionDiscriminatorEnum::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


UnionDiscriminatorAlias::UnionDiscriminatorAlias()
{
    // Union_Discriminator_alias m_var_union_discriminator_alias


    // Just to register all known types
    registerunionsTypes();
}

UnionDiscriminatorAlias::~UnionDiscriminatorAlias()
{
}

UnionDiscriminatorAlias::UnionDiscriminatorAlias(
        const UnionDiscriminatorAlias& x)
{
    m_var_union_discriminator_alias = x.m_var_union_discriminator_alias;
}

UnionDiscriminatorAlias::UnionDiscriminatorAlias(
        UnionDiscriminatorAlias&& x) noexcept 
{
    m_var_union_discriminator_alias = std::move(x.m_var_union_discriminator_alias);
}

UnionDiscriminatorAlias& UnionDiscriminatorAlias::operator =(
        const UnionDiscriminatorAlias& x)
{

    m_var_union_discriminator_alias = x.m_var_union_discriminator_alias;

    return *this;
}

UnionDiscriminatorAlias& UnionDiscriminatorAlias::operator =(
        UnionDiscriminatorAlias&& x) noexcept
{

    m_var_union_discriminator_alias = std::move(x.m_var_union_discriminator_alias);

    return *this;
}

bool UnionDiscriminatorAlias::operator ==(
        const UnionDiscriminatorAlias& x) const
{

    return (m_var_union_discriminator_alias == x.m_var_union_discriminator_alias);
}

bool UnionDiscriminatorAlias::operator !=(
        const UnionDiscriminatorAlias& x) const
{
    return !(*this == x);
}

size_t UnionDiscriminatorAlias::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorAlias_max_cdr_typesize;
}

size_t UnionDiscriminatorAlias::getCdrSerializedSize(
        const UnionDiscriminatorAlias& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Union_Discriminator_alias::getCdrSerializedSize(data.var_union_discriminator_alias(), current_alignment);

    return current_alignment - initial_alignment;
}

void UnionDiscriminatorAlias::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_union_discriminator_alias;
}

void UnionDiscriminatorAlias::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_union_discriminator_alias;
}

/*!
 * @brief This function copies the value in member var_union_discriminator_alias
 * @param _var_union_discriminator_alias New value to be copied in member var_union_discriminator_alias
 */
void UnionDiscriminatorAlias::var_union_discriminator_alias(
        const Union_Discriminator_alias& _var_union_discriminator_alias)
{
    m_var_union_discriminator_alias = _var_union_discriminator_alias;
}

/*!
 * @brief This function moves the value in member var_union_discriminator_alias
 * @param _var_union_discriminator_alias New value to be moved in member var_union_discriminator_alias
 */
void UnionDiscriminatorAlias::var_union_discriminator_alias(
        Union_Discriminator_alias&& _var_union_discriminator_alias)
{
    m_var_union_discriminator_alias = std::move(_var_union_discriminator_alias);
}

/*!
 * @brief This function returns a constant reference to member var_union_discriminator_alias
 * @return Constant reference to member var_union_discriminator_alias
 */
const Union_Discriminator_alias& UnionDiscriminatorAlias::var_union_discriminator_alias() const
{
    return m_var_union_discriminator_alias;
}

/*!
 * @brief This function returns a reference to member var_union_discriminator_alias
 * @return Reference to member var_union_discriminator_alias
 */
Union_Discriminator_alias& UnionDiscriminatorAlias::var_union_discriminator_alias()
{
    return m_var_union_discriminator_alias;
}


size_t UnionDiscriminatorAlias::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return UnionDiscriminatorAlias_max_key_cdr_typesize;
}

bool UnionDiscriminatorAlias::isKeyDefined()
{
    return false;
}

void UnionDiscriminatorAlias::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

