// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file unionsTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "unions.h"
#include "unionsTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

void registerunionsTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(true),
                GetInnerEnumHelperObject(true));
                factory->add_type_object("InnerEnumHelper", GetInnerEnumHelperIdentifier(false),
                GetInnerEnumHelperObject(false));

                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(true),
                GetInnerBitMaskHelperObject(true));
                factory->add_type_object("InnerBitMaskHelper", GetInnerBitMaskHelperIdentifier(false),
                GetInnerBitMaskHelperObject(false));

                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(true),
                GetInnerAliasHelperObject(true));
                factory->add_type_object("InnerAliasHelper", GetInnerAliasHelperIdentifier(false),
                GetInnerAliasHelperObject(false));

                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(true),
                GetInnerStructureHelperObject(true));
                factory->add_type_object("InnerStructureHelper", GetInnerStructureHelperIdentifier(false),
                GetInnerStructureHelperObject(false));

                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(true),
                GetInnerEmptyStructureHelperObject(true));
                factory->add_type_object("InnerEmptyStructureHelper", GetInnerEmptyStructureHelperIdentifier(false),
                GetInnerEmptyStructureHelperObject(false));

                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(true),
                GetInnerUnionHelperObject(true));
                factory->add_type_object("InnerUnionHelper", GetInnerUnionHelperIdentifier(false),
                GetInnerUnionHelperObject(false));

                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(true),
                GetInnerBitsetHelperObject(true));
                factory->add_type_object("InnerBitsetHelper", GetInnerBitsetHelperIdentifier(false),
                GetInnerBitsetHelperObject(false));

                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(true),
                GetInner_alias_bounded_string_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_string_helper", GetInner_alias_bounded_string_helperIdentifier(false),
                GetInner_alias_bounded_string_helperObject(false));

                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(true),
                GetInner_alias_bounded_wstring_helperObject(true));
                factory->add_type_object("Inner_alias_bounded_wstring_helper", GetInner_alias_bounded_wstring_helperIdentifier(false),
                GetInner_alias_bounded_wstring_helperObject(false));

                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(true),
                GetInner_alias_array_helperObject(true));
                factory->add_type_object("Inner_alias_array_helper", GetInner_alias_array_helperIdentifier(false),
                GetInner_alias_array_helperObject(false));

                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(true),
                GetInner_alias_sequence_helperObject(true));
                factory->add_type_object("Inner_alias_sequence_helper", GetInner_alias_sequence_helperIdentifier(false),
                GetInner_alias_sequence_helperObject(false));

                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(true),
                GetInner_alias_map_helperObject(true));
                factory->add_type_object("Inner_alias_map_helper", GetInner_alias_map_helperIdentifier(false),
                GetInner_alias_map_helperObject(false));

                factory->add_type_object("Union_Short", GetUnion_ShortIdentifier(true),
                GetUnion_ShortObject(true));
                factory->add_type_object("Union_Short", GetUnion_ShortIdentifier(false),
                GetUnion_ShortObject(false));

                factory->add_type_object("Union_UShort", GetUnion_UShortIdentifier(true),
                GetUnion_UShortObject(true));
                factory->add_type_object("Union_UShort", GetUnion_UShortIdentifier(false),
                GetUnion_UShortObject(false));

                factory->add_type_object("Union_Long", GetUnion_LongIdentifier(true),
                GetUnion_LongObject(true));
                factory->add_type_object("Union_Long", GetUnion_LongIdentifier(false),
                GetUnion_LongObject(false));

                factory->add_type_object("Union_ULong", GetUnion_ULongIdentifier(true),
                GetUnion_ULongObject(true));
                factory->add_type_object("Union_ULong", GetUnion_ULongIdentifier(false),
                GetUnion_ULongObject(false));

                factory->add_type_object("Union_LongLong", GetUnion_LongLongIdentifier(true),
                GetUnion_LongLongObject(true));
                factory->add_type_object("Union_LongLong", GetUnion_LongLongIdentifier(false),
                GetUnion_LongLongObject(false));

                factory->add_type_object("Union_ULongLOng", GetUnion_ULongLOngIdentifier(true),
                GetUnion_ULongLOngObject(true));
                factory->add_type_object("Union_ULongLOng", GetUnion_ULongLOngIdentifier(false),
                GetUnion_ULongLOngObject(false));

                factory->add_type_object("Union_Float", GetUnion_FloatIdentifier(true),
                GetUnion_FloatObject(true));
                factory->add_type_object("Union_Float", GetUnion_FloatIdentifier(false),
                GetUnion_FloatObject(false));

                factory->add_type_object("Union_Double", GetUnion_DoubleIdentifier(true),
                GetUnion_DoubleObject(true));
                factory->add_type_object("Union_Double", GetUnion_DoubleIdentifier(false),
                GetUnion_DoubleObject(false));

                factory->add_type_object("Union_LongDouble", GetUnion_LongDoubleIdentifier(true),
                GetUnion_LongDoubleObject(true));
                factory->add_type_object("Union_LongDouble", GetUnion_LongDoubleIdentifier(false),
                GetUnion_LongDoubleObject(false));

                factory->add_type_object("Union_Boolean", GetUnion_BooleanIdentifier(true),
                GetUnion_BooleanObject(true));
                factory->add_type_object("Union_Boolean", GetUnion_BooleanIdentifier(false),
                GetUnion_BooleanObject(false));

                factory->add_type_object("Union_Octet", GetUnion_OctetIdentifier(true),
                GetUnion_OctetObject(true));
                factory->add_type_object("Union_Octet", GetUnion_OctetIdentifier(false),
                GetUnion_OctetObject(false));

                factory->add_type_object("Union_Char", GetUnion_CharIdentifier(true),
                GetUnion_CharObject(true));
                factory->add_type_object("Union_Char", GetUnion_CharIdentifier(false),
                GetUnion_CharObject(false));

                factory->add_type_object("Union_WChar", GetUnion_WCharIdentifier(true),
                GetUnion_WCharObject(true));
                factory->add_type_object("Union_WChar", GetUnion_WCharIdentifier(false),
                GetUnion_WCharObject(false));

                factory->add_type_object("Union_String", GetUnion_StringIdentifier(true),
                GetUnion_StringObject(true));
                factory->add_type_object("Union_String", GetUnion_StringIdentifier(false),
                GetUnion_StringObject(false));

                factory->add_type_object("Union_WString", GetUnion_WStringIdentifier(true),
                GetUnion_WStringObject(true));
                factory->add_type_object("Union_WString", GetUnion_WStringIdentifier(false),
                GetUnion_WStringObject(false));

                factory->add_type_object("Union_BoundedString", GetUnion_BoundedStringIdentifier(true),
                GetUnion_BoundedStringObject(true));
                factory->add_type_object("Union_BoundedString", GetUnion_BoundedStringIdentifier(false),
                GetUnion_BoundedStringObject(false));

                factory->add_type_object("Union_BoundedWString", GetUnion_BoundedWStringIdentifier(true),
                GetUnion_BoundedWStringObject(true));
                factory->add_type_object("Union_BoundedWString", GetUnion_BoundedWStringIdentifier(false),
                GetUnion_BoundedWStringObject(false));

                factory->add_type_object("Union_InnerEnumHelper", GetUnion_InnerEnumHelperIdentifier(true),
                GetUnion_InnerEnumHelperObject(true));
                factory->add_type_object("Union_InnerEnumHelper", GetUnion_InnerEnumHelperIdentifier(false),
                GetUnion_InnerEnumHelperObject(false));

                factory->add_type_object("Union_InnerBitMaskHelper", GetUnion_InnerBitMaskHelperIdentifier(true),
                GetUnion_InnerBitMaskHelperObject(true));
                factory->add_type_object("Union_InnerBitMaskHelper", GetUnion_InnerBitMaskHelperIdentifier(false),
                GetUnion_InnerBitMaskHelperObject(false));

                factory->add_type_object("Union_InnerAliasHelper", GetUnion_InnerAliasHelperIdentifier(true),
                GetUnion_InnerAliasHelperObject(true));
                factory->add_type_object("Union_InnerAliasHelper", GetUnion_InnerAliasHelperIdentifier(false),
                GetUnion_InnerAliasHelperObject(false));

                factory->add_type_object("Union_Array", GetUnion_ArrayIdentifier(true),
                GetUnion_ArrayObject(true));
                factory->add_type_object("Union_Array", GetUnion_ArrayIdentifier(false),
                GetUnion_ArrayObject(false));

                factory->add_type_object("Union_Sequence", GetUnion_SequenceIdentifier(true),
                GetUnion_SequenceObject(true));
                factory->add_type_object("Union_Sequence", GetUnion_SequenceIdentifier(false),
                GetUnion_SequenceObject(false));

                factory->add_type_object("Union_Map", GetUnion_MapIdentifier(true),
                GetUnion_MapObject(true));
                factory->add_type_object("Union_Map", GetUnion_MapIdentifier(false),
                GetUnion_MapObject(false));

                factory->add_type_object("Union_InnerUnionHelper", GetUnion_InnerUnionHelperIdentifier(true),
                GetUnion_InnerUnionHelperObject(true));
                factory->add_type_object("Union_InnerUnionHelper", GetUnion_InnerUnionHelperIdentifier(false),
                GetUnion_InnerUnionHelperObject(false));

                factory->add_type_object("Union_InnerStructureHelper", GetUnion_InnerStructureHelperIdentifier(true),
                GetUnion_InnerStructureHelperObject(true));
                factory->add_type_object("Union_InnerStructureHelper", GetUnion_InnerStructureHelperIdentifier(false),
                GetUnion_InnerStructureHelperObject(false));

                factory->add_type_object("Union_InnerBitsetHelper", GetUnion_InnerBitsetHelperIdentifier(true),
                GetUnion_InnerBitsetHelperObject(true));
                factory->add_type_object("Union_InnerBitsetHelper", GetUnion_InnerBitsetHelperIdentifier(false),
                GetUnion_InnerBitsetHelperObject(false));

                factory->add_type_object("Union_Discriminator_short", GetUnion_Discriminator_shortIdentifier(true),
                GetUnion_Discriminator_shortObject(true));
                factory->add_type_object("Union_Discriminator_short", GetUnion_Discriminator_shortIdentifier(false),
                GetUnion_Discriminator_shortObject(false));

                factory->add_type_object("Union_Discriminator_unsigned_short", GetUnion_Discriminator_unsigned_shortIdentifier(true),
                GetUnion_Discriminator_unsigned_shortObject(true));
                factory->add_type_object("Union_Discriminator_unsigned_short", GetUnion_Discriminator_unsigned_shortIdentifier(false),
                GetUnion_Discriminator_unsigned_shortObject(false));

                factory->add_type_object("Union_Discriminator_long", GetUnion_Discriminator_longIdentifier(true),
                GetUnion_Discriminator_longObject(true));
                factory->add_type_object("Union_Discriminator_long", GetUnion_Discriminator_longIdentifier(false),
                GetUnion_Discriminator_longObject(false));

                factory->add_type_object("Union_Discriminator_unsigned_long", GetUnion_Discriminator_unsigned_longIdentifier(true),
                GetUnion_Discriminator_unsigned_longObject(true));
                factory->add_type_object("Union_Discriminator_unsigned_long", GetUnion_Discriminator_unsigned_longIdentifier(false),
                GetUnion_Discriminator_unsigned_longObject(false));

                factory->add_type_object("Union_Discriminator_long_long", GetUnion_Discriminator_long_longIdentifier(true),
                GetUnion_Discriminator_long_longObject(true));
                factory->add_type_object("Union_Discriminator_long_long", GetUnion_Discriminator_long_longIdentifier(false),
                GetUnion_Discriminator_long_longObject(false));

                factory->add_type_object("Union_Discriminator_unsigned_long_long", GetUnion_Discriminator_unsigned_long_longIdentifier(true),
                GetUnion_Discriminator_unsigned_long_longObject(true));
                factory->add_type_object("Union_Discriminator_unsigned_long_long", GetUnion_Discriminator_unsigned_long_longIdentifier(false),
                GetUnion_Discriminator_unsigned_long_longObject(false));

                factory->add_type_object("Union_Discriminator_boolean", GetUnion_Discriminator_booleanIdentifier(true),
                GetUnion_Discriminator_booleanObject(true));
                factory->add_type_object("Union_Discriminator_boolean", GetUnion_Discriminator_booleanIdentifier(false),
                GetUnion_Discriminator_booleanObject(false));

                factory->add_type_object("Union_Discriminator_octet", GetUnion_Discriminator_octetIdentifier(true),
                GetUnion_Discriminator_octetObject(true));
                factory->add_type_object("Union_Discriminator_octet", GetUnion_Discriminator_octetIdentifier(false),
                GetUnion_Discriminator_octetObject(false));

                factory->add_type_object("Union_Discriminator_char", GetUnion_Discriminator_charIdentifier(true),
                GetUnion_Discriminator_charObject(true));
                factory->add_type_object("Union_Discriminator_char", GetUnion_Discriminator_charIdentifier(false),
                GetUnion_Discriminator_charObject(false));

                factory->add_type_object("Union_Discriminator_wchar", GetUnion_Discriminator_wcharIdentifier(true),
                GetUnion_Discriminator_wcharObject(true));
                factory->add_type_object("Union_Discriminator_wchar", GetUnion_Discriminator_wcharIdentifier(false),
                GetUnion_Discriminator_wcharObject(false));

                factory->add_type_object("Union_Discriminator_enum", GetUnion_Discriminator_enumIdentifier(true),
                GetUnion_Discriminator_enumObject(true));
                factory->add_type_object("Union_Discriminator_enum", GetUnion_Discriminator_enumIdentifier(false),
                GetUnion_Discriminator_enumObject(false));

                factory->add_type_object("Union_Discriminator_alias", GetUnion_Discriminator_aliasIdentifier(true),
                GetUnion_Discriminator_aliasObject(true));
                factory->add_type_object("Union_Discriminator_alias", GetUnion_Discriminator_aliasIdentifier(false),
                GetUnion_Discriminator_aliasObject(false));

                factory->add_type_object("UnionShort", GetUnionShortIdentifier(true),
                GetUnionShortObject(true));
                factory->add_type_object("UnionShort", GetUnionShortIdentifier(false),
                GetUnionShortObject(false));

                factory->add_type_object("UnionUShort", GetUnionUShortIdentifier(true),
                GetUnionUShortObject(true));
                factory->add_type_object("UnionUShort", GetUnionUShortIdentifier(false),
                GetUnionUShortObject(false));

                factory->add_type_object("UnionLong", GetUnionLongIdentifier(true),
                GetUnionLongObject(true));
                factory->add_type_object("UnionLong", GetUnionLongIdentifier(false),
                GetUnionLongObject(false));

                factory->add_type_object("UnionULong", GetUnionULongIdentifier(true),
                GetUnionULongObject(true));
                factory->add_type_object("UnionULong", GetUnionULongIdentifier(false),
                GetUnionULongObject(false));

                factory->add_type_object("UnionLongLong", GetUnionLongLongIdentifier(true),
                GetUnionLongLongObject(true));
                factory->add_type_object("UnionLongLong", GetUnionLongLongIdentifier(false),
                GetUnionLongLongObject(false));

                factory->add_type_object("UnionULongLong", GetUnionULongLongIdentifier(true),
                GetUnionULongLongObject(true));
                factory->add_type_object("UnionULongLong", GetUnionULongLongIdentifier(false),
                GetUnionULongLongObject(false));

                factory->add_type_object("UnionFloat", GetUnionFloatIdentifier(true),
                GetUnionFloatObject(true));
                factory->add_type_object("UnionFloat", GetUnionFloatIdentifier(false),
                GetUnionFloatObject(false));

                factory->add_type_object("UnionDouble", GetUnionDoubleIdentifier(true),
                GetUnionDoubleObject(true));
                factory->add_type_object("UnionDouble", GetUnionDoubleIdentifier(false),
                GetUnionDoubleObject(false));

                factory->add_type_object("UnionLongDouble", GetUnionLongDoubleIdentifier(true),
                GetUnionLongDoubleObject(true));
                factory->add_type_object("UnionLongDouble", GetUnionLongDoubleIdentifier(false),
                GetUnionLongDoubleObject(false));

                factory->add_type_object("UnionBoolean", GetUnionBooleanIdentifier(true),
                GetUnionBooleanObject(true));
                factory->add_type_object("UnionBoolean", GetUnionBooleanIdentifier(false),
                GetUnionBooleanObject(false));

                factory->add_type_object("UnionOctet", GetUnionOctetIdentifier(true),
                GetUnionOctetObject(true));
                factory->add_type_object("UnionOctet", GetUnionOctetIdentifier(false),
                GetUnionOctetObject(false));

                factory->add_type_object("UnionChar", GetUnionCharIdentifier(true),
                GetUnionCharObject(true));
                factory->add_type_object("UnionChar", GetUnionCharIdentifier(false),
                GetUnionCharObject(false));

                factory->add_type_object("UnionWChar", GetUnionWCharIdentifier(true),
                GetUnionWCharObject(true));
                factory->add_type_object("UnionWChar", GetUnionWCharIdentifier(false),
                GetUnionWCharObject(false));

                factory->add_type_object("UnionString", GetUnionStringIdentifier(true),
                GetUnionStringObject(true));
                factory->add_type_object("UnionString", GetUnionStringIdentifier(false),
                GetUnionStringObject(false));

                factory->add_type_object("UnionWString", GetUnionWStringIdentifier(true),
                GetUnionWStringObject(true));
                factory->add_type_object("UnionWString", GetUnionWStringIdentifier(false),
                GetUnionWStringObject(false));

                factory->add_type_object("UnionBoundedString", GetUnionBoundedStringIdentifier(true),
                GetUnionBoundedStringObject(true));
                factory->add_type_object("UnionBoundedString", GetUnionBoundedStringIdentifier(false),
                GetUnionBoundedStringObject(false));

                factory->add_type_object("UnionBoundedWString", GetUnionBoundedWStringIdentifier(true),
                GetUnionBoundedWStringObject(true));
                factory->add_type_object("UnionBoundedWString", GetUnionBoundedWStringIdentifier(false),
                GetUnionBoundedWStringObject(false));

                factory->add_type_object("UnionInnerEnumHelper", GetUnionInnerEnumHelperIdentifier(true),
                GetUnionInnerEnumHelperObject(true));
                factory->add_type_object("UnionInnerEnumHelper", GetUnionInnerEnumHelperIdentifier(false),
                GetUnionInnerEnumHelperObject(false));

                factory->add_type_object("UnionInnerBitMaskHelper", GetUnionInnerBitMaskHelperIdentifier(true),
                GetUnionInnerBitMaskHelperObject(true));
                factory->add_type_object("UnionInnerBitMaskHelper", GetUnionInnerBitMaskHelperIdentifier(false),
                GetUnionInnerBitMaskHelperObject(false));

                factory->add_type_object("UnionInnerAliasHelper", GetUnionInnerAliasHelperIdentifier(true),
                GetUnionInnerAliasHelperObject(true));
                factory->add_type_object("UnionInnerAliasHelper", GetUnionInnerAliasHelperIdentifier(false),
                GetUnionInnerAliasHelperObject(false));

                factory->add_type_object("UnionArray", GetUnionArrayIdentifier(true),
                GetUnionArrayObject(true));
                factory->add_type_object("UnionArray", GetUnionArrayIdentifier(false),
                GetUnionArrayObject(false));

                factory->add_type_object("UnionSequence", GetUnionSequenceIdentifier(true),
                GetUnionSequenceObject(true));
                factory->add_type_object("UnionSequence", GetUnionSequenceIdentifier(false),
                GetUnionSequenceObject(false));

                factory->add_type_object("UnionMap", GetUnionMapIdentifier(true),
                GetUnionMapObject(true));
                factory->add_type_object("UnionMap", GetUnionMapIdentifier(false),
                GetUnionMapObject(false));

                factory->add_type_object("UnionInnerUnionHelper", GetUnionInnerUnionHelperIdentifier(true),
                GetUnionInnerUnionHelperObject(true));
                factory->add_type_object("UnionInnerUnionHelper", GetUnionInnerUnionHelperIdentifier(false),
                GetUnionInnerUnionHelperObject(false));

                factory->add_type_object("UnionInnerStructureHelper", GetUnionInnerStructureHelperIdentifier(true),
                GetUnionInnerStructureHelperObject(true));
                factory->add_type_object("UnionInnerStructureHelper", GetUnionInnerStructureHelperIdentifier(false),
                GetUnionInnerStructureHelperObject(false));

                factory->add_type_object("UnionInnerBitsetHelper", GetUnionInnerBitsetHelperIdentifier(true),
                GetUnionInnerBitsetHelperObject(true));
                factory->add_type_object("UnionInnerBitsetHelper", GetUnionInnerBitsetHelperIdentifier(false),
                GetUnionInnerBitsetHelperObject(false));

                factory->add_type_object("UnionDiscriminatorShort", GetUnionDiscriminatorShortIdentifier(true),
                GetUnionDiscriminatorShortObject(true));
                factory->add_type_object("UnionDiscriminatorShort", GetUnionDiscriminatorShortIdentifier(false),
                GetUnionDiscriminatorShortObject(false));

                factory->add_type_object("UnionDiscriminatorUShort", GetUnionDiscriminatorUShortIdentifier(true),
                GetUnionDiscriminatorUShortObject(true));
                factory->add_type_object("UnionDiscriminatorUShort", GetUnionDiscriminatorUShortIdentifier(false),
                GetUnionDiscriminatorUShortObject(false));

                factory->add_type_object("UnionDiscriminatorLong", GetUnionDiscriminatorLongIdentifier(true),
                GetUnionDiscriminatorLongObject(true));
                factory->add_type_object("UnionDiscriminatorLong", GetUnionDiscriminatorLongIdentifier(false),
                GetUnionDiscriminatorLongObject(false));

                factory->add_type_object("UnionDiscriminatorULong", GetUnionDiscriminatorULongIdentifier(true),
                GetUnionDiscriminatorULongObject(true));
                factory->add_type_object("UnionDiscriminatorULong", GetUnionDiscriminatorULongIdentifier(false),
                GetUnionDiscriminatorULongObject(false));

                factory->add_type_object("UnionDiscriminatorLongLong", GetUnionDiscriminatorLongLongIdentifier(true),
                GetUnionDiscriminatorLongLongObject(true));
                factory->add_type_object("UnionDiscriminatorLongLong", GetUnionDiscriminatorLongLongIdentifier(false),
                GetUnionDiscriminatorLongLongObject(false));

                factory->add_type_object("UnionDiscriminatorULongLong", GetUnionDiscriminatorULongLongIdentifier(true),
                GetUnionDiscriminatorULongLongObject(true));
                factory->add_type_object("UnionDiscriminatorULongLong", GetUnionDiscriminatorULongLongIdentifier(false),
                GetUnionDiscriminatorULongLongObject(false));

                factory->add_type_object("UnionDiscriminatorBoolean", GetUnionDiscriminatorBooleanIdentifier(true),
                GetUnionDiscriminatorBooleanObject(true));
                factory->add_type_object("UnionDiscriminatorBoolean", GetUnionDiscriminatorBooleanIdentifier(false),
                GetUnionDiscriminatorBooleanObject(false));

                factory->add_type_object("UnionDiscriminatorOctet", GetUnionDiscriminatorOctetIdentifier(true),
                GetUnionDiscriminatorOctetObject(true));
                factory->add_type_object("UnionDiscriminatorOctet", GetUnionDiscriminatorOctetIdentifier(false),
                GetUnionDiscriminatorOctetObject(false));

                factory->add_type_object("UnionDiscriminatorChar", GetUnionDiscriminatorCharIdentifier(true),
                GetUnionDiscriminatorCharObject(true));
                factory->add_type_object("UnionDiscriminatorChar", GetUnionDiscriminatorCharIdentifier(false),
                GetUnionDiscriminatorCharObject(false));

                factory->add_type_object("UnionDiscriminatorWChar", GetUnionDiscriminatorWCharIdentifier(true),
                GetUnionDiscriminatorWCharObject(true));
                factory->add_type_object("UnionDiscriminatorWChar", GetUnionDiscriminatorWCharIdentifier(false),
                GetUnionDiscriminatorWCharObject(false));

                factory->add_type_object("UnionDiscriminatorEnum", GetUnionDiscriminatorEnumIdentifier(true),
                GetUnionDiscriminatorEnumObject(true));
                factory->add_type_object("UnionDiscriminatorEnum", GetUnionDiscriminatorEnumIdentifier(false),
                GetUnionDiscriminatorEnumObject(false));

                factory->add_type_object("UnionDiscriminatorAlias", GetUnionDiscriminatorAliasIdentifier(true),
                GetUnionDiscriminatorAliasObject(true));
                factory->add_type_object("UnionDiscriminatorAlias", GetUnionDiscriminatorAliasIdentifier(false),
                GetUnionDiscriminatorAliasObject(false));

            });
}

const TypeIdentifier* GetUnion_ShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Short", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_ShortObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Short", complete);
}

const TypeObject* GetUnion_ShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Short", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_ShortObject();
    }
    // else
    return GetMinimalUnion_ShortObject();
}

const TypeObject* GetMinimalUnion_ShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Short", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_a;
    mst_a.common().member_id(memberId++);
    mst_a.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_a.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_a.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_a.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_a.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_a.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_a.common().member_flags().IS_DEFAULT(false);
    mst_a.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    mst_a.common().label_seq().emplace_back(0);
    MD5 a_hash("a");
    for(int i = 0; i < 4; ++i)
    {
        mst_a.detail().name_hash()[i] = a_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_a);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Short", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Short", false);
}

const TypeObject* GetCompleteUnion_ShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Short", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_a;
    cst_a.common().member_id(memberId++);
    cst_a.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_a.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_a.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_a.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_a.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_a.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_a.common().member_flags().IS_DEFAULT(false);
    cst_a.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));
    cst_a.common().label_seq().emplace_back(0);

    cst_a.detail().name("a");

    type_object->complete().union_type().member_seq().emplace_back(cst_a);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Short");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Short", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Short", true);
}

const TypeIdentifier* GetUnion_UShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_UShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_UShortObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_UShort", complete);
}

const TypeObject* GetUnion_UShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_UShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_UShortObject();
    }
    // else
    return GetMinimalUnion_UShortObject();
}

const TypeObject* GetMinimalUnion_UShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_UShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_b;
    mst_b.common().member_id(memberId++);
    mst_b.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_b.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_b.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_b.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_b.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_b.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_b.common().member_flags().IS_DEFAULT(false);
    mst_b.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    mst_b.common().label_seq().emplace_back(1);
    MD5 b_hash("b");
    for(int i = 0; i < 4; ++i)
    {
        mst_b.detail().name_hash()[i] = b_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_b);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_UShort", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_UShort", false);
}

const TypeObject* GetCompleteUnion_UShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_UShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_b;
    cst_b.common().member_id(memberId++);
    cst_b.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_b.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_b.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_b.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_b.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_b.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_b.common().member_flags().IS_DEFAULT(false);
    cst_b.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));
    cst_b.common().label_seq().emplace_back(1);

    cst_b.detail().name("b");

    type_object->complete().union_type().member_seq().emplace_back(cst_b);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_UShort");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_UShort", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_UShort", true);
}

const TypeIdentifier* GetUnion_LongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Long", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_LongObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Long", complete);
}

const TypeObject* GetUnion_LongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Long", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_LongObject();
    }
    // else
    return GetMinimalUnion_LongObject();
}

const TypeObject* GetMinimalUnion_LongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Long", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_c;
    mst_c.common().member_id(memberId++);
    mst_c.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_c.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_c.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_c.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_c.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_c.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_c.common().member_flags().IS_DEFAULT(false);
    mst_c.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_c.common().label_seq().emplace_back(2);
    MD5 c_hash("c");
    for(int i = 0; i < 4; ++i)
    {
        mst_c.detail().name_hash()[i] = c_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_c);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Long", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Long", false);
}

const TypeObject* GetCompleteUnion_LongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Long", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_c;
    cst_c.common().member_id(memberId++);
    cst_c.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_c.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_c.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_c.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_c.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_c.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_c.common().member_flags().IS_DEFAULT(false);
    cst_c.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_c.common().label_seq().emplace_back(2);

    cst_c.detail().name("c");

    type_object->complete().union_type().member_seq().emplace_back(cst_c);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Long");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Long", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Long", true);
}

const TypeIdentifier* GetUnion_ULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_ULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_ULongObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_ULong", complete);
}

const TypeObject* GetUnion_ULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_ULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_ULongObject();
    }
    // else
    return GetMinimalUnion_ULongObject();
}

const TypeObject* GetMinimalUnion_ULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_ULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_d;
    mst_d.common().member_id(memberId++);
    mst_d.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_d.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_d.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_d.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_d.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_d.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_d.common().member_flags().IS_DEFAULT(false);
    mst_d.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    mst_d.common().label_seq().emplace_back(3);
    MD5 d_hash("d");
    for(int i = 0; i < 4; ++i)
    {
        mst_d.detail().name_hash()[i] = d_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_d);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_ULong", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_ULong", false);
}

const TypeObject* GetCompleteUnion_ULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_ULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_d;
    cst_d.common().member_id(memberId++);
    cst_d.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_d.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_d.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_d.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_d.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_d.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_d.common().member_flags().IS_DEFAULT(false);
    cst_d.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));
    cst_d.common().label_seq().emplace_back(3);

    cst_d.detail().name("d");

    type_object->complete().union_type().member_seq().emplace_back(cst_d);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_ULong");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_ULong", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_ULong", true);
}

const TypeIdentifier* GetUnion_LongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_LongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_LongLongObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_LongLong", complete);
}

const TypeObject* GetUnion_LongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_LongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_LongLongObject();
    }
    // else
    return GetMinimalUnion_LongLongObject();
}

const TypeObject* GetMinimalUnion_LongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_LongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_e;
    mst_e.common().member_id(memberId++);
    mst_e.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_e.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_e.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_e.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_e.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_e.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_e.common().member_flags().IS_DEFAULT(false);
    mst_e.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    mst_e.common().label_seq().emplace_back(4);
    MD5 e_hash("e");
    for(int i = 0; i < 4; ++i)
    {
        mst_e.detail().name_hash()[i] = e_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_e);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_LongLong", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_LongLong", false);
}

const TypeObject* GetCompleteUnion_LongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_LongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_e;
    cst_e.common().member_id(memberId++);
    cst_e.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_e.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_e.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_e.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_e.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_e.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_e.common().member_flags().IS_DEFAULT(false);
    cst_e.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));
    cst_e.common().label_seq().emplace_back(4);

    cst_e.detail().name("e");

    type_object->complete().union_type().member_seq().emplace_back(cst_e);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_LongLong");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_LongLong", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_LongLong", true);
}

const TypeIdentifier* GetUnion_ULongLOngIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_ULongLOng", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_ULongLOngObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_ULongLOng", complete);
}

const TypeObject* GetUnion_ULongLOngObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_ULongLOng", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_ULongLOngObject();
    }
    // else
    return GetMinimalUnion_ULongLOngObject();
}

const TypeObject* GetMinimalUnion_ULongLOngObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_ULongLOng", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_f;
    mst_f.common().member_id(memberId++);
    mst_f.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_f.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_f.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_f.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_f.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_f.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_f.common().member_flags().IS_DEFAULT(false);
    mst_f.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    mst_f.common().label_seq().emplace_back(5);
    MD5 f_hash("f");
    for(int i = 0; i < 4; ++i)
    {
        mst_f.detail().name_hash()[i] = f_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_f);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_ULongLOng", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_ULongLOng", false);
}

const TypeObject* GetCompleteUnion_ULongLOngObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_ULongLOng", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_f;
    cst_f.common().member_id(memberId++);
    cst_f.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_f.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_f.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_f.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_f.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_f.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_f.common().member_flags().IS_DEFAULT(false);
    cst_f.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));
    cst_f.common().label_seq().emplace_back(5);

    cst_f.detail().name("f");

    type_object->complete().union_type().member_seq().emplace_back(cst_f);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_ULongLOng");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_ULongLOng", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_ULongLOng", true);
}

const TypeIdentifier* GetUnion_FloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Float", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_FloatObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Float", complete);
}

const TypeObject* GetUnion_FloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Float", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_FloatObject();
    }
    // else
    return GetMinimalUnion_FloatObject();
}

const TypeObject* GetMinimalUnion_FloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Float", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_g;
    mst_g.common().member_id(memberId++);
    mst_g.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_g.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_g.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_g.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_g.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_g.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_g.common().member_flags().IS_DEFAULT(false);
    mst_g.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    mst_g.common().label_seq().emplace_back(6);
    MD5 g_hash("g");
    for(int i = 0; i < 4; ++i)
    {
        mst_g.detail().name_hash()[i] = g_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_g);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Float", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Float", false);
}

const TypeObject* GetCompleteUnion_FloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Float", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_g;
    cst_g.common().member_id(memberId++);
    cst_g.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_g.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_g.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_g.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_g.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_g.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_g.common().member_flags().IS_DEFAULT(false);
    cst_g.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));
    cst_g.common().label_seq().emplace_back(6);

    cst_g.detail().name("g");

    type_object->complete().union_type().member_seq().emplace_back(cst_g);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Float");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Float", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Float", true);
}

const TypeIdentifier* GetUnion_DoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Double", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_DoubleObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Double", complete);
}

const TypeObject* GetUnion_DoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Double", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_DoubleObject();
    }
    // else
    return GetMinimalUnion_DoubleObject();
}

const TypeObject* GetMinimalUnion_DoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Double", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_h;
    mst_h.common().member_id(memberId++);
    mst_h.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_h.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_h.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_h.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_h.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_h.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_h.common().member_flags().IS_DEFAULT(false);
    mst_h.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    mst_h.common().label_seq().emplace_back(7);
    MD5 h_hash("h");
    for(int i = 0; i < 4; ++i)
    {
        mst_h.detail().name_hash()[i] = h_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_h);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Double", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Double", false);
}

const TypeObject* GetCompleteUnion_DoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Double", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_h;
    cst_h.common().member_id(memberId++);
    cst_h.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_h.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_h.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_h.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_h.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_h.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_h.common().member_flags().IS_DEFAULT(false);
    cst_h.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));
    cst_h.common().label_seq().emplace_back(7);

    cst_h.detail().name("h");

    type_object->complete().union_type().member_seq().emplace_back(cst_h);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Double");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Double", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Double", true);
}

const TypeIdentifier* GetUnion_LongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_LongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_LongDoubleObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_LongDouble", complete);
}

const TypeObject* GetUnion_LongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_LongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_LongDoubleObject();
    }
    // else
    return GetMinimalUnion_LongDoubleObject();
}

const TypeObject* GetMinimalUnion_LongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_LongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_i;
    mst_i.common().member_id(memberId++);
    mst_i.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_i.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_i.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_i.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_i.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_i.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_i.common().member_flags().IS_DEFAULT(false);
    mst_i.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    mst_i.common().label_seq().emplace_back(8);
    MD5 i_hash("i");
    for(int i = 0; i < 4; ++i)
    {
        mst_i.detail().name_hash()[i] = i_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_i);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_LongDouble", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_LongDouble", false);
}

const TypeObject* GetCompleteUnion_LongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_LongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_i;
    cst_i.common().member_id(memberId++);
    cst_i.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_i.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_i.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_i.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_i.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_i.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_i.common().member_flags().IS_DEFAULT(false);
    cst_i.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));
    cst_i.common().label_seq().emplace_back(8);

    cst_i.detail().name("i");

    type_object->complete().union_type().member_seq().emplace_back(cst_i);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_LongDouble");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_LongDouble", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_LongDouble", true);
}

const TypeIdentifier* GetUnion_BooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Boolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_BooleanObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Boolean", complete);
}

const TypeObject* GetUnion_BooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Boolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_BooleanObject();
    }
    // else
    return GetMinimalUnion_BooleanObject();
}

const TypeObject* GetMinimalUnion_BooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Boolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_j;
    mst_j.common().member_id(memberId++);
    mst_j.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_j.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_j.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_j.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_j.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_j.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_j.common().member_flags().IS_DEFAULT(false);
    mst_j.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    mst_j.common().label_seq().emplace_back(9);
    MD5 j_hash("j");
    for(int i = 0; i < 4; ++i)
    {
        mst_j.detail().name_hash()[i] = j_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_j);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Boolean", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Boolean", false);
}

const TypeObject* GetCompleteUnion_BooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Boolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_j;
    cst_j.common().member_id(memberId++);
    cst_j.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_j.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_j.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_j.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_j.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_j.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_j.common().member_flags().IS_DEFAULT(false);
    cst_j.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));
    cst_j.common().label_seq().emplace_back(9);

    cst_j.detail().name("j");

    type_object->complete().union_type().member_seq().emplace_back(cst_j);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Boolean");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Boolean", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Boolean", true);
}

const TypeIdentifier* GetUnion_OctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Octet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_OctetObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Octet", complete);
}

const TypeObject* GetUnion_OctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Octet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_OctetObject();
    }
    // else
    return GetMinimalUnion_OctetObject();
}

const TypeObject* GetMinimalUnion_OctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Octet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_k;
    mst_k.common().member_id(memberId++);
    mst_k.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_k.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_k.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_k.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_k.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_k.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_k.common().member_flags().IS_DEFAULT(false);
    mst_k.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    mst_k.common().label_seq().emplace_back(10);
    MD5 k_hash("k");
    for(int i = 0; i < 4; ++i)
    {
        mst_k.detail().name_hash()[i] = k_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_k);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Octet", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Octet", false);
}

const TypeObject* GetCompleteUnion_OctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Octet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_k;
    cst_k.common().member_id(memberId++);
    cst_k.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_k.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_k.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_k.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_k.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_k.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_k.common().member_flags().IS_DEFAULT(false);
    cst_k.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));
    cst_k.common().label_seq().emplace_back(10);

    cst_k.detail().name("k");

    type_object->complete().union_type().member_seq().emplace_back(cst_k);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Octet");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Octet", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Octet", true);
}

const TypeIdentifier* GetUnion_CharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Char", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_CharObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Char", complete);
}

const TypeObject* GetUnion_CharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Char", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_CharObject();
    }
    // else
    return GetMinimalUnion_CharObject();
}

const TypeObject* GetMinimalUnion_CharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Char", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_l;
    mst_l.common().member_id(memberId++);
    mst_l.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_l.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_l.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_l.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_l.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_l.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_l.common().member_flags().IS_DEFAULT(false);
    mst_l.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    mst_l.common().label_seq().emplace_back(11);
    MD5 l_hash("l");
    for(int i = 0; i < 4; ++i)
    {
        mst_l.detail().name_hash()[i] = l_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_l);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Char", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Char", false);
}

const TypeObject* GetCompleteUnion_CharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Char", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_l;
    cst_l.common().member_id(memberId++);
    cst_l.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_l.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_l.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_l.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_l.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_l.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_l.common().member_flags().IS_DEFAULT(false);
    cst_l.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));
    cst_l.common().label_seq().emplace_back(11);

    cst_l.detail().name("l");

    type_object->complete().union_type().member_seq().emplace_back(cst_l);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Char");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Char", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Char", true);
}

const TypeIdentifier* GetUnion_WCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_WChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_WCharObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_WChar", complete);
}

const TypeObject* GetUnion_WCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_WChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_WCharObject();
    }
    // else
    return GetMinimalUnion_WCharObject();
}

const TypeObject* GetMinimalUnion_WCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_WChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_m;
    mst_m.common().member_id(memberId++);
    mst_m.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_m.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_m.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_m.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_m.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_m.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_m.common().member_flags().IS_DEFAULT(false);
    mst_m.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    mst_m.common().label_seq().emplace_back(12);
    MD5 m_hash("m");
    for(int i = 0; i < 4; ++i)
    {
        mst_m.detail().name_hash()[i] = m_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_m);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_WChar", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_WChar", false);
}

const TypeObject* GetCompleteUnion_WCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_WChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_m;
    cst_m.common().member_id(memberId++);
    cst_m.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_m.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_m.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_m.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_m.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_m.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_m.common().member_flags().IS_DEFAULT(false);
    cst_m.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));
    cst_m.common().label_seq().emplace_back(12);

    cst_m.detail().name("m");

    type_object->complete().union_type().member_seq().emplace_back(cst_m);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_WChar");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_WChar", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_WChar", true);
}

const TypeIdentifier* GetUnion_StringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_String", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_StringObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_String", complete);
}

const TypeObject* GetUnion_StringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_String", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_StringObject();
    }
    // else
    return GetMinimalUnion_StringObject();
}

const TypeObject* GetMinimalUnion_StringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_String", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_n;
    mst_n.common().member_id(memberId++);
    mst_n.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_n.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_n.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_n.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_n.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_n.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_n.common().member_flags().IS_DEFAULT(false);
    mst_n.common().type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    mst_n.common().label_seq().emplace_back(13);
    MD5 n_hash("n");
    for(int i = 0; i < 4; ++i)
    {
        mst_n.detail().name_hash()[i] = n_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_n);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_String", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_String", false);
}

const TypeObject* GetCompleteUnion_StringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_String", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_n;
    cst_n.common().member_id(memberId++);
    cst_n.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_n.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_n.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_n.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_n.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_n.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_n.common().member_flags().IS_DEFAULT(false);
    cst_n.common().type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));

    cst_n.common().label_seq().emplace_back(13);

    cst_n.detail().name("n");

    type_object->complete().union_type().member_seq().emplace_back(cst_n);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_String");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_String", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_String", true);
}

const TypeIdentifier* GetUnion_WStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_WString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_WStringObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_WString", complete);
}

const TypeObject* GetUnion_WStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_WString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_WStringObject();
    }
    // else
    return GetMinimalUnion_WStringObject();
}

const TypeObject* GetMinimalUnion_WStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_WString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_o;
    mst_o.common().member_id(memberId++);
    mst_o.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_o.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_o.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_o.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_o.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_o.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_o.common().member_flags().IS_DEFAULT(false);
    mst_o.common().type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, true));


    mst_o.common().label_seq().emplace_back(14);
    MD5 o_hash("o");
    for(int i = 0; i < 4; ++i)
    {
        mst_o.detail().name_hash()[i] = o_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_o);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_WString", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_WString", false);
}

const TypeObject* GetCompleteUnion_WStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_WString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_o;
    cst_o.common().member_id(memberId++);
    cst_o.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_o.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_o.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_o.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_o.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_o.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_o.common().member_flags().IS_DEFAULT(false);
    cst_o.common().type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, true));

    cst_o.common().label_seq().emplace_back(14);

    cst_o.detail().name("o");

    type_object->complete().union_type().member_seq().emplace_back(cst_o);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_WString");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_WString", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_WString", true);
}

const TypeIdentifier* GetUnion_BoundedStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_BoundedString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_BoundedStringObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_BoundedString", complete);
}

const TypeObject* GetUnion_BoundedStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_BoundedString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_BoundedStringObject();
    }
    // else
    return GetMinimalUnion_BoundedStringObject();
}

const TypeObject* GetMinimalUnion_BoundedStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_BoundedString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_bn;
    mst_bn.common().member_id(memberId++);
    mst_bn.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_bn.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_bn.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_bn.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_bn.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_bn.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_bn.common().member_flags().IS_DEFAULT(false);
    mst_bn.common().type_id(*GetInner_alias_bounded_string_helperIdentifier(false));
    mst_bn.common().label_seq().emplace_back(13);
    MD5 bn_hash("bn");
    for(int i = 0; i < 4; ++i)
    {
        mst_bn.detail().name_hash()[i] = bn_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_bn);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_BoundedString", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_BoundedString", false);
}

const TypeObject* GetCompleteUnion_BoundedStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_BoundedString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_bn;
    cst_bn.common().member_id(memberId++);
    cst_bn.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_bn.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_bn.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_bn.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_bn.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_bn.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_bn.common().member_flags().IS_DEFAULT(false);
    cst_bn.common().type_id(*GetInner_alias_bounded_string_helperIdentifier(true));cst_bn.common().label_seq().emplace_back(13);

    cst_bn.detail().name("bn");

    type_object->complete().union_type().member_seq().emplace_back(cst_bn);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_BoundedString");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_BoundedString", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_BoundedString", true);
}

const TypeIdentifier* GetUnion_BoundedWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_BoundedWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_BoundedWStringObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_BoundedWString", complete);
}

const TypeObject* GetUnion_BoundedWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_BoundedWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_BoundedWStringObject();
    }
    // else
    return GetMinimalUnion_BoundedWStringObject();
}

const TypeObject* GetMinimalUnion_BoundedWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_BoundedWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_bo;
    mst_bo.common().member_id(memberId++);
    mst_bo.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_bo.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_bo.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_bo.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_bo.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_bo.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_bo.common().member_flags().IS_DEFAULT(false);
    mst_bo.common().type_id(*GetInner_alias_bounded_wstring_helperIdentifier(false));
    mst_bo.common().label_seq().emplace_back(14);
    MD5 bo_hash("bo");
    for(int i = 0; i < 4; ++i)
    {
        mst_bo.detail().name_hash()[i] = bo_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_bo);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_BoundedWString", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_BoundedWString", false);
}

const TypeObject* GetCompleteUnion_BoundedWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_BoundedWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_bo;
    cst_bo.common().member_id(memberId++);
    cst_bo.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_bo.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_bo.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_bo.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_bo.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_bo.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_bo.common().member_flags().IS_DEFAULT(false);
    cst_bo.common().type_id(*GetInner_alias_bounded_wstring_helperIdentifier(true));cst_bo.common().label_seq().emplace_back(14);

    cst_bo.detail().name("bo");

    type_object->complete().union_type().member_seq().emplace_back(cst_bo);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_BoundedWString");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_BoundedWString", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_BoundedWString", true);
}

const TypeIdentifier* GetUnion_InnerEnumHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_InnerEnumHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_InnerEnumHelperObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_InnerEnumHelper", complete);
}

const TypeObject* GetUnion_InnerEnumHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerEnumHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_InnerEnumHelperObject();
    }
    // else
    return GetMinimalUnion_InnerEnumHelperObject();
}

const TypeObject* GetMinimalUnion_InnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerEnumHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_p;
    mst_p.common().member_id(memberId++);
    mst_p.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_p.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_p.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_p.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_p.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_p.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_p.common().member_flags().IS_DEFAULT(false);
    mst_p.common().type_id(*GetInnerEnumHelperIdentifier(false));
    mst_p.common().label_seq().emplace_back(15);
    MD5 p_hash("p");
    for(int i = 0; i < 4; ++i)
    {
        mst_p.detail().name_hash()[i] = p_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_p);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_InnerEnumHelper", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_InnerEnumHelper", false);
}

const TypeObject* GetCompleteUnion_InnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerEnumHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_p;
    cst_p.common().member_id(memberId++);
    cst_p.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_p.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_p.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_p.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_p.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_p.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_p.common().member_flags().IS_DEFAULT(false);
    cst_p.common().type_id(*GetInnerEnumHelperIdentifier(true));cst_p.common().label_seq().emplace_back(15);

    cst_p.detail().name("p");

    type_object->complete().union_type().member_seq().emplace_back(cst_p);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_InnerEnumHelper");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_InnerEnumHelper", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_InnerEnumHelper", true);
}

const TypeIdentifier* GetUnion_InnerBitMaskHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_InnerBitMaskHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_InnerBitMaskHelperObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_InnerBitMaskHelper", complete);
}

const TypeObject* GetUnion_InnerBitMaskHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerBitMaskHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_InnerBitMaskHelperObject();
    }
    // else
    return GetMinimalUnion_InnerBitMaskHelperObject();
}

const TypeObject* GetMinimalUnion_InnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerBitMaskHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_q;
    mst_q.common().member_id(memberId++);
    mst_q.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_q.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_q.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_q.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_q.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_q.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_q.common().member_flags().IS_DEFAULT(false);
    mst_q.common().type_id(*GetInnerBitMaskHelperIdentifier(false));
    mst_q.common().label_seq().emplace_back(16);
    MD5 q_hash("q");
    for(int i = 0; i < 4; ++i)
    {
        mst_q.detail().name_hash()[i] = q_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_q);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_InnerBitMaskHelper", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_InnerBitMaskHelper", false);
}

const TypeObject* GetCompleteUnion_InnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerBitMaskHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_q;
    cst_q.common().member_id(memberId++);
    cst_q.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_q.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_q.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_q.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_q.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_q.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_q.common().member_flags().IS_DEFAULT(false);
    cst_q.common().type_id(*GetInnerBitMaskHelperIdentifier(true));cst_q.common().label_seq().emplace_back(16);

    cst_q.detail().name("q");

    type_object->complete().union_type().member_seq().emplace_back(cst_q);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_InnerBitMaskHelper");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_InnerBitMaskHelper", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_InnerBitMaskHelper", true);
}

const TypeIdentifier* GetUnion_InnerAliasHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_InnerAliasHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_InnerAliasHelperObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_InnerAliasHelper", complete);
}

const TypeObject* GetUnion_InnerAliasHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerAliasHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_InnerAliasHelperObject();
    }
    // else
    return GetMinimalUnion_InnerAliasHelperObject();
}

const TypeObject* GetMinimalUnion_InnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerAliasHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_r;
    mst_r.common().member_id(memberId++);
    mst_r.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_r.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_r.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_r.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_r.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_r.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_r.common().member_flags().IS_DEFAULT(false);
    mst_r.common().type_id(*GetInnerAliasHelperIdentifier(false));
    mst_r.common().label_seq().emplace_back(17);
    MD5 r_hash("r");
    for(int i = 0; i < 4; ++i)
    {
        mst_r.detail().name_hash()[i] = r_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_r);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_InnerAliasHelper", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_InnerAliasHelper", false);
}

const TypeObject* GetCompleteUnion_InnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerAliasHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_r;
    cst_r.common().member_id(memberId++);
    cst_r.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_r.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_r.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_r.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_r.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_r.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_r.common().member_flags().IS_DEFAULT(false);
    cst_r.common().type_id(*GetInnerAliasHelperIdentifier(true));cst_r.common().label_seq().emplace_back(17);

    cst_r.detail().name("r");

    type_object->complete().union_type().member_seq().emplace_back(cst_r);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_InnerAliasHelper");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_InnerAliasHelper", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_InnerAliasHelper", true);
}

const TypeIdentifier* GetUnion_ArrayIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Array", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_ArrayObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Array", complete);
}

const TypeObject* GetUnion_ArrayObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Array", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_ArrayObject();
    }
    // else
    return GetMinimalUnion_ArrayObject();
}

const TypeObject* GetMinimalUnion_ArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Array", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_s;
    mst_s.common().member_id(memberId++);
    mst_s.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_s.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_s.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_s.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_s.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_s.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_s.common().member_flags().IS_DEFAULT(false);
    mst_s.common().type_id(*GetInner_alias_array_helperIdentifier(false));
    mst_s.common().label_seq().emplace_back(18);
    MD5 s_hash("s");
    for(int i = 0; i < 4; ++i)
    {
        mst_s.detail().name_hash()[i] = s_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_s);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Array", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Array", false);
}

const TypeObject* GetCompleteUnion_ArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Array", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_s;
    cst_s.common().member_id(memberId++);
    cst_s.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_s.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_s.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_s.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_s.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_s.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_s.common().member_flags().IS_DEFAULT(false);
    cst_s.common().type_id(*GetInner_alias_array_helperIdentifier(true));cst_s.common().label_seq().emplace_back(18);

    cst_s.detail().name("s");

    type_object->complete().union_type().member_seq().emplace_back(cst_s);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Array");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Array", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Array", true);
}

const TypeIdentifier* GetUnion_SequenceIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Sequence", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_SequenceObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Sequence", complete);
}

const TypeObject* GetUnion_SequenceObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Sequence", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_SequenceObject();
    }
    // else
    return GetMinimalUnion_SequenceObject();
}

const TypeObject* GetMinimalUnion_SequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Sequence", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_t;
    mst_t.common().member_id(memberId++);
    mst_t.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_t.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_t.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_t.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_t.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_t.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_t.common().member_flags().IS_DEFAULT(false);
    mst_t.common().type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 100, false));


    mst_t.common().label_seq().emplace_back(19);
    MD5 t_hash("t");
    for(int i = 0; i < 4; ++i)
    {
        mst_t.detail().name_hash()[i] = t_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_t);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Sequence", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Sequence", false);
}

const TypeObject* GetCompleteUnion_SequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Sequence", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_t;
    cst_t.common().member_id(memberId++);
    cst_t.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_t.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_t.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_t.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_t.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_t.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_t.common().member_flags().IS_DEFAULT(false);
    cst_t.common().type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("int16_t", 100, false));

    cst_t.common().label_seq().emplace_back(19);

    cst_t.detail().name("t");

    type_object->complete().union_type().member_seq().emplace_back(cst_t);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Sequence");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Sequence", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Sequence", true);
}

const TypeIdentifier* GetUnion_MapIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Map", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_MapObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Map", complete);
}

const TypeObject* GetUnion_MapObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Map", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_MapObject();
    }
    // else
    return GetMinimalUnion_MapObject();
}

const TypeObject* GetMinimalUnion_MapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Map", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_u;
    mst_u.common().member_id(memberId++);
    mst_u.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_u.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_u.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_u.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_u.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_u.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_u.common().member_flags().IS_DEFAULT(false);
    mst_u.common().type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int32_t", 100, false));


    mst_u.common().label_seq().emplace_back(20);
    MD5 u_hash("u");
    for(int i = 0; i < 4; ++i)
    {
        mst_u.detail().name_hash()[i] = u_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_u);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Map", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Map", false);
}

const TypeObject* GetCompleteUnion_MapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Map", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_u;
    cst_u.common().member_id(memberId++);
    cst_u.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_u.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_u.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_u.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_u.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_u.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_u.common().member_flags().IS_DEFAULT(false);
    cst_u.common().type_id(*TypeObjectFactory::get_instance()->get_map_identifier("int32_t", "int32_t", 100, false));

    cst_u.common().label_seq().emplace_back(20);

    cst_u.detail().name("u");

    type_object->complete().union_type().member_seq().emplace_back(cst_u);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Map");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Map", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Map", true);
}

const TypeIdentifier* GetUnion_InnerUnionHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_InnerUnionHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_InnerUnionHelperObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_InnerUnionHelper", complete);
}

const TypeObject* GetUnion_InnerUnionHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerUnionHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_InnerUnionHelperObject();
    }
    // else
    return GetMinimalUnion_InnerUnionHelperObject();
}

const TypeObject* GetMinimalUnion_InnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerUnionHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_v;
    mst_v.common().member_id(memberId++);
    mst_v.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_v.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_v.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_v.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_v.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_v.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_v.common().member_flags().IS_DEFAULT(false);
    mst_v.common().type_id(*GetInnerUnionHelperIdentifier(false));
    mst_v.common().label_seq().emplace_back(21);
    MD5 v_hash("v");
    for(int i = 0; i < 4; ++i)
    {
        mst_v.detail().name_hash()[i] = v_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_v);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_InnerUnionHelper", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_InnerUnionHelper", false);
}

const TypeObject* GetCompleteUnion_InnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerUnionHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_v;
    cst_v.common().member_id(memberId++);
    cst_v.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_v.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_v.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_v.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_v.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_v.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_v.common().member_flags().IS_DEFAULT(false);
    cst_v.common().type_id(*GetInnerUnionHelperIdentifier(true));cst_v.common().label_seq().emplace_back(21);

    cst_v.detail().name("v");

    type_object->complete().union_type().member_seq().emplace_back(cst_v);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_InnerUnionHelper");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_InnerUnionHelper", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_InnerUnionHelper", true);
}

const TypeIdentifier* GetUnion_InnerStructureHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_InnerStructureHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_InnerStructureHelperObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_InnerStructureHelper", complete);
}

const TypeObject* GetUnion_InnerStructureHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerStructureHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_InnerStructureHelperObject();
    }
    // else
    return GetMinimalUnion_InnerStructureHelperObject();
}

const TypeObject* GetMinimalUnion_InnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerStructureHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_w;
    mst_w.common().member_id(memberId++);
    mst_w.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_w.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_w.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_w.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_w.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_w.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_w.common().member_flags().IS_DEFAULT(false);
    mst_w.common().type_id(*GetInnerStructureHelperIdentifier(false));
    mst_w.common().label_seq().emplace_back(22);
    MD5 w_hash("w");
    for(int i = 0; i < 4; ++i)
    {
        mst_w.detail().name_hash()[i] = w_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_w);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_InnerStructureHelper", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_InnerStructureHelper", false);
}

const TypeObject* GetCompleteUnion_InnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerStructureHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_w;
    cst_w.common().member_id(memberId++);
    cst_w.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_w.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_w.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_w.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_w.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_w.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_w.common().member_flags().IS_DEFAULT(false);
    cst_w.common().type_id(*GetInnerStructureHelperIdentifier(true));cst_w.common().label_seq().emplace_back(22);

    cst_w.detail().name("w");

    type_object->complete().union_type().member_seq().emplace_back(cst_w);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_InnerStructureHelper");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_InnerStructureHelper", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_InnerStructureHelper", true);
}

const TypeIdentifier* GetUnion_InnerBitsetHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_InnerBitsetHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_InnerBitsetHelperObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_InnerBitsetHelper", complete);
}

const TypeObject* GetUnion_InnerBitsetHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerBitsetHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_InnerBitsetHelperObject();
    }
    // else
    return GetMinimalUnion_InnerBitsetHelperObject();
}

const TypeObject* GetMinimalUnion_InnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerBitsetHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_x;
    mst_x.common().member_id(memberId++);
    mst_x.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_x.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_x.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_x.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_x.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_x.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_x.common().member_flags().IS_DEFAULT(false);
    mst_x.common().type_id(*GetInnerBitsetHelperIdentifier(false));
    mst_x.common().label_seq().emplace_back(23);
    MD5 x_hash("x");
    for(int i = 0; i < 4; ++i)
    {
        mst_x.detail().name_hash()[i] = x_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_x);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_InnerBitsetHelper", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_InnerBitsetHelper", false);
}

const TypeObject* GetCompleteUnion_InnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_InnerBitsetHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_x;
    cst_x.common().member_id(memberId++);
    cst_x.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_x.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_x.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_x.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_x.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_x.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_x.common().member_flags().IS_DEFAULT(false);
    cst_x.common().type_id(*GetInnerBitsetHelperIdentifier(true));cst_x.common().label_seq().emplace_back(23);

    cst_x.detail().name("x");

    type_object->complete().union_type().member_seq().emplace_back(cst_x);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_InnerBitsetHelper");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_InnerBitsetHelper", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_InnerBitsetHelper", true);
}

const TypeIdentifier* GetUnion_Discriminator_shortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_short", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_Discriminator_shortObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_short", complete);
}

const TypeObject* GetUnion_Discriminator_shortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_short", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_Discriminator_shortObject();
    }
    // else
    return GetMinimalUnion_Discriminator_shortObject();
}

const TypeObject* GetMinimalUnion_Discriminator_shortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_short", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_first.common().member_flags().IS_DEFAULT(false);
    mst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_first.common().label_seq().emplace_back(1);
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_second.common().member_flags().IS_DEFAULT(false);
    mst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    mst_second.common().label_seq().emplace_back(-2);
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_short", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_short", false);
}

const TypeObject* GetCompleteUnion_Discriminator_shortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_short", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_first.common().member_flags().IS_DEFAULT(false);
    cst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_first.common().label_seq().emplace_back(1);

    cst_first.detail().name("first");

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_second.common().member_flags().IS_DEFAULT(false);
    cst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));
    cst_second.common().label_seq().emplace_back(-2);

    cst_second.detail().name("second");

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Discriminator_short");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_short", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_short", true);
}

const TypeIdentifier* GetUnion_Discriminator_unsigned_shortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_unsigned_short", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_Discriminator_unsigned_shortObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_unsigned_short", complete);
}

const TypeObject* GetUnion_Discriminator_unsigned_shortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_short", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_Discriminator_unsigned_shortObject();
    }
    // else
    return GetMinimalUnion_Discriminator_unsigned_shortObject();
}

const TypeObject* GetMinimalUnion_Discriminator_unsigned_shortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_short", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_first.common().member_flags().IS_DEFAULT(false);
    mst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_first.common().label_seq().emplace_back(1);
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_second.common().member_flags().IS_DEFAULT(false);
    mst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    mst_second.common().label_seq().emplace_back(2);
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_unsigned_short", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_short", false);
}

const TypeObject* GetCompleteUnion_Discriminator_unsigned_shortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_short", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_first.common().member_flags().IS_DEFAULT(false);
    cst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_first.common().label_seq().emplace_back(1);

    cst_first.detail().name("first");

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_second.common().member_flags().IS_DEFAULT(false);
    cst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));
    cst_second.common().label_seq().emplace_back(2);

    cst_second.detail().name("second");

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Discriminator_unsigned_short");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_unsigned_short", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_short", true);
}

const TypeIdentifier* GetUnion_Discriminator_longIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_long", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_Discriminator_longObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_long", complete);
}

const TypeObject* GetUnion_Discriminator_longObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_long", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_Discriminator_longObject();
    }
    // else
    return GetMinimalUnion_Discriminator_longObject();
}

const TypeObject* GetMinimalUnion_Discriminator_longObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_long", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_first.common().member_flags().IS_DEFAULT(false);
    mst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_first.common().label_seq().emplace_back(1);
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_second.common().member_flags().IS_DEFAULT(false);
    mst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    mst_second.common().label_seq().emplace_back(-2);
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_long", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_long", false);
}

const TypeObject* GetCompleteUnion_Discriminator_longObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_long", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_first.common().member_flags().IS_DEFAULT(false);
    cst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_first.common().label_seq().emplace_back(1);

    cst_first.detail().name("first");

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_second.common().member_flags().IS_DEFAULT(false);
    cst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));
    cst_second.common().label_seq().emplace_back(-2);

    cst_second.detail().name("second");

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Discriminator_long");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_long", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_long", true);
}

const TypeIdentifier* GetUnion_Discriminator_unsigned_longIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_unsigned_long", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_Discriminator_unsigned_longObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_unsigned_long", complete);
}

const TypeObject* GetUnion_Discriminator_unsigned_longObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_long", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_Discriminator_unsigned_longObject();
    }
    // else
    return GetMinimalUnion_Discriminator_unsigned_longObject();
}

const TypeObject* GetMinimalUnion_Discriminator_unsigned_longObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_long", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_first.common().member_flags().IS_DEFAULT(false);
    mst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_first.common().label_seq().emplace_back(1);
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_second.common().member_flags().IS_DEFAULT(false);
    mst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    mst_second.common().label_seq().emplace_back(2);
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_unsigned_long", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_long", false);
}

const TypeObject* GetCompleteUnion_Discriminator_unsigned_longObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_long", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_first.common().member_flags().IS_DEFAULT(false);
    cst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_first.common().label_seq().emplace_back(1);

    cst_first.detail().name("first");

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_second.common().member_flags().IS_DEFAULT(false);
    cst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));
    cst_second.common().label_seq().emplace_back(2);

    cst_second.detail().name("second");

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Discriminator_unsigned_long");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_unsigned_long", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_long", true);
}

const TypeIdentifier* GetUnion_Discriminator_long_longIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_long_long", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_Discriminator_long_longObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_long_long", complete);
}

const TypeObject* GetUnion_Discriminator_long_longObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_long_long", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_Discriminator_long_longObject();
    }
    // else
    return GetMinimalUnion_Discriminator_long_longObject();
}

const TypeObject* GetMinimalUnion_Discriminator_long_longObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_long_long", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_first.common().member_flags().IS_DEFAULT(false);
    mst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_first.common().label_seq().emplace_back(1);
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_second.common().member_flags().IS_DEFAULT(false);
    mst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    mst_second.common().label_seq().emplace_back(-2);
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_long_long", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_long_long", false);
}

const TypeObject* GetCompleteUnion_Discriminator_long_longObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_long_long", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_first.common().member_flags().IS_DEFAULT(false);
    cst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_first.common().label_seq().emplace_back(1);

    cst_first.detail().name("first");

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_second.common().member_flags().IS_DEFAULT(false);
    cst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));
    cst_second.common().label_seq().emplace_back(-2);

    cst_second.detail().name("second");

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Discriminator_long_long");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_long_long", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_long_long", true);
}

const TypeIdentifier* GetUnion_Discriminator_unsigned_long_longIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_unsigned_long_long", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_Discriminator_unsigned_long_longObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_unsigned_long_long", complete);
}

const TypeObject* GetUnion_Discriminator_unsigned_long_longObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_long_long", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_Discriminator_unsigned_long_longObject();
    }
    // else
    return GetMinimalUnion_Discriminator_unsigned_long_longObject();
}

const TypeObject* GetMinimalUnion_Discriminator_unsigned_long_longObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_long_long", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_first.common().member_flags().IS_DEFAULT(false);
    mst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_first.common().label_seq().emplace_back(1);
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_second.common().member_flags().IS_DEFAULT(false);
    mst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    mst_second.common().label_seq().emplace_back(2);
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_unsigned_long_long", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_long_long", false);
}

const TypeObject* GetCompleteUnion_Discriminator_unsigned_long_longObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_long_long", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_first.common().member_flags().IS_DEFAULT(false);
    cst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_first.common().label_seq().emplace_back(1);

    cst_first.detail().name("first");

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_second.common().member_flags().IS_DEFAULT(false);
    cst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));
    cst_second.common().label_seq().emplace_back(2);

    cst_second.detail().name("second");

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Discriminator_unsigned_long_long");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_unsigned_long_long", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_unsigned_long_long", true);
}

const TypeIdentifier* GetUnion_Discriminator_booleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_boolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_Discriminator_booleanObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_boolean", complete);
}

const TypeObject* GetUnion_Discriminator_booleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_boolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_Discriminator_booleanObject();
    }
    // else
    return GetMinimalUnion_Discriminator_booleanObject();
}

const TypeObject* GetMinimalUnion_Discriminator_booleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_boolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_first.common().member_flags().IS_DEFAULT(false);
    mst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_first.common().label_seq().emplace_back(true);
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_second.common().member_flags().IS_DEFAULT(false);
    mst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    mst_second.common().label_seq().emplace_back(false);
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_boolean", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_boolean", false);
}

const TypeObject* GetCompleteUnion_Discriminator_booleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_boolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_first.common().member_flags().IS_DEFAULT(false);
    cst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_first.common().label_seq().emplace_back(true);

    cst_first.detail().name("first");

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_second.common().member_flags().IS_DEFAULT(false);
    cst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));
    cst_second.common().label_seq().emplace_back(false);

    cst_second.detail().name("second");

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Discriminator_boolean");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_boolean", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_boolean", true);
}

const TypeIdentifier* GetUnion_Discriminator_octetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_octet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_Discriminator_octetObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_octet", complete);
}

const TypeObject* GetUnion_Discriminator_octetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_octet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_Discriminator_octetObject();
    }
    // else
    return GetMinimalUnion_Discriminator_octetObject();
}

const TypeObject* GetMinimalUnion_Discriminator_octetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_octet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_first.common().member_flags().IS_DEFAULT(false);
    mst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_first.common().label_seq().emplace_back(0);
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_second.common().member_flags().IS_DEFAULT(false);
    mst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    mst_second.common().label_seq().emplace_back(1);
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_octet", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_octet", false);
}

const TypeObject* GetCompleteUnion_Discriminator_octetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_octet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_first.common().member_flags().IS_DEFAULT(false);
    cst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_first.common().label_seq().emplace_back(0);

    cst_first.detail().name("first");

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_second.common().member_flags().IS_DEFAULT(false);
    cst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));
    cst_second.common().label_seq().emplace_back(1);

    cst_second.detail().name("second");

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Discriminator_octet");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_octet", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_octet", true);
}

const TypeIdentifier* GetUnion_Discriminator_charIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_char", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_Discriminator_charObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_char", complete);
}

const TypeObject* GetUnion_Discriminator_charObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_char", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_Discriminator_charObject();
    }
    // else
    return GetMinimalUnion_Discriminator_charObject();
}

const TypeObject* GetMinimalUnion_Discriminator_charObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_char", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_first.common().member_flags().IS_DEFAULT(false);
    mst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_first.common().label_seq().emplace_back('a');
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_second.common().member_flags().IS_DEFAULT(false);
    mst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    mst_second.common().label_seq().emplace_back('b');
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_char", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_char", false);
}

const TypeObject* GetCompleteUnion_Discriminator_charObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_char", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_first.common().member_flags().IS_DEFAULT(false);
    cst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_first.common().label_seq().emplace_back('a');

    cst_first.detail().name("first");

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_second.common().member_flags().IS_DEFAULT(false);
    cst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));
    cst_second.common().label_seq().emplace_back('b');

    cst_second.detail().name("second");

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Discriminator_char");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_char", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_char", true);
}

const TypeIdentifier* GetUnion_Discriminator_wcharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_wchar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_Discriminator_wcharObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_wchar", complete);
}

const TypeObject* GetUnion_Discriminator_wcharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_wchar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_Discriminator_wcharObject();
    }
    // else
    return GetMinimalUnion_Discriminator_wcharObject();
}

const TypeObject* GetMinimalUnion_Discriminator_wcharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_wchar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_first.common().member_flags().IS_DEFAULT(false);
    mst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_first.common().label_seq().emplace_back('a');
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_second.common().member_flags().IS_DEFAULT(false);
    mst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    mst_second.common().label_seq().emplace_back('b');
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_wchar", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_wchar", false);
}

const TypeObject* GetCompleteUnion_Discriminator_wcharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_wchar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));


    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_first.common().member_flags().IS_DEFAULT(false);
    cst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_first.common().label_seq().emplace_back('a');

    cst_first.detail().name("first");

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_second.common().member_flags().IS_DEFAULT(false);
    cst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));
    cst_second.common().label_seq().emplace_back('b');

    cst_second.detail().name("second");

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Discriminator_wchar");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_wchar", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_wchar", true);
}

const TypeIdentifier* GetUnion_Discriminator_enumIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_enum", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_Discriminator_enumObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_enum", complete);
}

const TypeObject* GetUnion_Discriminator_enumObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_enum", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_Discriminator_enumObject();
    }
    // else
    return GetMinimalUnion_Discriminator_enumObject();
}

const TypeObject* GetMinimalUnion_Discriminator_enumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_enum", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*GetInnerEnumHelperIdentifier(false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_first.common().member_flags().IS_DEFAULT(false);
    mst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_first.common().label_seq().emplace_back(::ENUM_VALUE_1);
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_second.common().member_flags().IS_DEFAULT(false);
    mst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    mst_second.common().label_seq().emplace_back(::ENUM_VALUE_2);
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_enum", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_enum", false);
}

const TypeObject* GetCompleteUnion_Discriminator_enumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_enum", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*GetInnerEnumHelperIdentifier(true));


    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_first.common().member_flags().IS_DEFAULT(false);
    cst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_first.common().label_seq().emplace_back(::ENUM_VALUE_1);

    cst_first.detail().name("first");

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_second.common().member_flags().IS_DEFAULT(false);
    cst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));
    cst_second.common().label_seq().emplace_back(::ENUM_VALUE_2);

    cst_second.detail().name("second");

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Discriminator_enum");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_enum", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_enum", true);
}

const TypeIdentifier* GetUnion_Discriminator_aliasIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_alias", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnion_Discriminator_aliasObject(complete);
    return TypeObjectFactory::get_instance()->get_type_identifier("Union_Discriminator_alias", complete);
}

const TypeObject* GetUnion_Discriminator_aliasObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_alias", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnion_Discriminator_aliasObject();
    }
    // else
    return GetMinimalUnion_Discriminator_aliasObject();
}

const TypeObject* GetMinimalUnion_Discriminator_aliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_alias", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->minimal().union_type().discriminator().common().type_id(*GetInnerAliasHelperIdentifier(false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_first.common().member_flags().IS_DEFAULT(false);
    mst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    mst_first.common().label_seq().emplace_back(1);
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    mst_second.common().member_flags().IS_DEFAULT(false);
    mst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    mst_second.common().label_seq().emplace_back(2);
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_alias", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_alias", false);
}

const TypeObject* GetCompleteUnion_Discriminator_aliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_alias", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

    type_object->complete().union_type().discriminator().common().type_id(*GetInnerAliasHelperIdentifier(true));


    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_first.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_first.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_first.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_first.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_first.common().member_flags().IS_DEFAULT(false);
    cst_first.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));
    cst_first.common().label_seq().emplace_back(1);

    cst_first.detail().name("first");

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_second.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_second.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_second.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cst_second.common().member_flags().IS_KEY(false); // Doesn't apply
    cst_second.common().member_flags().IS_DEFAULT(false);
    cst_second.common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));
    cst_second.common().label_seq().emplace_back(2);

    cst_second.detail().name("second");

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    type_object->complete().union_type().header().detail().type_name("Union_Discriminator_alias");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Union_Discriminator_alias", identifier, type_object);
    delete type_object;
    delete identifier;
    return TypeObjectFactory::get_instance()->get_type_object("Union_Discriminator_alias", true);
}

const TypeIdentifier* GetUnionShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionShort", complete);
}

const TypeObject* GetUnionShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionShortObject();
    }
    //else
    return GetMinimalUnionShortObject();
}

const TypeObject* GetMinimalUnionShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_short;
    mst_var_union_short.common().member_id(memberId++);
    mst_var_union_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_short.common().member_flags().IS_KEY(false);
    mst_var_union_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_short.common().member_type_id(*GetUnion_ShortIdentifier(false));
    MD5 var_union_short_hash("var_union_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_short.detail().name_hash()[i] = var_union_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionShort", false);
}

const TypeObject* GetCompleteUnionShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_short;
    cst_var_union_short.common().member_id(memberId++);
    cst_var_union_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_short.common().member_flags().IS_KEY(false);
    cst_var_union_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_short.common().member_type_id(*GetUnion_ShortIdentifier(true));
    cst_var_union_short.detail().name("var_union_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionShort", true);
}

const TypeIdentifier* GetUnionUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionUShort", complete);
}

const TypeObject* GetUnionUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionUShortObject();
    }
    //else
    return GetMinimalUnionUShortObject();
}

const TypeObject* GetMinimalUnionUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_ushort;
    mst_var_union_ushort.common().member_id(memberId++);
    mst_var_union_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_ushort.common().member_flags().IS_KEY(false);
    mst_var_union_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_ushort.common().member_type_id(*GetUnion_UShortIdentifier(false));
    MD5 var_union_ushort_hash("var_union_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_ushort.detail().name_hash()[i] = var_union_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionUShort", false);
}

const TypeObject* GetCompleteUnionUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_ushort;
    cst_var_union_ushort.common().member_id(memberId++);
    cst_var_union_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_ushort.common().member_flags().IS_KEY(false);
    cst_var_union_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_ushort.common().member_type_id(*GetUnion_UShortIdentifier(true));
    cst_var_union_ushort.detail().name("var_union_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionUShort", true);
}

const TypeIdentifier* GetUnionLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionLong", complete);
}

const TypeObject* GetUnionLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionLongObject();
    }
    //else
    return GetMinimalUnionLongObject();
}

const TypeObject* GetMinimalUnionLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_long;
    mst_var_union_long.common().member_id(memberId++);
    mst_var_union_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_long.common().member_flags().IS_KEY(false);
    mst_var_union_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_long.common().member_type_id(*GetUnion_LongIdentifier(false));
    MD5 var_union_long_hash("var_union_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_long.detail().name_hash()[i] = var_union_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionLong", false);
}

const TypeObject* GetCompleteUnionLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_long;
    cst_var_union_long.common().member_id(memberId++);
    cst_var_union_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_long.common().member_flags().IS_KEY(false);
    cst_var_union_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_long.common().member_type_id(*GetUnion_LongIdentifier(true));
    cst_var_union_long.detail().name("var_union_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionLong", true);
}

const TypeIdentifier* GetUnionULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionULong", complete);
}

const TypeObject* GetUnionULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionULongObject();
    }
    //else
    return GetMinimalUnionULongObject();
}

const TypeObject* GetMinimalUnionULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_ulong;
    mst_var_union_ulong.common().member_id(memberId++);
    mst_var_union_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_ulong.common().member_flags().IS_KEY(false);
    mst_var_union_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_ulong.common().member_type_id(*GetUnion_ULongIdentifier(false));
    MD5 var_union_ulong_hash("var_union_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_ulong.detail().name_hash()[i] = var_union_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionULong", false);
}

const TypeObject* GetCompleteUnionULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_ulong;
    cst_var_union_ulong.common().member_id(memberId++);
    cst_var_union_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_ulong.common().member_flags().IS_KEY(false);
    cst_var_union_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_ulong.common().member_type_id(*GetUnion_ULongIdentifier(true));
    cst_var_union_ulong.detail().name("var_union_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionULong", true);
}

const TypeIdentifier* GetUnionLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionLongLong", complete);
}

const TypeObject* GetUnionLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionLongLongObject();
    }
    //else
    return GetMinimalUnionLongLongObject();
}

const TypeObject* GetMinimalUnionLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_long_long;
    mst_var_union_long_long.common().member_id(memberId++);
    mst_var_union_long_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_long_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_long_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_long_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_long_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_long_long.common().member_flags().IS_KEY(false);
    mst_var_union_long_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_long_long.common().member_type_id(*GetUnion_LongLongIdentifier(false));
    MD5 var_union_long_long_hash("var_union_long_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_long_long.detail().name_hash()[i] = var_union_long_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_long_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionLongLong", false);
}

const TypeObject* GetCompleteUnionLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_long_long;
    cst_var_union_long_long.common().member_id(memberId++);
    cst_var_union_long_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_long_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_long_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_long_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_long_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_long_long.common().member_flags().IS_KEY(false);
    cst_var_union_long_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_long_long.common().member_type_id(*GetUnion_LongLongIdentifier(true));
    cst_var_union_long_long.detail().name("var_union_long_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_long_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionLongLong", true);
}

const TypeIdentifier* GetUnionULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionULongLong", complete);
}

const TypeObject* GetUnionULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionULongLongObject();
    }
    //else
    return GetMinimalUnionULongLongObject();
}

const TypeObject* GetMinimalUnionULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_ulong_long;
    mst_var_union_ulong_long.common().member_id(memberId++);
    mst_var_union_ulong_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_ulong_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_ulong_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_ulong_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_ulong_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_ulong_long.common().member_flags().IS_KEY(false);
    mst_var_union_ulong_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_ulong_long.common().member_type_id(*GetUnion_ULongLOngIdentifier(false));
    MD5 var_union_ulong_long_hash("var_union_ulong_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_ulong_long.detail().name_hash()[i] = var_union_ulong_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_ulong_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionULongLong", false);
}

const TypeObject* GetCompleteUnionULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_ulong_long;
    cst_var_union_ulong_long.common().member_id(memberId++);
    cst_var_union_ulong_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_ulong_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_ulong_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_ulong_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_ulong_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_ulong_long.common().member_flags().IS_KEY(false);
    cst_var_union_ulong_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_ulong_long.common().member_type_id(*GetUnion_ULongLOngIdentifier(true));
    cst_var_union_ulong_long.detail().name("var_union_ulong_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_ulong_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionULongLong", true);
}

const TypeIdentifier* GetUnionFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionFloat", complete);
}

const TypeObject* GetUnionFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionFloatObject();
    }
    //else
    return GetMinimalUnionFloatObject();
}

const TypeObject* GetMinimalUnionFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_float;
    mst_var_union_float.common().member_id(memberId++);
    mst_var_union_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_float.common().member_flags().IS_KEY(false);
    mst_var_union_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_float.common().member_type_id(*GetUnion_FloatIdentifier(false));
    MD5 var_union_float_hash("var_union_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_float.detail().name_hash()[i] = var_union_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionFloat", false);
}

const TypeObject* GetCompleteUnionFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_float;
    cst_var_union_float.common().member_id(memberId++);
    cst_var_union_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_float.common().member_flags().IS_KEY(false);
    cst_var_union_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_float.common().member_type_id(*GetUnion_FloatIdentifier(true));
    cst_var_union_float.detail().name("var_union_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionFloat", true);
}

const TypeIdentifier* GetUnionDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionDouble", complete);
}

const TypeObject* GetUnionDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionDoubleObject();
    }
    //else
    return GetMinimalUnionDoubleObject();
}

const TypeObject* GetMinimalUnionDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_double;
    mst_var_union_double.common().member_id(memberId++);
    mst_var_union_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_double.common().member_flags().IS_KEY(false);
    mst_var_union_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_double.common().member_type_id(*GetUnion_DoubleIdentifier(false));
    MD5 var_union_double_hash("var_union_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_double.detail().name_hash()[i] = var_union_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDouble", false);
}

const TypeObject* GetCompleteUnionDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_double;
    cst_var_union_double.common().member_id(memberId++);
    cst_var_union_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_double.common().member_flags().IS_KEY(false);
    cst_var_union_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_double.common().member_type_id(*GetUnion_DoubleIdentifier(true));
    cst_var_union_double.detail().name("var_union_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDouble", true);
}

const TypeIdentifier* GetUnionLongDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionLongDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionLongDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionLongDouble", complete);
}

const TypeObject* GetUnionLongDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionLongDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionLongDoubleObject();
    }
    //else
    return GetMinimalUnionLongDoubleObject();
}

const TypeObject* GetMinimalUnionLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionLongDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_long_double;
    mst_var_union_long_double.common().member_id(memberId++);
    mst_var_union_long_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_long_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_long_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_long_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_long_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_long_double.common().member_flags().IS_KEY(false);
    mst_var_union_long_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_long_double.common().member_type_id(*GetUnion_LongDoubleIdentifier(false));
    MD5 var_union_long_double_hash("var_union_long_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_long_double.detail().name_hash()[i] = var_union_long_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_long_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionLongDouble", false);
}

const TypeObject* GetCompleteUnionLongDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionLongDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_long_double;
    cst_var_union_long_double.common().member_id(memberId++);
    cst_var_union_long_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_long_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_long_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_long_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_long_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_long_double.common().member_flags().IS_KEY(false);
    cst_var_union_long_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_long_double.common().member_type_id(*GetUnion_LongDoubleIdentifier(true));
    cst_var_union_long_double.detail().name("var_union_long_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_long_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionLongDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionLongDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionLongDouble", true);
}

const TypeIdentifier* GetUnionBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionBoolean", complete);
}

const TypeObject* GetUnionBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionBooleanObject();
    }
    //else
    return GetMinimalUnionBooleanObject();
}

const TypeObject* GetMinimalUnionBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_boolean;
    mst_var_union_boolean.common().member_id(memberId++);
    mst_var_union_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_boolean.common().member_flags().IS_KEY(false);
    mst_var_union_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_boolean.common().member_type_id(*GetUnion_BooleanIdentifier(false));
    MD5 var_union_boolean_hash("var_union_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_boolean.detail().name_hash()[i] = var_union_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionBoolean", false);
}

const TypeObject* GetCompleteUnionBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_boolean;
    cst_var_union_boolean.common().member_id(memberId++);
    cst_var_union_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_boolean.common().member_flags().IS_KEY(false);
    cst_var_union_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_boolean.common().member_type_id(*GetUnion_BooleanIdentifier(true));
    cst_var_union_boolean.detail().name("var_union_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionBoolean", true);
}

const TypeIdentifier* GetUnionOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionOctet", complete);
}

const TypeObject* GetUnionOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionOctetObject();
    }
    //else
    return GetMinimalUnionOctetObject();
}

const TypeObject* GetMinimalUnionOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_octet;
    mst_var_union_octet.common().member_id(memberId++);
    mst_var_union_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_octet.common().member_flags().IS_KEY(false);
    mst_var_union_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_octet.common().member_type_id(*GetUnion_OctetIdentifier(false));
    MD5 var_union_octet_hash("var_union_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_octet.detail().name_hash()[i] = var_union_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionOctet", false);
}

const TypeObject* GetCompleteUnionOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_octet;
    cst_var_union_octet.common().member_id(memberId++);
    cst_var_union_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_octet.common().member_flags().IS_KEY(false);
    cst_var_union_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_octet.common().member_type_id(*GetUnion_OctetIdentifier(true));
    cst_var_union_octet.detail().name("var_union_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionOctet", true);
}

const TypeIdentifier* GetUnionCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionChar", complete);
}

const TypeObject* GetUnionCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionCharObject();
    }
    //else
    return GetMinimalUnionCharObject();
}

const TypeObject* GetMinimalUnionCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_char;
    mst_var_union_char.common().member_id(memberId++);
    mst_var_union_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_char.common().member_flags().IS_KEY(false);
    mst_var_union_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_char.common().member_type_id(*GetUnion_CharIdentifier(false));
    MD5 var_union_char_hash("var_union_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_char.detail().name_hash()[i] = var_union_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionChar", false);
}

const TypeObject* GetCompleteUnionCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_char;
    cst_var_union_char.common().member_id(memberId++);
    cst_var_union_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_char.common().member_flags().IS_KEY(false);
    cst_var_union_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_char.common().member_type_id(*GetUnion_CharIdentifier(true));
    cst_var_union_char.detail().name("var_union_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionChar", true);
}

const TypeIdentifier* GetUnionWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionWChar", complete);
}

const TypeObject* GetUnionWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionWCharObject();
    }
    //else
    return GetMinimalUnionWCharObject();
}

const TypeObject* GetMinimalUnionWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_wchar;
    mst_var_union_wchar.common().member_id(memberId++);
    mst_var_union_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_wchar.common().member_flags().IS_KEY(false);
    mst_var_union_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_wchar.common().member_type_id(*GetUnion_WCharIdentifier(false));
    MD5 var_union_wchar_hash("var_union_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_wchar.detail().name_hash()[i] = var_union_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionWChar", false);
}

const TypeObject* GetCompleteUnionWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_wchar;
    cst_var_union_wchar.common().member_id(memberId++);
    cst_var_union_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_wchar.common().member_flags().IS_KEY(false);
    cst_var_union_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_wchar.common().member_type_id(*GetUnion_WCharIdentifier(true));
    cst_var_union_wchar.detail().name("var_union_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionWChar", true);
}

const TypeIdentifier* GetUnionStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionString", complete);
}

const TypeObject* GetUnionStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionStringObject();
    }
    //else
    return GetMinimalUnionStringObject();
}

const TypeObject* GetMinimalUnionStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_string;
    mst_var_union_string.common().member_id(memberId++);
    mst_var_union_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_string.common().member_flags().IS_KEY(false);
    mst_var_union_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_string.common().member_type_id(*GetUnion_StringIdentifier(false));
    MD5 var_union_string_hash("var_union_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_string.detail().name_hash()[i] = var_union_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionString", false);
}

const TypeObject* GetCompleteUnionStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_string;
    cst_var_union_string.common().member_id(memberId++);
    cst_var_union_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_string.common().member_flags().IS_KEY(false);
    cst_var_union_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_string.common().member_type_id(*GetUnion_StringIdentifier(true));
    cst_var_union_string.detail().name("var_union_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionString", true);
}

const TypeIdentifier* GetUnionWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionWString", complete);
}

const TypeObject* GetUnionWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionWStringObject();
    }
    //else
    return GetMinimalUnionWStringObject();
}

const TypeObject* GetMinimalUnionWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_wstring;
    mst_var_union_wstring.common().member_id(memberId++);
    mst_var_union_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_wstring.common().member_flags().IS_KEY(false);
    mst_var_union_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_wstring.common().member_type_id(*GetUnion_WStringIdentifier(false));
    MD5 var_union_wstring_hash("var_union_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_wstring.detail().name_hash()[i] = var_union_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionWString", false);
}

const TypeObject* GetCompleteUnionWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_wstring;
    cst_var_union_wstring.common().member_id(memberId++);
    cst_var_union_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_wstring.common().member_flags().IS_KEY(false);
    cst_var_union_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_wstring.common().member_type_id(*GetUnion_WStringIdentifier(true));
    cst_var_union_wstring.detail().name("var_union_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionWString", true);
}

const TypeIdentifier* GetUnionBoundedStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionBoundedString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionBoundedStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionBoundedString", complete);
}

const TypeObject* GetUnionBoundedStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionBoundedString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionBoundedStringObject();
    }
    //else
    return GetMinimalUnionBoundedStringObject();
}

const TypeObject* GetMinimalUnionBoundedStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionBoundedString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_bounded_string;
    mst_var_union_bounded_string.common().member_id(memberId++);
    mst_var_union_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_bounded_string.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_bounded_string.common().member_flags().IS_KEY(false);
    mst_var_union_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_bounded_string.common().member_type_id(*GetUnion_BoundedStringIdentifier(false));
    MD5 var_union_bounded_string_hash("var_union_bounded_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_bounded_string.detail().name_hash()[i] = var_union_bounded_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_bounded_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionBoundedString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionBoundedString", false);
}

const TypeObject* GetCompleteUnionBoundedStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionBoundedString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_bounded_string;
    cst_var_union_bounded_string.common().member_id(memberId++);
    cst_var_union_bounded_string.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_bounded_string.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_bounded_string.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_bounded_string.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_bounded_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_bounded_string.common().member_flags().IS_KEY(false);
    cst_var_union_bounded_string.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_bounded_string.common().member_type_id(*GetUnion_BoundedStringIdentifier(true));
    cst_var_union_bounded_string.detail().name("var_union_bounded_string");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_bounded_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionBoundedString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionBoundedString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionBoundedString", true);
}

const TypeIdentifier* GetUnionBoundedWStringIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionBoundedWString", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionBoundedWStringObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionBoundedWString", complete);
}

const TypeObject* GetUnionBoundedWStringObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionBoundedWString", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionBoundedWStringObject();
    }
    //else
    return GetMinimalUnionBoundedWStringObject();
}

const TypeObject* GetMinimalUnionBoundedWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionBoundedWString", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_bounded_wstring;
    mst_var_union_bounded_wstring.common().member_id(memberId++);
    mst_var_union_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_bounded_wstring.common().member_flags().IS_KEY(false);
    mst_var_union_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_bounded_wstring.common().member_type_id(*GetUnion_BoundedWStringIdentifier(false));
    MD5 var_union_bounded_wstring_hash("var_union_bounded_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_bounded_wstring.detail().name_hash()[i] = var_union_bounded_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_bounded_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionBoundedWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionBoundedWString", false);
}

const TypeObject* GetCompleteUnionBoundedWStringObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionBoundedWString", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_bounded_wstring;
    cst_var_union_bounded_wstring.common().member_id(memberId++);
    cst_var_union_bounded_wstring.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_bounded_wstring.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_bounded_wstring.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_bounded_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_bounded_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_bounded_wstring.common().member_flags().IS_KEY(false);
    cst_var_union_bounded_wstring.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_bounded_wstring.common().member_type_id(*GetUnion_BoundedWStringIdentifier(true));
    cst_var_union_bounded_wstring.detail().name("var_union_bounded_wstring");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_bounded_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionBoundedWString");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionBoundedWString", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionBoundedWString", true);
}

const TypeIdentifier* GetUnionInnerEnumHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionInnerEnumHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionInnerEnumHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionInnerEnumHelper", complete);
}

const TypeObject* GetUnionInnerEnumHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerEnumHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionInnerEnumHelperObject();
    }
    //else
    return GetMinimalUnionInnerEnumHelperObject();
}

const TypeObject* GetMinimalUnionInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerEnumHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_my_enum;
    mst_var_union_my_enum.common().member_id(memberId++);
    mst_var_union_my_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_my_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_my_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_my_enum.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_my_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_my_enum.common().member_flags().IS_KEY(false);
    mst_var_union_my_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_my_enum.common().member_type_id(*GetUnion_InnerEnumHelperIdentifier(false));
    MD5 var_union_my_enum_hash("var_union_my_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_my_enum.detail().name_hash()[i] = var_union_my_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_my_enum);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionInnerEnumHelper", false);
}

const TypeObject* GetCompleteUnionInnerEnumHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerEnumHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_my_enum;
    cst_var_union_my_enum.common().member_id(memberId++);
    cst_var_union_my_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_my_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_my_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_my_enum.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_my_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_my_enum.common().member_flags().IS_KEY(false);
    cst_var_union_my_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_my_enum.common().member_type_id(*GetUnion_InnerEnumHelperIdentifier(true));
    cst_var_union_my_enum.detail().name("var_union_my_enum");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_my_enum);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionInnerEnumHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionInnerEnumHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionInnerEnumHelper", true);
}

const TypeIdentifier* GetUnionInnerBitMaskHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionInnerBitMaskHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionInnerBitMaskHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionInnerBitMaskHelper", complete);
}

const TypeObject* GetUnionInnerBitMaskHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerBitMaskHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionInnerBitMaskHelperObject();
    }
    //else
    return GetMinimalUnionInnerBitMaskHelperObject();
}

const TypeObject* GetMinimalUnionInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerBitMaskHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_my_bit_mask;
    mst_var_union_my_bit_mask.common().member_id(memberId++);
    mst_var_union_my_bit_mask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_my_bit_mask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_my_bit_mask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_my_bit_mask.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_my_bit_mask.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_my_bit_mask.common().member_flags().IS_KEY(false);
    mst_var_union_my_bit_mask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_my_bit_mask.common().member_type_id(*GetUnion_InnerBitMaskHelperIdentifier(false));
    MD5 var_union_my_bit_mask_hash("var_union_my_bit_mask");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_my_bit_mask.detail().name_hash()[i] = var_union_my_bit_mask_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_my_bit_mask);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionInnerBitMaskHelper", false);
}

const TypeObject* GetCompleteUnionInnerBitMaskHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerBitMaskHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_my_bit_mask;
    cst_var_union_my_bit_mask.common().member_id(memberId++);
    cst_var_union_my_bit_mask.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_my_bit_mask.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_my_bit_mask.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_my_bit_mask.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_my_bit_mask.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_my_bit_mask.common().member_flags().IS_KEY(false);
    cst_var_union_my_bit_mask.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_my_bit_mask.common().member_type_id(*GetUnion_InnerBitMaskHelperIdentifier(true));
    cst_var_union_my_bit_mask.detail().name("var_union_my_bit_mask");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_my_bit_mask);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionInnerBitMaskHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionInnerBitMaskHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionInnerBitMaskHelper", true);
}

const TypeIdentifier* GetUnionInnerAliasHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionInnerAliasHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionInnerAliasHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionInnerAliasHelper", complete);
}

const TypeObject* GetUnionInnerAliasHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerAliasHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionInnerAliasHelperObject();
    }
    //else
    return GetMinimalUnionInnerAliasHelperObject();
}

const TypeObject* GetMinimalUnionInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerAliasHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_my_alias;
    mst_var_union_my_alias.common().member_id(memberId++);
    mst_var_union_my_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_my_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_my_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_my_alias.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_my_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_my_alias.common().member_flags().IS_KEY(false);
    mst_var_union_my_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_my_alias.common().member_type_id(*GetUnion_InnerAliasHelperIdentifier(false));
    MD5 var_union_my_alias_hash("var_union_my_alias");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_my_alias.detail().name_hash()[i] = var_union_my_alias_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_my_alias);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionInnerAliasHelper", false);
}

const TypeObject* GetCompleteUnionInnerAliasHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerAliasHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_my_alias;
    cst_var_union_my_alias.common().member_id(memberId++);
    cst_var_union_my_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_my_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_my_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_my_alias.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_my_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_my_alias.common().member_flags().IS_KEY(false);
    cst_var_union_my_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_my_alias.common().member_type_id(*GetUnion_InnerAliasHelperIdentifier(true));
    cst_var_union_my_alias.detail().name("var_union_my_alias");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_my_alias);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionInnerAliasHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionInnerAliasHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionInnerAliasHelper", true);
}

const TypeIdentifier* GetUnionArrayIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionArray", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionArrayObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionArray", complete);
}

const TypeObject* GetUnionArrayObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionArray", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionArrayObject();
    }
    //else
    return GetMinimalUnionArrayObject();
}

const TypeObject* GetMinimalUnionArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionArray", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_array;
    mst_var_union_array.common().member_id(memberId++);
    mst_var_union_array.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_array.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_array.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_array.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_array.common().member_flags().IS_KEY(false);
    mst_var_union_array.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_array.common().member_type_id(*GetUnion_ArrayIdentifier(false));
    MD5 var_union_array_hash("var_union_array");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_array.detail().name_hash()[i] = var_union_array_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_array);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionArray", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionArray", false);
}

const TypeObject* GetCompleteUnionArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionArray", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_array;
    cst_var_union_array.common().member_id(memberId++);
    cst_var_union_array.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_array.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_array.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_array.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_array.common().member_flags().IS_KEY(false);
    cst_var_union_array.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_array.common().member_type_id(*GetUnion_ArrayIdentifier(true));
    cst_var_union_array.detail().name("var_union_array");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_array);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionArray");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionArray", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionArray", true);
}

const TypeIdentifier* GetUnionSequenceIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionSequence", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionSequenceObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionSequence", complete);
}

const TypeObject* GetUnionSequenceObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionSequence", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionSequenceObject();
    }
    //else
    return GetMinimalUnionSequenceObject();
}

const TypeObject* GetMinimalUnionSequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionSequence", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_sequence;
    mst_var_union_sequence.common().member_id(memberId++);
    mst_var_union_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_sequence.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_sequence.common().member_flags().IS_KEY(false);
    mst_var_union_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_sequence.common().member_type_id(*GetUnion_SequenceIdentifier(false));
    MD5 var_union_sequence_hash("var_union_sequence");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_sequence.detail().name_hash()[i] = var_union_sequence_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_sequence);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionSequence", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionSequence", false);
}

const TypeObject* GetCompleteUnionSequenceObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionSequence", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_sequence;
    cst_var_union_sequence.common().member_id(memberId++);
    cst_var_union_sequence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_sequence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_sequence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_sequence.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_sequence.common().member_flags().IS_KEY(false);
    cst_var_union_sequence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_sequence.common().member_type_id(*GetUnion_SequenceIdentifier(true));
    cst_var_union_sequence.detail().name("var_union_sequence");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_sequence);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionSequence");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionSequence", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionSequence", true);
}

const TypeIdentifier* GetUnionMapIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionMap", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionMapObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionMap", complete);
}

const TypeObject* GetUnionMapObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionMap", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionMapObject();
    }
    //else
    return GetMinimalUnionMapObject();
}

const TypeObject* GetMinimalUnionMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionMap", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_map;
    mst_var_union_map.common().member_id(memberId++);
    mst_var_union_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_map.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_map.common().member_flags().IS_KEY(false);
    mst_var_union_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_map.common().member_type_id(*GetUnion_MapIdentifier(false));
    MD5 var_union_map_hash("var_union_map");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_map.detail().name_hash()[i] = var_union_map_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_map);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionMap", false);
}

const TypeObject* GetCompleteUnionMapObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionMap", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_map;
    cst_var_union_map.common().member_id(memberId++);
    cst_var_union_map.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_map.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_map.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_map.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_map.common().member_flags().IS_KEY(false);
    cst_var_union_map.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_map.common().member_type_id(*GetUnion_MapIdentifier(true));
    cst_var_union_map.detail().name("var_union_map");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_map);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionMap");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionMap", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionMap", true);
}

const TypeIdentifier* GetUnionInnerUnionHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionInnerUnionHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionInnerUnionHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionInnerUnionHelper", complete);
}

const TypeObject* GetUnionInnerUnionHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerUnionHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionInnerUnionHelperObject();
    }
    //else
    return GetMinimalUnionInnerUnionHelperObject();
}

const TypeObject* GetMinimalUnionInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerUnionHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_my_union;
    mst_var_union_my_union.common().member_id(memberId++);
    mst_var_union_my_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_my_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_my_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_my_union.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_my_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_my_union.common().member_flags().IS_KEY(false);
    mst_var_union_my_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_my_union.common().member_type_id(*GetUnion_InnerUnionHelperIdentifier(false));
    MD5 var_union_my_union_hash("var_union_my_union");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_my_union.detail().name_hash()[i] = var_union_my_union_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_my_union);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionInnerUnionHelper", false);
}

const TypeObject* GetCompleteUnionInnerUnionHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerUnionHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_my_union;
    cst_var_union_my_union.common().member_id(memberId++);
    cst_var_union_my_union.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_my_union.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_my_union.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_my_union.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_my_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_my_union.common().member_flags().IS_KEY(false);
    cst_var_union_my_union.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_my_union.common().member_type_id(*GetUnion_InnerUnionHelperIdentifier(true));
    cst_var_union_my_union.detail().name("var_union_my_union");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_my_union);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionInnerUnionHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionInnerUnionHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionInnerUnionHelper", true);
}

const TypeIdentifier* GetUnionInnerStructureHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionInnerStructureHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionInnerStructureHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionInnerStructureHelper", complete);
}

const TypeObject* GetUnionInnerStructureHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerStructureHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionInnerStructureHelperObject();
    }
    //else
    return GetMinimalUnionInnerStructureHelperObject();
}

const TypeObject* GetMinimalUnionInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerStructureHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_my_structure;
    mst_var_union_my_structure.common().member_id(memberId++);
    mst_var_union_my_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_my_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_my_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_my_structure.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_my_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_my_structure.common().member_flags().IS_KEY(false);
    mst_var_union_my_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_my_structure.common().member_type_id(*GetUnion_InnerStructureHelperIdentifier(false));
    MD5 var_union_my_structure_hash("var_union_my_structure");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_my_structure.detail().name_hash()[i] = var_union_my_structure_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_my_structure);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionInnerStructureHelper", false);
}

const TypeObject* GetCompleteUnionInnerStructureHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerStructureHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_my_structure;
    cst_var_union_my_structure.common().member_id(memberId++);
    cst_var_union_my_structure.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_my_structure.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_my_structure.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_my_structure.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_my_structure.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_my_structure.common().member_flags().IS_KEY(false);
    cst_var_union_my_structure.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_my_structure.common().member_type_id(*GetUnion_InnerStructureHelperIdentifier(true));
    cst_var_union_my_structure.detail().name("var_union_my_structure");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_my_structure);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionInnerStructureHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionInnerStructureHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionInnerStructureHelper", true);
}

const TypeIdentifier* GetUnionInnerBitsetHelperIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionInnerBitsetHelper", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionInnerBitsetHelperObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionInnerBitsetHelper", complete);
}

const TypeObject* GetUnionInnerBitsetHelperObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerBitsetHelper", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionInnerBitsetHelperObject();
    }
    //else
    return GetMinimalUnionInnerBitsetHelperObject();
}

const TypeObject* GetMinimalUnionInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerBitsetHelper", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_my_bitset;
    mst_var_union_my_bitset.common().member_id(memberId++);
    mst_var_union_my_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_my_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_my_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_my_bitset.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_my_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_my_bitset.common().member_flags().IS_KEY(false);
    mst_var_union_my_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_my_bitset.common().member_type_id(*GetUnion_InnerBitsetHelperIdentifier(false));
    MD5 var_union_my_bitset_hash("var_union_my_bitset");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_my_bitset.detail().name_hash()[i] = var_union_my_bitset_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_my_bitset);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionInnerBitsetHelper", false);
}

const TypeObject* GetCompleteUnionInnerBitsetHelperObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionInnerBitsetHelper", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_my_bitset;
    cst_var_union_my_bitset.common().member_id(memberId++);
    cst_var_union_my_bitset.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_my_bitset.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_my_bitset.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_my_bitset.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_my_bitset.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_my_bitset.common().member_flags().IS_KEY(false);
    cst_var_union_my_bitset.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_my_bitset.common().member_type_id(*GetUnion_InnerBitsetHelperIdentifier(true));
    cst_var_union_my_bitset.detail().name("var_union_my_bitset");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_my_bitset);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionInnerBitsetHelper");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionInnerBitsetHelper", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionInnerBitsetHelper", true);
}

const TypeIdentifier* GetUnionDiscriminatorShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionDiscriminatorShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorShort", complete);
}

const TypeObject* GetUnionDiscriminatorShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionDiscriminatorShortObject();
    }
    //else
    return GetMinimalUnionDiscriminatorShortObject();
}

const TypeObject* GetMinimalUnionDiscriminatorShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_discriminator_short;
    mst_var_union_discriminator_short.common().member_id(memberId++);
    mst_var_union_discriminator_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_discriminator_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_discriminator_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_discriminator_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_discriminator_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_discriminator_short.common().member_flags().IS_KEY(false);
    mst_var_union_discriminator_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_discriminator_short.common().member_type_id(*GetUnion_Discriminator_shortIdentifier(false));
    MD5 var_union_discriminator_short_hash("var_union_discriminator_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_discriminator_short.detail().name_hash()[i] = var_union_discriminator_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_discriminator_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorShort", false);
}

const TypeObject* GetCompleteUnionDiscriminatorShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_discriminator_short;
    cst_var_union_discriminator_short.common().member_id(memberId++);
    cst_var_union_discriminator_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_discriminator_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_discriminator_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_discriminator_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_discriminator_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_discriminator_short.common().member_flags().IS_KEY(false);
    cst_var_union_discriminator_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_discriminator_short.common().member_type_id(*GetUnion_Discriminator_shortIdentifier(true));
    cst_var_union_discriminator_short.detail().name("var_union_discriminator_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_discriminator_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionDiscriminatorShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorShort", true);
}

const TypeIdentifier* GetUnionDiscriminatorUShortIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorUShort", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionDiscriminatorUShortObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorUShort", complete);
}

const TypeObject* GetUnionDiscriminatorUShortObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorUShort", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionDiscriminatorUShortObject();
    }
    //else
    return GetMinimalUnionDiscriminatorUShortObject();
}

const TypeObject* GetMinimalUnionDiscriminatorUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorUShort", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_discriminator_ushort;
    mst_var_union_discriminator_ushort.common().member_id(memberId++);
    mst_var_union_discriminator_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_discriminator_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_discriminator_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_discriminator_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_discriminator_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_discriminator_ushort.common().member_flags().IS_KEY(false);
    mst_var_union_discriminator_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_discriminator_ushort.common().member_type_id(*GetUnion_Discriminator_unsigned_shortIdentifier(false));
    MD5 var_union_discriminator_ushort_hash("var_union_discriminator_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_discriminator_ushort.detail().name_hash()[i] = var_union_discriminator_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_discriminator_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorUShort", false);
}

const TypeObject* GetCompleteUnionDiscriminatorUShortObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorUShort", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_discriminator_ushort;
    cst_var_union_discriminator_ushort.common().member_id(memberId++);
    cst_var_union_discriminator_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_discriminator_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_discriminator_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_discriminator_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_discriminator_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_discriminator_ushort.common().member_flags().IS_KEY(false);
    cst_var_union_discriminator_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_discriminator_ushort.common().member_type_id(*GetUnion_Discriminator_unsigned_shortIdentifier(true));
    cst_var_union_discriminator_ushort.detail().name("var_union_discriminator_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_discriminator_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionDiscriminatorUShort");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorUShort", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorUShort", true);
}

const TypeIdentifier* GetUnionDiscriminatorLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionDiscriminatorLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorLong", complete);
}

const TypeObject* GetUnionDiscriminatorLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionDiscriminatorLongObject();
    }
    //else
    return GetMinimalUnionDiscriminatorLongObject();
}

const TypeObject* GetMinimalUnionDiscriminatorLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_discriminator_long;
    mst_var_union_discriminator_long.common().member_id(memberId++);
    mst_var_union_discriminator_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_discriminator_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_discriminator_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_discriminator_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_discriminator_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_discriminator_long.common().member_flags().IS_KEY(false);
    mst_var_union_discriminator_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_discriminator_long.common().member_type_id(*GetUnion_Discriminator_longIdentifier(false));
    MD5 var_union_discriminator_long_hash("var_union_discriminator_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_discriminator_long.detail().name_hash()[i] = var_union_discriminator_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_discriminator_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorLong", false);
}

const TypeObject* GetCompleteUnionDiscriminatorLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_discriminator_long;
    cst_var_union_discriminator_long.common().member_id(memberId++);
    cst_var_union_discriminator_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_discriminator_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_discriminator_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_discriminator_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_discriminator_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_discriminator_long.common().member_flags().IS_KEY(false);
    cst_var_union_discriminator_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_discriminator_long.common().member_type_id(*GetUnion_Discriminator_longIdentifier(true));
    cst_var_union_discriminator_long.detail().name("var_union_discriminator_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_discriminator_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionDiscriminatorLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorLong", true);
}

const TypeIdentifier* GetUnionDiscriminatorULongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorULong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionDiscriminatorULongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorULong", complete);
}

const TypeObject* GetUnionDiscriminatorULongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorULong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionDiscriminatorULongObject();
    }
    //else
    return GetMinimalUnionDiscriminatorULongObject();
}

const TypeObject* GetMinimalUnionDiscriminatorULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorULong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_discriminator_ulong;
    mst_var_union_discriminator_ulong.common().member_id(memberId++);
    mst_var_union_discriminator_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_discriminator_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_discriminator_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_discriminator_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_discriminator_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_discriminator_ulong.common().member_flags().IS_KEY(false);
    mst_var_union_discriminator_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_discriminator_ulong.common().member_type_id(*GetUnion_Discriminator_unsigned_longIdentifier(false));
    MD5 var_union_discriminator_ulong_hash("var_union_discriminator_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_discriminator_ulong.detail().name_hash()[i] = var_union_discriminator_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_discriminator_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorULong", false);
}

const TypeObject* GetCompleteUnionDiscriminatorULongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorULong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_discriminator_ulong;
    cst_var_union_discriminator_ulong.common().member_id(memberId++);
    cst_var_union_discriminator_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_discriminator_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_discriminator_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_discriminator_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_discriminator_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_discriminator_ulong.common().member_flags().IS_KEY(false);
    cst_var_union_discriminator_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_discriminator_ulong.common().member_type_id(*GetUnion_Discriminator_unsigned_longIdentifier(true));
    cst_var_union_discriminator_ulong.detail().name("var_union_discriminator_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_discriminator_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionDiscriminatorULong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorULong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorULong", true);
}

const TypeIdentifier* GetUnionDiscriminatorLongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorLongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionDiscriminatorLongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorLongLong", complete);
}

const TypeObject* GetUnionDiscriminatorLongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorLongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionDiscriminatorLongLongObject();
    }
    //else
    return GetMinimalUnionDiscriminatorLongLongObject();
}

const TypeObject* GetMinimalUnionDiscriminatorLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorLongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_discriminator_long_long;
    mst_var_union_discriminator_long_long.common().member_id(memberId++);
    mst_var_union_discriminator_long_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_discriminator_long_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_discriminator_long_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_discriminator_long_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_discriminator_long_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_discriminator_long_long.common().member_flags().IS_KEY(false);
    mst_var_union_discriminator_long_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_discriminator_long_long.common().member_type_id(*GetUnion_Discriminator_long_longIdentifier(false));
    MD5 var_union_discriminator_long_long_hash("var_union_discriminator_long_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_discriminator_long_long.detail().name_hash()[i] = var_union_discriminator_long_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_discriminator_long_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorLongLong", false);
}

const TypeObject* GetCompleteUnionDiscriminatorLongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorLongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_discriminator_long_long;
    cst_var_union_discriminator_long_long.common().member_id(memberId++);
    cst_var_union_discriminator_long_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_discriminator_long_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_discriminator_long_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_discriminator_long_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_discriminator_long_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_discriminator_long_long.common().member_flags().IS_KEY(false);
    cst_var_union_discriminator_long_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_discriminator_long_long.common().member_type_id(*GetUnion_Discriminator_long_longIdentifier(true));
    cst_var_union_discriminator_long_long.detail().name("var_union_discriminator_long_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_discriminator_long_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionDiscriminatorLongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorLongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorLongLong", true);
}

const TypeIdentifier* GetUnionDiscriminatorULongLongIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorULongLong", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionDiscriminatorULongLongObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorULongLong", complete);
}

const TypeObject* GetUnionDiscriminatorULongLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorULongLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionDiscriminatorULongLongObject();
    }
    //else
    return GetMinimalUnionDiscriminatorULongLongObject();
}

const TypeObject* GetMinimalUnionDiscriminatorULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorULongLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_discriminator_ulong_long_long;
    mst_var_union_discriminator_ulong_long_long.common().member_id(memberId++);
    mst_var_union_discriminator_ulong_long_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_discriminator_ulong_long_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_discriminator_ulong_long_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_discriminator_ulong_long_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_discriminator_ulong_long_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_discriminator_ulong_long_long.common().member_flags().IS_KEY(false);
    mst_var_union_discriminator_ulong_long_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_discriminator_ulong_long_long.common().member_type_id(*GetUnion_Discriminator_unsigned_long_longIdentifier(false));
    MD5 var_union_discriminator_ulong_long_long_hash("var_union_discriminator_ulong_long_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_discriminator_ulong_long_long.detail().name_hash()[i] = var_union_discriminator_ulong_long_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_discriminator_ulong_long_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorULongLong", false);
}

const TypeObject* GetCompleteUnionDiscriminatorULongLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorULongLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_discriminator_ulong_long_long;
    cst_var_union_discriminator_ulong_long_long.common().member_id(memberId++);
    cst_var_union_discriminator_ulong_long_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_discriminator_ulong_long_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_discriminator_ulong_long_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_discriminator_ulong_long_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_discriminator_ulong_long_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_discriminator_ulong_long_long.common().member_flags().IS_KEY(false);
    cst_var_union_discriminator_ulong_long_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_discriminator_ulong_long_long.common().member_type_id(*GetUnion_Discriminator_unsigned_long_longIdentifier(true));
    cst_var_union_discriminator_ulong_long_long.detail().name("var_union_discriminator_ulong_long_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_discriminator_ulong_long_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionDiscriminatorULongLong");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorULongLong", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorULongLong", true);
}

const TypeIdentifier* GetUnionDiscriminatorBooleanIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorBoolean", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionDiscriminatorBooleanObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorBoolean", complete);
}

const TypeObject* GetUnionDiscriminatorBooleanObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorBoolean", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionDiscriminatorBooleanObject();
    }
    //else
    return GetMinimalUnionDiscriminatorBooleanObject();
}

const TypeObject* GetMinimalUnionDiscriminatorBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorBoolean", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_discriminator_boolean;
    mst_var_union_discriminator_boolean.common().member_id(memberId++);
    mst_var_union_discriminator_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_discriminator_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_discriminator_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_discriminator_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_discriminator_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_discriminator_boolean.common().member_flags().IS_KEY(false);
    mst_var_union_discriminator_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_discriminator_boolean.common().member_type_id(*GetUnion_Discriminator_booleanIdentifier(false));
    MD5 var_union_discriminator_boolean_hash("var_union_discriminator_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_discriminator_boolean.detail().name_hash()[i] = var_union_discriminator_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_discriminator_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorBoolean", false);
}

const TypeObject* GetCompleteUnionDiscriminatorBooleanObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorBoolean", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_discriminator_boolean;
    cst_var_union_discriminator_boolean.common().member_id(memberId++);
    cst_var_union_discriminator_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_discriminator_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_discriminator_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_discriminator_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_discriminator_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_discriminator_boolean.common().member_flags().IS_KEY(false);
    cst_var_union_discriminator_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_discriminator_boolean.common().member_type_id(*GetUnion_Discriminator_booleanIdentifier(true));
    cst_var_union_discriminator_boolean.detail().name("var_union_discriminator_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_discriminator_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionDiscriminatorBoolean");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorBoolean", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorBoolean", true);
}

const TypeIdentifier* GetUnionDiscriminatorOctetIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorOctet", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionDiscriminatorOctetObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorOctet", complete);
}

const TypeObject* GetUnionDiscriminatorOctetObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorOctet", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionDiscriminatorOctetObject();
    }
    //else
    return GetMinimalUnionDiscriminatorOctetObject();
}

const TypeObject* GetMinimalUnionDiscriminatorOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorOctet", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_discriminator_octet;
    mst_var_union_discriminator_octet.common().member_id(memberId++);
    mst_var_union_discriminator_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_discriminator_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_discriminator_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_discriminator_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_discriminator_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_discriminator_octet.common().member_flags().IS_KEY(false);
    mst_var_union_discriminator_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_discriminator_octet.common().member_type_id(*GetUnion_Discriminator_octetIdentifier(false));
    MD5 var_union_discriminator_octet_hash("var_union_discriminator_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_discriminator_octet.detail().name_hash()[i] = var_union_discriminator_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_discriminator_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorOctet", false);
}

const TypeObject* GetCompleteUnionDiscriminatorOctetObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorOctet", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_discriminator_octet;
    cst_var_union_discriminator_octet.common().member_id(memberId++);
    cst_var_union_discriminator_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_discriminator_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_discriminator_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_discriminator_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_discriminator_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_discriminator_octet.common().member_flags().IS_KEY(false);
    cst_var_union_discriminator_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_discriminator_octet.common().member_type_id(*GetUnion_Discriminator_octetIdentifier(true));
    cst_var_union_discriminator_octet.detail().name("var_union_discriminator_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_discriminator_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionDiscriminatorOctet");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorOctet", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorOctet", true);
}

const TypeIdentifier* GetUnionDiscriminatorCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionDiscriminatorCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorChar", complete);
}

const TypeObject* GetUnionDiscriminatorCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionDiscriminatorCharObject();
    }
    //else
    return GetMinimalUnionDiscriminatorCharObject();
}

const TypeObject* GetMinimalUnionDiscriminatorCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_discriminator_char;
    mst_var_union_discriminator_char.common().member_id(memberId++);
    mst_var_union_discriminator_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_discriminator_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_discriminator_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_discriminator_char.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_discriminator_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_discriminator_char.common().member_flags().IS_KEY(false);
    mst_var_union_discriminator_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_discriminator_char.common().member_type_id(*GetUnion_Discriminator_charIdentifier(false));
    MD5 var_union_discriminator_char_hash("var_union_discriminator_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_discriminator_char.detail().name_hash()[i] = var_union_discriminator_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_discriminator_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorChar", false);
}

const TypeObject* GetCompleteUnionDiscriminatorCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_discriminator_char;
    cst_var_union_discriminator_char.common().member_id(memberId++);
    cst_var_union_discriminator_char.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_discriminator_char.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_discriminator_char.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_discriminator_char.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_discriminator_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_discriminator_char.common().member_flags().IS_KEY(false);
    cst_var_union_discriminator_char.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_discriminator_char.common().member_type_id(*GetUnion_Discriminator_charIdentifier(true));
    cst_var_union_discriminator_char.detail().name("var_union_discriminator_char");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_discriminator_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionDiscriminatorChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorChar", true);
}

const TypeIdentifier* GetUnionDiscriminatorWCharIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorWChar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionDiscriminatorWCharObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorWChar", complete);
}

const TypeObject* GetUnionDiscriminatorWCharObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorWChar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionDiscriminatorWCharObject();
    }
    //else
    return GetMinimalUnionDiscriminatorWCharObject();
}

const TypeObject* GetMinimalUnionDiscriminatorWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorWChar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_discriminator_wchar;
    mst_var_union_discriminator_wchar.common().member_id(memberId++);
    mst_var_union_discriminator_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_discriminator_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_discriminator_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_discriminator_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_discriminator_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_discriminator_wchar.common().member_flags().IS_KEY(false);
    mst_var_union_discriminator_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_discriminator_wchar.common().member_type_id(*GetUnion_Discriminator_wcharIdentifier(false));
    MD5 var_union_discriminator_wchar_hash("var_union_discriminator_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_discriminator_wchar.detail().name_hash()[i] = var_union_discriminator_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_discriminator_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorWChar", false);
}

const TypeObject* GetCompleteUnionDiscriminatorWCharObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorWChar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_discriminator_wchar;
    cst_var_union_discriminator_wchar.common().member_id(memberId++);
    cst_var_union_discriminator_wchar.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_discriminator_wchar.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_discriminator_wchar.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_discriminator_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_discriminator_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_discriminator_wchar.common().member_flags().IS_KEY(false);
    cst_var_union_discriminator_wchar.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_discriminator_wchar.common().member_type_id(*GetUnion_Discriminator_wcharIdentifier(true));
    cst_var_union_discriminator_wchar.detail().name("var_union_discriminator_wchar");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_discriminator_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionDiscriminatorWChar");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorWChar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorWChar", true);
}

const TypeIdentifier* GetUnionDiscriminatorEnumIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorEnum", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionDiscriminatorEnumObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorEnum", complete);
}

const TypeObject* GetUnionDiscriminatorEnumObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorEnum", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionDiscriminatorEnumObject();
    }
    //else
    return GetMinimalUnionDiscriminatorEnumObject();
}

const TypeObject* GetMinimalUnionDiscriminatorEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorEnum", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_discriminator_enum;
    mst_var_union_discriminator_enum.common().member_id(memberId++);
    mst_var_union_discriminator_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_discriminator_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_discriminator_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_discriminator_enum.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_discriminator_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_discriminator_enum.common().member_flags().IS_KEY(false);
    mst_var_union_discriminator_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_discriminator_enum.common().member_type_id(*GetUnion_Discriminator_enumIdentifier(false));
    MD5 var_union_discriminator_enum_hash("var_union_discriminator_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_discriminator_enum.detail().name_hash()[i] = var_union_discriminator_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_discriminator_enum);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorEnum", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorEnum", false);
}

const TypeObject* GetCompleteUnionDiscriminatorEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorEnum", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_discriminator_enum;
    cst_var_union_discriminator_enum.common().member_id(memberId++);
    cst_var_union_discriminator_enum.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_discriminator_enum.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_discriminator_enum.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_discriminator_enum.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_discriminator_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_discriminator_enum.common().member_flags().IS_KEY(false);
    cst_var_union_discriminator_enum.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_discriminator_enum.common().member_type_id(*GetUnion_Discriminator_enumIdentifier(true));
    cst_var_union_discriminator_enum.detail().name("var_union_discriminator_enum");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_discriminator_enum);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionDiscriminatorEnum");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorEnum", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorEnum", true);
}

const TypeIdentifier* GetUnionDiscriminatorAliasIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorAlias", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionDiscriminatorAliasObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("UnionDiscriminatorAlias", complete);
}

const TypeObject* GetUnionDiscriminatorAliasObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorAlias", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionDiscriminatorAliasObject();
    }
    //else
    return GetMinimalUnionDiscriminatorAliasObject();
}

const TypeObject* GetMinimalUnionDiscriminatorAliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorAlias", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_union_discriminator_alias;
    mst_var_union_discriminator_alias.common().member_id(memberId++);
    mst_var_union_discriminator_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_union_discriminator_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_union_discriminator_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_union_discriminator_alias.common().member_flags().IS_OPTIONAL(false);
    mst_var_union_discriminator_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_union_discriminator_alias.common().member_flags().IS_KEY(false);
    mst_var_union_discriminator_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_union_discriminator_alias.common().member_type_id(*GetUnion_Discriminator_aliasIdentifier(false));
    MD5 var_union_discriminator_alias_hash("var_union_discriminator_alias");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_union_discriminator_alias.detail().name_hash()[i] = var_union_discriminator_alias_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_union_discriminator_alias);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorAlias", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorAlias", false);
}

const TypeObject* GetCompleteUnionDiscriminatorAliasObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorAlias", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_union_discriminator_alias;
    cst_var_union_discriminator_alias.common().member_id(memberId++);
    cst_var_union_discriminator_alias.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_union_discriminator_alias.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_union_discriminator_alias.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_union_discriminator_alias.common().member_flags().IS_OPTIONAL(false);
    cst_var_union_discriminator_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_union_discriminator_alias.common().member_flags().IS_KEY(false);
    cst_var_union_discriminator_alias.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_union_discriminator_alias.common().member_type_id(*GetUnion_Discriminator_aliasIdentifier(true));
    cst_var_union_discriminator_alias.detail().name("var_union_discriminator_alias");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_union_discriminator_alias);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionDiscriminatorAlias");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("UnionDiscriminatorAlias", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("UnionDiscriminatorAlias", true);
}
