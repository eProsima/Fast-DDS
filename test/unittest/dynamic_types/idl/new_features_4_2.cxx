// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file new_features_4_2.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "new_features_4_2.h"
#include "new_features_4_2TypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

NewAliases::NewAliases()
{
    m__int8 = 0;
    m__uint8 = 0;
    m__int16 = 0;
    m__uint16 = 0;
    m__int32 = 0;
    m__uint32 = 0;
    m__int64 = 0;
    m__uint64 = 555;


    // Just to register all known types
    registernew_features_4_2Types();
}

NewAliases::~NewAliases()
{









}

NewAliases::NewAliases(const NewAliases &x)
{
    m__int8 = x.m__int8;
    m__uint8 = x.m__uint8;
    m__int16 = x.m__int16;
    m__uint16 = x.m__uint16;
    m__int32 = x.m__int32;
    m__uint32 = x.m__uint32;
    m__int64 = x.m__int64;
    m__uint64 = x.m__uint64;
    m_local_string = x.m_local_string;
}

NewAliases::NewAliases(NewAliases &&x)
{
    m__int8 = x.m__int8;
    m__uint8 = x.m__uint8;
    m__int16 = x.m__int16;
    m__uint16 = x.m__uint16;
    m__int32 = x.m__int32;
    m__uint32 = x.m__uint32;
    m__int64 = x.m__int64;
    m__uint64 = x.m__uint64;
    m_local_string = std::move(x.m_local_string);
}

NewAliases& NewAliases::operator=(const NewAliases &x)
{

    m__int8 = x.m__int8;
    m__uint8 = x.m__uint8;
    m__int16 = x.m__int16;
    m__uint16 = x.m__uint16;
    m__int32 = x.m__int32;
    m__uint32 = x.m__uint32;
    m__int64 = x.m__int64;
    m__uint64 = x.m__uint64;
    m_local_string = x.m_local_string;

    return *this;
}

NewAliases& NewAliases::operator=(NewAliases &&x)
{

    m__int8 = x.m__int8;
    m__uint8 = x.m__uint8;
    m__int16 = x.m__int16;
    m__uint16 = x.m__uint16;
    m__int32 = x.m__int32;
    m__uint32 = x.m__uint32;
    m__int64 = x.m__int64;
    m__uint64 = x.m__uint64;
    m_local_string = std::move(x.m_local_string);

    return *this;
}

size_t NewAliases::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);




    return current_alignment - initial_alignment;
}

size_t NewAliases::getCdrSerializedSize(const NewAliases& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);




    return current_alignment - initial_alignment;
}

void NewAliases::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m__int8;
    scdr << m__uint8;
    scdr << m__int16;
    scdr << m__uint16;
    scdr << m__int32;
    scdr << m__uint32;
    scdr << m__int64;
    scdr << m__uint64;

}

void NewAliases::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m__int8;
    dcdr >> m__uint8;
    dcdr >> m__int16;
    dcdr >> m__uint16;
    dcdr >> m__int32;
    dcdr >> m__uint32;
    dcdr >> m__int64;
    dcdr >> m__uint64;

}

/*!
 * @brief This function sets a value in member _int8
 * @param __int8 New value for member _int8
 */
void NewAliases::_int8(int8_t __int8)
{
m__int8 = __int8;
}

/*!
 * @brief This function returns the value of member _int8
 * @return Value of member _int8
 */
int8_t NewAliases::_int8() const
{
    return m__int8;
}

/*!
 * @brief This function returns a reference to member _int8
 * @return Reference to member _int8
 */
int8_t& NewAliases::_int8()
{
    return m__int8;
}
/*!
 * @brief This function sets a value in member _uint8
 * @param __uint8 New value for member _uint8
 */
void NewAliases::_uint8(uint8_t __uint8)
{
m__uint8 = __uint8;
}

/*!
 * @brief This function returns the value of member _uint8
 * @return Value of member _uint8
 */
uint8_t NewAliases::_uint8() const
{
    return m__uint8;
}

/*!
 * @brief This function returns a reference to member _uint8
 * @return Reference to member _uint8
 */
uint8_t& NewAliases::_uint8()
{
    return m__uint8;
}
/*!
 * @brief This function sets a value in member _int16
 * @param __int16 New value for member _int16
 */
void NewAliases::_int16(int16_t __int16)
{
m__int16 = __int16;
}

/*!
 * @brief This function returns the value of member _int16
 * @return Value of member _int16
 */
int16_t NewAliases::_int16() const
{
    return m__int16;
}

/*!
 * @brief This function returns a reference to member _int16
 * @return Reference to member _int16
 */
int16_t& NewAliases::_int16()
{
    return m__int16;
}
/*!
 * @brief This function sets a value in member _uint16
 * @param __uint16 New value for member _uint16
 */
void NewAliases::_uint16(uint16_t __uint16)
{
m__uint16 = __uint16;
}

/*!
 * @brief This function returns the value of member _uint16
 * @return Value of member _uint16
 */
uint16_t NewAliases::_uint16() const
{
    return m__uint16;
}

/*!
 * @brief This function returns a reference to member _uint16
 * @return Reference to member _uint16
 */
uint16_t& NewAliases::_uint16()
{
    return m__uint16;
}
/*!
 * @brief This function sets a value in member _int32
 * @param __int32 New value for member _int32
 */
void NewAliases::_int32(int32_t __int32)
{
m__int32 = __int32;
}

/*!
 * @brief This function returns the value of member _int32
 * @return Value of member _int32
 */
int32_t NewAliases::_int32() const
{
    return m__int32;
}

/*!
 * @brief This function returns a reference to member _int32
 * @return Reference to member _int32
 */
int32_t& NewAliases::_int32()
{
    return m__int32;
}
/*!
 * @brief This function sets a value in member _uint32
 * @param __uint32 New value for member _uint32
 */
void NewAliases::_uint32(uint32_t __uint32)
{
m__uint32 = __uint32;
}

/*!
 * @brief This function returns the value of member _uint32
 * @return Value of member _uint32
 */
uint32_t NewAliases::_uint32() const
{
    return m__uint32;
}

/*!
 * @brief This function returns a reference to member _uint32
 * @return Reference to member _uint32
 */
uint32_t& NewAliases::_uint32()
{
    return m__uint32;
}
/*!
 * @brief This function sets a value in member _int64
 * @param __int64 New value for member _int64
 */
void NewAliases::_int64(int64_t __int64)
{
m__int64 = __int64;
}

/*!
 * @brief This function returns the value of member _int64
 * @return Value of member _int64
 */
int64_t NewAliases::_int64() const
{
    return m__int64;
}

/*!
 * @brief This function returns a reference to member _int64
 * @return Reference to member _int64
 */
int64_t& NewAliases::_int64()
{
    return m__int64;
}
/*!
 * @brief This function sets a value in member _uint64
 * @param __uint64 New value for member _uint64
 */
void NewAliases::_uint64(uint64_t __uint64)
{
m__uint64 = __uint64;
}

/*!
 * @brief This function returns the value of member _uint64
 * @return Value of member _uint64
 */
uint64_t NewAliases::_uint64() const
{
    return m__uint64;
}

/*!
 * @brief This function returns a reference to member _uint64
 * @return Reference to member _uint64
 */
uint64_t& NewAliases::_uint64()
{
    return m__uint64;
}
/*!
 * @brief This function copies the value in member local_string
 * @param _local_string New value to be copied in member local_string
 */
void NewAliases::local_string(const std::string &_local_string)
{
m_local_string = _local_string;
}

/*!
 * @brief This function moves the value in member local_string
 * @param _local_string New value to be moved in member local_string
 */
void NewAliases::local_string(std::string &&_local_string)
{
m_local_string = std::move(_local_string);
}

/*!
 * @brief This function returns a constant reference to member local_string
 * @return Constant reference to member local_string
 */
const std::string& NewAliases::local_string() const
{
    return m_local_string;
}

/*!
 * @brief This function returns a reference to member local_string
 * @return Reference to member local_string
 */
std::string& NewAliases::local_string()
{
    return m_local_string;
}

size_t NewAliases::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;












    return current_align;
}

bool NewAliases::isKeyDefined()
{
   return false;
}

void NewAliases::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
	 
	 
}

WCharUnion::WCharUnion()
{
    m__d = 'a';
    m_case_zero = 0;
    m_case_one = 0;
}

WCharUnion::~WCharUnion()
{
}

WCharUnion::WCharUnion(const WCharUnion &x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 'a':
        m_case_zero = x.m_case_zero;
        break;
        case 'b':
        m_case_one = x.m_case_one;
        break;
        default:
        break;
    }
}

WCharUnion::WCharUnion(WCharUnion &&x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 'a':
        m_case_zero = x.m_case_zero;
        break;
        case 'b':
        m_case_one = x.m_case_one;
        break;
        default:
        break;
    }
}

WCharUnion& WCharUnion::operator=(const WCharUnion &x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 'a':
        m_case_zero = x.m_case_zero;
        break;
        case 'b':
        m_case_one = x.m_case_one;
        break;
        default:
        break;
    }

    return *this;
}

WCharUnion& WCharUnion::operator=(WCharUnion &&x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 'a':
        m_case_zero = x.m_case_zero;
        break;
        case 'b':
        m_case_one = x.m_case_one;
        break;
        default:
        break;
    }

    return *this;
}

void WCharUnion::_d(wchar_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 'a':
        switch(__d)
        {
            case 'a':
            b = true;
            break;
            default:
            break;
        }
        break;
        case 'b':
        switch(__d)
        {
            case 'b':
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

wchar_t WCharUnion::_d() const
{
    return m__d;
}

wchar_t& WCharUnion::_d()
{
    return m__d;
}

void WCharUnion::case_zero(int32_t _case_zero)
{
    m_case_zero = _case_zero;
    m__d = 'a';
}

int32_t WCharUnion::case_zero() const
{
    bool b = false;

    switch(m__d)
    {
        case 'a':
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_case_zero;
}

int32_t& WCharUnion::case_zero()
{
    bool b = false;

    switch(m__d)
    {
        case 'a':
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_case_zero;
}
void WCharUnion::case_one(int32_t _case_one)
{
    m_case_one = _case_one;
    m__d = 'b';
}

int32_t WCharUnion::case_one() const
{
    bool b = false;

    switch(m__d)
    {
        case 'b':
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_case_one;
}

int32_t& WCharUnion::case_one()
{
    bool b = false;

    switch(m__d)
    {
        case 'b':
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_case_one;
}

size_t WCharUnion::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t WCharUnion::getCdrSerializedSize(const WCharUnion& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 'a':
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 'b':
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void WCharUnion::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 'a':
        scdr << m_case_zero;
        break;
        case 'b':
        scdr << m_case_one;
        break;
        default:
        break;
    }
}

void WCharUnion::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 'a':
        dcdr >> m_case_zero;
        break;
        case 'b':
        dcdr >> m_case_one;
        break;
        default:
        break;
    }
}


OctetUnion::OctetUnion()
{
    m__d = 5;
    m_case_five = 0;
    m_case_seven = 0;
}

OctetUnion::~OctetUnion()
{
}

OctetUnion::OctetUnion(const OctetUnion &x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 5:
        m_case_five = x.m_case_five;
        break;
        case 7:
        m_case_seven = x.m_case_seven;
        break;
        default:
        break;
    }
}

OctetUnion::OctetUnion(OctetUnion &&x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 5:
        m_case_five = x.m_case_five;
        break;
        case 7:
        m_case_seven = x.m_case_seven;
        break;
        default:
        break;
    }
}

OctetUnion& OctetUnion::operator=(const OctetUnion &x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 5:
        m_case_five = x.m_case_five;
        break;
        case 7:
        m_case_seven = x.m_case_seven;
        break;
        default:
        break;
    }

    return *this;
}

OctetUnion& OctetUnion::operator=(OctetUnion &&x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 5:
        m_case_five = x.m_case_five;
        break;
        case 7:
        m_case_seven = x.m_case_seven;
        break;
        default:
        break;
    }

    return *this;
}

void OctetUnion::_d(uint8_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 5:
        switch(__d)
        {
            case 5:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 7:
        switch(__d)
        {
            case 7:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

uint8_t OctetUnion::_d() const
{
    return m__d;
}

uint8_t& OctetUnion::_d()
{
    return m__d;
}

void OctetUnion::case_five(int32_t _case_five)
{
    m_case_five = _case_five;
    m__d = 5;
}

int32_t OctetUnion::case_five() const
{
    bool b = false;

    switch(m__d)
    {
        case 5:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_case_five;
}

int32_t& OctetUnion::case_five()
{
    bool b = false;

    switch(m__d)
    {
        case 5:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_case_five;
}
void OctetUnion::case_seven(int32_t _case_seven)
{
    m_case_seven = _case_seven;
    m__d = 7;
}

int32_t OctetUnion::case_seven() const
{
    bool b = false;

    switch(m__d)
    {
        case 7:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_case_seven;
}

int32_t& OctetUnion::case_seven()
{
    bool b = false;

    switch(m__d)
    {
        case 7:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_case_seven;
}

size_t OctetUnion::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t OctetUnion::getCdrSerializedSize(const OctetUnion& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case 5:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 7:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void OctetUnion::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 5:
        scdr << m_case_five;
        break;
        case 7:
        scdr << m_case_seven;
        break;
        default:
        break;
    }
}

void OctetUnion::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 5:
        dcdr >> m_case_five;
        break;
        case 7:
        dcdr >> m_case_seven;
        break;
        default:
        break;
    }
}


Int8Union::Int8Union()
{
    m__d = 3;
    m_case_three = 0;
    m_case_six = 0;
}

Int8Union::~Int8Union()
{
}

Int8Union::Int8Union(const Int8Union &x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 3:
        m_case_three = x.m_case_three;
        break;
        case 6:
        m_case_six = x.m_case_six;
        break;
        default:
        break;
    }
}

Int8Union::Int8Union(Int8Union &&x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 3:
        m_case_three = x.m_case_three;
        break;
        case 6:
        m_case_six = x.m_case_six;
        break;
        default:
        break;
    }
}

Int8Union& Int8Union::operator=(const Int8Union &x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 3:
        m_case_three = x.m_case_three;
        break;
        case 6:
        m_case_six = x.m_case_six;
        break;
        default:
        break;
    }

    return *this;
}

Int8Union& Int8Union::operator=(Int8Union &&x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 3:
        m_case_three = x.m_case_three;
        break;
        case 6:
        m_case_six = x.m_case_six;
        break;
        default:
        break;
    }

    return *this;
}

void Int8Union::_d(int8_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 3:
        switch(__d)
        {
            case 3:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 6:
        switch(__d)
        {
            case 6:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int8_t Int8Union::_d() const
{
    return m__d;
}

int8_t& Int8Union::_d()
{
    return m__d;
}

void Int8Union::case_three(int32_t _case_three)
{
    m_case_three = _case_three;
    m__d = 3;
}

int32_t Int8Union::case_three() const
{
    bool b = false;

    switch(m__d)
    {
        case 3:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_case_three;
}

int32_t& Int8Union::case_three()
{
    bool b = false;

    switch(m__d)
    {
        case 3:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_case_three;
}
void Int8Union::case_six(int32_t _case_six)
{
    m_case_six = _case_six;
    m__d = 6;
}

int32_t Int8Union::case_six() const
{
    bool b = false;

    switch(m__d)
    {
        case 6:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_case_six;
}

int32_t& Int8Union::case_six()
{
    bool b = false;

    switch(m__d)
    {
        case 6:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_case_six;
}

size_t Int8Union::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t Int8Union::getCdrSerializedSize(const Int8Union& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case 3:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 6:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void Int8Union::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 3:
        scdr << m_case_three;
        break;
        case 6:
        scdr << m_case_six;
        break;
        default:
        break;
    }
}

void Int8Union::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 3:
        dcdr >> m_case_three;
        break;
        case 6:
        dcdr >> m_case_six;
        break;
        default:
        break;
    }
}


bitmodule::ParentBitset::ParentBitset()
{
    // Just to register all known types
    registernew_features_4_2Types();
}

bitmodule::ParentBitset::~ParentBitset()
{
}

bitmodule::ParentBitset::ParentBitset(const ParentBitset &x)
{
    m_bitset = x.m_bitset;
}

bitmodule::ParentBitset::ParentBitset(ParentBitset &&x)
{
    m_bitset = x.m_bitset;
}

bitmodule::ParentBitset& bitmodule::ParentBitset::operator=(const ParentBitset &x)
{

    m_bitset = x.m_bitset;

    return *this;
}

bitmodule::ParentBitset& bitmodule::ParentBitset::operator=(ParentBitset &&x)
{

    m_bitset = x.m_bitset;

    return *this;
}

size_t bitmodule::ParentBitset::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += sizeof(m_bitset);

    return current_alignment - initial_alignment;
}

size_t bitmodule::ParentBitset::getCdrSerializedSize(const bitmodule::ParentBitset& , size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += sizeof(m_bitset);

    return current_alignment - initial_alignment;
}

void bitmodule::ParentBitset::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << static_cast<uint64_t>(m_bitset.to_ullong());
}

void bitmodule::ParentBitset::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    uint64_t temp = 0;
    dcdr >> temp;
    m_bitset = temp;
}


void bitmodule::ParentBitset::parent_bitfield(uint32_t _parent_bitfield)
{
    int base = 0;
    int size = 17;
    for (int i = base + size - 1; i >= base; --i)
    {
        m_bitset.set(i, _parent_bitfield | 0x01);
        _parent_bitfield = _parent_bitfield >> 1;
    }
}

uint32_t bitmodule::ParentBitset::parent_bitfield() const
{
    int base = 0;
    int size = 17;
    std::bitset<17> aux;
    for (int i = size - 1; i >= 0; --i)
    {
        aux.set(i, m_bitset.test(i + base));
    }
    return static_cast<uint32_t>(aux.to_ullong());
}

bitmodule::MyBitset::MyBitset() : bitmodule::ParentBitset() 
{
    // Just to register all known types
    registernew_features_4_2Types();
}

bitmodule::MyBitset::~MyBitset()
{
}

bitmodule::MyBitset::MyBitset(const MyBitset &x) : bitmodule::ParentBitset(x) 
{
    m_bitset = x.m_bitset;
}

bitmodule::MyBitset::MyBitset(MyBitset &&x) : bitmodule::ParentBitset(std::move(x)) 
{
    m_bitset = x.m_bitset;
}

bitmodule::MyBitset& bitmodule::MyBitset::operator=(const MyBitset &x)
{
    bitmodule::ParentBitset::operator=(x); 

    m_bitset = x.m_bitset;

    return *this;
}

bitmodule::MyBitset& bitmodule::MyBitset::operator=(MyBitset &&x)
{
    bitmodule::ParentBitset::operator=(std::move(x)); 

    m_bitset = x.m_bitset;

    return *this;
}

size_t bitmodule::MyBitset::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += bitmodule::ParentBitset::getMaxCdrSerializedSize(current_alignment); 

    current_alignment += sizeof(m_bitset);

    return current_alignment - initial_alignment;
}

size_t bitmodule::MyBitset::getCdrSerializedSize(const bitmodule::MyBitset& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += bitmodule::ParentBitset::getCdrSerializedSize(data, current_alignment); 

    current_alignment += sizeof(m_bitset);

    return current_alignment - initial_alignment;
}

void bitmodule::MyBitset::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    bitmodule::ParentBitset::serialize(scdr); 

    scdr << static_cast<uint64_t>(m_bitset.to_ullong());
}

void bitmodule::MyBitset::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    bitmodule::ParentBitset::deserialize(dcdr); 

    uint64_t temp = 0;
    dcdr >> temp;
    m_bitset = temp;
}


void bitmodule::MyBitset::a(char _a)
{
    int base = 0;
    int size = 3;
    for (int i = base + size - 1; i >= base; --i)
    {
        m_bitset.set(i, _a | 0x01);
        _a = _a >> 1;
    }
}

char bitmodule::MyBitset::a() const
{
    int base = 0;
    int size = 3;
    std::bitset<3> aux;
    for (int i = size - 1; i >= 0; --i)
    {
        aux.set(i, m_bitset.test(i + base));
    }
    return static_cast<char>(aux.to_ullong());
}
void bitmodule::MyBitset::b(bool _b)
{
    int base = 3;
    m_bitset.set(base, _b);
}

bool bitmodule::MyBitset::b() const
{
    int base = 3;
    return m_bitset.test(base);
}

void bitmodule::MyBitset::c(uint16_t _c)
{
    int base = 8;
    int size = 10;
    for (int i = base + size - 1; i >= base; --i)
    {
        m_bitset.set(i, _c | 0x01);
        _c = _c >> 1;
    }
}

uint16_t bitmodule::MyBitset::c() const
{
    int base = 8;
    int size = 10;
    std::bitset<10> aux;
    for (int i = size - 1; i >= 0; --i)
    {
        aux.set(i, m_bitset.test(i + base));
    }
    return static_cast<uint16_t>(aux.to_ullong());
}
void bitmodule::MyBitset::d(int16_t _d)
{
    int base = 18;
    int size = 12;
    for (int i = base + size - 1; i >= base; --i)
    {
        m_bitset.set(i, _d | 0x01);
        _d = _d >> 1;
    }
}

int16_t bitmodule::MyBitset::d() const
{
    int base = 18;
    int size = 12;
    std::bitset<12> aux;
    for (int i = size - 1; i >= 0; --i)
    {
        aux.set(i, m_bitset.test(i + base));
    }
    return static_cast<int16_t>(aux.to_ullong());
}
void bitmodule::MyBitset::e(int16_t _e)
{
    int base = 30;
    int size = 12;
    for (int i = base + size - 1; i >= base; --i)
    {
        m_bitset.set(i, _e | 0x01);
        _e = _e >> 1;
    }
}

int16_t bitmodule::MyBitset::e() const
{
    int base = 30;
    int size = 12;
    std::bitset<12> aux;
    for (int i = size - 1; i >= 0; --i)
    {
        aux.set(i, m_bitset.test(i + base));
    }
    return static_cast<int16_t>(aux.to_ullong());
}
void bitmodule::MyBitset::f(int16_t _f)
{
    int base = 42;
    int size = 12;
    for (int i = base + size - 1; i >= base; --i)
    {
        m_bitset.set(i, _f | 0x01);
        _f = _f >> 1;
    }
}

int16_t bitmodule::MyBitset::f() const
{
    int base = 42;
    int size = 12;
    std::bitset<12> aux;
    for (int i = size - 1; i >= 0; --i)
    {
        aux.set(i, m_bitset.test(i + base));
    }
    return static_cast<int16_t>(aux.to_ullong());
}


bitmodule::BitsetBitmask::BitsetBitmask()
{

    m_mybitmask = bitmodule::flag0;

    // Just to register all known types
    registernew_features_4_2Types();
}

bitmodule::BitsetBitmask::~BitsetBitmask()
{


}

bitmodule::BitsetBitmask::BitsetBitmask(const BitsetBitmask &x)
{
    m_mybitset = x.m_mybitset;
    m_mybitmask = x.m_mybitmask;
}

bitmodule::BitsetBitmask::BitsetBitmask(BitsetBitmask &&x)
{
    m_mybitset = std::move(x.m_mybitset);
    m_mybitmask = x.m_mybitmask;
}

bitmodule::BitsetBitmask& bitmodule::BitsetBitmask::operator=(const BitsetBitmask &x)
{

    m_mybitset = x.m_mybitset;
    m_mybitmask = x.m_mybitmask;

    return *this;
}

bitmodule::BitsetBitmask& bitmodule::BitsetBitmask::operator=(BitsetBitmask &&x)
{

    m_mybitset = std::move(x.m_mybitset);
    m_mybitmask = x.m_mybitmask;

    return *this;
}

size_t bitmodule::BitsetBitmask::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += bitmodule::MyBitset::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t bitmodule::BitsetBitmask::getCdrSerializedSize(const bitmodule::BitsetBitmask& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += bitmodule::MyBitset::getCdrSerializedSize(data.mybitset(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void bitmodule::BitsetBitmask::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_mybitset;
    scdr << (uint8_t)
    m_mybitmask;
}

void bitmodule::BitsetBitmask::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_mybitset;
    {
        uint8_t enum_value = 0;
        dcdr >> enum_value;
        m_mybitmask = (bitmodule::MyBitMask)enum_value;
    }
}

/*!
 * @brief This function copies the value in member mybitset
 * @param _mybitset New value to be copied in member mybitset
 */
void bitmodule::BitsetBitmask::mybitset(const bitmodule::MyBitset &_mybitset)
{
m_mybitset = _mybitset;
}

/*!
 * @brief This function moves the value in member mybitset
 * @param _mybitset New value to be moved in member mybitset
 */
void bitmodule::BitsetBitmask::mybitset(bitmodule::MyBitset &&_mybitset)
{
m_mybitset = std::move(_mybitset);
}

/*!
 * @brief This function returns a constant reference to member mybitset
 * @return Constant reference to member mybitset
 */
const bitmodule::MyBitset& bitmodule::BitsetBitmask::mybitset() const
{
    return m_mybitset;
}

/*!
 * @brief This function returns a reference to member mybitset
 * @return Reference to member mybitset
 */
bitmodule::MyBitset& bitmodule::BitsetBitmask::mybitset()
{
    return m_mybitset;
}
/*!
 * @brief This function sets a value in member mybitmask
 * @param _mybitmask New value for member mybitmask
 */
void bitmodule::BitsetBitmask::mybitmask(bitmodule::MyBitMask _mybitmask)
{
m_mybitmask = _mybitmask;
}

/*!
 * @brief This function returns the value of member mybitmask
 * @return Value of member mybitmask
 */
bitmodule::MyBitMask bitmodule::BitsetBitmask::mybitmask() const
{
    return m_mybitmask;
}

/*!
 * @brief This function returns a reference to member mybitmask
 * @return Reference to member mybitmask
 */
bitmodule::MyBitMask& bitmodule::BitsetBitmask::mybitmask()
{
    return m_mybitmask;
}

size_t bitmodule::BitsetBitmask::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;





    return current_align;
}

bool bitmodule::BitsetBitmask::isKeyDefined()
{
   return false;
}

void bitmodule::BitsetBitmask::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}

bitmodule::BM2::BM2() : bitmodule::BitsetBitmask() 
{
    m_two = bitmodule::flag0;
    m_mylong = 0;

    // Just to register all known types
    registernew_features_4_2Types();
}

bitmodule::BM2::~BM2()
{


}

bitmodule::BM2::BM2(const BM2 &x) : bitmodule::BitsetBitmask(x) 
{
    m_two = x.m_two;
    m_mylong = x.m_mylong;
}

bitmodule::BM2::BM2(BM2 &&x) : bitmodule::BitsetBitmask(std::move(x)) 
{
    m_two = x.m_two;
    m_mylong = x.m_mylong;
}

bitmodule::BM2& bitmodule::BM2::operator=(const BM2 &x)
{
    bitmodule::BitsetBitmask::operator=(x); 

    m_two = x.m_two;
    m_mylong = x.m_mylong;

    return *this;
}

bitmodule::BM2& bitmodule::BM2::operator=(BM2 &&x)
{
    bitmodule::BitsetBitmask::operator=(std::move(x)); 

    m_two = x.m_two;
    m_mylong = x.m_mylong;

    return *this;
}

size_t bitmodule::BM2::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += bitmodule::BitsetBitmask::getMaxCdrSerializedSize(current_alignment); 

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t bitmodule::BM2::getCdrSerializedSize(const bitmodule::BM2& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += bitmodule::BitsetBitmask::getCdrSerializedSize(data, current_alignment); 

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void bitmodule::BM2::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    bitmodule::BitsetBitmask::serialize(scdr); 

    scdr << (uint8_t)
    m_two;
    scdr << m_mylong;
}

void bitmodule::BM2::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    bitmodule::BitsetBitmask::deserialize(dcdr); 

    {
        uint8_t enum_value = 0;
        dcdr >> enum_value;
        m_two = (bitmodule::MyBitMask)enum_value;
    }
    dcdr >> m_mylong;
}

/*!
 * @brief This function sets a value in member two
 * @param _two New value for member two
 */
void bitmodule::BM2::two(bitmodule::MyBitMask _two)
{
m_two = _two;
}

/*!
 * @brief This function returns the value of member two
 * @return Value of member two
 */
bitmodule::MyBitMask bitmodule::BM2::two() const
{
    return m_two;
}

/*!
 * @brief This function returns a reference to member two
 * @return Reference to member two
 */
bitmodule::MyBitMask& bitmodule::BM2::two()
{
    return m_two;
}
/*!
 * @brief This function sets a value in member mylong
 * @param _mylong New value for member mylong
 */
void bitmodule::BM2::mylong(int32_t _mylong)
{
m_mylong = _mylong;
}

/*!
 * @brief This function returns the value of member mylong
 * @return Value of member mylong
 */
int32_t bitmodule::BM2::mylong() const
{
    return m_mylong;
}

/*!
 * @brief This function returns a reference to member mylong
 * @return Reference to member mylong
 */
int32_t& bitmodule::BM2::mylong()
{
    return m_mylong;
}

size_t bitmodule::BM2::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;

    current_alignment += bitmodule::BitsetBitmask::getKeyMaxCdrSerializedSize(current_alignment); 




    return current_align;
}

bool bitmodule::BM2::isKeyDefined()
{
    if (bitmodule::BitsetBitmask::isKeyDefined())
        return true;
    return false;
}

void bitmodule::BM2::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
    bitmodule::BitsetBitmask::serializeKey(scdr); 
	 
	 
}


StructTest::StructTest() : NewAliases() 
{





    // Just to register all known types
    registernew_features_4_2Types();
}

StructTest::~StructTest()
{




}

StructTest::StructTest(const StructTest &x) : NewAliases(x) 
{
    m_charUnion = x.m_charUnion;
    m_octetUnion = x.m_octetUnion;
    m_int8Union = x.m_int8Union;
    m_myStructBits = x.m_myStructBits;
}

StructTest::StructTest(StructTest &&x) : NewAliases(std::move(x)) 
{
    m_charUnion = std::move(x.m_charUnion);
    m_octetUnion = std::move(x.m_octetUnion);
    m_int8Union = std::move(x.m_int8Union);
    m_myStructBits = std::move(x.m_myStructBits);
}

StructTest& StructTest::operator=(const StructTest &x)
{
    NewAliases::operator=(x); 

    m_charUnion = x.m_charUnion;
    m_octetUnion = x.m_octetUnion;
    m_int8Union = x.m_int8Union;
    m_myStructBits = x.m_myStructBits;

    return *this;
}

StructTest& StructTest::operator=(StructTest &&x)
{
    NewAliases::operator=(std::move(x)); 

    m_charUnion = std::move(x.m_charUnion);
    m_octetUnion = std::move(x.m_octetUnion);
    m_int8Union = std::move(x.m_int8Union);
    m_myStructBits = std::move(x.m_myStructBits);

    return *this;
}

size_t StructTest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += NewAliases::getMaxCdrSerializedSize(current_alignment); 

    current_alignment += WCharUnion::getMaxCdrSerializedSize(current_alignment);
    current_alignment += OctetUnion::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Int8Union::getMaxCdrSerializedSize(current_alignment);
    current_alignment += bitmodule::BM2::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t StructTest::getCdrSerializedSize(const StructTest& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += NewAliases::getCdrSerializedSize(data, current_alignment); 

    current_alignment += WCharUnion::getCdrSerializedSize(data.charUnion(), current_alignment);
    current_alignment += OctetUnion::getCdrSerializedSize(data.octetUnion(), current_alignment);
    current_alignment += Int8Union::getCdrSerializedSize(data.int8Union(), current_alignment);
    current_alignment += bitmodule::BM2::getCdrSerializedSize(data.myStructBits(), current_alignment);

    return current_alignment - initial_alignment;
}

void StructTest::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    NewAliases::serialize(scdr); 

    scdr << m_charUnion;
    scdr << m_octetUnion;
    scdr << m_int8Union;
    scdr << m_myStructBits;
}

void StructTest::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    NewAliases::deserialize(dcdr); 

    dcdr >> m_charUnion;
    dcdr >> m_octetUnion;
    dcdr >> m_int8Union;
    dcdr >> m_myStructBits;
}

/*!
 * @brief This function copies the value in member charUnion
 * @param _charUnion New value to be copied in member charUnion
 */
void StructTest::charUnion(const WCharUnion &_charUnion)
{
m_charUnion = _charUnion;
}

/*!
 * @brief This function moves the value in member charUnion
 * @param _charUnion New value to be moved in member charUnion
 */
void StructTest::charUnion(WCharUnion &&_charUnion)
{
m_charUnion = std::move(_charUnion);
}

/*!
 * @brief This function returns a constant reference to member charUnion
 * @return Constant reference to member charUnion
 */
const WCharUnion& StructTest::charUnion() const
{
    return m_charUnion;
}

/*!
 * @brief This function returns a reference to member charUnion
 * @return Reference to member charUnion
 */
WCharUnion& StructTest::charUnion()
{
    return m_charUnion;
}
/*!
 * @brief This function copies the value in member octetUnion
 * @param _octetUnion New value to be copied in member octetUnion
 */
void StructTest::octetUnion(const OctetUnion &_octetUnion)
{
m_octetUnion = _octetUnion;
}

/*!
 * @brief This function moves the value in member octetUnion
 * @param _octetUnion New value to be moved in member octetUnion
 */
void StructTest::octetUnion(OctetUnion &&_octetUnion)
{
m_octetUnion = std::move(_octetUnion);
}

/*!
 * @brief This function returns a constant reference to member octetUnion
 * @return Constant reference to member octetUnion
 */
const OctetUnion& StructTest::octetUnion() const
{
    return m_octetUnion;
}

/*!
 * @brief This function returns a reference to member octetUnion
 * @return Reference to member octetUnion
 */
OctetUnion& StructTest::octetUnion()
{
    return m_octetUnion;
}
/*!
 * @brief This function copies the value in member int8Union
 * @param _int8Union New value to be copied in member int8Union
 */
void StructTest::int8Union(const Int8Union &_int8Union)
{
m_int8Union = _int8Union;
}

/*!
 * @brief This function moves the value in member int8Union
 * @param _int8Union New value to be moved in member int8Union
 */
void StructTest::int8Union(Int8Union &&_int8Union)
{
m_int8Union = std::move(_int8Union);
}

/*!
 * @brief This function returns a constant reference to member int8Union
 * @return Constant reference to member int8Union
 */
const Int8Union& StructTest::int8Union() const
{
    return m_int8Union;
}

/*!
 * @brief This function returns a reference to member int8Union
 * @return Reference to member int8Union
 */
Int8Union& StructTest::int8Union()
{
    return m_int8Union;
}
/*!
 * @brief This function copies the value in member myStructBits
 * @param _myStructBits New value to be copied in member myStructBits
 */
void StructTest::myStructBits(const bitmodule::BM2 &_myStructBits)
{
m_myStructBits = _myStructBits;
}

/*!
 * @brief This function moves the value in member myStructBits
 * @param _myStructBits New value to be moved in member myStructBits
 */
void StructTest::myStructBits(bitmodule::BM2 &&_myStructBits)
{
m_myStructBits = std::move(_myStructBits);
}

/*!
 * @brief This function returns a constant reference to member myStructBits
 * @return Constant reference to member myStructBits
 */
const bitmodule::BM2& StructTest::myStructBits() const
{
    return m_myStructBits;
}

/*!
 * @brief This function returns a reference to member myStructBits
 * @return Reference to member myStructBits
 */
bitmodule::BM2& StructTest::myStructBits()
{
    return m_myStructBits;
}

size_t StructTest::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;

    current_alignment += NewAliases::getKeyMaxCdrSerializedSize(current_alignment); 






    return current_align;
}

bool StructTest::isKeyDefined()
{
    if (NewAliases::isKeyDefined())
        return true;
    return false;
}

void StructTest::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
    NewAliases::serializeKey(scdr); 
	 
	 
	 
	 
}
