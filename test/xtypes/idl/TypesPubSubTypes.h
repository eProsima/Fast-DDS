// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file TypesPubSubTypes.h
 * This header file contains the declaration of the serialization functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#ifndef _FAST_DDS_GENERATED_TYPES_PUBSUBTYPES_H_
#define _FAST_DDS_GENERATED_TYPES_PUBSUBTYPES_H_

#include <fastdds/dds/topic/TopicDataType.hpp>
#include <fastrtps/utils/md5.h>
#include <fastrtps/utils/data_sizeof.hpp>

#include "Types.h"

#if !defined(GEN_API_VER) || (GEN_API_VER != 1)
#error \
    Generated Types is not compatible with current installed Fast DDS. Please, regenerate it with fastddsgen.
#endif  // GEN_API_VER




namespace detail {

    template<typename Tag, typename Tag::type M>
    struct MyEnumStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct MyEnumStruct_f
    {
        typedef MyEnum MyEnumStruct::* type;
        friend type get(
                MyEnumStruct_f);
    };

    template struct MyEnumStruct_rob<MyEnumStruct_f, &MyEnumStruct::m_my_enum>;
}

/*!
 * @brief This class represents the TopicDataType of the type MyEnumStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class MyEnumStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef MyEnumStruct type;

    eProsima_user_DllExport MyEnumStructPubSubType();

    eProsima_user_DllExport virtual ~MyEnumStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 4ULL == eprosima::fastrtps::size_of_<MyEnumStruct, detail::MyEnumStruct_f, MyEnum>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct MyBadEnumStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct MyBadEnumStruct_f
    {
        typedef MyBadEnum MyBadEnumStruct::* type;
        friend type get(
                MyBadEnumStruct_f);
    };

    template struct MyBadEnumStruct_rob<MyBadEnumStruct_f, &MyBadEnumStruct::m_my_enum>;
}

/*!
 * @brief This class represents the TopicDataType of the type MyBadEnumStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class MyBadEnumStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef MyBadEnumStruct type;

    eProsima_user_DllExport MyBadEnumStructPubSubType();

    eProsima_user_DllExport virtual ~MyBadEnumStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 4ULL == eprosima::fastrtps::size_of_<MyBadEnumStruct, detail::MyBadEnumStruct_f, MyBadEnum>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};
typedef MyEnum MyAliasEnum;

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct MyAliasEnumStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct MyAliasEnumStruct_f
    {
        typedef MyAliasEnum MyAliasEnumStruct::* type;
        friend type get(
                MyAliasEnumStruct_f);
    };

    template struct MyAliasEnumStruct_rob<MyAliasEnumStruct_f, &MyAliasEnumStruct::m_my_enum>;
}

/*!
 * @brief This class represents the TopicDataType of the type MyAliasEnumStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class MyAliasEnumStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef MyAliasEnumStruct type;

    eProsima_user_DllExport MyAliasEnumStructPubSubType();

    eProsima_user_DllExport virtual ~MyAliasEnumStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 4ULL == eprosima::fastrtps::size_of_<MyAliasEnumStruct, detail::MyAliasEnumStruct_f, MyAliasEnum>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct BasicStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct BasicStruct_f
    {
        typedef std::string BasicStruct::* type;
        friend type get(
                BasicStruct_f);
    };

    template struct BasicStruct_rob<BasicStruct_f, &BasicStruct::m_my_string>;
}

/*!
 * @brief This class represents the TopicDataType of the type BasicStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class BasicStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef BasicStruct type;

    eProsima_user_DllExport BasicStructPubSubType();

    eProsima_user_DllExport virtual ~BasicStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 268ULL == eprosima::fastrtps::size_of_<BasicStruct, detail::BasicStruct_f, std::string>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct BasicNamesStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct BasicNamesStruct_f
    {
        typedef std::string BasicNamesStruct::* type;
        friend type get(
                BasicNamesStruct_f);
    };

    template struct BasicNamesStruct_rob<BasicNamesStruct_f, &BasicNamesStruct::m_my_string_name>;
}

/*!
 * @brief This class represents the TopicDataType of the type BasicNamesStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class BasicNamesStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef BasicNamesStruct type;

    eProsima_user_DllExport BasicNamesStructPubSubType();

    eProsima_user_DllExport virtual ~BasicNamesStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 268ULL == eprosima::fastrtps::size_of_<BasicNamesStruct, detail::BasicNamesStruct_f, std::string>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct BasicBadStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct BasicBadStruct_f
    {
        typedef std::string BasicBadStruct::* type;
        friend type get(
                BasicBadStruct_f);
    };

    template struct BasicBadStruct_rob<BasicBadStruct_f, &BasicBadStruct::m_my_string>;
}

/*!
 * @brief This class represents the TopicDataType of the type BasicBadStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class BasicBadStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef BasicBadStruct type;

    eProsima_user_DllExport BasicBadStructPubSubType();

    eProsima_user_DllExport virtual ~BasicBadStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 268ULL == eprosima::fastrtps::size_of_<BasicBadStruct, detail::BasicBadStruct_f, std::string>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct BasicWideStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct BasicWideStruct_f
    {
        typedef std::string BasicWideStruct::* type;
        friend type get(
                BasicWideStruct_f);
    };

    template struct BasicWideStruct_rob<BasicWideStruct_f, &BasicWideStruct::m_new_string>;
}

/*!
 * @brief This class represents the TopicDataType of the type BasicWideStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class BasicWideStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef BasicWideStruct type;

    eProsima_user_DllExport BasicWideStructPubSubType();

    eProsima_user_DllExport virtual ~BasicWideStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 532ULL == eprosima::fastrtps::size_of_<BasicWideStruct, detail::BasicWideStruct_f, std::string>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct BadBasicWideStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct BadBasicWideStruct_f
    {
        typedef std::string BadBasicWideStruct::* type;
        friend type get(
                BadBasicWideStruct_f);
    };

    template struct BadBasicWideStruct_rob<BadBasicWideStruct_f, &BadBasicWideStruct::m_my_string>;
}

/*!
 * @brief This class represents the TopicDataType of the type BadBasicWideStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class BadBasicWideStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef BadBasicWideStruct type;

    eProsima_user_DllExport BadBasicWideStructPubSubType();

    eProsima_user_DllExport virtual ~BadBasicWideStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 532ULL == eprosima::fastrtps::size_of_<BadBasicWideStruct, detail::BadBasicWideStruct_f, std::string>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct StringStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct StringStruct_f
    {
        typedef std::string StringStruct::* type;
        friend type get(
                StringStruct_f);
    };

    template struct StringStruct_rob<StringStruct_f, &StringStruct::m_my_string>;
}

/*!
 * @brief This class represents the TopicDataType of the type StringStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class StringStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef StringStruct type;

    eProsima_user_DllExport StringStructPubSubType();

    eProsima_user_DllExport virtual ~StringStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 260ULL == eprosima::fastrtps::size_of_<StringStruct, detail::StringStruct_f, std::string>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct LargeStringStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct LargeStringStruct_f
    {
        typedef eprosima::fastrtps::fixed_string<41925> LargeStringStruct::* type;
        friend type get(
                LargeStringStruct_f);
    };

    template struct LargeStringStruct_rob<LargeStringStruct_f, &LargeStringStruct::m_my_large_string>;
}

/*!
 * @brief This class represents the TopicDataType of the type LargeStringStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class LargeStringStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef LargeStringStruct type;

    eProsima_user_DllExport LargeStringStructPubSubType();

    eProsima_user_DllExport virtual ~LargeStringStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 41930ULL == eprosima::fastrtps::size_of_<LargeStringStruct, detail::LargeStringStruct_f, eprosima::fastrtps::fixed_string<41925>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct WStringStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct WStringStruct_f
    {
        typedef std::wstring WStringStruct::* type;
        friend type get(
                WStringStruct_f);
    };

    template struct WStringStruct_rob<WStringStruct_f, &WStringStruct::m_my_wstring>;
}

/*!
 * @brief This class represents the TopicDataType of the type WStringStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class WStringStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef WStringStruct type;

    eProsima_user_DllExport WStringStructPubSubType();

    eProsima_user_DllExport virtual ~WStringStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 1024ULL == eprosima::fastrtps::size_of_<WStringStruct, detail::WStringStruct_f, std::wstring>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct LargeWStringStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct LargeWStringStruct_f
    {
        typedef std::wstring LargeWStringStruct::* type;
        friend type get(
                LargeWStringStruct_f);
    };

    template struct LargeWStringStruct_rob<LargeWStringStruct_f, &LargeWStringStruct::m_my_large_wstring>;
}

/*!
 * @brief This class represents the TopicDataType of the type LargeWStringStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class LargeWStringStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef LargeWStringStruct type;

    eProsima_user_DllExport LargeWStringStructPubSubType();

    eProsima_user_DllExport virtual ~LargeWStringStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 167704ULL == eprosima::fastrtps::size_of_<LargeWStringStruct, detail::LargeWStringStruct_f, std::wstring>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayStruct_f
    {
        typedef std::array<int32_t, 2> ArrayStruct::* type;
        friend type get(
                ArrayStruct_f);
    };

    template struct ArrayStruct_rob<ArrayStruct_f, &ArrayStruct::m_my_array>;
}

/*!
 * @brief This class represents the TopicDataType of the type ArrayStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class ArrayStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayStruct type;

    eProsima_user_DllExport ArrayStructPubSubType();

    eProsima_user_DllExport virtual ~ArrayStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 8ULL == eprosima::fastrtps::size_of_<ArrayStruct, detail::ArrayStruct_f, std::array<int32_t, 2>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayStruct();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayStructEqual_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayStructEqual_f
    {
        typedef std::array<int32_t, 2> ArrayStructEqual::* type;
        friend type get(
                ArrayStructEqual_f);
    };

    template struct ArrayStructEqual_rob<ArrayStructEqual_f, &ArrayStructEqual::m_my_array_equal>;
}

/*!
 * @brief This class represents the TopicDataType of the type ArrayStructEqual defined by the user in the IDL file.
 * @ingroup TYPES
 */
class ArrayStructEqualPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayStructEqual type;

    eProsima_user_DllExport ArrayStructEqualPubSubType();

    eProsima_user_DllExport virtual ~ArrayStructEqualPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 8ULL == eprosima::fastrtps::size_of_<ArrayStructEqual, detail::ArrayStructEqual_f, std::array<int32_t, 2>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayStructEqual();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayBadStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayBadStruct_f
    {
        typedef std::array<uint8_t, 2> ArrayBadStruct::* type;
        friend type get(
                ArrayBadStruct_f);
    };

    template struct ArrayBadStruct_rob<ArrayBadStruct_f, &ArrayBadStruct::m_my_array>;
}

/*!
 * @brief This class represents the TopicDataType of the type ArrayBadStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class ArrayBadStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayBadStruct type;

    eProsima_user_DllExport ArrayBadStructPubSubType();

    eProsima_user_DllExport virtual ~ArrayBadStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 2ULL == eprosima::fastrtps::size_of_<ArrayBadStruct, detail::ArrayBadStruct_f, std::array<uint8_t, 2>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayBadStruct();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayDimensionsStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayDimensionsStruct_f
    {
        typedef std::array<std::array<int32_t, 2>, 2> ArrayDimensionsStruct::* type;
        friend type get(
                ArrayDimensionsStruct_f);
    };

    template struct ArrayDimensionsStruct_rob<ArrayDimensionsStruct_f, &ArrayDimensionsStruct::m_my_array>;
}

/*!
 * @brief This class represents the TopicDataType of the type ArrayDimensionsStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class ArrayDimensionsStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayDimensionsStruct type;

    eProsima_user_DllExport ArrayDimensionsStructPubSubType();

    eProsima_user_DllExport virtual ~ArrayDimensionsStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 16ULL == eprosima::fastrtps::size_of_<ArrayDimensionsStruct, detail::ArrayDimensionsStruct_f, std::array<std::array<int32_t, 2>, 2>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayDimensionsStruct();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySizeStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySizeStruct_f
    {
        typedef std::array<int32_t, 5> ArraySizeStruct::* type;
        friend type get(
                ArraySizeStruct_f);
    };

    template struct ArraySizeStruct_rob<ArraySizeStruct_f, &ArraySizeStruct::m_my_array>;
}

/*!
 * @brief This class represents the TopicDataType of the type ArraySizeStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class ArraySizeStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySizeStruct type;

    eProsima_user_DllExport ArraySizeStructPubSubType();

    eProsima_user_DllExport virtual ~ArraySizeStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 20ULL == eprosima::fastrtps::size_of_<ArraySizeStruct, detail::ArraySizeStruct_f, std::array<int32_t, 5>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySizeStruct();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct SequenceStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct SequenceStruct_f
    {
        typedef std::vector<int32_t> SequenceStruct::* type;
        friend type get(
                SequenceStruct_f);
    };

    template struct SequenceStruct_rob<SequenceStruct_f, &SequenceStruct::m_my_sequence>;
}

/*!
 * @brief This class represents the TopicDataType of the type SequenceStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class SequenceStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef SequenceStruct type;

    eProsima_user_DllExport SequenceStructPubSubType();

    eProsima_user_DllExport virtual ~SequenceStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 12ULL == eprosima::fastrtps::size_of_<SequenceStruct, detail::SequenceStruct_f, std::vector<int32_t>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct SequenceStructEqual_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct SequenceStructEqual_f
    {
        typedef std::vector<int32_t> SequenceStructEqual::* type;
        friend type get(
                SequenceStructEqual_f);
    };

    template struct SequenceStructEqual_rob<SequenceStructEqual_f, &SequenceStructEqual::m_my_sequence_equal>;
}

/*!
 * @brief This class represents the TopicDataType of the type SequenceStructEqual defined by the user in the IDL file.
 * @ingroup TYPES
 */
class SequenceStructEqualPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef SequenceStructEqual type;

    eProsima_user_DllExport SequenceStructEqualPubSubType();

    eProsima_user_DllExport virtual ~SequenceStructEqualPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 12ULL == eprosima::fastrtps::size_of_<SequenceStructEqual, detail::SequenceStructEqual_f, std::vector<int32_t>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct SequenceBadStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct SequenceBadStruct_f
    {
        typedef std::vector<uint8_t> SequenceBadStruct::* type;
        friend type get(
                SequenceBadStruct_f);
    };

    template struct SequenceBadStruct_rob<SequenceBadStruct_f, &SequenceBadStruct::m_my_sequence>;
}

/*!
 * @brief This class represents the TopicDataType of the type SequenceBadStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class SequenceBadStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef SequenceBadStruct type;

    eProsima_user_DllExport SequenceBadStructPubSubType();

    eProsima_user_DllExport virtual ~SequenceBadStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 6ULL == eprosima::fastrtps::size_of_<SequenceBadStruct, detail::SequenceBadStruct_f, std::vector<uint8_t>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct SequenceBoundsStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct SequenceBoundsStruct_f
    {
        typedef std::vector<int32_t> SequenceBoundsStruct::* type;
        friend type get(
                SequenceBoundsStruct_f);
    };

    template struct SequenceBoundsStruct_rob<SequenceBoundsStruct_f, &SequenceBoundsStruct::m_my_sequence>;
}

/*!
 * @brief This class represents the TopicDataType of the type SequenceBoundsStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class SequenceBoundsStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef SequenceBoundsStruct type;

    eProsima_user_DllExport SequenceBoundsStructPubSubType();

    eProsima_user_DllExport virtual ~SequenceBoundsStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 20ULL == eprosima::fastrtps::size_of_<SequenceBoundsStruct, detail::SequenceBoundsStruct_f, std::vector<int32_t>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct SequenceSequenceStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct SequenceSequenceStruct_f
    {
        typedef std::vector<std::vector<int32_t>> SequenceSequenceStruct::* type;
        friend type get(
                SequenceSequenceStruct_f);
    };

    template struct SequenceSequenceStruct_rob<SequenceSequenceStruct_f, &SequenceSequenceStruct::m_my_sequence_sequence>;
}

/*!
 * @brief This class represents the TopicDataType of the type SequenceSequenceStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class SequenceSequenceStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef SequenceSequenceStruct type;

    eProsima_user_DllExport SequenceSequenceStructPubSubType();

    eProsima_user_DllExport virtual ~SequenceSequenceStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 40ULL == eprosima::fastrtps::size_of_<SequenceSequenceStruct, detail::SequenceSequenceStruct_f, std::vector<std::vector<int32_t>>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct SequenceSequenceBoundsStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct SequenceSequenceBoundsStruct_f
    {
        typedef std::vector<std::vector<int32_t>> SequenceSequenceBoundsStruct::* type;
        friend type get(
                SequenceSequenceBoundsStruct_f);
    };

    template struct SequenceSequenceBoundsStruct_rob<SequenceSequenceBoundsStruct_f, &SequenceSequenceBoundsStruct::m_my_sequence_sequence>;
}

/*!
 * @brief This class represents the TopicDataType of the type SequenceSequenceBoundsStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class SequenceSequenceBoundsStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef SequenceSequenceBoundsStruct type;

    eProsima_user_DllExport SequenceSequenceBoundsStructPubSubType();

    eProsima_user_DllExport virtual ~SequenceSequenceBoundsStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 124ULL == eprosima::fastrtps::size_of_<SequenceSequenceBoundsStruct, detail::SequenceSequenceBoundsStruct_f, std::vector<std::vector<int32_t>>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct MapStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct MapStruct_f
    {
        typedef std::map<int32_t, int32_t> MapStruct::* type;
        friend type get(
                MapStruct_f);
    };

    template struct MapStruct_rob<MapStruct_f, &MapStruct::m_my_map>;
}

/*!
 * @brief This class represents the TopicDataType of the type MapStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class MapStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef MapStruct type;

    eProsima_user_DllExport MapStructPubSubType();

    eProsima_user_DllExport virtual ~MapStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 20ULL == eprosima::fastrtps::size_of_<MapStruct, detail::MapStruct_f, std::map<int32_t, int32_t>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct MapStructEqual_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct MapStructEqual_f
    {
        typedef std::map<int32_t, int32_t> MapStructEqual::* type;
        friend type get(
                MapStructEqual_f);
    };

    template struct MapStructEqual_rob<MapStructEqual_f, &MapStructEqual::m_my_map_equal>;
}

/*!
 * @brief This class represents the TopicDataType of the type MapStructEqual defined by the user in the IDL file.
 * @ingroup TYPES
 */
class MapStructEqualPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef MapStructEqual type;

    eProsima_user_DllExport MapStructEqualPubSubType();

    eProsima_user_DllExport virtual ~MapStructEqualPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 20ULL == eprosima::fastrtps::size_of_<MapStructEqual, detail::MapStructEqual_f, std::map<int32_t, int32_t>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct MapBadKeyStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct MapBadKeyStruct_f
    {
        typedef std::map<uint8_t, int32_t> MapBadKeyStruct::* type;
        friend type get(
                MapBadKeyStruct_f);
    };

    template struct MapBadKeyStruct_rob<MapBadKeyStruct_f, &MapBadKeyStruct::m_my_map>;
}

/*!
 * @brief This class represents the TopicDataType of the type MapBadKeyStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class MapBadKeyStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef MapBadKeyStruct type;

    eProsima_user_DllExport MapBadKeyStructPubSubType();

    eProsima_user_DllExport virtual ~MapBadKeyStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 20ULL == eprosima::fastrtps::size_of_<MapBadKeyStruct, detail::MapBadKeyStruct_f, std::map<uint8_t, int32_t>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct MapBadElemStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct MapBadElemStruct_f
    {
        typedef std::map<int32_t, int64_t> MapBadElemStruct::* type;
        friend type get(
                MapBadElemStruct_f);
    };

    template struct MapBadElemStruct_rob<MapBadElemStruct_f, &MapBadElemStruct::m_my_map>;
}

/*!
 * @brief This class represents the TopicDataType of the type MapBadElemStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class MapBadElemStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef MapBadElemStruct type;

    eProsima_user_DllExport MapBadElemStructPubSubType();

    eProsima_user_DllExport virtual ~MapBadElemStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 32ULL == eprosima::fastrtps::size_of_<MapBadElemStruct, detail::MapBadElemStruct_f, std::map<int32_t, int64_t>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct MapBoundsStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct MapBoundsStruct_f
    {
        typedef std::map<int32_t, int32_t> MapBoundsStruct::* type;
        friend type get(
                MapBoundsStruct_f);
    };

    template struct MapBoundsStruct_rob<MapBoundsStruct_f, &MapBoundsStruct::m_my_map>;
}

/*!
 * @brief This class represents the TopicDataType of the type MapBoundsStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class MapBoundsStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef MapBoundsStruct type;

    eProsima_user_DllExport MapBoundsStructPubSubType();

    eProsima_user_DllExport virtual ~MapBoundsStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 36ULL == eprosima::fastrtps::size_of_<MapBoundsStruct, detail::MapBoundsStruct_f, std::map<int32_t, int32_t>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct MapMapStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct MapMapStruct_f
    {
        typedef std::map<int32_t, std::map<int32_t, int32_t>> MapMapStruct::* type;
        friend type get(
                MapMapStruct_f);
    };

    template struct MapMapStruct_rob<MapMapStruct_f, &MapMapStruct::m_my_map_map>;
}

/*!
 * @brief This class represents the TopicDataType of the type MapMapStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class MapMapStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef MapMapStruct type;

    eProsima_user_DllExport MapMapStructPubSubType();

    eProsima_user_DllExport virtual ~MapMapStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 52ULL == eprosima::fastrtps::size_of_<MapMapStruct, detail::MapMapStruct_f, std::map<int32_t, std::map<int32_t, int32_t>>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct MapMapBoundsStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct MapMapBoundsStruct_f
    {
        typedef std::map<int32_t, std::map<int32_t, int32_t>> MapMapBoundsStruct::* type;
        friend type get(
                MapMapBoundsStruct_f);
    };

    template struct MapMapBoundsStruct_rob<MapMapBoundsStruct_f, &MapMapBoundsStruct::m_my_map_map>;
}

/*!
 * @brief This class represents the TopicDataType of the type MapMapBoundsStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class MapMapBoundsStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef MapMapBoundsStruct type;

    eProsima_user_DllExport MapMapBoundsStructPubSubType();

    eProsima_user_DllExport virtual ~MapMapBoundsStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 100ULL == eprosima::fastrtps::size_of_<MapMapBoundsStruct, detail::MapMapBoundsStruct_f, std::map<int32_t, std::map<int32_t, int32_t>>>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};






namespace detail {

    template<typename Tag, typename Tag::type M>
    struct SimpleUnionStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct SimpleUnionStruct_f
    {
        typedef SimpleUnion SimpleUnionStruct::* type;
        friend type get(
                SimpleUnionStruct_f);
    };

    template struct SimpleUnionStruct_rob<SimpleUnionStruct_f, &SimpleUnionStruct::m_my_union>;
}

/*!
 * @brief This class represents the TopicDataType of the type SimpleUnionStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class SimpleUnionStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef SimpleUnionStruct type;

    eProsima_user_DllExport SimpleUnionStructPubSubType();

    eProsima_user_DllExport virtual ~SimpleUnionStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 16ULL == eprosima::fastrtps::size_of_<SimpleUnionStruct, detail::SimpleUnionStruct_f, SimpleUnion>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct SimpleUnionStructEqual_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct SimpleUnionStructEqual_f
    {
        typedef SimpleUnion SimpleUnionStructEqual::* type;
        friend type get(
                SimpleUnionStructEqual_f);
    };

    template struct SimpleUnionStructEqual_rob<SimpleUnionStructEqual_f, &SimpleUnionStructEqual::m_my_union_equal>;
}

/*!
 * @brief This class represents the TopicDataType of the type SimpleUnionStructEqual defined by the user in the IDL file.
 * @ingroup TYPES
 */
class SimpleUnionStructEqualPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef SimpleUnionStructEqual type;

    eProsima_user_DllExport SimpleUnionStructEqualPubSubType();

    eProsima_user_DllExport virtual ~SimpleUnionStructEqualPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 16ULL == eprosima::fastrtps::size_of_<SimpleUnionStructEqual, detail::SimpleUnionStructEqual_f, SimpleUnion>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct SimpleUnionNamesStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct SimpleUnionNamesStruct_f
    {
        typedef SimpleUnionNames SimpleUnionNamesStruct::* type;
        friend type get(
                SimpleUnionNamesStruct_f);
    };

    template struct SimpleUnionNamesStruct_rob<SimpleUnionNamesStruct_f, &SimpleUnionNamesStruct::m_my_union>;
}

/*!
 * @brief This class represents the TopicDataType of the type SimpleUnionNamesStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class SimpleUnionNamesStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef SimpleUnionNamesStruct type;

    eProsima_user_DllExport SimpleUnionNamesStructPubSubType();

    eProsima_user_DllExport virtual ~SimpleUnionNamesStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 16ULL == eprosima::fastrtps::size_of_<SimpleUnionNamesStruct, detail::SimpleUnionNamesStruct_f, SimpleUnionNames>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct SimpleTypeUnionStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct SimpleTypeUnionStruct_f
    {
        typedef SimpleTypeUnion SimpleTypeUnionStruct::* type;
        friend type get(
                SimpleTypeUnionStruct_f);
    };

    template struct SimpleTypeUnionStruct_rob<SimpleTypeUnionStruct_f, &SimpleTypeUnionStruct::m_my_union>;
}

/*!
 * @brief This class represents the TopicDataType of the type SimpleTypeUnionStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class SimpleTypeUnionStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef SimpleTypeUnionStruct type;

    eProsima_user_DllExport SimpleTypeUnionStructPubSubType();

    eProsima_user_DllExport virtual ~SimpleTypeUnionStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 16ULL == eprosima::fastrtps::size_of_<SimpleTypeUnionStruct, detail::SimpleTypeUnionStruct_f, SimpleTypeUnion>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct SimpleBadUnionStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct SimpleBadUnionStruct_f
    {
        typedef SimpleBadUnion SimpleBadUnionStruct::* type;
        friend type get(
                SimpleBadUnionStruct_f);
    };

    template struct SimpleBadUnionStruct_rob<SimpleBadUnionStruct_f, &SimpleBadUnionStruct::m_my_union>;
}

/*!
 * @brief This class represents the TopicDataType of the type SimpleBadUnionStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class SimpleBadUnionStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef SimpleBadUnionStruct type;

    eProsima_user_DllExport SimpleBadUnionStructPubSubType();

    eProsima_user_DllExport virtual ~SimpleBadUnionStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 16ULL == eprosima::fastrtps::size_of_<SimpleBadUnionStruct, detail::SimpleBadUnionStruct_f, SimpleBadUnion>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

namespace detail {

    template<typename Tag, typename Tag::type M>
    struct SimplBadDiscUnionStruct_rob
    {
        friend typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct SimplBadDiscUnionStruct_f
    {
        typedef SimpleBadDiscUnion SimplBadDiscUnionStruct::* type;
        friend type get(
                SimplBadDiscUnionStruct_f);
    };

    template struct SimplBadDiscUnionStruct_rob<SimplBadDiscUnionStruct_f, &SimplBadDiscUnionStruct::m_my_union>;
}

/*!
 * @brief This class represents the TopicDataType of the type SimplBadDiscUnionStruct defined by the user in the IDL file.
 * @ingroup TYPES
 */
class SimplBadDiscUnionStructPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef SimplBadDiscUnionStruct type;

    eProsima_user_DllExport SimplBadDiscUnionStructPubSubType();

    eProsima_user_DllExport virtual ~SimplBadDiscUnionStructPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return 16ULL == eprosima::fastrtps::size_of_<SimplBadDiscUnionStruct, detail::SimplBadDiscUnionStruct_f, SimpleBadDiscUnion>();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;
};

#endif // _FAST_DDS_GENERATED_TYPES_PUBSUBTYPES_H_